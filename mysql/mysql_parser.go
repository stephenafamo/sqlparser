// Code generated from ./mysql/MySqlParser.g4 by ANTLR 4.12.0. DO NOT EDIT.

package parser // MySqlParser

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr/antlr4/runtime/Go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type MySqlParser struct {
	*antlr.BaseParser
}

var mysqlparserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	literalNames           []string
	symbolicNames          []string
	ruleNames              []string
	predictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func mysqlparserParserInit() {
	staticData := &mysqlparserParserStaticData
	staticData.literalNames = []string{
		"", "", "", "", "", "'ADD'", "'ALL'", "'ALTER'", "'ALWAYS'", "'ANALYZE'",
		"'AND'", "'ARRAY'", "'AS'", "'ASC'", "'ATTRIBUTE'", "'BEFORE'", "'BETWEEN'",
		"'BOTH'", "'BUCKETS'", "'BY'", "'CALL'", "'CASCADE'", "'CASE'", "'CAST'",
		"'CHANGE'", "'CHARACTER'", "'CHECK'", "'COLLATE'", "'COLUMN'", "'CONDITION'",
		"'CONSTRAINT'", "'CONTINUE'", "'CONVERT'", "'CREATE'", "'CROSS'", "'CURRENT'",
		"'CURRENT_ROLE'", "'CURRENT_USER'", "'CURSOR'", "'DATABASE'", "'DATABASES'",
		"'DECLARE'", "'DEFAULT'", "'DELAYED'", "'DELETE'", "'DESC'", "'DESCRIBE'",
		"'DETERMINISTIC'", "'DIAGNOSTICS'", "'DISTINCT'", "'DISTINCTROW'", "'DROP'",
		"'EACH'", "'ELSE'", "'ELSEIF'", "'EMPTY'", "'ENCLOSED'", "'ENFORCED'",
		"'ESCAPED'", "'EXCEPT'", "'EXISTS'", "'EXIT'", "'EXPLAIN'", "'FALSE'",
		"'FETCH'", "'FOR'", "'FORCE'", "'FOREIGN'", "'FROM'", "'FULLTEXT'",
		"'GENERATED'", "'GET'", "'GRANT'", "'GROUP'", "'HAVING'", "'HIGH_PRIORITY'",
		"'HISTOGRAM'", "'IF'", "'IGNORE'", "'IGNORED'", "'IN'", "'INDEX'", "'INFILE'",
		"'INNER'", "'INOUT'", "'INSERT'", "'INTERVAL'", "'INTO'", "'IS'", "'ITERATE'",
		"'JOIN'", "'KEY'", "'KEYS'", "'KILL'", "'LATERAL'", "'LEADING'", "'LEAVE'",
		"'LEFT'", "'LIKE'", "'LIMIT'", "'LINEAR'", "'LINES'", "'LOAD'", "'LOCK'",
		"'LOCKED'", "'LOOP'", "'LOW_PRIORITY'", "'MASTER_BIND'", "'MASTER_SSL_VERIFY_SERVER_CERT'",
		"'MATCH'", "'MAXVALUE'", "'MINVALUE'", "'MODIFIES'", "'NATURAL'", "'NOT'",
		"'NO_WRITE_TO_BINLOG'", "'NULL'", "'NUMBER'", "'ON'", "'OPTIMIZE'",
		"'OPTION'", "'OPTIONAL'", "'OPTIONALLY'", "'OR'", "'ORDER'", "'OUT'",
		"'OUTER'", "'OUTFILE'", "'OVER'", "'PARTITION'", "'PRIMARY'", "'PROCEDURE'",
		"'PURGE'", "'RANGE'", "'READ'", "'READS'", "'REFERENCES'", "'REGEXP'",
		"'RELEASE'", "'RENAME'", "'REPEAT'", "'REPLACE'", "'REQUIRE'", "'RESIGNAL'",
		"'RESTRICT'", "'RETAIN'", "'RETURN'", "'REVOKE'", "'RIGHT'", "'RLIKE'",
		"'SCHEMA'", "'SCHEMAS'", "'SELECT'", "'SET'", "'SEPARATOR'", "'SHOW'",
		"'SIGNAL'", "'SKIP'", "'SKIP_QUERY_REWRITE'", "'SPATIAL'", "'SQL'",
		"'SQLEXCEPTION'", "'SQLSTATE'", "'SQLWARNING'", "'SQL_BIG_RESULT'",
		"'SQL_CALC_FOUND_ROWS'", "'SQL_SMALL_RESULT'", "'SSL'", "'STACKED'",
		"'STARTING'", "'STATEMENT'", "'STRAIGHT_JOIN'", "'TABLE'", "'TERMINATED'",
		"'THEN'", "'TO'", "'TRAILING'", "'TRIGGER'", "'TRUE'", "'UNDO'", "'UNION'",
		"'UNIQUE'", "'UNLOCK'", "'UNSIGNED'", "'UPDATE'", "'USAGE'", "'USE'",
		"'USING'", "'VALUES'", "'WHEN'", "'WHERE'", "'WHILE'", "'WITH'", "'WRITE'",
		"'XOR'", "'ZEROFILL'", "'TINYINT'", "'SMALLINT'", "'MEDIUMINT'", "'MIDDLEINT'",
		"'INT'", "'INT1'", "'INT2'", "'INT3'", "'INT4'", "'INT8'", "'INTEGER'",
		"'BIGINT'", "'REAL'", "'DOUBLE'", "'PRECISION'", "'FLOAT'", "'FLOAT4'",
		"'FLOAT8'", "'DECIMAL'", "'DEC'", "'NUMERIC'", "'DATE'", "'TIME'", "'TIMESTAMP'",
		"'DATETIME'", "'YEAR'", "'CHAR'", "'VARCHAR'", "'NVARCHAR'", "'NATIONAL'",
		"'BINARY'", "'VARBINARY'", "'TINYBLOB'", "'BLOB'", "'MEDIUMBLOB'", "'LONG'",
		"'LONGBLOB'", "'TINYTEXT'", "'TEXT'", "'MEDIUMTEXT'", "'LONGTEXT'",
		"'ENUM'", "'VARYING'", "'SERIAL'", "'YEAR_MONTH'", "'DAY_HOUR'", "'DAY_MINUTE'",
		"'DAY_SECOND'", "'HOUR_MINUTE'", "'HOUR_SECOND'", "'MINUTE_SECOND'",
		"'SECOND_MICROSECOND'", "'MINUTE_MICROSECOND'", "'HOUR_MICROSECOND'",
		"'DAY_MICROSECOND'", "'JSON_ARRAY'", "'JSON_ARRAYAGG'", "'JSON_ARRAY_APPEND'",
		"'JSON_ARRAY_INSERT'", "'JSON_CONTAINS'", "'JSON_CONTAINS_PATH'", "'JSON_DEPTH'",
		"'JSON_EXTRACT'", "'JSON_INSERT'", "'JSON_KEYS'", "'JSON_LENGTH'", "'JSON_MERGE'",
		"'JSON_MERGE_PATCH'", "'JSON_MERGE_PRESERVE'", "'JSON_OBJECT'", "'JSON_OBJECTAGG'",
		"'JSON_OVERLAPS'", "'JSON_PRETTY'", "'JSON_QUOTE'", "'JSON_REMOVE'",
		"'JSON_REPLACE'", "'JSON_SCHEMA_VALID'", "'JSON_SCHEMA_VALIDATION_REPORT'",
		"'JSON_SEARCH'", "'JSON_SET'", "'JSON_STORAGE_FREE'", "'JSON_STORAGE_SIZE'",
		"'JSON_TABLE'", "'JSON_TYPE'", "'JSON_UNQUOTE'", "'JSON_VALID'", "'JSON_VALUE'",
		"'NESTED'", "'ORDINALITY'", "'PATH'", "'AVG'", "'BIT_AND'", "'BIT_OR'",
		"'BIT_XOR'", "'COUNT'", "'CUME_DIST'", "'DENSE_RANK'", "'FIRST_VALUE'",
		"'GROUP_CONCAT'", "'LAG'", "'LAST_VALUE'", "'LEAD'", "'MAX'", "'MIN'",
		"'NTILE'", "'NTH_VALUE'", "'PERCENT_RANK'", "'RANK'", "'ROW_NUMBER'",
		"'STD'", "'STDDEV'", "'STDDEV_POP'", "'STDDEV_SAMP'", "'SUM'", "'VAR_POP'",
		"'VAR_SAMP'", "'VARIANCE'", "'CURRENT_DATE'", "'CURRENT_TIME'", "'CURRENT_TIMESTAMP'",
		"'LOCALTIME'", "'CURDATE'", "'CURTIME'", "'DATE_ADD'", "'DATE_SUB'",
		"'EXTRACT'", "'LOCALTIMESTAMP'", "'NOW'", "'POSITION'", "'SUBSTR'",
		"'SUBSTRING'", "'SYSDATE'", "'TRIM'", "'UTC_DATE'", "'UTC_TIME'", "'UTC_TIMESTAMP'",
		"'ACCOUNT'", "'ACTION'", "'AFTER'", "'AGGREGATE'", "'ALGORITHM'", "'ANY'",
		"'AT'", "'AUTHORS'", "'AUTOCOMMIT'", "'AUTOEXTEND_SIZE'", "'AUTO_INCREMENT'",
		"'AVG_ROW_LENGTH'", "'BEGIN'", "'BINLOG'", "'BIT'", "'BLOCK'", "'BOOL'",
		"'BOOLEAN'", "'BTREE'", "'CACHE'", "'CASCADED'", "'CHAIN'", "'CHANGED'",
		"'CHANNEL'", "'CHECKSUM'", "'PAGE_CHECKSUM'", "'CIPHER'", "'CLASS_ORIGIN'",
		"'CLIENT'", "'CLOSE'", "'CLUSTERING'", "'COALESCE'", "'CODE'", "'COLUMNS'",
		"'COLUMN_FORMAT'", "'COLUMN_NAME'", "'COMMENT'", "'COMMIT'", "'COMPACT'",
		"'COMPLETION'", "'COMPRESSED'", "", "'CONCURRENT'", "'CONNECT'", "'CONNECTION'",
		"'CONSISTENT'", "'CONSTRAINT_CATALOG'", "'CONSTRAINT_SCHEMA'", "'CONSTRAINT_NAME'",
		"'CONTAINS'", "'CONTEXT'", "'CONTRIBUTORS'", "'COPY'", "'CPU'", "'CYCLE'",
		"'CURSOR_NAME'", "'DATA'", "'DATAFILE'", "'DEALLOCATE'", "'DEFAULT_AUTH'",
		"'DEFINER'", "'DELAY_KEY_WRITE'", "'DES_KEY_FILE'", "'DIRECTORY'", "'DISABLE'",
		"'DISCARD'", "'DISK'", "'DO'", "'DUMPFILE'", "'DUPLICATE'", "'DYNAMIC'",
		"'ENABLE'", "'ENCRYPTED'", "'ENCRYPTION'", "'ENCRYPTION_KEY_ID'", "'END'",
		"'ENDS'", "'ENGINE'", "'ENGINES'", "'ERROR'", "'ERRORS'", "'ESCAPE'",
		"'EVEN'", "'EVENT'", "'EVENTS'", "'EVERY'", "'EXCHANGE'", "'EXCLUSIVE'",
		"'EXPIRE'", "'EXPORT'", "'EXTENDED'", "'EXTENT_SIZE'", "'FAILED_LOGIN_ATTEMPTS'",
		"'FAST'", "'FAULTS'", "'FIELDS'", "'FILE_BLOCK_SIZE'", "'FILTER'", "'FIRST'",
		"'FIXED'", "'FLUSH'", "'FOLLOWING'", "'FOLLOWS'", "'FOUND'", "'FULL'",
		"'FUNCTION'", "'GENERAL'", "'GLOBAL'", "'GRANTS'", "'GROUP_REPLICATION'",
		"'HANDLER'", "'HASH'", "'HELP'", "'HISTORY'", "'HOST'", "'HOSTS'", "'IDENTIFIED'",
		"'IGNORE_SERVER_IDS'", "'IMPORT'", "'INCREMENT'", "'INDEXES'", "'INITIAL_SIZE'",
		"'INPLACE'", "'INSERT_METHOD'", "'INSTALL'", "'INSTANCE'", "'INSTANT'",
		"'INVISIBLE'", "'INVOKER'", "'IO'", "'IO_THREAD'", "'IPC'", "'ISOLATION'",
		"'ISSUER'", "'JSON'", "'KEY_BLOCK_SIZE'", "'LANGUAGE'", "'LAST'", "'LEAVES'",
		"'LESS'", "'LEVEL'", "'LIST'", "'LOCAL'", "'LOGFILE'", "'LOGS'", "'MASTER'",
		"'MASTER_AUTO_POSITION'", "'MASTER_CONNECT_RETRY'", "'MASTER_DELAY'",
		"'MASTER_HEARTBEAT_PERIOD'", "'MASTER_HOST'", "'MASTER_LOG_FILE'", "'MASTER_LOG_POS'",
		"'MASTER_PASSWORD'", "'MASTER_PORT'", "'MASTER_RETRY_COUNT'", "'MASTER_SSL'",
		"'MASTER_SSL_CA'", "'MASTER_SSL_CAPATH'", "'MASTER_SSL_CERT'", "'MASTER_SSL_CIPHER'",
		"'MASTER_SSL_CRL'", "'MASTER_SSL_CRLPATH'", "'MASTER_SSL_KEY'", "'MASTER_TLS_VERSION'",
		"'MASTER_USER'", "'MAX_CONNECTIONS_PER_HOUR'", "'MAX_QUERIES_PER_HOUR'",
		"'MAX_ROWS'", "'MAX_SIZE'", "'MAX_UPDATES_PER_HOUR'", "'MAX_USER_CONNECTIONS'",
		"'MEDIUM'", "'MEMBER'", "'MERGE'", "'MESSAGE_TEXT'", "'MID'", "'MIGRATE'",
		"'MIN_ROWS'", "'MODE'", "'MODIFY'", "'MUTEX'", "'MYSQL'", "'MYSQL_ERRNO'",
		"'NAME'", "'NAMES'", "'NCHAR'", "'NEVER'", "'NEXT'", "'NO'", "'NOCACHE'",
		"'NOCOPY'", "'NOCYCLE'", "'NOMAXVALUE'", "'NOMINVALUE'", "'NOWAIT'",
		"'NODEGROUP'", "'NONE'", "'ODBC'", "'OFFLINE'", "'OFFSET'", "'OF'",
		"'OJ'", "'OLD_PASSWORD'", "'ONE'", "'ONLINE'", "'ONLY'", "'OPEN'", "'OPTIMIZER_COSTS'",
		"'OPTIONS'", "'OWNER'", "'PACK_KEYS'", "'PAGE'", "'PAGE_COMPRESSED'",
		"'PAGE_COMPRESSION_LEVEL'", "'PARSER'", "'PARTIAL'", "'PARTITIONING'",
		"'PARTITIONS'", "'PASSWORD'", "'PASSWORD_LOCK_TIME'", "'PHASE'", "'PLUGIN'",
		"'PLUGIN_DIR'", "'PLUGINS'", "'PORT'", "'PRECEDES'", "'PRECEDING'",
		"'PREPARE'", "'PRESERVE'", "'PREV'", "'PROCESSLIST'", "'PROFILE'", "'PROFILES'",
		"'PROXY'", "'QUERY'", "'QUICK'", "'REBUILD'", "'RECOVER'", "'RECURSIVE'",
		"'REDO_BUFFER_SIZE'", "'REDUNDANT'", "'RELAY'", "'RELAY_LOG_FILE'",
		"'RELAY_LOG_POS'", "'RELAYLOG'", "'REMOVE'", "'REORGANIZE'", "'REPAIR'",
		"'REPLICATE_DO_DB'", "'REPLICATE_DO_TABLE'", "'REPLICATE_IGNORE_DB'",
		"'REPLICATE_IGNORE_TABLE'", "'REPLICATE_REWRITE_DB'", "'REPLICATE_WILD_DO_TABLE'",
		"'REPLICATE_WILD_IGNORE_TABLE'", "'REPLICATION'", "'RESET'", "'RESTART'",
		"'RESUME'", "'RETURNED_SQLSTATE'", "'RETURNING'", "'RETURNS'", "'REUSE'",
		"'ROLE'", "'ROLLBACK'", "'ROLLUP'", "'ROTATE'", "'ROW'", "'ROWS'", "'ROW_FORMAT'",
		"'RTREE'", "'SAVEPOINT'", "'SCHEDULE'", "'SECURITY'", "'SEQUENCE'",
		"'SERVER'", "'SESSION'", "'SHARE'", "'SHARED'", "'SIGNED'", "'SIMPLE'",
		"'SLAVE'", "'SLOW'", "'SNAPSHOT'", "'SOCKET'", "'SOME'", "'SONAME'",
		"'SOUNDS'", "'SOURCE'", "'SQL_AFTER_GTIDS'", "'SQL_AFTER_MTS_GAPS'",
		"'SQL_BEFORE_GTIDS'", "'SQL_BUFFER_RESULT'", "'SQL_CACHE'", "'SQL_NO_CACHE'",
		"'SQL_THREAD'", "'START'", "'STARTS'", "'STATS_AUTO_RECALC'", "'STATS_PERSISTENT'",
		"'STATS_SAMPLE_PAGES'", "'STATUS'", "'STOP'", "'STORAGE'", "'STORED'",
		"'STRING'", "'SUBCLASS_ORIGIN'", "'SUBJECT'", "'SUBPARTITION'", "'SUBPARTITIONS'",
		"'SUSPEND'", "'SWAPS'", "'SWITCHES'", "'TABLE_NAME'", "'TABLESPACE'",
		"'TABLE_TYPE'", "'TEMPORARY'", "'TEMPTABLE'", "'THAN'", "'TRADITIONAL'",
		"'TRANSACTION'", "'TRANSACTIONAL'", "'TRIGGERS'", "'TRUNCATE'", "'UNBOUNDED'",
		"'UNDEFINED'", "'UNDOFILE'", "'UNDO_BUFFER_SIZE'", "'UNINSTALL'", "'UNKNOWN'",
		"'UNTIL'", "'UPGRADE'", "'USER'", "'USE_FRM'", "'USER_RESOURCES'", "'VALIDATION'",
		"'VALUE'", "'VARIABLES'", "'VIEW'", "'VIRTUAL'", "'VISIBLE'", "'WAIT'",
		"'WARNINGS'", "'WINDOW'", "'WITHOUT'", "'WORK'", "'WRAPPER'", "'X509'",
		"'XA'", "'XML'", "'YES'", "'EUR'", "'USA'", "'JIS'", "'ISO'", "'INTERNAL'",
		"'QUARTER'", "'MONTH'", "'DAY'", "'HOUR'", "'MINUTE'", "'WEEK'", "'SECOND'",
		"'MICROSECOND'", "'ADMIN'", "'APPLICATION_PASSWORD_ADMIN'", "'AUDIT_ABORT_EXEMPT'",
		"'AUDIT_ADMIN'", "'BACKUP_ADMIN'", "'BINLOG_ADMIN'", "'BINLOG_ENCRYPTION_ADMIN'",
		"'CLONE_ADMIN'", "'CONNECTION_ADMIN'", "'ENCRYPTION_KEY_ADMIN'", "'EXECUTE'",
		"'FILE'", "'FIREWALL_ADMIN'", "'FIREWALL_EXEMPT'", "'FIREWALL_USER'",
		"'FLUSH_OPTIMIZER_COSTS'", "'FLUSH_STATUS'", "'FLUSH_TABLES'", "'FLUSH_USER_RESOURCES'",
		"'GROUP_REPLICATION_ADMIN'", "'INNODB_REDO_LOG_ARCHIVE'", "'INNODB_REDO_LOG_ENABLE'",
		"'INVOKE'", "'LAMBDA'", "'NDB_STORED_USER'", "'PASSWORDLESS_USER_ADMIN'",
		"'PERSIST_RO_VARIABLES_ADMIN'", "'PRIVILEGES'", "'PROCESS'", "'RELOAD'",
		"'REPLICATION_APPLIER'", "'REPLICATION_SLAVE_ADMIN'", "'RESOURCE_GROUP_ADMIN'",
		"'RESOURCE_GROUP_USER'", "'ROLE_ADMIN'", "'ROUTINE'", "'S3'", "'SERVICE_CONNECTION_ADMIN'",
		"", "'SET_USER_ID'", "'SHOW_ROUTINE'", "'SHUTDOWN'", "'SUPER'", "'SYSTEM_VARIABLES_ADMIN'",
		"'TABLES'", "'TABLE_ENCRYPTION_ADMIN'", "'VERSION_TOKEN_ADMIN'", "'XA_RECOVER_ADMIN'",
		"'ARMSCII8'", "'ASCII'", "'BIG5'", "'CP1250'", "'CP1251'", "'CP1256'",
		"'CP1257'", "'CP850'", "'CP852'", "'CP866'", "'CP932'", "'DEC8'", "'EUCJPMS'",
		"'EUCKR'", "'GB18030'", "'GB2312'", "'GBK'", "'GEOSTD8'", "'GREEK'",
		"'HEBREW'", "'HP8'", "'KEYBCS2'", "'KOI8R'", "'KOI8U'", "'LATIN1'",
		"'LATIN2'", "'LATIN5'", "'LATIN7'", "'MACCE'", "'MACROMAN'", "'SJIS'",
		"'SWE7'", "'TIS620'", "'UCS2'", "'UJIS'", "'UTF16'", "'UTF16LE'", "'UTF32'",
		"'UTF8'", "'UTF8MB3'", "'UTF8MB4'", "'ARCHIVE'", "'BLACKHOLE'", "'CSV'",
		"'FEDERATED'", "'INNODB'", "'MEMORY'", "'MRG_MYISAM'", "'MYISAM'", "'NDB'",
		"'NDBCLUSTER'", "'PERFORMANCE_SCHEMA'", "'TOKUDB'", "'REPEATABLE'",
		"'COMMITTED'", "'UNCOMMITTED'", "'SERIALIZABLE'", "'GEOMETRYCOLLECTION'",
		"'GEOMCOLLECTION'", "'GEOMETRY'", "'LINESTRING'", "'MULTILINESTRING'",
		"'MULTIPOINT'", "'MULTIPOLYGON'", "'POINT'", "'POLYGON'", "'ABS'", "'ACOS'",
		"'ADDDATE'", "'ADDTIME'", "'AES_DECRYPT'", "'AES_ENCRYPT'", "'AREA'",
		"'ASBINARY'", "'ASIN'", "'ASTEXT'", "'ASWKB'", "'ASWKT'", "'ASYMMETRIC_DECRYPT'",
		"'ASYMMETRIC_DERIVE'", "'ASYMMETRIC_ENCRYPT'", "'ASYMMETRIC_SIGN'",
		"'ASYMMETRIC_VERIFY'", "'ATAN'", "'ATAN2'", "'BENCHMARK'", "'BIN'",
		"'BIT_COUNT'", "'BIT_LENGTH'", "'BUFFER'", "'CATALOG_NAME'", "'CEIL'",
		"'CEILING'", "'CENTROID'", "'CHARACTER_LENGTH'", "'CHARSET'", "'CHAR_LENGTH'",
		"'COERCIBILITY'", "'COLLATION'", "'COMPRESS'", "'CONCAT'", "'CONCAT_WS'",
		"'CONNECTION_ID'", "'CONV'", "'CONVERT_TZ'", "'COS'", "'COT'", "'CRC32'",
		"'CREATE_ASYMMETRIC_PRIV_KEY'", "'CREATE_ASYMMETRIC_PUB_KEY'", "'CREATE_DH_PARAMETERS'",
		"'CREATE_DIGEST'", "'CROSSES'", "'DATEDIFF'", "'DATE_FORMAT'", "'DAYNAME'",
		"'DAYOFMONTH'", "'DAYOFWEEK'", "'DAYOFYEAR'", "'DECODE'", "'DEGREES'",
		"'DES_DECRYPT'", "'DES_ENCRYPT'", "'DIMENSION'", "'DISJOINT'", "'ELT'",
		"'ENCODE'", "'ENCRYPT'", "'ENDPOINT'", "'ENGINE_ATTRIBUTE'", "'ENVELOPE'",
		"'EQUALS'", "'EXP'", "'EXPORT_SET'", "'EXTERIORRING'", "'EXTRACTVALUE'",
		"'FIELD'", "'FIND_IN_SET'", "'FLOOR'", "'FORMAT'", "'FOUND_ROWS'", "'FROM_BASE64'",
		"'FROM_DAYS'", "'FROM_UNIXTIME'", "'GEOMCOLLFROMTEXT'", "'GEOMCOLLFROMWKB'",
		"'GEOMETRYCOLLECTIONFROMTEXT'", "'GEOMETRYCOLLECTIONFROMWKB'", "'GEOMETRYFROMTEXT'",
		"'GEOMETRYFROMWKB'", "'GEOMETRYN'", "'GEOMETRYTYPE'", "'GEOMFROMTEXT'",
		"'GEOMFROMWKB'", "'GET_FORMAT'", "'GET_LOCK'", "'GLENGTH'", "'GREATEST'",
		"'GTID_SUBSET'", "'GTID_SUBTRACT'", "'HEX'", "'IFNULL'", "'INET6_ATON'",
		"'INET6_NTOA'", "'INET_ATON'", "'INET_NTOA'", "'INSTR'", "'INTERIORRINGN'",
		"'INTERSECTS'", "'ISCLOSED'", "'ISEMPTY'", "'ISNULL'", "'ISSIMPLE'",
		"'IS_FREE_LOCK'", "'IS_IPV4'", "'IS_IPV4_COMPAT'", "'IS_IPV4_MAPPED'",
		"'IS_IPV6'", "'IS_USED_LOCK'", "'LAST_INSERT_ID'", "'LCASE'", "'LEAST'",
		"'LENGTH'", "'LINEFROMTEXT'", "'LINEFROMWKB'", "'LINESTRINGFROMTEXT'",
		"'LINESTRINGFROMWKB'", "'LN'", "'LOAD_FILE'", "'LOCATE'", "'LOG'", "'LOG10'",
		"'LOG2'", "'LOWER'", "'LPAD'", "'LTRIM'", "'MAKEDATE'", "'MAKETIME'",
		"'MAKE_SET'", "'MASTER_POS_WAIT'", "'MBRCONTAINS'", "'MBRDISJOINT'",
		"'MBREQUAL'", "'MBRINTERSECTS'", "'MBROVERLAPS'", "'MBRTOUCHES'", "'MBRWITHIN'",
		"'MD5'", "'MLINEFROMTEXT'", "'MLINEFROMWKB'", "'MONTHNAME'", "'MPOINTFROMTEXT'",
		"'MPOINTFROMWKB'", "'MPOLYFROMTEXT'", "'MPOLYFROMWKB'", "'MULTILINESTRINGFROMTEXT'",
		"'MULTILINESTRINGFROMWKB'", "'MULTIPOINTFROMTEXT'", "'MULTIPOINTFROMWKB'",
		"'MULTIPOLYGONFROMTEXT'", "'MULTIPOLYGONFROMWKB'", "'NAME_CONST'", "'NULLIF'",
		"'NUMGEOMETRIES'", "'NUMINTERIORRINGS'", "'NUMPOINTS'", "'OCT'", "'OCTET_LENGTH'",
		"'ORD'", "'OVERLAPS'", "'PERIOD_ADD'", "'PERIOD_DIFF'", "'PI'", "'POINTFROMTEXT'",
		"'POINTFROMWKB'", "'POINTN'", "'POLYFROMTEXT'", "'POLYFROMWKB'", "'POLYGONFROMTEXT'",
		"'POLYGONFROMWKB'", "'POW'", "'POWER'", "'QUOTE'", "'RADIANS'", "'RAND'",
		"'RANDOM_BYTES'", "'RELEASE_LOCK'", "'REVERSE'", "'ROUND'", "'ROW_COUNT'",
		"'RPAD'", "'RTRIM'", "'SEC_TO_TIME'", "'SECONDARY_ENGINE_ATTRIBUTE'",
		"'SESSION_USER'", "'SHA'", "'SHA1'", "'SHA2'", "'SCHEMA_NAME'", "'SIGN'",
		"'SIN'", "'SLEEP'", "'SOUNDEX'", "'SQL_THREAD_WAIT_AFTER_GTIDS'", "'SQRT'",
		"'SRID'", "'STARTPOINT'", "'STRCMP'", "'STR_TO_DATE'", "'ST_AREA'",
		"'ST_ASBINARY'", "'ST_ASTEXT'", "'ST_ASWKB'", "'ST_ASWKT'", "'ST_BUFFER'",
		"'ST_CENTROID'", "'ST_CONTAINS'", "'ST_CROSSES'", "'ST_DIFFERENCE'",
		"'ST_DIMENSION'", "'ST_DISJOINT'", "'ST_DISTANCE'", "'ST_ENDPOINT'",
		"'ST_ENVELOPE'", "'ST_EQUALS'", "'ST_EXTERIORRING'", "'ST_GEOMCOLLFROMTEXT'",
		"'ST_GEOMCOLLFROMTXT'", "'ST_GEOMCOLLFROMWKB'", "'ST_GEOMETRYCOLLECTIONFROMTEXT'",
		"'ST_GEOMETRYCOLLECTIONFROMWKB'", "'ST_GEOMETRYFROMTEXT'", "'ST_GEOMETRYFROMWKB'",
		"'ST_GEOMETRYN'", "'ST_GEOMETRYTYPE'", "'ST_GEOMFROMTEXT'", "'ST_GEOMFROMWKB'",
		"'ST_INTERIORRINGN'", "'ST_INTERSECTION'", "'ST_INTERSECTS'", "'ST_ISCLOSED'",
		"'ST_ISEMPTY'", "'ST_ISSIMPLE'", "'ST_LINEFROMTEXT'", "'ST_LINEFROMWKB'",
		"'ST_LINESTRINGFROMTEXT'", "'ST_LINESTRINGFROMWKB'", "'ST_NUMGEOMETRIES'",
		"'ST_NUMINTERIORRING'", "'ST_NUMINTERIORRINGS'", "'ST_NUMPOINTS'", "'ST_OVERLAPS'",
		"'ST_POINTFROMTEXT'", "'ST_POINTFROMWKB'", "'ST_POINTN'", "'ST_POLYFROMTEXT'",
		"'ST_POLYFROMWKB'", "'ST_POLYGONFROMTEXT'", "'ST_POLYGONFROMWKB'", "'ST_SRID'",
		"'ST_STARTPOINT'", "'ST_SYMDIFFERENCE'", "'ST_TOUCHES'", "'ST_UNION'",
		"'ST_WITHIN'", "'ST_X'", "'ST_Y'", "'SUBDATE'", "'SUBSTRING_INDEX'",
		"'SUBTIME'", "'SYSTEM_USER'", "'TAN'", "'TIMEDIFF'", "'TIMESTAMPADD'",
		"'TIMESTAMPDIFF'", "'TIME_FORMAT'", "'TIME_TO_SEC'", "'TOUCHES'", "'TO_BASE64'",
		"'TO_DAYS'", "'TO_SECONDS'", "'TP_CONNECTION_ADMIN'", "'UCASE'", "'UNCOMPRESS'",
		"'UNCOMPRESSED_LENGTH'", "'UNHEX'", "'UNIX_TIMESTAMP'", "'UPDATEXML'",
		"'UPPER'", "'UUID'", "'UUID_SHORT'", "'VALIDATE_PASSWORD_STRENGTH'",
		"'VERSION'", "'WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS'", "'WEEKDAY'", "'WEEKOFYEAR'",
		"'WEIGHT_STRING'", "'WITHIN'", "'YEARWEEK'", "'Y'", "'X'", "':='", "'+='",
		"'-='", "'*='", "'/='", "'%='", "'&='", "'^='", "'|='", "'*'", "'/'",
		"'%'", "'+'", "'-'", "'DIV'", "'MOD'", "'='", "'>'", "'<'", "'!'", "'~'",
		"'|'", "'&'", "'^'", "'.'", "'('", "')'", "','", "';'", "'@'", "'0'",
		"'1'", "'2'", "'''", "'\"'", "'`'", "':'", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "'?'",
	}
	staticData.symbolicNames = []string{
		"", "SPACE", "SPEC_MYSQL_COMMENT", "COMMENT_INPUT", "LINE_COMMENT",
		"ADD", "ALL", "ALTER", "ALWAYS", "ANALYZE", "AND", "ARRAY", "AS", "ASC",
		"ATTRIBUTE", "BEFORE", "BETWEEN", "BOTH", "BUCKETS", "BY", "CALL", "CASCADE",
		"CASE", "CAST", "CHANGE", "CHARACTER", "CHECK", "COLLATE", "COLUMN",
		"CONDITION", "CONSTRAINT", "CONTINUE", "CONVERT", "CREATE", "CROSS",
		"CURRENT", "CURRENT_ROLE", "CURRENT_USER", "CURSOR", "DATABASE", "DATABASES",
		"DECLARE", "DEFAULT", "DELAYED", "DELETE", "DESC", "DESCRIBE", "DETERMINISTIC",
		"DIAGNOSTICS", "DISTINCT", "DISTINCTROW", "DROP", "EACH", "ELSE", "ELSEIF",
		"EMPTY", "ENCLOSED", "ENFORCED", "ESCAPED", "EXCEPT", "EXISTS", "EXIT",
		"EXPLAIN", "FALSE", "FETCH", "FOR", "FORCE", "FOREIGN", "FROM", "FULLTEXT",
		"GENERATED", "GET", "GRANT", "GROUP", "HAVING", "HIGH_PRIORITY", "HISTOGRAM",
		"IF", "IGNORE", "IGNORED", "IN", "INDEX", "INFILE", "INNER", "INOUT",
		"INSERT", "INTERVAL", "INTO", "IS", "ITERATE", "JOIN", "KEY", "KEYS",
		"KILL", "LATERAL", "LEADING", "LEAVE", "LEFT", "LIKE", "LIMIT", "LINEAR",
		"LINES", "LOAD", "LOCK", "LOCKED", "LOOP", "LOW_PRIORITY", "MASTER_BIND",
		"MASTER_SSL_VERIFY_SERVER_CERT", "MATCH", "MAXVALUE", "MINVALUE", "MODIFIES",
		"NATURAL", "NOT", "NO_WRITE_TO_BINLOG", "NULL_LITERAL", "NUMBER", "ON",
		"OPTIMIZE", "OPTION", "OPTIONAL", "OPTIONALLY", "OR", "ORDER", "OUT",
		"OUTER", "OUTFILE", "OVER", "PARTITION", "PRIMARY", "PROCEDURE", "PURGE",
		"RANGE", "READ", "READS", "REFERENCES", "REGEXP", "RELEASE", "RENAME",
		"REPEAT", "REPLACE", "REQUIRE", "RESIGNAL", "RESTRICT", "RETAIN", "RETURN",
		"REVOKE", "RIGHT", "RLIKE", "SCHEMA", "SCHEMAS", "SELECT", "SET", "SEPARATOR",
		"SHOW", "SIGNAL", "SKIP_", "SKIP_QUERY_REWRITE", "SPATIAL", "SQL", "SQLEXCEPTION",
		"SQLSTATE", "SQLWARNING", "SQL_BIG_RESULT", "SQL_CALC_FOUND_ROWS", "SQL_SMALL_RESULT",
		"SSL", "STACKED", "STARTING", "STATEMENT", "STRAIGHT_JOIN", "TABLE",
		"TERMINATED", "THEN", "TO", "TRAILING", "TRIGGER", "TRUE", "UNDO", "UNION",
		"UNIQUE", "UNLOCK", "UNSIGNED", "UPDATE", "USAGE", "USE", "USING", "VALUES",
		"WHEN", "WHERE", "WHILE", "WITH", "WRITE", "XOR", "ZEROFILL", "TINYINT",
		"SMALLINT", "MEDIUMINT", "MIDDLEINT", "INT", "INT1", "INT2", "INT3",
		"INT4", "INT8", "INTEGER", "BIGINT", "REAL", "DOUBLE", "PRECISION",
		"FLOAT", "FLOAT4", "FLOAT8", "DECIMAL", "DEC", "NUMERIC", "DATE", "TIME",
		"TIMESTAMP", "DATETIME", "YEAR", "CHAR", "VARCHAR", "NVARCHAR", "NATIONAL",
		"BINARY", "VARBINARY", "TINYBLOB", "BLOB", "MEDIUMBLOB", "LONG", "LONGBLOB",
		"TINYTEXT", "TEXT", "MEDIUMTEXT", "LONGTEXT", "ENUM", "VARYING", "SERIAL",
		"YEAR_MONTH", "DAY_HOUR", "DAY_MINUTE", "DAY_SECOND", "HOUR_MINUTE",
		"HOUR_SECOND", "MINUTE_SECOND", "SECOND_MICROSECOND", "MINUTE_MICROSECOND",
		"HOUR_MICROSECOND", "DAY_MICROSECOND", "JSON_ARRAY", "JSON_ARRAYAGG",
		"JSON_ARRAY_APPEND", "JSON_ARRAY_INSERT", "JSON_CONTAINS", "JSON_CONTAINS_PATH",
		"JSON_DEPTH", "JSON_EXTRACT", "JSON_INSERT", "JSON_KEYS", "JSON_LENGTH",
		"JSON_MERGE", "JSON_MERGE_PATCH", "JSON_MERGE_PRESERVE", "JSON_OBJECT",
		"JSON_OBJECTAGG", "JSON_OVERLAPS", "JSON_PRETTY", "JSON_QUOTE", "JSON_REMOVE",
		"JSON_REPLACE", "JSON_SCHEMA_VALID", "JSON_SCHEMA_VALIDATION_REPORT",
		"JSON_SEARCH", "JSON_SET", "JSON_STORAGE_FREE", "JSON_STORAGE_SIZE",
		"JSON_TABLE", "JSON_TYPE", "JSON_UNQUOTE", "JSON_VALID", "JSON_VALUE",
		"NESTED", "ORDINALITY", "PATH", "AVG", "BIT_AND", "BIT_OR", "BIT_XOR",
		"COUNT", "CUME_DIST", "DENSE_RANK", "FIRST_VALUE", "GROUP_CONCAT", "LAG",
		"LAST_VALUE", "LEAD", "MAX", "MIN", "NTILE", "NTH_VALUE", "PERCENT_RANK",
		"RANK", "ROW_NUMBER", "STD", "STDDEV", "STDDEV_POP", "STDDEV_SAMP",
		"SUM", "VAR_POP", "VAR_SAMP", "VARIANCE", "CURRENT_DATE", "CURRENT_TIME",
		"CURRENT_TIMESTAMP", "LOCALTIME", "CURDATE", "CURTIME", "DATE_ADD",
		"DATE_SUB", "EXTRACT", "LOCALTIMESTAMP", "NOW", "POSITION", "SUBSTR",
		"SUBSTRING", "SYSDATE", "TRIM", "UTC_DATE", "UTC_TIME", "UTC_TIMESTAMP",
		"ACCOUNT", "ACTION", "AFTER", "AGGREGATE", "ALGORITHM", "ANY", "AT",
		"AUTHORS", "AUTOCOMMIT", "AUTOEXTEND_SIZE", "AUTO_INCREMENT", "AVG_ROW_LENGTH",
		"BEGIN", "BINLOG", "BIT", "BLOCK", "BOOL", "BOOLEAN", "BTREE", "CACHE",
		"CASCADED", "CHAIN", "CHANGED", "CHANNEL", "CHECKSUM", "PAGE_CHECKSUM",
		"CIPHER", "CLASS_ORIGIN", "CLIENT", "CLOSE", "CLUSTERING", "COALESCE",
		"CODE", "COLUMNS", "COLUMN_FORMAT", "COLUMN_NAME", "COMMENT", "COMMIT",
		"COMPACT", "COMPLETION", "COMPRESSED", "COMPRESSION", "CONCURRENT",
		"CONNECT", "CONNECTION", "CONSISTENT", "CONSTRAINT_CATALOG", "CONSTRAINT_SCHEMA",
		"CONSTRAINT_NAME", "CONTAINS", "CONTEXT", "CONTRIBUTORS", "COPY", "CPU",
		"CYCLE", "CURSOR_NAME", "DATA", "DATAFILE", "DEALLOCATE", "DEFAULT_AUTH",
		"DEFINER", "DELAY_KEY_WRITE", "DES_KEY_FILE", "DIRECTORY", "DISABLE",
		"DISCARD", "DISK", "DO", "DUMPFILE", "DUPLICATE", "DYNAMIC", "ENABLE",
		"ENCRYPTED", "ENCRYPTION", "ENCRYPTION_KEY_ID", "END", "ENDS", "ENGINE",
		"ENGINES", "ERROR", "ERRORS", "ESCAPE", "EVEN", "EVENT", "EVENTS", "EVERY",
		"EXCHANGE", "EXCLUSIVE", "EXPIRE", "EXPORT", "EXTENDED", "EXTENT_SIZE",
		"FAILED_LOGIN_ATTEMPTS", "FAST", "FAULTS", "FIELDS", "FILE_BLOCK_SIZE",
		"FILTER", "FIRST", "FIXED", "FLUSH", "FOLLOWING", "FOLLOWS", "FOUND",
		"FULL", "FUNCTION", "GENERAL", "GLOBAL", "GRANTS", "GROUP_REPLICATION",
		"HANDLER", "HASH", "HELP", "HISTORY", "HOST", "HOSTS", "IDENTIFIED",
		"IGNORE_SERVER_IDS", "IMPORT", "INCREMENT", "INDEXES", "INITIAL_SIZE",
		"INPLACE", "INSERT_METHOD", "INSTALL", "INSTANCE", "INSTANT", "INVISIBLE",
		"INVOKER", "IO", "IO_THREAD", "IPC", "ISOLATION", "ISSUER", "JSON",
		"KEY_BLOCK_SIZE", "LANGUAGE", "LAST", "LEAVES", "LESS", "LEVEL", "LIST",
		"LOCAL", "LOGFILE", "LOGS", "MASTER", "MASTER_AUTO_POSITION", "MASTER_CONNECT_RETRY",
		"MASTER_DELAY", "MASTER_HEARTBEAT_PERIOD", "MASTER_HOST", "MASTER_LOG_FILE",
		"MASTER_LOG_POS", "MASTER_PASSWORD", "MASTER_PORT", "MASTER_RETRY_COUNT",
		"MASTER_SSL", "MASTER_SSL_CA", "MASTER_SSL_CAPATH", "MASTER_SSL_CERT",
		"MASTER_SSL_CIPHER", "MASTER_SSL_CRL", "MASTER_SSL_CRLPATH", "MASTER_SSL_KEY",
		"MASTER_TLS_VERSION", "MASTER_USER", "MAX_CONNECTIONS_PER_HOUR", "MAX_QUERIES_PER_HOUR",
		"MAX_ROWS", "MAX_SIZE", "MAX_UPDATES_PER_HOUR", "MAX_USER_CONNECTIONS",
		"MEDIUM", "MEMBER", "MERGE", "MESSAGE_TEXT", "MID", "MIGRATE", "MIN_ROWS",
		"MODE", "MODIFY", "MUTEX", "MYSQL", "MYSQL_ERRNO", "NAME", "NAMES",
		"NCHAR", "NEVER", "NEXT", "NO", "NOCACHE", "NOCOPY", "NOCYCLE", "NOMAXVALUE",
		"NOMINVALUE", "NOWAIT", "NODEGROUP", "NONE", "ODBC", "OFFLINE", "OFFSET",
		"OF", "OJ", "OLD_PASSWORD", "ONE", "ONLINE", "ONLY", "OPEN", "OPTIMIZER_COSTS",
		"OPTIONS", "OWNER", "PACK_KEYS", "PAGE", "PAGE_COMPRESSED", "PAGE_COMPRESSION_LEVEL",
		"PARSER", "PARTIAL", "PARTITIONING", "PARTITIONS", "PASSWORD", "PASSWORD_LOCK_TIME",
		"PHASE", "PLUGIN", "PLUGIN_DIR", "PLUGINS", "PORT", "PRECEDES", "PRECEDING",
		"PREPARE", "PRESERVE", "PREV", "PROCESSLIST", "PROFILE", "PROFILES",
		"PROXY", "QUERY", "QUICK", "REBUILD", "RECOVER", "RECURSIVE", "REDO_BUFFER_SIZE",
		"REDUNDANT", "RELAY", "RELAY_LOG_FILE", "RELAY_LOG_POS", "RELAYLOG",
		"REMOVE", "REORGANIZE", "REPAIR", "REPLICATE_DO_DB", "REPLICATE_DO_TABLE",
		"REPLICATE_IGNORE_DB", "REPLICATE_IGNORE_TABLE", "REPLICATE_REWRITE_DB",
		"REPLICATE_WILD_DO_TABLE", "REPLICATE_WILD_IGNORE_TABLE", "REPLICATION",
		"RESET", "RESTART", "RESUME", "RETURNED_SQLSTATE", "RETURNING", "RETURNS",
		"REUSE", "ROLE", "ROLLBACK", "ROLLUP", "ROTATE", "ROW", "ROWS", "ROW_FORMAT",
		"RTREE", "SAVEPOINT", "SCHEDULE", "SECURITY", "SEQUENCE", "SERVER",
		"SESSION", "SHARE", "SHARED", "SIGNED", "SIMPLE", "SLAVE", "SLOW", "SNAPSHOT",
		"SOCKET", "SOME", "SONAME", "SOUNDS", "SOURCE", "SQL_AFTER_GTIDS", "SQL_AFTER_MTS_GAPS",
		"SQL_BEFORE_GTIDS", "SQL_BUFFER_RESULT", "SQL_CACHE", "SQL_NO_CACHE",
		"SQL_THREAD", "START", "STARTS", "STATS_AUTO_RECALC", "STATS_PERSISTENT",
		"STATS_SAMPLE_PAGES", "STATUS", "STOP", "STORAGE", "STORED", "STRING",
		"SUBCLASS_ORIGIN", "SUBJECT", "SUBPARTITION", "SUBPARTITIONS", "SUSPEND",
		"SWAPS", "SWITCHES", "TABLE_NAME", "TABLESPACE", "TABLE_TYPE", "TEMPORARY",
		"TEMPTABLE", "THAN", "TRADITIONAL", "TRANSACTION", "TRANSACTIONAL",
		"TRIGGERS", "TRUNCATE", "UNBOUNDED", "UNDEFINED", "UNDOFILE", "UNDO_BUFFER_SIZE",
		"UNINSTALL", "UNKNOWN", "UNTIL", "UPGRADE", "USER", "USE_FRM", "USER_RESOURCES",
		"VALIDATION", "VALUE", "VARIABLES", "VIEW", "VIRTUAL", "VISIBLE", "WAIT",
		"WARNINGS", "WINDOW", "WITHOUT", "WORK", "WRAPPER", "X509", "XA", "XML",
		"YES", "EUR", "USA", "JIS", "ISO", "INTERNAL", "QUARTER", "MONTH", "DAY",
		"HOUR", "MINUTE", "WEEK", "SECOND", "MICROSECOND", "ADMIN", "APPLICATION_PASSWORD_ADMIN",
		"AUDIT_ABORT_EXEMPT", "AUDIT_ADMIN", "BACKUP_ADMIN", "BINLOG_ADMIN",
		"BINLOG_ENCRYPTION_ADMIN", "CLONE_ADMIN", "CONNECTION_ADMIN", "ENCRYPTION_KEY_ADMIN",
		"EXECUTE", "FILE", "FIREWALL_ADMIN", "FIREWALL_EXEMPT", "FIREWALL_USER",
		"FLUSH_OPTIMIZER_COSTS", "FLUSH_STATUS", "FLUSH_TABLES", "FLUSH_USER_RESOURCES",
		"GROUP_REPLICATION_ADMIN", "INNODB_REDO_LOG_ARCHIVE", "INNODB_REDO_LOG_ENABLE",
		"INVOKE", "LAMBDA", "NDB_STORED_USER", "PASSWORDLESS_USER_ADMIN", "PERSIST_RO_VARIABLES_ADMIN",
		"PRIVILEGES", "PROCESS", "RELOAD", "REPLICATION_APPLIER", "REPLICATION_SLAVE_ADMIN",
		"RESOURCE_GROUP_ADMIN", "RESOURCE_GROUP_USER", "ROLE_ADMIN", "ROUTINE",
		"S3", "SERVICE_CONNECTION_ADMIN", "SESSION_VARIABLES_ADMIN", "SET_USER_ID",
		"SHOW_ROUTINE", "SHUTDOWN", "SUPER", "SYSTEM_VARIABLES_ADMIN", "TABLES",
		"TABLE_ENCRYPTION_ADMIN", "VERSION_TOKEN_ADMIN", "XA_RECOVER_ADMIN",
		"ARMSCII8", "ASCII", "BIG5", "CP1250", "CP1251", "CP1256", "CP1257",
		"CP850", "CP852", "CP866", "CP932", "DEC8", "EUCJPMS", "EUCKR", "GB18030",
		"GB2312", "GBK", "GEOSTD8", "GREEK", "HEBREW", "HP8", "KEYBCS2", "KOI8R",
		"KOI8U", "LATIN1", "LATIN2", "LATIN5", "LATIN7", "MACCE", "MACROMAN",
		"SJIS", "SWE7", "TIS620", "UCS2", "UJIS", "UTF16", "UTF16LE", "UTF32",
		"UTF8", "UTF8MB3", "UTF8MB4", "ARCHIVE", "BLACKHOLE", "CSV", "FEDERATED",
		"INNODB", "MEMORY", "MRG_MYISAM", "MYISAM", "NDB", "NDBCLUSTER", "PERFORMANCE_SCHEMA",
		"TOKUDB", "REPEATABLE", "COMMITTED", "UNCOMMITTED", "SERIALIZABLE",
		"GEOMETRYCOLLECTION", "GEOMCOLLECTION", "GEOMETRY", "LINESTRING", "MULTILINESTRING",
		"MULTIPOINT", "MULTIPOLYGON", "POINT", "POLYGON", "ABS", "ACOS", "ADDDATE",
		"ADDTIME", "AES_DECRYPT", "AES_ENCRYPT", "AREA", "ASBINARY", "ASIN",
		"ASTEXT", "ASWKB", "ASWKT", "ASYMMETRIC_DECRYPT", "ASYMMETRIC_DERIVE",
		"ASYMMETRIC_ENCRYPT", "ASYMMETRIC_SIGN", "ASYMMETRIC_VERIFY", "ATAN",
		"ATAN2", "BENCHMARK", "BIN", "BIT_COUNT", "BIT_LENGTH", "BUFFER", "CATALOG_NAME",
		"CEIL", "CEILING", "CENTROID", "CHARACTER_LENGTH", "CHARSET", "CHAR_LENGTH",
		"COERCIBILITY", "COLLATION", "COMPRESS", "CONCAT", "CONCAT_WS", "CONNECTION_ID",
		"CONV", "CONVERT_TZ", "COS", "COT", "CRC32", "CREATE_ASYMMETRIC_PRIV_KEY",
		"CREATE_ASYMMETRIC_PUB_KEY", "CREATE_DH_PARAMETERS", "CREATE_DIGEST",
		"CROSSES", "DATEDIFF", "DATE_FORMAT", "DAYNAME", "DAYOFMONTH", "DAYOFWEEK",
		"DAYOFYEAR", "DECODE", "DEGREES", "DES_DECRYPT", "DES_ENCRYPT", "DIMENSION",
		"DISJOINT", "ELT", "ENCODE", "ENCRYPT", "ENDPOINT", "ENGINE_ATTRIBUTE",
		"ENVELOPE", "EQUALS", "EXP", "EXPORT_SET", "EXTERIORRING", "EXTRACTVALUE",
		"FIELD", "FIND_IN_SET", "FLOOR", "FORMAT", "FOUND_ROWS", "FROM_BASE64",
		"FROM_DAYS", "FROM_UNIXTIME", "GEOMCOLLFROMTEXT", "GEOMCOLLFROMWKB",
		"GEOMETRYCOLLECTIONFROMTEXT", "GEOMETRYCOLLECTIONFROMWKB", "GEOMETRYFROMTEXT",
		"GEOMETRYFROMWKB", "GEOMETRYN", "GEOMETRYTYPE", "GEOMFROMTEXT", "GEOMFROMWKB",
		"GET_FORMAT", "GET_LOCK", "GLENGTH", "GREATEST", "GTID_SUBSET", "GTID_SUBTRACT",
		"HEX", "IFNULL", "INET6_ATON", "INET6_NTOA", "INET_ATON", "INET_NTOA",
		"INSTR", "INTERIORRINGN", "INTERSECTS", "ISCLOSED", "ISEMPTY", "ISNULL",
		"ISSIMPLE", "IS_FREE_LOCK", "IS_IPV4", "IS_IPV4_COMPAT", "IS_IPV4_MAPPED",
		"IS_IPV6", "IS_USED_LOCK", "LAST_INSERT_ID", "LCASE", "LEAST", "LENGTH",
		"LINEFROMTEXT", "LINEFROMWKB", "LINESTRINGFROMTEXT", "LINESTRINGFROMWKB",
		"LN", "LOAD_FILE", "LOCATE", "LOG", "LOG10", "LOG2", "LOWER", "LPAD",
		"LTRIM", "MAKEDATE", "MAKETIME", "MAKE_SET", "MASTER_POS_WAIT", "MBRCONTAINS",
		"MBRDISJOINT", "MBREQUAL", "MBRINTERSECTS", "MBROVERLAPS", "MBRTOUCHES",
		"MBRWITHIN", "MD5", "MLINEFROMTEXT", "MLINEFROMWKB", "MONTHNAME", "MPOINTFROMTEXT",
		"MPOINTFROMWKB", "MPOLYFROMTEXT", "MPOLYFROMWKB", "MULTILINESTRINGFROMTEXT",
		"MULTILINESTRINGFROMWKB", "MULTIPOINTFROMTEXT", "MULTIPOINTFROMWKB",
		"MULTIPOLYGONFROMTEXT", "MULTIPOLYGONFROMWKB", "NAME_CONST", "NULLIF",
		"NUMGEOMETRIES", "NUMINTERIORRINGS", "NUMPOINTS", "OCT", "OCTET_LENGTH",
		"ORD", "OVERLAPS", "PERIOD_ADD", "PERIOD_DIFF", "PI", "POINTFROMTEXT",
		"POINTFROMWKB", "POINTN", "POLYFROMTEXT", "POLYFROMWKB", "POLYGONFROMTEXT",
		"POLYGONFROMWKB", "POW", "POWER", "QUOTE", "RADIANS", "RAND", "RANDOM_BYTES",
		"RELEASE_LOCK", "REVERSE", "ROUND", "ROW_COUNT", "RPAD", "RTRIM", "SEC_TO_TIME",
		"SECONDARY_ENGINE_ATTRIBUTE", "SESSION_USER", "SHA", "SHA1", "SHA2",
		"SCHEMA_NAME", "SIGN", "SIN", "SLEEP", "SOUNDEX", "SQL_THREAD_WAIT_AFTER_GTIDS",
		"SQRT", "SRID", "STARTPOINT", "STRCMP", "STR_TO_DATE", "ST_AREA", "ST_ASBINARY",
		"ST_ASTEXT", "ST_ASWKB", "ST_ASWKT", "ST_BUFFER", "ST_CENTROID", "ST_CONTAINS",
		"ST_CROSSES", "ST_DIFFERENCE", "ST_DIMENSION", "ST_DISJOINT", "ST_DISTANCE",
		"ST_ENDPOINT", "ST_ENVELOPE", "ST_EQUALS", "ST_EXTERIORRING", "ST_GEOMCOLLFROMTEXT",
		"ST_GEOMCOLLFROMTXT", "ST_GEOMCOLLFROMWKB", "ST_GEOMETRYCOLLECTIONFROMTEXT",
		"ST_GEOMETRYCOLLECTIONFROMWKB", "ST_GEOMETRYFROMTEXT", "ST_GEOMETRYFROMWKB",
		"ST_GEOMETRYN", "ST_GEOMETRYTYPE", "ST_GEOMFROMTEXT", "ST_GEOMFROMWKB",
		"ST_INTERIORRINGN", "ST_INTERSECTION", "ST_INTERSECTS", "ST_ISCLOSED",
		"ST_ISEMPTY", "ST_ISSIMPLE", "ST_LINEFROMTEXT", "ST_LINEFROMWKB", "ST_LINESTRINGFROMTEXT",
		"ST_LINESTRINGFROMWKB", "ST_NUMGEOMETRIES", "ST_NUMINTERIORRING", "ST_NUMINTERIORRINGS",
		"ST_NUMPOINTS", "ST_OVERLAPS", "ST_POINTFROMTEXT", "ST_POINTFROMWKB",
		"ST_POINTN", "ST_POLYFROMTEXT", "ST_POLYFROMWKB", "ST_POLYGONFROMTEXT",
		"ST_POLYGONFROMWKB", "ST_SRID", "ST_STARTPOINT", "ST_SYMDIFFERENCE",
		"ST_TOUCHES", "ST_UNION", "ST_WITHIN", "ST_X", "ST_Y", "SUBDATE", "SUBSTRING_INDEX",
		"SUBTIME", "SYSTEM_USER", "TAN", "TIMEDIFF", "TIMESTAMPADD", "TIMESTAMPDIFF",
		"TIME_FORMAT", "TIME_TO_SEC", "TOUCHES", "TO_BASE64", "TO_DAYS", "TO_SECONDS",
		"TP_CONNECTION_ADMIN", "UCASE", "UNCOMPRESS", "UNCOMPRESSED_LENGTH",
		"UNHEX", "UNIX_TIMESTAMP", "UPDATEXML", "UPPER", "UUID", "UUID_SHORT",
		"VALIDATE_PASSWORD_STRENGTH", "VERSION", "WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS",
		"WEEKDAY", "WEEKOFYEAR", "WEIGHT_STRING", "WITHIN", "YEARWEEK", "Y_FUNCTION",
		"X_FUNCTION", "VAR_ASSIGN", "PLUS_ASSIGN", "MINUS_ASSIGN", "MULT_ASSIGN",
		"DIV_ASSIGN", "MOD_ASSIGN", "AND_ASSIGN", "XOR_ASSIGN", "OR_ASSIGN",
		"STAR", "DIVIDE", "MODULE", "PLUS", "MINUS", "DIV", "MOD", "EQUAL_SYMBOL",
		"GREATER_SYMBOL", "LESS_SYMBOL", "EXCLAMATION_SYMBOL", "BIT_NOT_OP",
		"BIT_OR_OP", "BIT_AND_OP", "BIT_XOR_OP", "DOT", "LR_BRACKET", "RR_BRACKET",
		"COMMA", "SEMI", "AT_SIGN", "ZERO_DECIMAL", "ONE_DECIMAL", "TWO_DECIMAL",
		"SINGLE_QUOTE_SYMB", "DOUBLE_QUOTE_SYMB", "REVERSE_QUOTE_SYMB", "COLON_SYMB",
		"CHARSET_REVERSE_QOUTE_STRING", "FILESIZE_LITERAL", "START_NATIONAL_STRING_LITERAL",
		"STRING_LITERAL", "DECIMAL_LITERAL", "HEXADECIMAL_LITERAL", "REAL_LITERAL",
		"NULL_SPEC_LITERAL", "BIT_STRING", "STRING_CHARSET_NAME", "DOT_ID",
		"ID", "REVERSE_QUOTE_ID", "STRING_USER_NAME", "IP_ADDRESS", "LOCAL_ID",
		"GLOBAL_ID", "BIND_PARAMETER", "ERROR_RECONGNIGION",
	}
	staticData.ruleNames = []string{
		"root", "sqlStatements", "sqlStatement", "emptyStatement_", "ddlStatement",
		"dmlStatement", "transactionStatement", "replicationStatement", "preparedStatement",
		"compoundStatement", "administrationStatement", "utilityStatement",
		"createDatabase", "createEvent", "createIndex", "createLogfileGroup",
		"createProcedure", "createFunction", "createRole", "createServer", "createTable",
		"createTablespaceInnodb", "createTablespaceNdb", "createTrigger", "withClause",
		"commonTableExpressions", "cteName", "cteColumnName", "createView",
		"createDatabaseOption", "charSet", "ownerStatement", "scheduleExpression",
		"timestampValue", "intervalExpr", "intervalType", "enableType", "indexType",
		"indexOption", "procedureParameter", "functionParameter", "routineOption",
		"serverOption", "createDefinitions", "createDefinition", "columnDefinition",
		"columnConstraint", "tableConstraint", "referenceDefinition", "referenceAction",
		"referenceControlType", "indexColumnDefinition", "tableOption", "tableType",
		"tablespaceStorage", "partitionDefinitions", "partitionFunctionDefinition",
		"subpartitionFunctionDefinition", "partitionDefinition", "partitionDefinerAtom",
		"partitionDefinerVector", "subpartitionDefinition", "partitionOption",
		"alterDatabase", "alterEvent", "alterFunction", "alterInstance", "alterLogfileGroup",
		"alterProcedure", "alterServer", "alterTable", "alterTablespace", "alterView",
		"alterSpecification", "dropDatabase", "dropEvent", "dropIndex", "dropLogfileGroup",
		"dropProcedure", "dropFunction", "dropServer", "dropTable", "dropTablespace",
		"dropTrigger", "dropView", "dropRole", "setRole", "renameTable", "renameTableClause",
		"truncateTable", "callStatement", "deleteStatement", "doStatement",
		"handlerStatement", "insertStatement", "loadDataStatement", "loadXmlStatement",
		"replaceStatement", "selectStatement", "updateStatement", "valuesStatement",
		"insertStatementValue", "updatedElement", "assignmentField", "lockClause",
		"singleDeleteStatement", "multipleDeleteStatement", "handlerOpenStatement",
		"handlerReadIndexStatement", "handlerReadStatement", "handlerCloseStatement",
		"singleUpdateStatement", "multipleUpdateStatement", "orderByClause",
		"orderByExpression", "tableSources", "tableSource", "tableSourceItem",
		"indexHint", "indexHintType", "joinPart", "queryExpression", "queryExpressionNointo",
		"querySpecification", "querySpecificationNointo", "unionParenthesis",
		"unionStatement", "lateralStatement", "jsonTable", "jsonColumnList",
		"jsonColumn", "jsonOnEmpty", "jsonOnError", "selectSpec", "selectElements",
		"selectElement", "selectIntoExpression", "selectFieldsInto", "selectLinesInto",
		"fromClause", "groupByClause", "havingClause", "windowClause", "groupByItem",
		"limitClause", "limitClauseAtom", "startTransaction", "beginWork", "commitWork",
		"rollbackWork", "savepointStatement", "rollbackStatement", "releaseStatement",
		"lockTables", "unlockTables", "setAutocommitStatement", "setTransactionStatement",
		"transactionMode", "lockTableElement", "lockAction", "transactionOption",
		"transactionLevel", "changeMaster", "changeReplicationFilter", "purgeBinaryLogs",
		"resetMaster", "resetSlave", "startSlave", "stopSlave", "startGroupReplication",
		"stopGroupReplication", "masterOption", "stringMasterOption", "decimalMasterOption",
		"boolMasterOption", "channelOption", "replicationFilter", "tablePair",
		"threadType", "untilOption", "connectionOption", "gtuidSet", "xaStartTransaction",
		"xaEndTransaction", "xaPrepareStatement", "xaCommitWork", "xaRollbackWork",
		"xaRecoverWork", "prepareStatement", "executeStatement", "deallocatePrepare",
		"routineBody", "blockStatement", "caseStatement", "ifStatement", "iterateStatement",
		"leaveStatement", "loopStatement", "repeatStatement", "returnStatement",
		"whileStatement", "cursorStatement", "declareVariable", "declareCondition",
		"declareCursor", "declareHandler", "handlerConditionValue", "procedureSqlStatement",
		"caseAlternative", "elifAlternative", "alterUser", "createUser", "dropUser",
		"grantStatement", "roleOption", "grantProxy", "renameUser", "revokeStatement",
		"revokeProxy", "setPasswordStatement", "userSpecification", "userAuthOption",
		"authenticationRule", "tlsOption", "userResourceOption", "userPasswordOption",
		"userLockOption", "privelegeClause", "privilege", "privilegeLevel",
		"renameUserClause", "analyzeTable", "checkTable", "checksumTable", "optimizeTable",
		"repairTable", "checkTableOption", "createUdfunction", "installPlugin",
		"uninstallPlugin", "setStatement", "showStatement", "variableClause",
		"showCommonEntity", "showFilter", "showGlobalInfoClause", "showSchemaEntity",
		"showProfileType", "binlogStatement", "cacheIndexStatement", "flushStatement",
		"killStatement", "loadIndexIntoCache", "resetStatement", "shutdownStatement",
		"tableIndexes", "flushOption", "flushTableOption", "loadedTableIndexes",
		"simpleDescribeStatement", "fullDescribeStatement", "helpStatement",
		"useStatement", "signalStatement", "resignalStatement", "signalConditionInformation",
		"withStatement", "diagnosticsStatement", "diagnosticsConditionInformationName",
		"describeObjectClause", "fullId", "tableName", "roleName", "fullColumnName",
		"indexColumnName", "userName", "mysqlVariable", "charsetName", "collationName",
		"engineName", "uuidSet", "xid", "xuidStringId", "authPlugin", "uid",
		"simpleId", "dottedId", "decimalLiteral", "fileSizeLiteral", "stringLiteral",
		"booleanLiteral", "hexadecimalLiteral", "nullNotnull", "constant", "dataType",
		"collectionOptions", "convertedDataType", "lengthOneDimension", "lengthTwoDimension",
		"lengthTwoOptionalDimension", "uidList", "fullColumnNameList", "tables",
		"indexColumnNames", "expressions", "expressionsWithDefaults", "constants",
		"simpleStrings", "userVariables", "defaultValue", "currentTimestamp",
		"expressionOrDefault", "ifExists", "ifNotExists", "orReplace", "waitNowaitClause",
		"functionCall", "specificFunction", "caseFuncAlternative", "levelsInWeightString",
		"levelInWeightListElement", "aggregateWindowedFunction", "nonAggregateWindowedFunction",
		"overClause", "windowSpec", "windowName", "frameClause", "frameUnits",
		"frameExtent", "frameBetween", "frameRange", "partitionClause", "scalarFunctionName",
		"passwordFunctionClause", "functionArgs", "functionArg", "expression",
		"predicate", "expressionAtom", "unaryOperator", "comparisonOperator",
		"logicalOperator", "bitOperator", "mathOperator", "jsonOperator", "charsetNameBase",
		"transactionLevelBase", "privilegesBase", "intervalTypeBase", "dataTypeBase",
		"keywordsCanBeId", "functionNameBase",
	}
	staticData.predictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 1161, 7373, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7,
		153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2,
		158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7,
		162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2,
		167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7,
		171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2,
		176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7,
		180, 2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2,
		185, 7, 185, 2, 186, 7, 186, 2, 187, 7, 187, 2, 188, 7, 188, 2, 189, 7,
		189, 2, 190, 7, 190, 2, 191, 7, 191, 2, 192, 7, 192, 2, 193, 7, 193, 2,
		194, 7, 194, 2, 195, 7, 195, 2, 196, 7, 196, 2, 197, 7, 197, 2, 198, 7,
		198, 2, 199, 7, 199, 2, 200, 7, 200, 2, 201, 7, 201, 2, 202, 7, 202, 2,
		203, 7, 203, 2, 204, 7, 204, 2, 205, 7, 205, 2, 206, 7, 206, 2, 207, 7,
		207, 2, 208, 7, 208, 2, 209, 7, 209, 2, 210, 7, 210, 2, 211, 7, 211, 2,
		212, 7, 212, 2, 213, 7, 213, 2, 214, 7, 214, 2, 215, 7, 215, 2, 216, 7,
		216, 2, 217, 7, 217, 2, 218, 7, 218, 2, 219, 7, 219, 2, 220, 7, 220, 2,
		221, 7, 221, 2, 222, 7, 222, 2, 223, 7, 223, 2, 224, 7, 224, 2, 225, 7,
		225, 2, 226, 7, 226, 2, 227, 7, 227, 2, 228, 7, 228, 2, 229, 7, 229, 2,
		230, 7, 230, 2, 231, 7, 231, 2, 232, 7, 232, 2, 233, 7, 233, 2, 234, 7,
		234, 2, 235, 7, 235, 2, 236, 7, 236, 2, 237, 7, 237, 2, 238, 7, 238, 2,
		239, 7, 239, 2, 240, 7, 240, 2, 241, 7, 241, 2, 242, 7, 242, 2, 243, 7,
		243, 2, 244, 7, 244, 2, 245, 7, 245, 2, 246, 7, 246, 2, 247, 7, 247, 2,
		248, 7, 248, 2, 249, 7, 249, 2, 250, 7, 250, 2, 251, 7, 251, 2, 252, 7,
		252, 2, 253, 7, 253, 2, 254, 7, 254, 2, 255, 7, 255, 2, 256, 7, 256, 2,
		257, 7, 257, 2, 258, 7, 258, 2, 259, 7, 259, 2, 260, 7, 260, 2, 261, 7,
		261, 2, 262, 7, 262, 2, 263, 7, 263, 2, 264, 7, 264, 2, 265, 7, 265, 2,
		266, 7, 266, 2, 267, 7, 267, 2, 268, 7, 268, 2, 269, 7, 269, 2, 270, 7,
		270, 2, 271, 7, 271, 2, 272, 7, 272, 2, 273, 7, 273, 2, 274, 7, 274, 2,
		275, 7, 275, 2, 276, 7, 276, 2, 277, 7, 277, 2, 278, 7, 278, 2, 279, 7,
		279, 2, 280, 7, 280, 2, 281, 7, 281, 2, 282, 7, 282, 2, 283, 7, 283, 2,
		284, 7, 284, 2, 285, 7, 285, 2, 286, 7, 286, 2, 287, 7, 287, 2, 288, 7,
		288, 2, 289, 7, 289, 2, 290, 7, 290, 2, 291, 7, 291, 2, 292, 7, 292, 2,
		293, 7, 293, 2, 294, 7, 294, 2, 295, 7, 295, 2, 296, 7, 296, 2, 297, 7,
		297, 2, 298, 7, 298, 2, 299, 7, 299, 2, 300, 7, 300, 2, 301, 7, 301, 2,
		302, 7, 302, 2, 303, 7, 303, 2, 304, 7, 304, 2, 305, 7, 305, 2, 306, 7,
		306, 2, 307, 7, 307, 2, 308, 7, 308, 2, 309, 7, 309, 2, 310, 7, 310, 2,
		311, 7, 311, 2, 312, 7, 312, 2, 313, 7, 313, 2, 314, 7, 314, 2, 315, 7,
		315, 2, 316, 7, 316, 2, 317, 7, 317, 2, 318, 7, 318, 2, 319, 7, 319, 2,
		320, 7, 320, 2, 321, 7, 321, 2, 322, 7, 322, 2, 323, 7, 323, 2, 324, 7,
		324, 2, 325, 7, 325, 2, 326, 7, 326, 2, 327, 7, 327, 2, 328, 7, 328, 2,
		329, 7, 329, 2, 330, 7, 330, 2, 331, 7, 331, 2, 332, 7, 332, 2, 333, 7,
		333, 2, 334, 7, 334, 2, 335, 7, 335, 2, 336, 7, 336, 2, 337, 7, 337, 2,
		338, 7, 338, 2, 339, 7, 339, 2, 340, 7, 340, 2, 341, 7, 341, 2, 342, 7,
		342, 2, 343, 7, 343, 2, 344, 7, 344, 2, 345, 7, 345, 2, 346, 7, 346, 2,
		347, 7, 347, 2, 348, 7, 348, 2, 349, 7, 349, 2, 350, 7, 350, 2, 351, 7,
		351, 1, 0, 3, 0, 706, 8, 0, 1, 0, 1, 0, 3, 0, 710, 8, 0, 1, 0, 1, 0, 1,
		1, 1, 1, 1, 1, 3, 1, 717, 8, 1, 1, 1, 3, 1, 720, 8, 1, 1, 1, 5, 1, 723,
		8, 1, 10, 1, 12, 1, 726, 9, 1, 1, 1, 1, 1, 1, 1, 3, 1, 731, 8, 1, 1, 1,
		3, 1, 734, 8, 1, 1, 1, 3, 1, 737, 8, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1,
		2, 1, 2, 3, 2, 746, 8, 2, 1, 3, 1, 3, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 788, 8, 4, 1,
		5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3,
		5, 802, 8, 5, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 3,
		6, 813, 8, 6, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1,
		7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 3, 7, 830, 8, 7, 1, 8, 1, 8, 1, 8, 3,
		8, 835, 8, 8, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1,
		9, 3, 9, 847, 8, 9, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1,
		10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10,
		1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 3, 10, 874, 8, 10, 1,
		11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 3, 11, 883, 8, 11, 1, 12,
		1, 12, 1, 12, 3, 12, 888, 8, 12, 1, 12, 1, 12, 5, 12, 892, 8, 12, 10, 12,
		12, 12, 895, 9, 12, 1, 13, 1, 13, 3, 13, 899, 8, 13, 1, 13, 1, 13, 3, 13,
		903, 8, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 912,
		8, 13, 1, 13, 3, 13, 915, 8, 13, 1, 13, 3, 13, 918, 8, 13, 1, 13, 1, 13,
		3, 13, 922, 8, 13, 1, 13, 1, 13, 1, 13, 1, 14, 1, 14, 3, 14, 929, 8, 14,
		1, 14, 3, 14, 932, 8, 14, 1, 14, 1, 14, 1, 14, 3, 14, 937, 8, 14, 1, 14,
		1, 14, 1, 14, 1, 14, 5, 14, 943, 8, 14, 10, 14, 12, 14, 946, 9, 14, 1,
		14, 1, 14, 3, 14, 950, 8, 14, 1, 14, 1, 14, 1, 14, 3, 14, 955, 8, 14, 1,
		14, 5, 14, 958, 8, 14, 10, 14, 12, 14, 961, 9, 14, 1, 15, 1, 15, 1, 15,
		1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 972, 8, 15, 1, 15, 3,
		15, 975, 8, 15, 1, 15, 1, 15, 3, 15, 979, 8, 15, 1, 15, 3, 15, 982, 8,
		15, 1, 15, 1, 15, 3, 15, 986, 8, 15, 1, 15, 3, 15, 989, 8, 15, 1, 15, 1,
		15, 3, 15, 993, 8, 15, 1, 15, 3, 15, 996, 8, 15, 1, 15, 3, 15, 999, 8,
		15, 1, 15, 1, 15, 3, 15, 1003, 8, 15, 1, 15, 3, 15, 1006, 8, 15, 1, 15,
		1, 15, 3, 15, 1010, 8, 15, 1, 15, 1, 15, 1, 16, 1, 16, 3, 16, 1016, 8,
		16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 1022, 8, 16, 1, 16, 1, 16, 5, 16,
		1026, 8, 16, 10, 16, 12, 16, 1029, 9, 16, 1, 16, 1, 16, 5, 16, 1033, 8,
		16, 10, 16, 12, 16, 1036, 9, 16, 1, 16, 1, 16, 1, 17, 1, 17, 3, 17, 1042,
		8, 17, 1, 17, 3, 17, 1045, 8, 17, 1, 17, 1, 17, 3, 17, 1049, 8, 17, 1,
		17, 1, 17, 1, 17, 3, 17, 1054, 8, 17, 1, 17, 1, 17, 5, 17, 1058, 8, 17,
		10, 17, 12, 17, 1061, 9, 17, 1, 17, 1, 17, 1, 17, 1, 17, 5, 17, 1067, 8,
		17, 10, 17, 12, 17, 1070, 9, 17, 1, 17, 1, 17, 3, 17, 1074, 8, 17, 1, 18,
		1, 18, 1, 18, 3, 18, 1079, 8, 18, 1, 18, 1, 18, 1, 18, 5, 18, 1084, 8,
		18, 10, 18, 12, 18, 1087, 9, 18, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1,
		19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 5, 19, 1101, 8, 19, 10, 19,
		12, 19, 1104, 9, 19, 1, 19, 1, 19, 1, 20, 1, 20, 3, 20, 1110, 8, 20, 1,
		20, 1, 20, 3, 20, 1114, 8, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20,
		1, 20, 1, 20, 3, 20, 1124, 8, 20, 1, 20, 1, 20, 3, 20, 1128, 8, 20, 1,
		20, 1, 20, 3, 20, 1132, 8, 20, 1, 20, 1, 20, 3, 20, 1136, 8, 20, 1, 20,
		1, 20, 3, 20, 1140, 8, 20, 1, 20, 5, 20, 1143, 8, 20, 10, 20, 12, 20, 1146,
		9, 20, 3, 20, 1148, 8, 20, 1, 20, 3, 20, 1151, 8, 20, 1, 20, 3, 20, 1154,
		8, 20, 1, 20, 3, 20, 1157, 8, 20, 1, 20, 1, 20, 1, 20, 1, 20, 3, 20, 1163,
		8, 20, 1, 20, 1, 20, 3, 20, 1167, 8, 20, 1, 20, 1, 20, 1, 20, 1, 20, 3,
		20, 1173, 8, 20, 1, 20, 5, 20, 1176, 8, 20, 10, 20, 12, 20, 1179, 9, 20,
		3, 20, 1181, 8, 20, 1, 20, 3, 20, 1184, 8, 20, 3, 20, 1186, 8, 20, 1, 21,
		1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 3, 21, 1197, 8,
		21, 1, 21, 1, 21, 3, 21, 1201, 8, 21, 1, 21, 3, 21, 1204, 8, 21, 1, 22,
		1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1,
		22, 3, 22, 1218, 8, 22, 1, 22, 3, 22, 1221, 8, 22, 1, 22, 1, 22, 3, 22,
		1225, 8, 22, 1, 22, 3, 22, 1228, 8, 22, 1, 22, 1, 22, 3, 22, 1232, 8, 22,
		1, 22, 3, 22, 1235, 8, 22, 1, 22, 1, 22, 3, 22, 1239, 8, 22, 1, 22, 3,
		22, 1242, 8, 22, 1, 22, 1, 22, 3, 22, 1246, 8, 22, 1, 22, 3, 22, 1249,
		8, 22, 1, 22, 3, 22, 1252, 8, 22, 1, 22, 1, 22, 3, 22, 1256, 8, 22, 1,
		22, 3, 22, 1259, 8, 22, 1, 22, 1, 22, 3, 22, 1263, 8, 22, 1, 22, 1, 22,
		1, 23, 1, 23, 3, 23, 1269, 8, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1,
		23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 3, 23, 1282, 8, 23, 1, 23, 1, 23,
		1, 24, 1, 24, 3, 24, 1288, 8, 24, 1, 24, 1, 24, 1, 25, 1, 25, 1, 25, 1,
		25, 1, 25, 5, 25, 1297, 8, 25, 10, 25, 12, 25, 1300, 9, 25, 1, 25, 1, 25,
		3, 25, 1304, 8, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 3, 25, 1312,
		8, 25, 1, 26, 1, 26, 1, 27, 1, 27, 1, 28, 1, 28, 3, 28, 1320, 8, 28, 1,
		28, 1, 28, 1, 28, 3, 28, 1325, 8, 28, 1, 28, 3, 28, 1328, 8, 28, 1, 28,
		1, 28, 1, 28, 3, 28, 1333, 8, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1,
		28, 3, 28, 1341, 8, 28, 1, 28, 1, 28, 1, 28, 3, 28, 1346, 8, 28, 1, 28,
		1, 28, 1, 28, 1, 28, 3, 28, 1352, 8, 28, 1, 28, 1, 28, 1, 28, 3, 28, 1357,
		8, 28, 1, 28, 1, 28, 3, 28, 1361, 8, 28, 3, 28, 1363, 8, 28, 1, 29, 3,
		29, 1366, 8, 29, 1, 29, 1, 29, 3, 29, 1370, 8, 29, 1, 29, 1, 29, 3, 29,
		1374, 8, 29, 1, 29, 3, 29, 1377, 8, 29, 1, 29, 1, 29, 3, 29, 1381, 8, 29,
		1, 29, 1, 29, 3, 29, 1385, 8, 29, 1, 29, 1, 29, 3, 29, 1389, 8, 29, 1,
		29, 1, 29, 1, 29, 1, 29, 3, 29, 1395, 8, 29, 1, 29, 3, 29, 1398, 8, 29,
		1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 1405, 8, 30, 1, 31, 1, 31, 1,
		31, 1, 31, 1, 31, 1, 31, 3, 31, 1413, 8, 31, 3, 31, 1415, 8, 31, 1, 32,
		1, 32, 1, 32, 5, 32, 1420, 8, 32, 10, 32, 12, 32, 1423, 9, 32, 1, 32, 1,
		32, 1, 32, 3, 32, 1428, 8, 32, 1, 32, 1, 32, 1, 32, 1, 32, 5, 32, 1434,
		8, 32, 10, 32, 12, 32, 1437, 9, 32, 3, 32, 1439, 8, 32, 1, 32, 1, 32, 1,
		32, 5, 32, 1444, 8, 32, 10, 32, 12, 32, 1447, 9, 32, 3, 32, 1449, 8, 32,
		3, 32, 1451, 8, 32, 1, 33, 1, 33, 1, 33, 1, 33, 3, 33, 1457, 8, 33, 1,
		34, 1, 34, 1, 34, 1, 34, 3, 34, 1463, 8, 34, 1, 34, 1, 34, 1, 35, 1, 35,
		1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1,
		35, 3, 35, 1480, 8, 35, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 3, 36, 1487,
		8, 36, 1, 37, 1, 37, 1, 37, 1, 38, 1, 38, 3, 38, 1494, 8, 38, 1, 38, 1,
		38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 3, 38, 1506,
		8, 38, 1, 38, 1, 38, 1, 38, 3, 38, 1511, 8, 38, 1, 38, 3, 38, 1514, 8,
		38, 1, 39, 3, 39, 1517, 8, 39, 1, 39, 1, 39, 1, 39, 1, 40, 1, 40, 1, 40,
		1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 1530, 8, 41, 1, 41, 1, 41, 1,
		41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 1543,
		8, 41, 1, 41, 1, 41, 1, 41, 3, 41, 1548, 8, 41, 1, 42, 1, 42, 1, 42, 1,
		42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42,
		3, 42, 1564, 8, 42, 1, 43, 1, 43, 1, 43, 1, 43, 5, 43, 1570, 8, 43, 10,
		43, 12, 43, 1573, 9, 43, 1, 43, 1, 43, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44,
		3, 44, 1582, 8, 44, 1, 44, 3, 44, 1585, 8, 44, 1, 44, 3, 44, 1588, 8, 44,
		1, 45, 1, 45, 5, 45, 1592, 8, 45, 10, 45, 12, 45, 1595, 9, 45, 1, 45, 3,
		45, 1598, 8, 45, 1, 45, 3, 45, 1601, 8, 45, 1, 46, 1, 46, 1, 46, 1, 46,
		1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 3, 46, 1612, 8, 46, 1, 46, 3, 46, 1615,
		8, 46, 1, 46, 1, 46, 1, 46, 3, 46, 1620, 8, 46, 1, 46, 1, 46, 1, 46, 1,
		46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 3, 46, 1633, 8, 46,
		1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 3, 46, 1640, 8, 46, 1, 46, 1, 46, 1,
		46, 1, 46, 1, 46, 3, 46, 1647, 8, 46, 3, 46, 1649, 8, 46, 1, 46, 1, 46,
		1, 46, 1, 46, 1, 46, 3, 46, 1656, 8, 46, 1, 47, 1, 47, 3, 47, 1660, 8,
		47, 3, 47, 1662, 8, 47, 1, 47, 1, 47, 1, 47, 3, 47, 1667, 8, 47, 1, 47,
		3, 47, 1670, 8, 47, 1, 47, 1, 47, 5, 47, 1674, 8, 47, 10, 47, 12, 47, 1677,
		9, 47, 1, 47, 1, 47, 3, 47, 1681, 8, 47, 3, 47, 1683, 8, 47, 1, 47, 1,
		47, 3, 47, 1687, 8, 47, 1, 47, 3, 47, 1690, 8, 47, 1, 47, 3, 47, 1693,
		8, 47, 1, 47, 1, 47, 5, 47, 1697, 8, 47, 10, 47, 12, 47, 1700, 9, 47, 1,
		47, 1, 47, 3, 47, 1704, 8, 47, 3, 47, 1706, 8, 47, 1, 47, 1, 47, 1, 47,
		3, 47, 1711, 8, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 3, 47, 1718, 8,
		47, 3, 47, 1720, 8, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 3, 47, 1727,
		8, 47, 1, 48, 1, 48, 1, 48, 3, 48, 1732, 8, 48, 1, 48, 1, 48, 3, 48, 1736,
		8, 48, 1, 48, 3, 48, 1739, 8, 48, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1,
		49, 3, 49, 1747, 8, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 3, 49,
		1755, 8, 49, 3, 49, 1757, 8, 49, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1,
		50, 1, 50, 1, 50, 3, 50, 1767, 8, 50, 1, 51, 1, 51, 3, 51, 1771, 8, 51,
		1, 51, 3, 51, 1774, 8, 51, 1, 51, 1, 51, 5, 51, 1778, 8, 51, 10, 51, 12,
		51, 1781, 9, 51, 1, 51, 1, 51, 3, 51, 1785, 8, 51, 1, 51, 3, 51, 1788,
		8, 51, 1, 51, 1, 51, 5, 51, 1792, 8, 51, 10, 51, 12, 51, 1795, 9, 51, 3,
		51, 1797, 8, 51, 1, 52, 1, 52, 3, 52, 1801, 8, 52, 1, 52, 3, 52, 1804,
		8, 52, 1, 52, 1, 52, 3, 52, 1808, 8, 52, 1, 52, 1, 52, 1, 52, 3, 52, 1813,
		8, 52, 1, 52, 1, 52, 1, 52, 3, 52, 1818, 8, 52, 1, 52, 1, 52, 1, 52, 3,
		52, 1823, 8, 52, 1, 52, 1, 52, 3, 52, 1827, 8, 52, 1, 52, 1, 52, 3, 52,
		1831, 8, 52, 1, 52, 1, 52, 3, 52, 1835, 8, 52, 1, 52, 1, 52, 3, 52, 1839,
		8, 52, 1, 52, 1, 52, 3, 52, 1843, 8, 52, 1, 52, 1, 52, 3, 52, 1847, 8,
		52, 1, 52, 1, 52, 1, 52, 3, 52, 1852, 8, 52, 1, 52, 1, 52, 1, 52, 3, 52,
		1857, 8, 52, 1, 52, 1, 52, 1, 52, 3, 52, 1862, 8, 52, 1, 52, 1, 52, 1,
		52, 1, 52, 3, 52, 1868, 8, 52, 1, 52, 1, 52, 1, 52, 3, 52, 1873, 8, 52,
		1, 52, 1, 52, 1, 52, 3, 52, 1878, 8, 52, 1, 52, 1, 52, 1, 52, 3, 52, 1883,
		8, 52, 1, 52, 1, 52, 1, 52, 3, 52, 1888, 8, 52, 1, 52, 1, 52, 1, 52, 3,
		52, 1893, 8, 52, 1, 52, 1, 52, 1, 52, 1, 52, 3, 52, 1899, 8, 52, 1, 52,
		1, 52, 1, 52, 3, 52, 1904, 8, 52, 1, 52, 1, 52, 1, 52, 3, 52, 1909, 8,
		52, 1, 52, 1, 52, 1, 52, 3, 52, 1914, 8, 52, 1, 52, 1, 52, 1, 52, 3, 52,
		1919, 8, 52, 1, 52, 1, 52, 1, 52, 3, 52, 1924, 8, 52, 1, 52, 1, 52, 1,
		52, 3, 52, 1929, 8, 52, 1, 52, 1, 52, 1, 52, 3, 52, 1934, 8, 52, 1, 52,
		1, 52, 1, 52, 1, 52, 1, 52, 3, 52, 1941, 8, 52, 1, 52, 1, 52, 1, 52, 3,
		52, 1946, 8, 52, 1, 52, 1, 52, 1, 52, 3, 52, 1951, 8, 52, 1, 52, 1, 52,
		1, 52, 3, 52, 1956, 8, 52, 1, 52, 1, 52, 3, 52, 1960, 8, 52, 1, 52, 1,
		52, 1, 52, 3, 52, 1965, 8, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52,
		3, 52, 1973, 8, 52, 1, 52, 1, 52, 1, 52, 3, 52, 1978, 8, 52, 1, 52, 1,
		52, 1, 52, 1, 52, 3, 52, 1984, 8, 52, 1, 53, 1, 53, 1, 54, 1, 54, 1, 54,
		1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 3, 55, 1996, 8, 55, 1, 55, 1, 55, 1,
		55, 1, 55, 1, 55, 3, 55, 2003, 8, 55, 3, 55, 2005, 8, 55, 1, 55, 1, 55,
		1, 55, 1, 55, 5, 55, 2011, 8, 55, 10, 55, 12, 55, 2014, 9, 55, 1, 55, 1,
		55, 3, 55, 2018, 8, 55, 1, 56, 3, 56, 2021, 8, 56, 1, 56, 1, 56, 1, 56,
		1, 56, 1, 56, 1, 56, 3, 56, 2029, 8, 56, 1, 56, 1, 56, 1, 56, 1, 56, 3,
		56, 2035, 8, 56, 1, 56, 1, 56, 3, 56, 2039, 8, 56, 1, 56, 1, 56, 1, 56,
		1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 3, 56, 2052, 8,
		56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56,
		3, 56, 2064, 8, 56, 3, 56, 2066, 8, 56, 1, 57, 3, 57, 2069, 8, 57, 1, 57,
		1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 2077, 8, 57, 1, 57, 1, 57, 1,
		57, 1, 57, 3, 57, 2083, 8, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 2089,
		8, 57, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 5,
		58, 2100, 8, 58, 10, 58, 12, 58, 2103, 9, 58, 1, 58, 1, 58, 5, 58, 2107,
		8, 58, 10, 58, 12, 58, 2110, 9, 58, 1, 58, 1, 58, 1, 58, 1, 58, 5, 58,
		2116, 8, 58, 10, 58, 12, 58, 2119, 9, 58, 1, 58, 1, 58, 3, 58, 2123, 8,
		58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 5, 58, 2132, 8, 58,
		10, 58, 12, 58, 2135, 9, 58, 1, 58, 1, 58, 1, 58, 1, 58, 5, 58, 2141, 8,
		58, 10, 58, 12, 58, 2144, 9, 58, 1, 58, 1, 58, 3, 58, 2148, 8, 58, 1, 58,
		1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 5, 58, 2158, 8, 58, 10,
		58, 12, 58, 2161, 9, 58, 1, 58, 1, 58, 5, 58, 2165, 8, 58, 10, 58, 12,
		58, 2168, 9, 58, 1, 58, 1, 58, 1, 58, 1, 58, 5, 58, 2174, 8, 58, 10, 58,
		12, 58, 2177, 9, 58, 1, 58, 1, 58, 3, 58, 2181, 8, 58, 1, 58, 1, 58, 1,
		58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 5, 58, 2191, 8, 58, 10, 58, 12,
		58, 2194, 9, 58, 1, 58, 1, 58, 5, 58, 2198, 8, 58, 10, 58, 12, 58, 2201,
		9, 58, 1, 58, 1, 58, 1, 58, 1, 58, 5, 58, 2207, 8, 58, 10, 58, 12, 58,
		2210, 9, 58, 1, 58, 1, 58, 3, 58, 2214, 8, 58, 1, 58, 1, 58, 1, 58, 5,
		58, 2219, 8, 58, 10, 58, 12, 58, 2222, 9, 58, 1, 58, 1, 58, 1, 58, 1, 58,
		5, 58, 2228, 8, 58, 10, 58, 12, 58, 2231, 9, 58, 1, 58, 1, 58, 3, 58, 2235,
		8, 58, 3, 58, 2237, 8, 58, 1, 59, 1, 59, 1, 59, 3, 59, 2242, 8, 59, 1,
		60, 1, 60, 1, 60, 1, 60, 4, 60, 2248, 8, 60, 11, 60, 12, 60, 2249, 1, 60,
		1, 60, 1, 61, 1, 61, 1, 61, 5, 61, 2257, 8, 61, 10, 61, 12, 61, 2260, 9,
		61, 1, 62, 3, 62, 2263, 8, 62, 1, 62, 3, 62, 2266, 8, 62, 1, 62, 1, 62,
		3, 62, 2270, 8, 62, 1, 62, 1, 62, 1, 62, 3, 62, 2275, 8, 62, 1, 62, 1,
		62, 1, 62, 1, 62, 3, 62, 2281, 8, 62, 1, 62, 1, 62, 1, 62, 1, 62, 3, 62,
		2287, 8, 62, 1, 62, 1, 62, 1, 62, 3, 62, 2292, 8, 62, 1, 62, 1, 62, 1,
		62, 3, 62, 2297, 8, 62, 1, 62, 1, 62, 1, 62, 3, 62, 2302, 8, 62, 1, 62,
		1, 62, 1, 62, 3, 62, 2307, 8, 62, 1, 62, 3, 62, 2310, 8, 62, 1, 63, 1,
		63, 1, 63, 3, 63, 2315, 8, 63, 1, 63, 4, 63, 2318, 8, 63, 11, 63, 12, 63,
		2319, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 3, 63, 2330,
		8, 63, 1, 64, 1, 64, 3, 64, 2334, 8, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1,
		64, 3, 64, 2341, 8, 64, 1, 64, 1, 64, 1, 64, 3, 64, 2346, 8, 64, 1, 64,
		3, 64, 2349, 8, 64, 1, 64, 1, 64, 1, 64, 3, 64, 2354, 8, 64, 1, 64, 3,
		64, 2357, 8, 64, 1, 64, 1, 64, 3, 64, 2361, 8, 64, 1, 64, 1, 64, 3, 64,
		2365, 8, 64, 1, 65, 1, 65, 1, 65, 1, 65, 5, 65, 2371, 8, 65, 10, 65, 12,
		65, 2374, 9, 65, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 67,
		1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 3, 67, 2392, 8,
		67, 1, 67, 3, 67, 2395, 8, 67, 1, 67, 3, 67, 2398, 8, 67, 1, 67, 1, 67,
		3, 67, 2402, 8, 67, 1, 67, 1, 67, 1, 68, 1, 68, 1, 68, 1, 68, 5, 68, 2410,
		8, 68, 10, 68, 12, 68, 2413, 9, 68, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69,
		1, 69, 1, 69, 1, 69, 5, 69, 2423, 8, 69, 10, 69, 12, 69, 2426, 9, 69, 1,
		69, 1, 69, 1, 70, 1, 70, 3, 70, 2432, 8, 70, 1, 70, 3, 70, 2435, 8, 70,
		1, 70, 1, 70, 1, 70, 3, 70, 2440, 8, 70, 1, 70, 1, 70, 1, 70, 5, 70, 2445,
		8, 70, 10, 70, 12, 70, 2448, 9, 70, 3, 70, 2450, 8, 70, 1, 70, 3, 70, 2453,
		8, 70, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 3,
		71, 2464, 8, 71, 1, 71, 3, 71, 2467, 8, 71, 1, 71, 1, 71, 3, 71, 2471,
		8, 71, 1, 71, 1, 71, 1, 72, 1, 72, 1, 72, 1, 72, 3, 72, 2479, 8, 72, 1,
		72, 3, 72, 2482, 8, 72, 1, 72, 1, 72, 1, 72, 3, 72, 2487, 8, 72, 1, 72,
		1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 3, 72, 2495, 8, 72, 1, 72, 1, 72, 1,
		72, 1, 72, 3, 72, 2501, 8, 72, 1, 72, 1, 72, 3, 72, 2505, 8, 72, 1, 73,
		1, 73, 3, 73, 2509, 8, 73, 1, 73, 5, 73, 2512, 8, 73, 10, 73, 12, 73, 2515,
		9, 73, 1, 73, 1, 73, 3, 73, 2519, 8, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1,
		73, 3, 73, 2526, 8, 73, 1, 73, 1, 73, 3, 73, 2530, 8, 73, 1, 73, 1, 73,
		1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 5, 73, 2539, 8, 73, 10, 73, 12, 73,
		2542, 9, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 2549, 8, 73, 1,
		73, 3, 73, 2552, 8, 73, 1, 73, 1, 73, 5, 73, 2556, 8, 73, 10, 73, 12, 73,
		2559, 9, 73, 1, 73, 1, 73, 1, 73, 3, 73, 2564, 8, 73, 3, 73, 2566, 8, 73,
		1, 73, 1, 73, 1, 73, 3, 73, 2571, 8, 73, 1, 73, 3, 73, 2574, 8, 73, 1,
		73, 1, 73, 5, 73, 2578, 8, 73, 10, 73, 12, 73, 2581, 9, 73, 1, 73, 1, 73,
		1, 73, 3, 73, 2586, 8, 73, 3, 73, 2588, 8, 73, 1, 73, 1, 73, 3, 73, 2592,
		8, 73, 1, 73, 3, 73, 2595, 8, 73, 1, 73, 3, 73, 2598, 8, 73, 1, 73, 1,
		73, 5, 73, 2602, 8, 73, 10, 73, 12, 73, 2605, 9, 73, 1, 73, 1, 73, 1, 73,
		3, 73, 2610, 8, 73, 1, 73, 3, 73, 2613, 8, 73, 1, 73, 1, 73, 5, 73, 2617,
		8, 73, 10, 73, 12, 73, 2620, 9, 73, 1, 73, 1, 73, 1, 73, 3, 73, 2625, 8,
		73, 3, 73, 2627, 8, 73, 1, 73, 1, 73, 1, 73, 3, 73, 2632, 8, 73, 1, 73,
		1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 2640, 8, 73, 3, 73, 2642, 8,
		73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 2651, 8, 73,
		1, 73, 3, 73, 2654, 8, 73, 1, 73, 3, 73, 2657, 8, 73, 1, 73, 1, 73, 1,
		73, 3, 73, 2662, 8, 73, 3, 73, 2664, 8, 73, 1, 73, 1, 73, 1, 73, 1, 73,
		1, 73, 1, 73, 1, 73, 3, 73, 2673, 8, 73, 1, 73, 3, 73, 2676, 8, 73, 1,
		73, 3, 73, 2679, 8, 73, 1, 73, 1, 73, 1, 73, 3, 73, 2684, 8, 73, 3, 73,
		2686, 8, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 2695,
		8, 73, 1, 73, 1, 73, 1, 73, 3, 73, 2700, 8, 73, 1, 73, 1, 73, 1, 73, 1,
		73, 1, 73, 1, 73, 3, 73, 2708, 8, 73, 1, 73, 1, 73, 3, 73, 2712, 8, 73,
		1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 2720, 8, 73, 1, 73, 1,
		73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 2730, 8, 73, 1, 73,
		1, 73, 1, 73, 3, 73, 2735, 8, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3,
		73, 2742, 8, 73, 1, 73, 1, 73, 3, 73, 2746, 8, 73, 1, 73, 1, 73, 3, 73,
		2750, 8, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1,
		73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 2769,
		8, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 2779,
		8, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 2785, 8, 73, 1, 73, 1, 73, 1,
		73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73,
		1, 73, 1, 73, 3, 73, 2802, 8, 73, 1, 73, 1, 73, 3, 73, 2806, 8, 73, 1,
		73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 2816, 8, 73,
		1, 73, 1, 73, 1, 73, 3, 73, 2821, 8, 73, 1, 73, 3, 73, 2824, 8, 73, 1,
		73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 2833, 8, 73, 1, 73,
		1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1,
		73, 1, 73, 5, 73, 2848, 8, 73, 10, 73, 12, 73, 2851, 9, 73, 1, 73, 1, 73,
		1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 2862, 8, 73, 1,
		73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 2869, 8, 73, 1, 73, 1, 73, 1, 73,
		1, 73, 1, 73, 3, 73, 2876, 8, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1,
		73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 5, 73, 2889, 8, 73, 10, 73, 12,
		73, 2892, 9, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73,
		1, 73, 1, 73, 3, 73, 2904, 8, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 2910,
		8, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 2916, 8, 73, 1, 73, 1, 73, 1,
		73, 1, 73, 3, 73, 2922, 8, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 2928,
		8, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 2934, 8, 73, 1, 73, 1, 73, 1,
		73, 1, 73, 1, 73, 1, 73, 3, 73, 2942, 8, 73, 1, 73, 1, 73, 1, 73, 1, 73,
		5, 73, 2948, 8, 73, 10, 73, 12, 73, 2951, 9, 73, 1, 73, 1, 73, 3, 73, 2955,
		8, 73, 1, 74, 1, 74, 1, 74, 3, 74, 2960, 8, 74, 1, 74, 1, 74, 1, 75, 1,
		75, 1, 75, 3, 75, 2967, 8, 75, 1, 75, 1, 75, 1, 76, 1, 76, 1, 76, 3, 76,
		2974, 8, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 3, 76, 2981, 8, 76, 1,
		76, 1, 76, 1, 76, 3, 76, 2986, 8, 76, 1, 76, 5, 76, 2989, 8, 76, 10, 76,
		12, 76, 2992, 9, 76, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1,
		77, 1, 78, 1, 78, 1, 78, 3, 78, 3005, 8, 78, 1, 78, 1, 78, 1, 79, 1, 79,
		1, 79, 3, 79, 3012, 8, 79, 1, 79, 1, 79, 1, 80, 1, 80, 1, 80, 3, 80, 3019,
		8, 80, 1, 80, 1, 80, 1, 81, 1, 81, 3, 81, 3025, 8, 81, 1, 81, 1, 81, 3,
		81, 3029, 8, 81, 1, 81, 1, 81, 3, 81, 3033, 8, 81, 1, 82, 1, 82, 1, 82,
		1, 82, 1, 82, 3, 82, 3040, 8, 82, 1, 82, 3, 82, 3043, 8, 82, 1, 83, 1,
		83, 1, 83, 3, 83, 3048, 8, 83, 1, 83, 1, 83, 1, 84, 1, 84, 1, 84, 3, 84,
		3055, 8, 84, 1, 84, 1, 84, 1, 84, 5, 84, 3060, 8, 84, 10, 84, 12, 84, 3063,
		9, 84, 1, 84, 3, 84, 3066, 8, 84, 1, 85, 1, 85, 1, 85, 3, 85, 3071, 8,
		85, 1, 85, 1, 85, 1, 85, 5, 85, 3076, 8, 85, 10, 85, 12, 85, 3079, 9, 85,
		1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 5, 86, 3089, 8,
		86, 10, 86, 12, 86, 3092, 9, 86, 3, 86, 3094, 8, 86, 1, 86, 1, 86, 1, 86,
		3, 86, 3099, 8, 86, 1, 86, 1, 86, 1, 86, 3, 86, 3104, 8, 86, 5, 86, 3106,
		8, 86, 10, 86, 12, 86, 3109, 9, 86, 1, 86, 1, 86, 1, 86, 3, 86, 3114, 8,
		86, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 5, 87, 3121, 8, 87, 10, 87, 12,
		87, 3124, 9, 87, 1, 88, 1, 88, 1, 88, 1, 88, 1, 89, 1, 89, 3, 89, 3132,
		8, 89, 1, 89, 1, 89, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 3, 90, 3141, 8,
		90, 1, 90, 3, 90, 3144, 8, 90, 1, 91, 1, 91, 3, 91, 3148, 8, 91, 1, 92,
		1, 92, 1, 92, 1, 93, 1, 93, 1, 93, 1, 93, 3, 93, 3157, 8, 93, 1, 94, 1,
		94, 3, 94, 3161, 8, 94, 1, 94, 3, 94, 3164, 8, 94, 1, 94, 3, 94, 3167,
		8, 94, 1, 94, 1, 94, 1, 94, 1, 94, 3, 94, 3173, 8, 94, 1, 94, 3, 94, 3176,
		8, 94, 1, 94, 1, 94, 1, 94, 1, 94, 3, 94, 3182, 8, 94, 1, 94, 1, 94, 1,
		94, 1, 94, 1, 94, 5, 94, 3189, 8, 94, 10, 94, 12, 94, 3192, 9, 94, 3, 94,
		3194, 8, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 5, 94, 3202, 8,
		94, 10, 94, 12, 94, 3205, 9, 94, 1, 94, 1, 94, 3, 94, 3209, 8, 94, 3, 94,
		3211, 8, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 5, 94, 3220,
		8, 94, 10, 94, 12, 94, 3223, 9, 94, 3, 94, 3225, 8, 94, 1, 95, 1, 95, 1,
		95, 3, 95, 3230, 8, 95, 1, 95, 3, 95, 3233, 8, 95, 1, 95, 1, 95, 1, 95,
		3, 95, 3238, 8, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1,
		95, 3, 95, 3248, 8, 95, 1, 95, 1, 95, 1, 95, 3, 95, 3253, 8, 95, 1, 95,
		1, 95, 4, 95, 3257, 8, 95, 11, 95, 12, 95, 3258, 3, 95, 3261, 8, 95, 1,
		95, 1, 95, 4, 95, 3265, 8, 95, 11, 95, 12, 95, 3266, 3, 95, 3269, 8, 95,
		1, 95, 1, 95, 1, 95, 1, 95, 3, 95, 3275, 8, 95, 1, 95, 1, 95, 1, 95, 1,
		95, 5, 95, 3281, 8, 95, 10, 95, 12, 95, 3284, 9, 95, 1, 95, 1, 95, 3, 95,
		3288, 8, 95, 1, 95, 1, 95, 1, 95, 1, 95, 5, 95, 3294, 8, 95, 10, 95, 12,
		95, 3297, 9, 95, 3, 95, 3299, 8, 95, 1, 96, 1, 96, 1, 96, 3, 96, 3304,
		8, 96, 1, 96, 3, 96, 3307, 8, 96, 1, 96, 1, 96, 1, 96, 3, 96, 3312, 8,
		96, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 3, 96, 3320, 8, 96, 1, 96,
		1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 3, 96, 3328, 8, 96, 1, 96, 1, 96, 1,
		96, 1, 96, 3, 96, 3334, 8, 96, 1, 96, 1, 96, 1, 96, 1, 96, 5, 96, 3340,
		8, 96, 10, 96, 12, 96, 3343, 9, 96, 1, 96, 1, 96, 3, 96, 3347, 8, 96, 1,
		96, 1, 96, 1, 96, 1, 96, 5, 96, 3353, 8, 96, 10, 96, 12, 96, 3356, 9, 96,
		3, 96, 3358, 8, 96, 1, 97, 1, 97, 3, 97, 3362, 8, 97, 1, 97, 3, 97, 3365,
		8, 97, 1, 97, 1, 97, 1, 97, 1, 97, 1, 97, 1, 97, 3, 97, 3373, 8, 97, 1,
		97, 1, 97, 1, 97, 1, 97, 3, 97, 3379, 8, 97, 1, 97, 1, 97, 1, 97, 1, 97,
		1, 97, 5, 97, 3386, 8, 97, 10, 97, 12, 97, 3389, 9, 97, 3, 97, 3391, 8,
		97, 1, 98, 1, 98, 3, 98, 3395, 8, 98, 1, 98, 1, 98, 3, 98, 3399, 8, 98,
		1, 98, 1, 98, 4, 98, 3403, 8, 98, 11, 98, 12, 98, 3404, 1, 98, 1, 98, 3,
		98, 3409, 8, 98, 1, 98, 1, 98, 3, 98, 3413, 8, 98, 3, 98, 3415, 8, 98,
		1, 98, 3, 98, 3418, 8, 98, 1, 98, 3, 98, 3421, 8, 98, 1, 98, 3, 98, 3424,
		8, 98, 1, 98, 1, 98, 4, 98, 3428, 8, 98, 11, 98, 12, 98, 3429, 1, 98, 1,
		98, 3, 98, 3434, 8, 98, 1, 98, 3, 98, 3437, 8, 98, 1, 98, 3, 98, 3440,
		8, 98, 1, 98, 3, 98, 3443, 8, 98, 1, 98, 3, 98, 3446, 8, 98, 1, 98, 1,
		98, 1, 98, 4, 98, 3451, 8, 98, 11, 98, 12, 98, 3452, 3, 98, 3455, 8, 98,
		1, 99, 1, 99, 3, 99, 3459, 8, 99, 1, 100, 1, 100, 1, 100, 3, 100, 3464,
		8, 100, 1, 100, 1, 100, 1, 100, 1, 100, 3, 100, 3470, 8, 100, 1, 100, 5,
		100, 3473, 8, 100, 10, 100, 12, 100, 3476, 9, 100, 1, 101, 1, 101, 1, 101,
		1, 101, 3, 101, 3482, 8, 101, 1, 101, 1, 101, 1, 101, 1, 101, 3, 101, 3488,
		8, 101, 1, 101, 5, 101, 3491, 8, 101, 10, 101, 12, 101, 3494, 9, 101, 3,
		101, 3496, 8, 101, 1, 102, 1, 102, 1, 102, 1, 102, 3, 102, 3502, 8, 102,
		1, 103, 1, 103, 3, 103, 3506, 8, 103, 1, 104, 1, 104, 1, 104, 1, 104, 1,
		104, 1, 104, 3, 104, 3514, 8, 104, 1, 105, 1, 105, 3, 105, 3518, 8, 105,
		1, 105, 3, 105, 3521, 8, 105, 1, 105, 3, 105, 3524, 8, 105, 1, 105, 1,
		105, 1, 105, 3, 105, 3529, 8, 105, 1, 105, 3, 105, 3532, 8, 105, 1, 105,
		1, 105, 1, 105, 1, 105, 1, 105, 3, 105, 3539, 8, 105, 1, 105, 1, 105, 3,
		105, 3543, 8, 105, 1, 105, 3, 105, 3546, 8, 105, 1, 105, 1, 105, 3, 105,
		3550, 8, 105, 1, 106, 1, 106, 3, 106, 3554, 8, 106, 1, 106, 3, 106, 3557,
		8, 106, 1, 106, 3, 106, 3560, 8, 106, 1, 106, 1, 106, 1, 106, 3, 106, 3565,
		8, 106, 1, 106, 1, 106, 1, 106, 1, 106, 3, 106, 3571, 8, 106, 5, 106, 3573,
		8, 106, 10, 106, 12, 106, 3576, 9, 106, 1, 106, 1, 106, 1, 106, 1, 106,
		1, 106, 1, 106, 1, 106, 3, 106, 3585, 8, 106, 1, 106, 1, 106, 1, 106, 1,
		106, 3, 106, 3591, 8, 106, 5, 106, 3593, 8, 106, 10, 106, 12, 106, 3596,
		9, 106, 1, 106, 1, 106, 1, 106, 3, 106, 3601, 8, 106, 1, 106, 1, 106, 3,
		106, 3605, 8, 106, 1, 107, 1, 107, 1, 107, 1, 107, 3, 107, 3611, 8, 107,
		1, 107, 3, 107, 3614, 8, 107, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1,
		108, 1, 108, 1, 108, 1, 108, 1, 108, 3, 108, 3626, 8, 108, 1, 108, 1, 108,
		3, 108, 3630, 8, 108, 1, 108, 1, 108, 3, 108, 3634, 8, 108, 1, 109, 1,
		109, 1, 109, 1, 109, 1, 109, 1, 109, 3, 109, 3642, 8, 109, 1, 109, 1, 109,
		3, 109, 3646, 8, 109, 1, 110, 1, 110, 1, 110, 1, 110, 1, 111, 1, 111, 3,
		111, 3654, 8, 111, 1, 111, 3, 111, 3657, 8, 111, 1, 111, 1, 111, 3, 111,
		3661, 8, 111, 1, 111, 3, 111, 3664, 8, 111, 1, 111, 1, 111, 1, 111, 1,
		111, 5, 111, 3670, 8, 111, 10, 111, 12, 111, 3673, 9, 111, 1, 111, 1, 111,
		3, 111, 3677, 8, 111, 1, 111, 3, 111, 3680, 8, 111, 1, 111, 3, 111, 3683,
		8, 111, 1, 112, 1, 112, 3, 112, 3687, 8, 112, 1, 112, 3, 112, 3690, 8,
		112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 5, 112, 3697, 8, 112, 10,
		112, 12, 112, 3700, 9, 112, 1, 112, 1, 112, 3, 112, 3704, 8, 112, 1, 113,
		1, 113, 1, 113, 1, 113, 1, 113, 5, 113, 3711, 8, 113, 10, 113, 12, 113,
		3714, 9, 113, 1, 114, 1, 114, 3, 114, 3718, 8, 114, 1, 115, 1, 115, 1,
		115, 5, 115, 3723, 8, 115, 10, 115, 12, 115, 3726, 9, 115, 1, 116, 1, 116,
		5, 116, 3730, 8, 116, 10, 116, 12, 116, 3733, 9, 116, 1, 116, 1, 116, 1,
		116, 5, 116, 3738, 8, 116, 10, 116, 12, 116, 3741, 9, 116, 1, 116, 1, 116,
		1, 116, 3, 116, 3746, 8, 116, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1,
		117, 3, 117, 3754, 8, 117, 1, 117, 3, 117, 3757, 8, 117, 1, 117, 3, 117,
		3760, 8, 117, 1, 117, 1, 117, 1, 117, 5, 117, 3765, 8, 117, 10, 117, 12,
		117, 3768, 9, 117, 3, 117, 3770, 8, 117, 1, 117, 1, 117, 1, 117, 1, 117,
		1, 117, 3, 117, 3777, 8, 117, 1, 117, 3, 117, 3780, 8, 117, 1, 117, 1,
		117, 1, 117, 1, 117, 1, 117, 1, 117, 3, 117, 3788, 8, 117, 1, 118, 1, 118,
		1, 118, 1, 118, 3, 118, 3794, 8, 118, 1, 118, 1, 118, 1, 118, 1, 118, 1,
		119, 1, 119, 1, 119, 1, 119, 1, 119, 3, 119, 3805, 8, 119, 1, 120, 3, 120,
		3808, 8, 120, 1, 120, 1, 120, 3, 120, 3812, 8, 120, 1, 120, 1, 120, 1,
		120, 1, 120, 1, 120, 1, 120, 1, 120, 1, 120, 3, 120, 3822, 8, 120, 1, 120,
		1, 120, 1, 120, 1, 120, 3, 120, 3828, 8, 120, 1, 120, 1, 120, 3, 120, 3832,
		8, 120, 1, 120, 1, 120, 3, 120, 3836, 8, 120, 1, 120, 1, 120, 1, 120, 1,
		120, 1, 120, 1, 120, 1, 120, 1, 120, 3, 120, 3846, 8, 120, 1, 120, 1, 120,
		1, 120, 3, 120, 3851, 8, 120, 3, 120, 3853, 8, 120, 1, 120, 1, 120, 3,
		120, 3857, 8, 120, 1, 121, 1, 121, 1, 121, 1, 121, 1, 121, 1, 121, 1, 121,
		1, 121, 3, 121, 3867, 8, 121, 1, 122, 1, 122, 1, 122, 1, 122, 1, 122, 1,
		122, 1, 122, 1, 122, 3, 122, 3877, 8, 122, 1, 123, 1, 123, 5, 123, 3881,
		8, 123, 10, 123, 12, 123, 3884, 9, 123, 1, 123, 1, 123, 3, 123, 3888, 8,
		123, 1, 123, 1, 123, 3, 123, 3892, 8, 123, 1, 123, 3, 123, 3895, 8, 123,
		1, 123, 3, 123, 3898, 8, 123, 1, 123, 3, 123, 3901, 8, 123, 1, 123, 3,
		123, 3904, 8, 123, 1, 123, 1, 123, 5, 123, 3908, 8, 123, 10, 123, 12, 123,
		3911, 9, 123, 1, 123, 1, 123, 1, 123, 3, 123, 3916, 8, 123, 1, 123, 3,
		123, 3919, 8, 123, 1, 123, 3, 123, 3922, 8, 123, 1, 123, 3, 123, 3925,
		8, 123, 1, 123, 3, 123, 3928, 8, 123, 1, 123, 3, 123, 3931, 8, 123, 3,
		123, 3933, 8, 123, 1, 124, 1, 124, 5, 124, 3937, 8, 124, 10, 124, 12, 124,
		3940, 9, 124, 1, 124, 1, 124, 1, 124, 3, 124, 3945, 8, 124, 1, 124, 3,
		124, 3948, 8, 124, 1, 124, 3, 124, 3951, 8, 124, 1, 124, 3, 124, 3954,
		8, 124, 1, 124, 3, 124, 3957, 8, 124, 1, 125, 1, 125, 3, 125, 3961, 8,
		125, 1, 125, 1, 125, 1, 126, 1, 126, 3, 126, 3967, 8, 126, 1, 126, 1, 126,
		3, 126, 3971, 8, 126, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 3,
		127, 3979, 8, 127, 1, 127, 1, 127, 3, 127, 3983, 8, 127, 1, 127, 3, 127,
		3986, 8, 127, 3, 127, 3988, 8, 127, 1, 128, 1, 128, 1, 128, 1, 128, 1,
		128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 3, 128, 4001, 8, 128,
		1, 128, 3, 128, 4004, 8, 128, 1, 129, 1, 129, 1, 129, 5, 129, 4009, 8,
		129, 10, 129, 12, 129, 4012, 9, 129, 1, 130, 1, 130, 1, 130, 1, 130, 1,
		130, 1, 130, 1, 130, 3, 130, 4021, 8, 130, 1, 130, 3, 130, 4024, 8, 130,
		1, 130, 1, 130, 1, 130, 3, 130, 4029, 8, 130, 3, 130, 4031, 8, 130, 1,
		130, 1, 130, 3, 130, 4035, 8, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130,
		1, 130, 3, 130, 4043, 8, 130, 1, 131, 1, 131, 1, 131, 1, 131, 3, 131, 4049,
		8, 131, 1, 131, 1, 131, 1, 131, 1, 132, 1, 132, 1, 132, 1, 132, 3, 132,
		4058, 8, 132, 1, 132, 1, 132, 1, 132, 1, 133, 1, 133, 1, 133, 1, 133, 1,
		133, 1, 133, 1, 133, 1, 133, 3, 133, 4071, 8, 133, 1, 134, 1, 134, 3, 134,
		4075, 8, 134, 1, 134, 1, 134, 5, 134, 4079, 8, 134, 10, 134, 12, 134, 4082,
		9, 134, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 3, 135, 4090, 8,
		135, 1, 135, 3, 135, 4093, 8, 135, 1, 135, 1, 135, 3, 135, 4097, 8, 135,
		1, 135, 3, 135, 4100, 8, 135, 1, 135, 1, 135, 3, 135, 4104, 8, 135, 1,
		135, 1, 135, 3, 135, 4108, 8, 135, 1, 135, 3, 135, 4111, 8, 135, 3, 135,
		4113, 8, 135, 1, 136, 1, 136, 1, 136, 1, 136, 5, 136, 4119, 8, 136, 10,
		136, 12, 136, 4122, 9, 136, 1, 136, 1, 136, 1, 136, 1, 136, 1, 136, 1,
		136, 1, 136, 1, 136, 1, 136, 3, 136, 4133, 8, 136, 1, 136, 1, 136, 4, 136,
		4137, 8, 136, 11, 136, 12, 136, 4138, 3, 136, 4141, 8, 136, 1, 136, 1,
		136, 4, 136, 4145, 8, 136, 11, 136, 12, 136, 4146, 3, 136, 4149, 8, 136,
		3, 136, 4151, 8, 136, 1, 137, 1, 137, 1, 137, 1, 137, 3, 137, 4157, 8,
		137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 3, 137, 4165, 8, 137,
		1, 138, 1, 138, 1, 138, 1, 138, 1, 138, 1, 138, 3, 138, 4173, 8, 138, 1,
		139, 1, 139, 3, 139, 4177, 8, 139, 1, 139, 1, 139, 3, 139, 4181, 8, 139,
		1, 140, 1, 140, 1, 140, 1, 140, 1, 140, 5, 140, 4188, 8, 140, 10, 140,
		12, 140, 4191, 9, 140, 1, 140, 1, 140, 3, 140, 4195, 8, 140, 1, 141, 1,
		141, 1, 141, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1,
		142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 5, 142, 4213, 8, 142, 10,
		142, 12, 142, 4216, 9, 142, 1, 143, 1, 143, 3, 143, 4220, 8, 143, 1, 144,
		1, 144, 1, 144, 1, 144, 3, 144, 4226, 8, 144, 1, 144, 1, 144, 1, 144, 1,
		144, 1, 144, 3, 144, 4233, 8, 144, 1, 145, 1, 145, 1, 145, 3, 145, 4238,
		8, 145, 1, 146, 1, 146, 1, 146, 1, 146, 1, 146, 5, 146, 4245, 8, 146, 10,
		146, 12, 146, 4248, 9, 146, 3, 146, 4250, 8, 146, 1, 147, 1, 147, 3, 147,
		4254, 8, 147, 1, 148, 1, 148, 3, 148, 4258, 8, 148, 1, 148, 1, 148, 3,
		148, 4262, 8, 148, 1, 148, 3, 148, 4265, 8, 148, 1, 148, 3, 148, 4268,
		8, 148, 1, 148, 3, 148, 4271, 8, 148, 1, 149, 1, 149, 3, 149, 4275, 8,
		149, 1, 149, 1, 149, 3, 149, 4279, 8, 149, 1, 149, 3, 149, 4282, 8, 149,
		1, 149, 3, 149, 4285, 8, 149, 1, 149, 3, 149, 4288, 8, 149, 1, 150, 1,
		150, 1, 150, 1, 151, 1, 151, 3, 151, 4295, 8, 151, 1, 151, 1, 151, 3, 151,
		4299, 8, 151, 1, 151, 1, 151, 1, 152, 1, 152, 1, 152, 1, 152, 1, 153, 1,
		153, 1, 153, 1, 153, 1, 153, 5, 153, 4312, 8, 153, 10, 153, 12, 153, 4315,
		9, 153, 1, 153, 3, 153, 4318, 8, 153, 1, 154, 1, 154, 1, 154, 1, 155, 1,
		155, 1, 155, 1, 155, 1, 155, 1, 156, 1, 156, 3, 156, 4330, 8, 156, 1, 156,
		1, 156, 1, 156, 1, 156, 5, 156, 4336, 8, 156, 10, 156, 12, 156, 4339, 9,
		156, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 3, 157, 4348,
		8, 157, 1, 158, 1, 158, 3, 158, 4352, 8, 158, 1, 158, 3, 158, 4355, 8,
		158, 1, 158, 1, 158, 1, 159, 1, 159, 3, 159, 4361, 8, 159, 1, 159, 3, 159,
		4364, 8, 159, 1, 159, 3, 159, 4367, 8, 159, 1, 160, 1, 160, 1, 160, 1,
		160, 1, 160, 1, 160, 1, 160, 3, 160, 4376, 8, 160, 1, 161, 1, 161, 1, 161,
		1, 161, 1, 161, 1, 161, 1, 161, 3, 161, 4385, 8, 161, 1, 162, 1, 162, 1,
		162, 1, 162, 1, 162, 1, 162, 5, 162, 4393, 8, 162, 10, 162, 12, 162, 4396,
		9, 162, 1, 162, 3, 162, 4399, 8, 162, 1, 163, 1, 163, 1, 163, 1, 163, 1,
		163, 1, 163, 5, 163, 4407, 8, 163, 10, 163, 12, 163, 4410, 9, 163, 1, 164,
		1, 164, 1, 164, 1, 164, 1, 164, 1, 164, 1, 164, 3, 164, 4419, 8, 164, 1,
		165, 1, 165, 1, 165, 1, 166, 1, 166, 1, 166, 3, 166, 4427, 8, 166, 1, 166,
		3, 166, 4430, 8, 166, 1, 167, 1, 167, 1, 167, 1, 167, 1, 167, 5, 167, 4437,
		8, 167, 10, 167, 12, 167, 4440, 9, 167, 3, 167, 4442, 8, 167, 1, 167, 1,
		167, 3, 167, 4446, 8, 167, 1, 167, 5, 167, 4449, 8, 167, 10, 167, 12, 167,
		4452, 9, 167, 1, 167, 3, 167, 4455, 8, 167, 1, 168, 1, 168, 1, 168, 1,
		168, 1, 168, 5, 168, 4462, 8, 168, 10, 168, 12, 168, 4465, 9, 168, 3, 168,
		4467, 8, 168, 1, 169, 1, 169, 1, 169, 1, 170, 1, 170, 1, 170, 1, 171, 1,
		171, 1, 171, 1, 171, 1, 171, 1, 171, 1, 171, 1, 171, 1, 171, 1, 171, 1,
		171, 1, 171, 1, 171, 1, 171, 1, 171, 1, 171, 1, 171, 1, 171, 1, 171, 1,
		171, 1, 171, 5, 171, 4496, 8, 171, 10, 171, 12, 171, 4499, 9, 171, 3, 171,
		4501, 8, 171, 1, 171, 3, 171, 4504, 8, 171, 1, 172, 1, 172, 1, 173, 1,
		173, 1, 174, 1, 174, 1, 175, 1, 175, 1, 175, 1, 175, 1, 176, 1, 176, 1,
		176, 1, 176, 1, 176, 1, 176, 1, 176, 1, 176, 1, 176, 1, 176, 1, 176, 1,
		176, 1, 176, 1, 176, 1, 176, 1, 176, 1, 176, 1, 176, 1, 176, 1, 176, 1,
		176, 1, 176, 1, 176, 1, 176, 1, 176, 1, 176, 1, 176, 1, 176, 1, 176, 1,
		176, 1, 176, 1, 176, 1, 176, 1, 176, 1, 176, 1, 176, 1, 176, 1, 176, 1,
		176, 1, 176, 1, 176, 1, 176, 5, 176, 4558, 8, 176, 10, 176, 12, 176, 4561,
		9, 176, 1, 176, 1, 176, 3, 176, 4565, 8, 176, 1, 177, 1, 177, 1, 177, 1,
		177, 1, 177, 1, 177, 1, 178, 1, 178, 1, 179, 1, 179, 1, 179, 1, 179, 1,
		179, 1, 179, 1, 179, 1, 179, 1, 179, 1, 179, 1, 179, 1, 179, 1, 179, 1,
		179, 1, 179, 1, 179, 1, 179, 1, 179, 3, 179, 4593, 8, 179, 1, 180, 1, 180,
		1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180,
		1, 180, 3, 180, 4607, 8, 180, 1, 181, 1, 181, 1, 181, 5, 181, 4612, 8,
		181, 10, 181, 12, 181, 4615, 9, 181, 1, 181, 3, 181, 4618, 8, 181, 1, 182,
		1, 182, 1, 182, 1, 182, 3, 182, 4624, 8, 182, 1, 183, 1, 183, 1, 183, 1,
		183, 1, 183, 1, 183, 3, 183, 4632, 8, 183, 3, 183, 4634, 8, 183, 1, 184,
		1, 184, 1, 184, 1, 184, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 3, 185,
		4645, 8, 185, 1, 186, 1, 186, 1, 186, 1, 186, 1, 187, 1, 187, 1, 187, 1,
		187, 3, 187, 4655, 8, 187, 1, 188, 1, 188, 1, 188, 1, 188, 1, 188, 3, 188,
		4662, 8, 188, 1, 189, 1, 189, 1, 189, 1, 189, 3, 189, 4668, 8, 189, 1,
		190, 1, 190, 1, 190, 1, 190, 1, 191, 1, 191, 3, 191, 4676, 8, 191, 1, 192,
		1, 192, 1, 192, 3, 192, 4681, 8, 192, 1, 192, 1, 192, 1, 192, 1, 192, 5,
		192, 4687, 8, 192, 10, 192, 12, 192, 4690, 9, 192, 1, 192, 1, 192, 1, 192,
		5, 192, 4695, 8, 192, 10, 192, 12, 192, 4698, 9, 192, 1, 192, 1, 192, 1,
		192, 5, 192, 4703, 8, 192, 10, 192, 12, 192, 4706, 9, 192, 1, 192, 1, 192,
		1, 192, 5, 192, 4711, 8, 192, 10, 192, 12, 192, 4714, 9, 192, 1, 192, 5,
		192, 4717, 8, 192, 10, 192, 12, 192, 4720, 9, 192, 1, 192, 1, 192, 3, 192,
		4724, 8, 192, 1, 193, 1, 193, 1, 193, 3, 193, 4729, 8, 193, 1, 193, 4,
		193, 4732, 8, 193, 11, 193, 12, 193, 4733, 1, 193, 1, 193, 4, 193, 4738,
		8, 193, 11, 193, 12, 193, 4739, 3, 193, 4742, 8, 193, 1, 193, 1, 193, 1,
		193, 1, 194, 1, 194, 1, 194, 1, 194, 4, 194, 4751, 8, 194, 11, 194, 12,
		194, 4752, 1, 194, 5, 194, 4756, 8, 194, 10, 194, 12, 194, 4759, 9, 194,
		1, 194, 1, 194, 4, 194, 4763, 8, 194, 11, 194, 12, 194, 4764, 3, 194, 4767,
		8, 194, 1, 194, 1, 194, 1, 194, 1, 195, 1, 195, 1, 195, 1, 196, 1, 196,
		1, 196, 1, 197, 1, 197, 1, 197, 3, 197, 4781, 8, 197, 1, 197, 1, 197, 4,
		197, 4785, 8, 197, 11, 197, 12, 197, 4786, 1, 197, 1, 197, 1, 197, 3, 197,
		4792, 8, 197, 1, 198, 1, 198, 1, 198, 3, 198, 4797, 8, 198, 1, 198, 1,
		198, 4, 198, 4801, 8, 198, 11, 198, 12, 198, 4802, 1, 198, 1, 198, 1, 198,
		1, 198, 1, 198, 3, 198, 4810, 8, 198, 1, 199, 1, 199, 1, 199, 1, 200, 1,
		200, 1, 200, 3, 200, 4818, 8, 200, 1, 200, 1, 200, 1, 200, 1, 200, 4, 200,
		4824, 8, 200, 11, 200, 12, 200, 4825, 1, 200, 1, 200, 1, 200, 3, 200, 4831,
		8, 200, 1, 201, 1, 201, 1, 201, 1, 201, 3, 201, 4837, 8, 201, 1, 201, 3,
		201, 4840, 8, 201, 1, 201, 1, 201, 1, 201, 1, 201, 1, 201, 1, 201, 3, 201,
		4848, 8, 201, 1, 202, 1, 202, 1, 202, 1, 202, 1, 202, 3, 202, 4855, 8,
		202, 1, 203, 1, 203, 1, 203, 1, 203, 1, 203, 1, 203, 1, 203, 3, 203, 4864,
		8, 203, 1, 203, 3, 203, 4867, 8, 203, 1, 204, 1, 204, 1, 204, 1, 204, 1,
		204, 1, 204, 1, 205, 1, 205, 1, 205, 1, 205, 1, 205, 1, 205, 1, 205, 5,
		205, 4882, 8, 205, 10, 205, 12, 205, 4885, 9, 205, 1, 205, 1, 205, 1, 206,
		1, 206, 1, 206, 3, 206, 4892, 8, 206, 1, 206, 1, 206, 1, 206, 1, 206, 1,
		206, 1, 206, 3, 206, 4900, 8, 206, 1, 207, 1, 207, 3, 207, 4904, 8, 207,
		1, 207, 1, 207, 1, 208, 1, 208, 1, 208, 3, 208, 4911, 8, 208, 1, 208, 1,
		208, 4, 208, 4915, 8, 208, 11, 208, 12, 208, 4916, 1, 209, 1, 209, 1, 209,
		1, 209, 4, 209, 4923, 8, 209, 11, 209, 12, 209, 4924, 1, 210, 1, 210, 1,
		210, 1, 210, 1, 210, 5, 210, 4932, 8, 210, 10, 210, 12, 210, 4935, 9, 210,
		1, 210, 1, 210, 1, 210, 3, 210, 4940, 8, 210, 1, 210, 1, 210, 1, 210, 5,
		210, 4945, 8, 210, 10, 210, 12, 210, 4948, 9, 210, 1, 210, 1, 210, 1, 210,
		1, 210, 3, 210, 4954, 8, 210, 1, 210, 5, 210, 4957, 8, 210, 10, 210, 12,
		210, 4960, 9, 210, 3, 210, 4962, 8, 210, 3, 210, 4964, 8, 210, 1, 210,
		1, 210, 4, 210, 4968, 8, 210, 11, 210, 12, 210, 4969, 3, 210, 4972, 8,
		210, 1, 210, 1, 210, 5, 210, 4976, 8, 210, 10, 210, 12, 210, 4979, 9, 210,
		1, 210, 1, 210, 1, 210, 1, 210, 3, 210, 4985, 8, 210, 1, 210, 1, 210, 1,
		210, 3, 210, 4990, 8, 210, 1, 210, 1, 210, 3, 210, 4994, 8, 210, 1, 210,
		1, 210, 1, 210, 1, 210, 3, 210, 5000, 8, 210, 1, 211, 1, 211, 1, 211, 1,
		211, 1, 211, 5, 211, 5007, 8, 211, 10, 211, 12, 211, 5010, 9, 211, 1, 211,
		1, 211, 1, 211, 3, 211, 5015, 8, 211, 1, 211, 1, 211, 1, 211, 5, 211, 5020,
		8, 211, 10, 211, 12, 211, 5023, 9, 211, 1, 211, 1, 211, 1, 211, 3, 211,
		5028, 8, 211, 1, 211, 1, 211, 1, 211, 1, 211, 3, 211, 5034, 8, 211, 1,
		211, 5, 211, 5037, 8, 211, 10, 211, 12, 211, 5040, 9, 211, 3, 211, 5042,
		8, 211, 3, 211, 5044, 8, 211, 1, 211, 1, 211, 4, 211, 5048, 8, 211, 11,
		211, 12, 211, 5049, 3, 211, 5052, 8, 211, 1, 211, 1, 211, 5, 211, 5056,
		8, 211, 10, 211, 12, 211, 5059, 9, 211, 1, 211, 1, 211, 1, 211, 1, 211,
		3, 211, 5065, 8, 211, 3, 211, 5067, 8, 211, 1, 212, 1, 212, 1, 212, 3,
		212, 5072, 8, 212, 1, 212, 1, 212, 1, 212, 5, 212, 5077, 8, 212, 10, 212,
		12, 212, 5080, 9, 212, 1, 213, 1, 213, 1, 213, 1, 213, 5, 213, 5086, 8,
		213, 10, 213, 12, 213, 5089, 9, 213, 1, 213, 1, 213, 3, 213, 5093, 8, 213,
		1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 5, 213, 5100, 8, 213, 10, 213,
		12, 213, 5103, 9, 213, 1, 213, 1, 213, 1, 213, 1, 213, 3, 213, 5109, 8,
		213, 1, 213, 5, 213, 5112, 8, 213, 10, 213, 12, 213, 5115, 9, 213, 3, 213,
		5117, 8, 213, 3, 213, 5119, 8, 213, 1, 213, 1, 213, 1, 213, 1, 213, 5,
		213, 5125, 8, 213, 10, 213, 12, 213, 5128, 9, 213, 3, 213, 5130, 8, 213,
		1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 3, 213, 5138, 8, 213, 1,
		213, 1, 213, 1, 213, 3, 213, 5143, 8, 213, 1, 213, 1, 213, 1, 213, 3, 213,
		5148, 8, 213, 5, 213, 5150, 8, 213, 10, 213, 12, 213, 5153, 9, 213, 1,
		213, 1, 213, 1, 213, 3, 213, 5158, 8, 213, 1, 213, 1, 213, 1, 213, 3, 213,
		5163, 8, 213, 5, 213, 5165, 8, 213, 10, 213, 12, 213, 5168, 9, 213, 1,
		213, 1, 213, 1, 213, 3, 213, 5173, 8, 213, 3, 213, 5175, 8, 213, 1, 214,
		1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 5, 214, 5184, 8, 214, 10,
		214, 12, 214, 5187, 9, 214, 3, 214, 5189, 8, 214, 1, 214, 1, 214, 1, 214,
		5, 214, 5194, 8, 214, 10, 214, 12, 214, 5197, 9, 214, 3, 214, 5199, 8,
		214, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 5,
		215, 5209, 8, 215, 10, 215, 12, 215, 5212, 9, 215, 1, 215, 1, 215, 1, 215,
		3, 215, 5217, 8, 215, 1, 216, 1, 216, 1, 216, 1, 216, 1, 216, 5, 216, 5224,
		8, 216, 10, 216, 12, 216, 5227, 9, 216, 1, 217, 1, 217, 1, 217, 1, 217,
		5, 217, 5233, 8, 217, 10, 217, 12, 217, 5236, 9, 217, 1, 217, 1, 217, 3,
		217, 5240, 8, 217, 1, 217, 1, 217, 1, 217, 1, 217, 1, 217, 5, 217, 5247,
		8, 217, 10, 217, 12, 217, 5250, 9, 217, 1, 217, 1, 217, 1, 217, 3, 217,
		5255, 8, 217, 1, 217, 1, 217, 1, 217, 1, 217, 1, 217, 1, 217, 1, 217, 5,
		217, 5264, 8, 217, 10, 217, 12, 217, 5267, 9, 217, 1, 217, 1, 217, 1, 217,
		3, 217, 5272, 8, 217, 1, 217, 1, 217, 1, 217, 3, 217, 5277, 8, 217, 5,
		217, 5279, 8, 217, 10, 217, 12, 217, 5282, 9, 217, 1, 217, 1, 217, 1, 217,
		3, 217, 5287, 8, 217, 1, 217, 1, 217, 1, 217, 3, 217, 5292, 8, 217, 5,
		217, 5294, 8, 217, 10, 217, 12, 217, 5297, 9, 217, 3, 217, 5299, 8, 217,
		1, 218, 1, 218, 1, 218, 1, 218, 1, 218, 1, 218, 1, 218, 1, 218, 5, 218,
		5309, 8, 218, 10, 218, 12, 218, 5312, 9, 218, 1, 219, 1, 219, 1, 219, 1,
		219, 3, 219, 5318, 8, 219, 1, 219, 1, 219, 1, 219, 3, 219, 5323, 8, 219,
		1, 220, 1, 220, 1, 220, 1, 221, 1, 221, 1, 221, 1, 221, 1, 221, 1, 221,
		1, 221, 1, 221, 1, 221, 1, 221, 1, 221, 1, 221, 1, 221, 3, 221, 5341, 8,
		221, 1, 221, 1, 221, 1, 221, 1, 221, 1, 221, 1, 221, 3, 221, 5349, 8, 221,
		1, 222, 1, 222, 1, 222, 3, 222, 5354, 8, 222, 1, 222, 1, 222, 1, 222, 1,
		222, 3, 222, 5360, 8, 222, 1, 223, 1, 223, 1, 223, 1, 223, 1, 223, 1, 223,
		1, 223, 1, 223, 3, 223, 5370, 8, 223, 1, 224, 1, 224, 1, 224, 1, 224, 1,
		224, 1, 224, 1, 224, 1, 224, 3, 224, 5380, 8, 224, 1, 225, 1, 225, 1, 225,
		1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 3, 225, 5390, 8, 225, 1, 225, 1,
		225, 1, 225, 1, 225, 3, 225, 5396, 8, 225, 1, 225, 1, 225, 1, 225, 1, 225,
		1, 225, 1, 225, 1, 225, 3, 225, 5405, 8, 225, 1, 225, 1, 225, 1, 225, 1,
		225, 3, 225, 5411, 8, 225, 1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 3, 225,
		5418, 8, 225, 3, 225, 5420, 8, 225, 1, 226, 1, 226, 1, 226, 1, 227, 1,
		227, 1, 227, 1, 227, 1, 227, 3, 227, 5430, 8, 227, 1, 228, 1, 228, 3, 228,
		5434, 8, 228, 1, 228, 1, 228, 3, 228, 5438, 8, 228, 1, 228, 1, 228, 1,
		228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 3, 228, 5448, 8, 228, 1, 228,
		1, 228, 1, 228, 3, 228, 5453, 8, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1,
		228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1,
		228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1,
		228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1,
		228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1,
		228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1,
		228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1,
		228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1, 228, 1,
		228, 1, 228, 3, 228, 5524, 8, 228, 1, 229, 1, 229, 1, 229, 1, 229, 1, 229,
		1, 229, 1, 229, 1, 229, 1, 229, 1, 229, 1, 229, 1, 229, 1, 229, 1, 229,
		1, 229, 1, 229, 3, 229, 5542, 8, 229, 1, 230, 1, 230, 1, 230, 1, 230, 1,
		231, 1, 231, 3, 231, 5550, 8, 231, 1, 231, 1, 231, 1, 231, 1, 231, 1, 231,
		1, 231, 1, 231, 1, 231, 5, 231, 5560, 8, 231, 10, 231, 12, 231, 5563, 9,
		231, 1, 231, 1, 231, 1, 231, 1, 231, 3, 231, 5569, 8, 231, 3, 231, 5571,
		8, 231, 1, 231, 1, 231, 1, 231, 1, 231, 1, 231, 1, 231, 5, 231, 5579, 8,
		231, 10, 231, 12, 231, 5582, 9, 231, 3, 231, 5584, 8, 231, 1, 232, 1, 232,
		1, 232, 1, 232, 5, 232, 5590, 8, 232, 10, 232, 12, 232, 5593, 9, 232, 1,
		233, 1, 233, 1, 233, 1, 233, 3, 233, 5599, 8, 233, 1, 234, 1, 234, 3, 234,
		5603, 8, 234, 1, 234, 1, 234, 1, 234, 1, 235, 1, 235, 3, 235, 5610, 8,
		235, 1, 235, 1, 235, 1, 235, 3, 235, 5615, 8, 235, 1, 235, 3, 235, 5618,
		8, 235, 1, 235, 3, 235, 5621, 8, 235, 1, 236, 1, 236, 1, 236, 1, 236, 1,
		236, 1, 236, 1, 236, 3, 236, 5630, 8, 236, 1, 237, 1, 237, 3, 237, 5634,
		8, 237, 1, 237, 1, 237, 3, 237, 5638, 8, 237, 1, 237, 1, 237, 1, 237, 1,
		237, 1, 237, 1, 237, 1, 238, 1, 238, 1, 238, 1, 238, 1, 238, 1, 238, 1,
		239, 1, 239, 1, 239, 1, 239, 1, 240, 1, 240, 1, 240, 1, 240, 1, 240, 3,
		240, 5661, 8, 240, 1, 240, 1, 240, 1, 240, 1, 240, 1, 240, 3, 240, 5668,
		8, 240, 5, 240, 5670, 8, 240, 10, 240, 12, 240, 5673, 9, 240, 1, 240, 1,
		240, 1, 240, 1, 240, 3, 240, 5679, 8, 240, 1, 240, 1, 240, 1, 240, 1, 240,
		1, 240, 3, 240, 5686, 8, 240, 1, 240, 3, 240, 5689, 8, 240, 1, 240, 1,
		240, 1, 240, 1, 240, 1, 240, 1, 240, 1, 240, 1, 240, 1, 240, 1, 240, 1,
		240, 1, 240, 5, 240, 5703, 8, 240, 10, 240, 12, 240, 5706, 9, 240, 3, 240,
		5708, 8, 240, 1, 241, 1, 241, 1, 241, 1, 241, 1, 241, 1, 241, 1, 241, 1,
		241, 3, 241, 5718, 8, 241, 1, 241, 1, 241, 3, 241, 5722, 8, 241, 1, 241,
		1, 241, 1, 241, 1, 241, 3, 241, 5728, 8, 241, 1, 241, 3, 241, 5731, 8,
		241, 1, 241, 1, 241, 1, 241, 3, 241, 5736, 8, 241, 1, 241, 1, 241, 3, 241,
		5740, 8, 241, 1, 241, 1, 241, 1, 241, 1, 241, 1, 241, 3, 241, 5747, 8,
		241, 1, 241, 3, 241, 5750, 8, 241, 1, 241, 1, 241, 1, 241, 1, 241, 3, 241,
		5756, 8, 241, 1, 241, 1, 241, 1, 241, 1, 241, 1, 241, 1, 241, 1, 241, 1,
		241, 1, 241, 1, 241, 1, 241, 1, 241, 1, 241, 1, 241, 1, 241, 1, 241, 1,
		241, 1, 241, 1, 241, 1, 241, 1, 241, 1, 241, 3, 241, 5780, 8, 241, 1, 241,
		3, 241, 5783, 8, 241, 1, 241, 1, 241, 1, 241, 1, 241, 1, 241, 1, 241, 1,
		241, 1, 241, 1, 241, 1, 241, 3, 241, 5795, 8, 241, 1, 241, 3, 241, 5798,
		8, 241, 1, 241, 1, 241, 1, 241, 1, 241, 1, 241, 1, 241, 1, 241, 1, 241,
		3, 241, 5808, 8, 241, 1, 241, 1, 241, 1, 241, 1, 241, 1, 241, 1, 241, 3,
		241, 5816, 8, 241, 1, 241, 1, 241, 3, 241, 5820, 8, 241, 1, 241, 1, 241,
		1, 241, 1, 241, 1, 241, 3, 241, 5827, 8, 241, 1, 241, 3, 241, 5830, 8,
		241, 1, 241, 1, 241, 1, 241, 1, 241, 1, 241, 5, 241, 5837, 8, 241, 10,
		241, 12, 241, 5840, 9, 241, 1, 241, 1, 241, 1, 241, 3, 241, 5845, 8, 241,
		1, 241, 1, 241, 1, 241, 1, 241, 3, 241, 5851, 8, 241, 1, 241, 1, 241, 1,
		241, 1, 241, 1, 241, 1, 241, 1, 241, 1, 241, 3, 241, 5861, 8, 241, 3, 241,
		5863, 8, 241, 1, 242, 1, 242, 1, 242, 1, 242, 3, 242, 5869, 8, 242, 1,
		242, 3, 242, 5872, 8, 242, 1, 242, 3, 242, 5875, 8, 242, 1, 243, 1, 243,
		1, 243, 1, 243, 1, 243, 1, 243, 1, 243, 1, 243, 1, 243, 1, 243, 3, 243,
		5887, 8, 243, 1, 243, 3, 243, 5890, 8, 243, 1, 244, 1, 244, 1, 244, 1,
		244, 3, 244, 5896, 8, 244, 1, 245, 3, 245, 5899, 8, 245, 1, 245, 1, 245,
		1, 245, 1, 245, 1, 245, 1, 245, 3, 245, 5907, 8, 245, 1, 245, 1, 245, 1,
		245, 1, 245, 1, 245, 1, 245, 3, 245, 5915, 8, 245, 1, 246, 1, 246, 1, 246,
		1, 246, 3, 246, 5921, 8, 246, 1, 246, 1, 246, 3, 246, 5925, 8, 246, 1,
		247, 1, 247, 1, 247, 1, 247, 1, 247, 1, 247, 1, 247, 1, 247, 1, 247, 1,
		247, 1, 247, 1, 247, 3, 247, 5939, 8, 247, 1, 248, 1, 248, 1, 248, 1, 249,
		1, 249, 1, 249, 1, 249, 1, 249, 5, 249, 5949, 8, 249, 10, 249, 12, 249,
		5952, 9, 249, 1, 249, 1, 249, 1, 249, 1, 249, 3, 249, 5958, 8, 249, 1,
		249, 3, 249, 5961, 8, 249, 1, 249, 1, 249, 1, 249, 1, 250, 1, 250, 3, 250,
		5968, 8, 250, 1, 250, 1, 250, 1, 250, 5, 250, 5973, 8, 250, 10, 250, 12,
		250, 5976, 9, 250, 1, 251, 1, 251, 3, 251, 5980, 8, 251, 1, 251, 1, 251,
		1, 252, 1, 252, 1, 252, 1, 252, 1, 252, 1, 252, 1, 252, 5, 252, 5991, 8,
		252, 10, 252, 12, 252, 5994, 9, 252, 1, 253, 1, 253, 1, 253, 1, 253, 1,
		254, 1, 254, 1, 255, 1, 255, 3, 255, 6004, 8, 255, 1, 255, 1, 255, 1, 255,
		1, 255, 3, 255, 6010, 8, 255, 1, 256, 1, 256, 1, 256, 3, 256, 6015, 8,
		256, 1, 256, 1, 256, 1, 256, 1, 256, 1, 256, 1, 256, 1, 256, 1, 256, 1,
		256, 1, 256, 1, 256, 3, 256, 6028, 8, 256, 3, 256, 6030, 8, 256, 1, 256,
		1, 256, 1, 256, 3, 256, 6035, 8, 256, 1, 256, 1, 256, 3, 256, 6039, 8,
		256, 1, 256, 3, 256, 6042, 8, 256, 3, 256, 6044, 8, 256, 1, 257, 1, 257,
		1, 257, 1, 257, 1, 257, 3, 257, 6051, 8, 257, 1, 258, 1, 258, 1, 258, 1,
		258, 1, 258, 3, 258, 6058, 8, 258, 1, 258, 3, 258, 6061, 8, 258, 1, 258,
		3, 258, 6064, 8, 258, 1, 258, 1, 258, 1, 258, 1, 258, 3, 258, 6070, 8,
		258, 1, 258, 1, 258, 3, 258, 6074, 8, 258, 1, 259, 1, 259, 1, 259, 1, 259,
		3, 259, 6080, 8, 259, 1, 260, 1, 260, 1, 260, 1, 260, 3, 260, 6086, 8,
		260, 1, 260, 1, 260, 1, 261, 1, 261, 1, 261, 1, 262, 1, 262, 1, 262, 1,
		263, 1, 263, 1, 263, 3, 263, 6099, 8, 263, 1, 263, 1, 263, 1, 263, 3, 263,
		6104, 8, 263, 1, 263, 1, 263, 1, 263, 1, 263, 5, 263, 6110, 8, 263, 10,
		263, 12, 263, 6113, 9, 263, 3, 263, 6115, 8, 263, 1, 264, 1, 264, 1, 264,
		3, 264, 6120, 8, 264, 1, 264, 1, 264, 1, 264, 3, 264, 6125, 8, 264, 1,
		264, 1, 264, 1, 264, 1, 264, 5, 264, 6131, 8, 264, 10, 264, 12, 264, 6134,
		9, 264, 3, 264, 6136, 8, 264, 1, 265, 1, 265, 1, 265, 1, 265, 1, 265, 1,
		265, 3, 265, 6144, 8, 265, 1, 266, 1, 266, 3, 266, 6148, 8, 266, 1, 266,
		1, 266, 1, 266, 5, 266, 6153, 8, 266, 10, 266, 12, 266, 6156, 9, 266, 1,
		267, 1, 267, 3, 267, 6160, 8, 267, 1, 267, 1, 267, 1, 267, 1, 267, 1, 267,
		1, 267, 1, 267, 1, 267, 1, 267, 5, 267, 6171, 8, 267, 10, 267, 12, 267,
		6174, 9, 267, 1, 267, 1, 267, 1, 267, 3, 267, 6179, 8, 267, 1, 267, 1,
		267, 1, 267, 1, 267, 1, 267, 1, 267, 1, 267, 1, 267, 5, 267, 6189, 8, 267,
		10, 267, 12, 267, 6192, 9, 267, 3, 267, 6194, 8, 267, 1, 268, 1, 268, 1,
		269, 1, 269, 1, 269, 1, 269, 1, 269, 3, 269, 6203, 8, 269, 1, 269, 1, 269,
		1, 269, 3, 269, 6208, 8, 269, 1, 270, 1, 270, 1, 270, 1, 270, 3, 270, 6214,
		8, 270, 1, 271, 1, 271, 1, 272, 1, 272, 3, 272, 6220, 8, 272, 1, 273, 1,
		273, 1, 273, 3, 273, 6225, 8, 273, 3, 273, 6227, 8, 273, 1, 273, 3, 273,
		6230, 8, 273, 1, 273, 1, 273, 3, 273, 6234, 8, 273, 3, 273, 6236, 8, 273,
		1, 274, 1, 274, 3, 274, 6240, 8, 274, 1, 274, 1, 274, 1, 274, 1, 274, 3,
		274, 6246, 8, 274, 1, 274, 3, 274, 6249, 8, 274, 1, 274, 3, 274, 6252,
		8, 274, 1, 275, 1, 275, 1, 275, 1, 275, 1, 275, 3, 275, 6259, 8, 275, 1,
		276, 1, 276, 1, 277, 1, 277, 1, 277, 1, 277, 3, 277, 6267, 8, 277, 1, 278,
		1, 278, 3, 278, 6271, 8, 278, 1, 279, 1, 279, 1, 280, 1, 280, 1, 280, 1,
		280, 1, 280, 1, 280, 1, 280, 1, 280, 1, 280, 1, 280, 1, 280, 1, 280, 1,
		280, 1, 280, 4, 280, 6289, 8, 280, 11, 280, 12, 280, 6290, 1, 281, 1, 281,
		1, 281, 1, 281, 1, 281, 3, 281, 6298, 8, 281, 3, 281, 6300, 8, 281, 1,
		282, 1, 282, 1, 282, 4, 282, 6305, 8, 282, 11, 282, 12, 282, 6306, 3, 282,
		6309, 8, 282, 1, 283, 1, 283, 3, 283, 6313, 8, 283, 1, 284, 1, 284, 1,
		284, 3, 284, 6318, 8, 284, 1, 285, 1, 285, 1, 285, 1, 285, 1, 285, 1, 285,
		1, 285, 1, 285, 1, 285, 3, 285, 6329, 8, 285, 1, 286, 1, 286, 1, 286, 3,
		286, 6334, 8, 286, 1, 287, 1, 287, 1, 288, 1, 288, 3, 288, 6340, 8, 288,
		1, 289, 3, 289, 6343, 8, 289, 1, 289, 1, 289, 3, 289, 6347, 8, 289, 1,
		289, 4, 289, 6350, 8, 289, 11, 289, 12, 289, 6351, 1, 289, 3, 289, 6355,
		8, 289, 1, 289, 1, 289, 3, 289, 6359, 8, 289, 1, 289, 1, 289, 3, 289, 6363,
		8, 289, 3, 289, 6365, 8, 289, 1, 290, 1, 290, 1, 291, 3, 291, 6370, 8,
		291, 1, 291, 1, 291, 1, 292, 3, 292, 6375, 8, 292, 1, 292, 1, 292, 1, 293,
		1, 293, 1, 293, 1, 293, 1, 293, 1, 293, 1, 293, 1, 293, 1, 293, 3, 293,
		6388, 8, 293, 1, 293, 3, 293, 6391, 8, 293, 1, 294, 1, 294, 3, 294, 6395,
		8, 294, 1, 294, 3, 294, 6398, 8, 294, 1, 294, 3, 294, 6401, 8, 294, 1,
		294, 1, 294, 1, 294, 3, 294, 6406, 8, 294, 1, 294, 1, 294, 1, 294, 3, 294,
		6411, 8, 294, 1, 294, 1, 294, 1, 294, 1, 294, 3, 294, 6417, 8, 294, 1,
		294, 3, 294, 6420, 8, 294, 1, 294, 1, 294, 1, 294, 3, 294, 6425, 8, 294,
		1, 294, 3, 294, 6428, 8, 294, 1, 294, 1, 294, 1, 294, 3, 294, 6433, 8,
		294, 1, 294, 3, 294, 6436, 8, 294, 1, 294, 1, 294, 3, 294, 6440, 8, 294,
		1, 294, 5, 294, 6443, 8, 294, 10, 294, 12, 294, 6446, 9, 294, 1, 294, 1,
		294, 3, 294, 6450, 8, 294, 1, 294, 5, 294, 6453, 8, 294, 10, 294, 12, 294,
		6456, 9, 294, 1, 294, 1, 294, 3, 294, 6460, 8, 294, 1, 294, 3, 294, 6463,
		8, 294, 1, 294, 5, 294, 6466, 8, 294, 10, 294, 12, 294, 6469, 9, 294, 1,
		294, 1, 294, 3, 294, 6473, 8, 294, 1, 294, 5, 294, 6476, 8, 294, 10, 294,
		12, 294, 6479, 9, 294, 1, 294, 1, 294, 1, 294, 3, 294, 6484, 8, 294, 1,
		294, 1, 294, 1, 294, 3, 294, 6489, 8, 294, 1, 294, 1, 294, 1, 294, 3, 294,
		6494, 8, 294, 1, 294, 1, 294, 1, 294, 3, 294, 6499, 8, 294, 1, 294, 1,
		294, 3, 294, 6503, 8, 294, 1, 294, 3, 294, 6506, 8, 294, 1, 294, 1, 294,
		1, 294, 3, 294, 6511, 8, 294, 1, 294, 1, 294, 3, 294, 6515, 8, 294, 1,
		294, 1, 294, 3, 294, 6519, 8, 294, 1, 295, 1, 295, 1, 295, 1, 295, 5, 295,
		6525, 8, 295, 10, 295, 12, 295, 6528, 9, 295, 1, 295, 1, 295, 1, 296, 1,
		296, 3, 296, 6534, 8, 296, 1, 296, 1, 296, 3, 296, 6538, 8, 296, 1, 296,
		1, 296, 1, 296, 3, 296, 6543, 8, 296, 1, 296, 1, 296, 1, 296, 3, 296, 6548,
		8, 296, 1, 296, 1, 296, 3, 296, 6552, 8, 296, 3, 296, 6554, 8, 296, 1,
		296, 3, 296, 6557, 8, 296, 1, 297, 1, 297, 1, 297, 1, 297, 1, 298, 1, 298,
		1, 298, 1, 298, 1, 298, 1, 298, 1, 299, 1, 299, 1, 299, 1, 299, 3, 299,
		6573, 8, 299, 1, 299, 1, 299, 1, 300, 1, 300, 1, 300, 5, 300, 6580, 8,
		300, 10, 300, 12, 300, 6583, 9, 300, 1, 301, 1, 301, 1, 301, 5, 301, 6588,
		8, 301, 10, 301, 12, 301, 6591, 9, 301, 1, 302, 1, 302, 1, 302, 5, 302,
		6596, 8, 302, 10, 302, 12, 302, 6599, 9, 302, 1, 303, 1, 303, 1, 303, 1,
		303, 5, 303, 6605, 8, 303, 10, 303, 12, 303, 6608, 9, 303, 1, 303, 1, 303,
		1, 304, 1, 304, 1, 304, 5, 304, 6615, 8, 304, 10, 304, 12, 304, 6618, 9,
		304, 1, 305, 1, 305, 1, 305, 5, 305, 6623, 8, 305, 10, 305, 12, 305, 6626,
		9, 305, 1, 306, 1, 306, 1, 306, 5, 306, 6631, 8, 306, 10, 306, 12, 306,
		6634, 9, 306, 1, 307, 1, 307, 1, 307, 5, 307, 6639, 8, 307, 10, 307, 12,
		307, 6642, 9, 307, 1, 308, 1, 308, 1, 308, 5, 308, 6647, 8, 308, 10, 308,
		12, 308, 6650, 9, 308, 1, 309, 1, 309, 1, 309, 1, 309, 1, 309, 1, 309,
		1, 309, 1, 309, 1, 309, 3, 309, 6661, 8, 309, 1, 309, 1, 309, 1, 309, 1,
		309, 1, 309, 3, 309, 6668, 8, 309, 1, 309, 1, 309, 1, 309, 1, 309, 1, 309,
		1, 309, 1, 309, 1, 309, 3, 309, 6678, 8, 309, 1, 310, 1, 310, 1, 310, 3,
		310, 6683, 8, 310, 1, 310, 3, 310, 6686, 8, 310, 1, 310, 1, 310, 1, 310,
		3, 310, 6691, 8, 310, 1, 310, 3, 310, 6694, 8, 310, 1, 311, 1, 311, 3,
		311, 6698, 8, 311, 1, 312, 1, 312, 1, 312, 1, 313, 1, 313, 1, 313, 1, 313,
		1, 314, 1, 314, 1, 314, 1, 315, 1, 315, 1, 315, 3, 315, 6713, 8, 315, 1,
		316, 1, 316, 1, 316, 1, 316, 1, 316, 1, 316, 3, 316, 6721, 8, 316, 1, 316,
		1, 316, 1, 316, 1, 316, 1, 316, 3, 316, 6728, 8, 316, 1, 316, 1, 316, 1,
		316, 3, 316, 6733, 8, 316, 1, 317, 1, 317, 1, 317, 3, 317, 6738, 8, 317,
		1, 317, 1, 317, 1, 317, 1, 317, 1, 317, 1, 317, 1, 317, 1, 317, 1, 317,
		1, 317, 1, 317, 1, 317, 1, 317, 1, 317, 1, 317, 1, 317, 1, 317, 1, 317,
		1, 317, 1, 317, 1, 317, 1, 317, 1, 317, 1, 317, 1, 317, 1, 317, 1, 317,
		1, 317, 1, 317, 4, 317, 6769, 8, 317, 11, 317, 12, 317, 6770, 1, 317, 1,
		317, 3, 317, 6775, 8, 317, 1, 317, 1, 317, 1, 317, 1, 317, 4, 317, 6781,
		8, 317, 11, 317, 12, 317, 6782, 1, 317, 1, 317, 3, 317, 6787, 8, 317, 1,
		317, 1, 317, 1, 317, 1, 317, 1, 317, 1, 317, 1, 317, 3, 317, 6796, 8, 317,
		1, 317, 1, 317, 1, 317, 1, 317, 1, 317, 1, 317, 3, 317, 6804, 8, 317, 1,
		317, 1, 317, 1, 317, 3, 317, 6809, 8, 317, 1, 317, 1, 317, 1, 317, 1, 317,
		1, 317, 1, 317, 3, 317, 6817, 8, 317, 1, 317, 1, 317, 1, 317, 3, 317, 6822,
		8, 317, 1, 317, 1, 317, 1, 317, 3, 317, 6827, 8, 317, 3, 317, 6829, 8,
		317, 1, 317, 1, 317, 1, 317, 1, 317, 1, 317, 1, 317, 1, 317, 3, 317, 6838,
		8, 317, 1, 317, 1, 317, 1, 317, 3, 317, 6843, 8, 317, 1, 317, 1, 317, 1,
		317, 1, 317, 1, 317, 1, 317, 3, 317, 6851, 8, 317, 1, 317, 1, 317, 1, 317,
		3, 317, 6856, 8, 317, 1, 317, 1, 317, 1, 317, 1, 317, 1, 317, 1, 317, 3,
		317, 6864, 8, 317, 1, 317, 1, 317, 1, 317, 1, 317, 1, 317, 1, 317, 3, 317,
		6872, 8, 317, 1, 317, 3, 317, 6875, 8, 317, 1, 317, 1, 317, 1, 317, 1,
		317, 1, 317, 1, 317, 1, 317, 1, 317, 3, 317, 6885, 8, 317, 1, 317, 1, 317,
		1, 317, 1, 317, 1, 317, 1, 317, 1, 317, 1, 317, 1, 317, 1, 317, 1, 317,
		1, 317, 1, 317, 1, 317, 1, 317, 1, 317, 3, 317, 6903, 8, 317, 1, 317, 3,
		317, 6906, 8, 317, 1, 317, 3, 317, 6909, 8, 317, 1, 317, 1, 317, 3, 317,
		6913, 8, 317, 1, 318, 1, 318, 1, 318, 1, 318, 1, 318, 1, 319, 1, 319, 1,
		319, 1, 319, 5, 319, 6924, 8, 319, 10, 319, 12, 319, 6927, 9, 319, 1, 319,
		1, 319, 1, 319, 1, 319, 1, 319, 3, 319, 6934, 8, 319, 1, 320, 1, 320, 3,
		320, 6938, 8, 320, 1, 321, 1, 321, 1, 321, 3, 321, 6943, 8, 321, 1, 321,
		1, 321, 1, 321, 3, 321, 6948, 8, 321, 1, 321, 1, 321, 1, 321, 1, 321, 3,
		321, 6954, 8, 321, 1, 321, 1, 321, 1, 321, 3, 321, 6959, 8, 321, 1, 321,
		1, 321, 3, 321, 6963, 8, 321, 1, 321, 1, 321, 1, 321, 3, 321, 6968, 8,
		321, 1, 321, 1, 321, 1, 321, 3, 321, 6973, 8, 321, 1, 321, 1, 321, 1, 321,
		3, 321, 6978, 8, 321, 1, 321, 1, 321, 1, 321, 1, 321, 1, 321, 1, 321, 5,
		321, 6986, 8, 321, 10, 321, 12, 321, 6989, 9, 321, 3, 321, 6991, 8, 321,
		1, 321, 1, 321, 3, 321, 6995, 8, 321, 1, 321, 1, 321, 3, 321, 6999, 8,
		321, 1, 322, 1, 322, 1, 322, 1, 322, 1, 322, 3, 322, 7006, 8, 322, 1, 322,
		1, 322, 3, 322, 7010, 8, 322, 1, 322, 1, 322, 1, 322, 1, 322, 1, 322, 1,
		322, 1, 322, 1, 322, 1, 322, 1, 322, 1, 322, 1, 322, 1, 322, 1, 322, 1,
		322, 1, 322, 1, 322, 1, 322, 1, 322, 1, 322, 1, 322, 1, 322, 1, 322, 1,
		322, 1, 322, 1, 322, 1, 322, 3, 322, 7039, 8, 322, 1, 323, 1, 323, 1, 323,
		1, 323, 1, 323, 1, 323, 3, 323, 7047, 8, 323, 1, 324, 3, 324, 7050, 8,
		324, 1, 324, 3, 324, 7053, 8, 324, 1, 324, 3, 324, 7056, 8, 324, 1, 324,
		3, 324, 7059, 8, 324, 1, 325, 1, 325, 1, 326, 1, 326, 1, 326, 1, 327, 1,
		327, 1, 328, 1, 328, 3, 328, 7070, 8, 328, 1, 329, 1, 329, 1, 329, 1, 329,
		1, 329, 1, 330, 1, 330, 1, 330, 1, 330, 1, 330, 1, 330, 1, 330, 3, 330,
		7084, 8, 330, 1, 331, 1, 331, 1, 331, 1, 331, 1, 331, 5, 331, 7091, 8,
		331, 10, 331, 12, 331, 7094, 9, 331, 1, 332, 1, 332, 1, 332, 1, 332, 1,
		332, 1, 332, 1, 332, 1, 332, 1, 332, 1, 332, 1, 332, 1, 332, 1, 332, 1,
		332, 1, 332, 1, 332, 1, 332, 1, 332, 1, 332, 1, 332, 1, 332, 1, 332, 1,
		332, 3, 332, 7119, 8, 332, 1, 333, 1, 333, 1, 333, 1, 333, 1, 333, 1, 334,
		1, 334, 1, 334, 1, 334, 3, 334, 7130, 8, 334, 1, 334, 1, 334, 1, 334, 1,
		334, 1, 334, 3, 334, 7137, 8, 334, 5, 334, 7139, 8, 334, 10, 334, 12, 334,
		7142, 9, 334, 1, 335, 1, 335, 1, 335, 1, 335, 3, 335, 7148, 8, 335, 1,
		336, 1, 336, 1, 336, 1, 336, 1, 336, 1, 336, 3, 336, 7156, 8, 336, 1, 336,
		1, 336, 1, 336, 3, 336, 7161, 8, 336, 1, 336, 1, 336, 1, 336, 1, 336, 5,
		336, 7167, 8, 336, 10, 336, 12, 336, 7170, 9, 336, 1, 337, 1, 337, 1, 337,
		3, 337, 7175, 8, 337, 1, 337, 1, 337, 1, 337, 1, 337, 1, 337, 1, 337, 1,
		337, 1, 337, 3, 337, 7185, 8, 337, 1, 337, 1, 337, 1, 337, 1, 337, 1, 337,
		1, 337, 1, 337, 1, 337, 1, 337, 1, 337, 1, 337, 3, 337, 7198, 8, 337, 1,
		337, 1, 337, 1, 337, 1, 337, 3, 337, 7204, 8, 337, 1, 337, 1, 337, 1, 337,
		1, 337, 3, 337, 7210, 8, 337, 1, 337, 1, 337, 1, 337, 1, 337, 1, 337, 1,
		337, 1, 337, 1, 337, 1, 337, 1, 337, 1, 337, 1, 337, 1, 337, 1, 337, 3,
		337, 7226, 8, 337, 1, 337, 1, 337, 1, 337, 1, 337, 3, 337, 7232, 8, 337,
		1, 337, 1, 337, 1, 337, 1, 337, 1, 337, 1, 337, 1, 337, 5, 337, 7241, 8,
		337, 10, 337, 12, 337, 7244, 9, 337, 1, 338, 1, 338, 1, 338, 1, 338, 1,
		338, 1, 338, 1, 338, 1, 338, 1, 338, 1, 338, 1, 338, 1, 338, 1, 338, 1,
		338, 1, 338, 5, 338, 7261, 8, 338, 10, 338, 12, 338, 7264, 9, 338, 1, 338,
		1, 338, 1, 338, 1, 338, 1, 338, 1, 338, 1, 338, 4, 338, 7273, 8, 338, 11,
		338, 12, 338, 7274, 1, 338, 1, 338, 1, 338, 1, 338, 1, 338, 1, 338, 1,
		338, 1, 338, 1, 338, 1, 338, 1, 338, 1, 338, 1, 338, 1, 338, 1, 338, 3,
		338, 7292, 8, 338, 1, 338, 1, 338, 1, 338, 1, 338, 1, 338, 1, 338, 1, 338,
		1, 338, 1, 338, 1, 338, 1, 338, 1, 338, 1, 338, 1, 338, 1, 338, 5, 338,
		7309, 8, 338, 10, 338, 12, 338, 7312, 9, 338, 1, 339, 1, 339, 1, 340, 1,
		340, 1, 340, 1, 340, 1, 340, 1, 340, 1, 340, 1, 340, 1, 340, 1, 340, 1,
		340, 1, 340, 1, 340, 1, 340, 3, 340, 7330, 8, 340, 1, 341, 1, 341, 1, 341,
		1, 341, 1, 341, 1, 341, 1, 341, 3, 341, 7339, 8, 341, 1, 342, 1, 342, 1,
		342, 1, 342, 1, 342, 1, 342, 1, 342, 3, 342, 7348, 8, 342, 1, 343, 1, 343,
		1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 3, 344, 7357, 8, 344, 1, 345, 1,
		345, 1, 346, 1, 346, 1, 347, 1, 347, 1, 348, 1, 348, 1, 349, 1, 349, 1,
		350, 1, 350, 1, 351, 1, 351, 1, 351, 0, 3, 672, 674, 676, 352, 0, 2, 4,
		6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42,
		44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78,
		80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112,
		114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142,
		144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172,
		174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202,
		204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232,
		234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262,
		264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292,
		294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314, 316, 318, 320, 322,
		324, 326, 328, 330, 332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352,
		354, 356, 358, 360, 362, 364, 366, 368, 370, 372, 374, 376, 378, 380, 382,
		384, 386, 388, 390, 392, 394, 396, 398, 400, 402, 404, 406, 408, 410, 412,
		414, 416, 418, 420, 422, 424, 426, 428, 430, 432, 434, 436, 438, 440, 442,
		444, 446, 448, 450, 452, 454, 456, 458, 460, 462, 464, 466, 468, 470, 472,
		474, 476, 478, 480, 482, 484, 486, 488, 490, 492, 494, 496, 498, 500, 502,
		504, 506, 508, 510, 512, 514, 516, 518, 520, 522, 524, 526, 528, 530, 532,
		534, 536, 538, 540, 542, 544, 546, 548, 550, 552, 554, 556, 558, 560, 562,
		564, 566, 568, 570, 572, 574, 576, 578, 580, 582, 584, 586, 588, 590, 592,
		594, 596, 598, 600, 602, 604, 606, 608, 610, 612, 614, 616, 618, 620, 622,
		624, 626, 628, 630, 632, 634, 636, 638, 640, 642, 644, 646, 648, 650, 652,
		654, 656, 658, 660, 662, 664, 666, 668, 670, 672, 674, 676, 678, 680, 682,
		684, 686, 688, 690, 692, 694, 696, 698, 700, 702, 0, 140, 2, 0, 39, 39,
		150, 150, 2, 0, 531, 531, 537, 537, 3, 0, 69, 69, 159, 159, 181, 181, 3,
		0, 42, 42, 384, 384, 454, 454, 4, 0, 42, 42, 419, 419, 529, 529, 611, 611,
		2, 0, 514, 514, 1146, 1146, 2, 0, 78, 78, 141, 141, 2, 0, 15, 15, 334,
		334, 3, 0, 44, 44, 85, 85, 184, 184, 2, 0, 434, 434, 558, 558, 3, 0, 506,
		506, 650, 650, 658, 658, 2, 0, 392, 392, 460, 460, 2, 0, 352, 352, 474,
		474, 2, 0, 42, 42, 1136, 1137, 2, 0, 350, 350, 443, 443, 2, 0, 459, 459,
		673, 673, 3, 0, 80, 80, 84, 84, 125, 125, 3, 0, 42, 42, 402, 402, 431,
		431, 3, 0, 42, 42, 398, 398, 791, 791, 2, 0, 637, 637, 672, 672, 2, 0,
		81, 81, 91, 91, 3, 0, 436, 436, 548, 548, 613, 613, 2, 0, 69, 69, 159,
		159, 1, 0, 356, 357, 1, 0, 1136, 1137, 2, 0, 1146, 1146, 1154, 1154, 2,
		0, 81, 81, 388, 388, 2, 0, 545, 545, 1146, 1146, 2, 0, 546, 546, 1146,
		1146, 3, 0, 430, 430, 469, 469, 521, 521, 7, 0, 42, 42, 370, 370, 372,
		372, 402, 402, 431, 431, 573, 573, 1154, 1154, 2, 0, 514, 514, 530, 530,
		1, 0, 1137, 1138, 2, 0, 5, 5, 51, 51, 4, 0, 42, 42, 384, 384, 454, 454,
		458, 458, 2, 0, 26, 26, 30, 30, 2, 0, 12, 12, 175, 175, 2, 0, 192, 192,
		677, 677, 2, 0, 21, 21, 144, 144, 3, 0, 43, 43, 75, 75, 106, 106, 2, 0,
		106, 106, 374, 374, 2, 0, 365, 365, 427, 427, 2, 0, 101, 101, 601, 601,
		2, 0, 43, 43, 106, 106, 2, 0, 6, 6, 49, 49, 2, 0, 188, 188, 669, 669, 4,
		0, 430, 430, 469, 469, 520, 520, 562, 562, 2, 0, 430, 430, 520, 520, 2,
		0, 13, 13, 45, 45, 3, 0, 66, 66, 78, 78, 186, 186, 2, 0, 34, 34, 83, 83,
		2, 0, 97, 97, 148, 148, 2, 0, 6, 6, 49, 50, 1, 0, 626, 627, 2, 0, 172,
		172, 741, 741, 2, 0, 439, 439, 609, 609, 2, 0, 226, 226, 477, 477, 5, 0,
		107, 107, 482, 483, 485, 485, 489, 497, 575, 575, 4, 0, 479, 480, 484,
		484, 486, 487, 576, 576, 3, 0, 108, 108, 478, 478, 488, 488, 2, 0, 462,
		462, 628, 628, 2, 0, 622, 622, 624, 624, 2, 0, 344, 344, 629, 629, 2, 0,
		90, 90, 591, 591, 2, 0, 51, 51, 390, 390, 3, 0, 31, 31, 61, 61, 179, 179,
		3, 0, 131, 131, 172, 172, 437, 437, 3, 0, 12, 12, 19, 19, 187, 187, 2,
		0, 42, 42, 121, 121, 2, 0, 103, 103, 182, 182, 2, 0, 360, 360, 614, 614,
		2, 0, 40, 40, 671, 671, 2, 0, 115, 115, 474, 474, 2, 0, 422, 422, 568,
		568, 4, 0, 206, 206, 208, 208, 214, 214, 638, 638, 2, 0, 1106, 1106, 1122,
		1122, 2, 0, 345, 345, 577, 577, 2, 0, 68, 68, 80, 80, 6, 0, 131, 131, 172,
		172, 177, 177, 415, 415, 437, 437, 671, 671, 2, 0, 513, 513, 634, 634,
		2, 0, 412, 412, 675, 675, 2, 0, 131, 131, 437, 437, 3, 0, 81, 81, 92, 92,
		452, 452, 3, 0, 439, 439, 474, 474, 609, 609, 2, 0, 634, 634, 670, 670,
		2, 0, 376, 376, 567, 567, 6, 0, 226, 226, 409, 409, 411, 411, 438, 438,
		574, 574, 615, 615, 2, 0, 45, 46, 62, 62, 3, 0, 422, 422, 550, 550, 884,
		884, 2, 0, 466, 466, 652, 652, 10, 0, 359, 359, 367, 367, 378, 380, 387,
		387, 507, 507, 515, 515, 639, 639, 646, 646, 835, 835, 1003, 1003, 2, 0,
		35, 35, 168, 168, 2, 0, 117, 117, 994, 994, 11, 0, 359, 359, 367, 367,
		378, 380, 387, 387, 507, 507, 515, 515, 592, 592, 639, 639, 646, 646, 835,
		835, 1003, 1003, 1, 0, 1158, 1159, 4, 0, 375, 375, 786, 797, 1146, 1146,
		1154, 1155, 3, 0, 1136, 1138, 1147, 1147, 1149, 1149, 2, 0, 63, 63, 178,
		178, 2, 0, 116, 116, 1150, 1150, 5, 0, 25, 25, 222, 224, 231, 231, 233,
		236, 518, 518, 2, 0, 25, 25, 222, 222, 2, 0, 25, 25, 222, 223, 1, 0, 196,
		207, 3, 0, 183, 183, 195, 195, 612, 612, 2, 0, 211, 216, 431, 431, 6, 0,
		217, 217, 228, 228, 230, 230, 232, 232, 239, 239, 348, 349, 4, 0, 218,
		221, 226, 227, 229, 229, 346, 346, 2, 0, 153, 153, 237, 237, 2, 0, 466,
		466, 802, 810, 2, 0, 226, 226, 518, 518, 5, 0, 200, 200, 206, 206, 217,
		218, 220, 220, 466, 466, 2, 0, 183, 183, 612, 612, 2, 0, 315, 316, 322,
		322, 4, 0, 37, 37, 150, 150, 313, 316, 331, 331, 1, 0, 325, 326, 3, 0,
		17, 17, 95, 95, 176, 176, 2, 0, 222, 222, 226, 226, 2, 0, 217, 218, 220,
		220, 3, 0, 13, 13, 45, 45, 992, 992, 3, 0, 286, 286, 298, 299, 309, 309,
		3, 0, 287, 289, 305, 308, 310, 312, 2, 0, 295, 295, 297, 297, 2, 0, 293,
		293, 296, 296, 2, 0, 291, 292, 302, 304, 2, 0, 133, 133, 601, 601, 2, 0,
		433, 433, 559, 559, 2, 0, 535, 535, 551, 551, 2, 0, 114, 114, 1125, 1125,
		3, 0, 63, 63, 178, 178, 662, 662, 2, 0, 137, 137, 149, 149, 3, 0, 6, 6,
		337, 337, 618, 618, 3, 0, 114, 114, 1118, 1119, 1125, 1126, 1, 0, 1115,
		1121, 2, 0, 226, 226, 745, 785, 1, 0, 798, 801, 5, 0, 707, 708, 724, 726,
		732, 732, 738, 739, 741, 741, 1, 0, 689, 696, 3, 0, 217, 221, 234, 234,
		237, 237, 58, 0, 14, 14, 18, 18, 29, 29, 35, 35, 37, 37, 42, 42, 48, 48,
		55, 55, 57, 57, 59, 59, 73, 73, 79, 79, 94, 94, 117, 117, 121, 121, 124,
		124, 130, 130, 158, 158, 168, 168, 239, 239, 283, 290, 294, 294, 298, 299,
		305, 312, 332, 385, 387, 403, 405, 405, 407, 432, 434, 450, 452, 458, 460,
		521, 523, 523, 527, 544, 547, 558, 560, 589, 591, 592, 594, 606, 608, 636,
		638, 672, 674, 675, 677, 682, 684, 688, 697, 697, 699, 706, 709, 711, 716,
		717, 719, 723, 727, 731, 733, 733, 735, 737, 740, 740, 742, 744, 791, 791,
		835, 835, 874, 874, 998, 998, 1003, 1003, 1086, 1086, 23, 0, 39, 39, 97,
		97, 148, 148, 150, 150, 217, 219, 221, 221, 251, 282, 290, 293, 295, 297,
		300, 304, 324, 324, 459, 459, 673, 673, 689, 696, 735, 735, 802, 802, 805,
		834, 836, 873, 875, 997, 999, 1002, 1004, 1085, 1087, 1105, 1121, 1121,
		8687, 0, 705, 1, 0, 0, 0, 2, 724, 1, 0, 0, 0, 4, 745, 1, 0, 0, 0, 6, 747,
		1, 0, 0, 0, 8, 787, 1, 0, 0, 0, 10, 801, 1, 0, 0, 0, 12, 812, 1, 0, 0,
		0, 14, 829, 1, 0, 0, 0, 16, 834, 1, 0, 0, 0, 18, 846, 1, 0, 0, 0, 20, 873,
		1, 0, 0, 0, 22, 882, 1, 0, 0, 0, 24, 884, 1, 0, 0, 0, 26, 896, 1, 0, 0,
		0, 28, 926, 1, 0, 0, 0, 30, 962, 1, 0, 0, 0, 32, 1013, 1, 0, 0, 0, 34,
		1039, 1, 0, 0, 0, 36, 1075, 1, 0, 0, 0, 38, 1088, 1, 0, 0, 0, 40, 1185,
		1, 0, 0, 0, 42, 1187, 1, 0, 0, 0, 44, 1205, 1, 0, 0, 0, 46, 1266, 1, 0,
		0, 0, 48, 1285, 1, 0, 0, 0, 50, 1291, 1, 0, 0, 0, 52, 1313, 1, 0, 0, 0,
		54, 1315, 1, 0, 0, 0, 56, 1317, 1, 0, 0, 0, 58, 1397, 1, 0, 0, 0, 60, 1404,
		1, 0, 0, 0, 62, 1406, 1, 0, 0, 0, 64, 1450, 1, 0, 0, 0, 66, 1456, 1, 0,
		0, 0, 68, 1458, 1, 0, 0, 0, 70, 1479, 1, 0, 0, 0, 72, 1486, 1, 0, 0, 0,
		74, 1488, 1, 0, 0, 0, 76, 1513, 1, 0, 0, 0, 78, 1516, 1, 0, 0, 0, 80, 1521,
		1, 0, 0, 0, 82, 1547, 1, 0, 0, 0, 84, 1563, 1, 0, 0, 0, 86, 1565, 1, 0,
		0, 0, 88, 1587, 1, 0, 0, 0, 90, 1589, 1, 0, 0, 0, 92, 1655, 1, 0, 0, 0,
		94, 1726, 1, 0, 0, 0, 96, 1728, 1, 0, 0, 0, 98, 1756, 1, 0, 0, 0, 100,
		1766, 1, 0, 0, 0, 102, 1796, 1, 0, 0, 0, 104, 1983, 1, 0, 0, 0, 106, 1985,
		1, 0, 0, 0, 108, 1987, 1, 0, 0, 0, 110, 1990, 1, 0, 0, 0, 112, 2065, 1,
		0, 0, 0, 114, 2088, 1, 0, 0, 0, 116, 2236, 1, 0, 0, 0, 118, 2241, 1, 0,
		0, 0, 120, 2243, 1, 0, 0, 0, 122, 2253, 1, 0, 0, 0, 124, 2309, 1, 0, 0,
		0, 126, 2329, 1, 0, 0, 0, 128, 2331, 1, 0, 0, 0, 130, 2366, 1, 0, 0, 0,
		132, 2375, 1, 0, 0, 0, 134, 2382, 1, 0, 0, 0, 136, 2405, 1, 0, 0, 0, 138,
		2414, 1, 0, 0, 0, 140, 2429, 1, 0, 0, 0, 142, 2454, 1, 0, 0, 0, 144, 2474,
		1, 0, 0, 0, 146, 2954, 1, 0, 0, 0, 148, 2956, 1, 0, 0, 0, 150, 2963, 1,
		0, 0, 0, 152, 2970, 1, 0, 0, 0, 154, 2993, 1, 0, 0, 0, 156, 3001, 1, 0,
		0, 0, 158, 3008, 1, 0, 0, 0, 160, 3015, 1, 0, 0, 0, 162, 3022, 1, 0, 0,
		0, 164, 3034, 1, 0, 0, 0, 166, 3044, 1, 0, 0, 0, 168, 3051, 1, 0, 0, 0,
		170, 3067, 1, 0, 0, 0, 172, 3113, 1, 0, 0, 0, 174, 3115, 1, 0, 0, 0, 176,
		3125, 1, 0, 0, 0, 178, 3129, 1, 0, 0, 0, 180, 3135, 1, 0, 0, 0, 182, 3147,
		1, 0, 0, 0, 184, 3149, 1, 0, 0, 0, 186, 3156, 1, 0, 0, 0, 188, 3158, 1,
		0, 0, 0, 190, 3226, 1, 0, 0, 0, 192, 3300, 1, 0, 0, 0, 194, 3359, 1, 0,
		0, 0, 196, 3454, 1, 0, 0, 0, 198, 3458, 1, 0, 0, 0, 200, 3460, 1, 0, 0,
		0, 202, 3495, 1, 0, 0, 0, 204, 3497, 1, 0, 0, 0, 206, 3505, 1, 0, 0, 0,
		208, 3513, 1, 0, 0, 0, 210, 3515, 1, 0, 0, 0, 212, 3551, 1, 0, 0, 0, 214,
		3606, 1, 0, 0, 0, 216, 3615, 1, 0, 0, 0, 218, 3635, 1, 0, 0, 0, 220, 3647,
		1, 0, 0, 0, 222, 3651, 1, 0, 0, 0, 224, 3684, 1, 0, 0, 0, 226, 3705, 1,
		0, 0, 0, 228, 3715, 1, 0, 0, 0, 230, 3719, 1, 0, 0, 0, 232, 3745, 1, 0,
		0, 0, 234, 3787, 1, 0, 0, 0, 236, 3789, 1, 0, 0, 0, 238, 3804, 1, 0, 0,
		0, 240, 3856, 1, 0, 0, 0, 242, 3866, 1, 0, 0, 0, 244, 3876, 1, 0, 0, 0,
		246, 3932, 1, 0, 0, 0, 248, 3934, 1, 0, 0, 0, 250, 3958, 1, 0, 0, 0, 252,
		3964, 1, 0, 0, 0, 254, 3972, 1, 0, 0, 0, 256, 3989, 1, 0, 0, 0, 258, 4005,
		1, 0, 0, 0, 260, 4042, 1, 0, 0, 0, 262, 4048, 1, 0, 0, 0, 264, 4057, 1,
		0, 0, 0, 266, 4070, 1, 0, 0, 0, 268, 4074, 1, 0, 0, 0, 270, 4112, 1, 0,
		0, 0, 272, 4150, 1, 0, 0, 0, 274, 4164, 1, 0, 0, 0, 276, 4172, 1, 0, 0,
		0, 278, 4176, 1, 0, 0, 0, 280, 4182, 1, 0, 0, 0, 282, 4196, 1, 0, 0, 0,
		284, 4199, 1, 0, 0, 0, 286, 4217, 1, 0, 0, 0, 288, 4221, 1, 0, 0, 0, 290,
		4237, 1, 0, 0, 0, 292, 4239, 1, 0, 0, 0, 294, 4251, 1, 0, 0, 0, 296, 4255,
		1, 0, 0, 0, 298, 4272, 1, 0, 0, 0, 300, 4289, 1, 0, 0, 0, 302, 4292, 1,
		0, 0, 0, 304, 4302, 1, 0, 0, 0, 306, 4306, 1, 0, 0, 0, 308, 4319, 1, 0,
		0, 0, 310, 4322, 1, 0, 0, 0, 312, 4327, 1, 0, 0, 0, 314, 4347, 1, 0, 0,
		0, 316, 4349, 1, 0, 0, 0, 318, 4366, 1, 0, 0, 0, 320, 4375, 1, 0, 0, 0,
		322, 4384, 1, 0, 0, 0, 324, 4386, 1, 0, 0, 0, 326, 4400, 1, 0, 0, 0, 328,
		4411, 1, 0, 0, 0, 330, 4420, 1, 0, 0, 0, 332, 4423, 1, 0, 0, 0, 334, 4431,
		1, 0, 0, 0, 336, 4456, 1, 0, 0, 0, 338, 4468, 1, 0, 0, 0, 340, 4471, 1,
		0, 0, 0, 342, 4503, 1, 0, 0, 0, 344, 4505, 1, 0, 0, 0, 346, 4507, 1, 0,
		0, 0, 348, 4509, 1, 0, 0, 0, 350, 4511, 1, 0, 0, 0, 352, 4564, 1, 0, 0,
		0, 354, 4566, 1, 0, 0, 0, 356, 4572, 1, 0, 0, 0, 358, 4592, 1, 0, 0, 0,
		360, 4606, 1, 0, 0, 0, 362, 4617, 1, 0, 0, 0, 364, 4619, 1, 0, 0, 0, 366,
		4625, 1, 0, 0, 0, 368, 4635, 1, 0, 0, 0, 370, 4639, 1, 0, 0, 0, 372, 4646,
		1, 0, 0, 0, 374, 4650, 1, 0, 0, 0, 376, 4656, 1, 0, 0, 0, 378, 4663, 1,
		0, 0, 0, 380, 4669, 1, 0, 0, 0, 382, 4675, 1, 0, 0, 0, 384, 4680, 1, 0,
		0, 0, 386, 4725, 1, 0, 0, 0, 388, 4746, 1, 0, 0, 0, 390, 4771, 1, 0, 0,
		0, 392, 4774, 1, 0, 0, 0, 394, 4780, 1, 0, 0, 0, 396, 4796, 1, 0, 0, 0,
		398, 4811, 1, 0, 0, 0, 400, 4817, 1, 0, 0, 0, 402, 4847, 1, 0, 0, 0, 404,
		4849, 1, 0, 0, 0, 406, 4856, 1, 0, 0, 0, 408, 4868, 1, 0, 0, 0, 410, 4874,
		1, 0, 0, 0, 412, 4899, 1, 0, 0, 0, 414, 4903, 1, 0, 0, 0, 416, 4907, 1,
		0, 0, 0, 418, 4918, 1, 0, 0, 0, 420, 4999, 1, 0, 0, 0, 422, 5066, 1, 0,
		0, 0, 424, 5068, 1, 0, 0, 0, 426, 5174, 1, 0, 0, 0, 428, 5198, 1, 0, 0,
		0, 430, 5200, 1, 0, 0, 0, 432, 5218, 1, 0, 0, 0, 434, 5298, 1, 0, 0, 0,
		436, 5300, 1, 0, 0, 0, 438, 5313, 1, 0, 0, 0, 440, 5324, 1, 0, 0, 0, 442,
		5348, 1, 0, 0, 0, 444, 5359, 1, 0, 0, 0, 446, 5369, 1, 0, 0, 0, 448, 5379,
		1, 0, 0, 0, 450, 5419, 1, 0, 0, 0, 452, 5421, 1, 0, 0, 0, 454, 5424, 1,
		0, 0, 0, 456, 5523, 1, 0, 0, 0, 458, 5541, 1, 0, 0, 0, 460, 5543, 1, 0,
		0, 0, 462, 5547, 1, 0, 0, 0, 464, 5585, 1, 0, 0, 0, 466, 5594, 1, 0, 0,
		0, 468, 5600, 1, 0, 0, 0, 470, 5607, 1, 0, 0, 0, 472, 5629, 1, 0, 0, 0,
		474, 5631, 1, 0, 0, 0, 476, 5645, 1, 0, 0, 0, 478, 5651, 1, 0, 0, 0, 480,
		5707, 1, 0, 0, 0, 482, 5862, 1, 0, 0, 0, 484, 5874, 1, 0, 0, 0, 486, 5889,
		1, 0, 0, 0, 488, 5895, 1, 0, 0, 0, 490, 5914, 1, 0, 0, 0, 492, 5924, 1,
		0, 0, 0, 494, 5938, 1, 0, 0, 0, 496, 5940, 1, 0, 0, 0, 498, 5943, 1, 0,
		0, 0, 500, 5965, 1, 0, 0, 0, 502, 5977, 1, 0, 0, 0, 504, 5983, 1, 0, 0,
		0, 506, 5995, 1, 0, 0, 0, 508, 5999, 1, 0, 0, 0, 510, 6001, 1, 0, 0, 0,
		512, 6043, 1, 0, 0, 0, 514, 6050, 1, 0, 0, 0, 516, 6052, 1, 0, 0, 0, 518,
		6075, 1, 0, 0, 0, 520, 6081, 1, 0, 0, 0, 522, 6089, 1, 0, 0, 0, 524, 6092,
		1, 0, 0, 0, 526, 6095, 1, 0, 0, 0, 528, 6116, 1, 0, 0, 0, 530, 6137, 1,
		0, 0, 0, 532, 6145, 1, 0, 0, 0, 534, 6157, 1, 0, 0, 0, 536, 6195, 1, 0,
		0, 0, 538, 6207, 1, 0, 0, 0, 540, 6209, 1, 0, 0, 0, 542, 6215, 1, 0, 0,
		0, 544, 6219, 1, 0, 0, 0, 546, 6235, 1, 0, 0, 0, 548, 6248, 1, 0, 0, 0,
		550, 6258, 1, 0, 0, 0, 552, 6260, 1, 0, 0, 0, 554, 6266, 1, 0, 0, 0, 556,
		6270, 1, 0, 0, 0, 558, 6272, 1, 0, 0, 0, 560, 6274, 1, 0, 0, 0, 562, 6292,
		1, 0, 0, 0, 564, 6308, 1, 0, 0, 0, 566, 6312, 1, 0, 0, 0, 568, 6317, 1,
		0, 0, 0, 570, 6328, 1, 0, 0, 0, 572, 6333, 1, 0, 0, 0, 574, 6335, 1, 0,
		0, 0, 576, 6339, 1, 0, 0, 0, 578, 6364, 1, 0, 0, 0, 580, 6366, 1, 0, 0,
		0, 582, 6369, 1, 0, 0, 0, 584, 6374, 1, 0, 0, 0, 586, 6390, 1, 0, 0, 0,
		588, 6518, 1, 0, 0, 0, 590, 6520, 1, 0, 0, 0, 592, 6553, 1, 0, 0, 0, 594,
		6558, 1, 0, 0, 0, 596, 6562, 1, 0, 0, 0, 598, 6568, 1, 0, 0, 0, 600, 6576,
		1, 0, 0, 0, 602, 6584, 1, 0, 0, 0, 604, 6592, 1, 0, 0, 0, 606, 6600, 1,
		0, 0, 0, 608, 6611, 1, 0, 0, 0, 610, 6619, 1, 0, 0, 0, 612, 6627, 1, 0,
		0, 0, 614, 6635, 1, 0, 0, 0, 616, 6643, 1, 0, 0, 0, 618, 6677, 1, 0, 0,
		0, 620, 6693, 1, 0, 0, 0, 622, 6697, 1, 0, 0, 0, 624, 6699, 1, 0, 0, 0,
		626, 6702, 1, 0, 0, 0, 628, 6706, 1, 0, 0, 0, 630, 6712, 1, 0, 0, 0, 632,
		6732, 1, 0, 0, 0, 634, 6912, 1, 0, 0, 0, 636, 6914, 1, 0, 0, 0, 638, 6933,
		1, 0, 0, 0, 640, 6935, 1, 0, 0, 0, 642, 6998, 1, 0, 0, 0, 644, 7038, 1,
		0, 0, 0, 646, 7040, 1, 0, 0, 0, 648, 7049, 1, 0, 0, 0, 650, 7060, 1, 0,
		0, 0, 652, 7062, 1, 0, 0, 0, 654, 7065, 1, 0, 0, 0, 656, 7069, 1, 0, 0,
		0, 658, 7071, 1, 0, 0, 0, 660, 7083, 1, 0, 0, 0, 662, 7085, 1, 0, 0, 0,
		664, 7118, 1, 0, 0, 0, 666, 7120, 1, 0, 0, 0, 668, 7129, 1, 0, 0, 0, 670,
		7147, 1, 0, 0, 0, 672, 7160, 1, 0, 0, 0, 674, 7171, 1, 0, 0, 0, 676, 7291,
		1, 0, 0, 0, 678, 7313, 1, 0, 0, 0, 680, 7329, 1, 0, 0, 0, 682, 7338, 1,
		0, 0, 0, 684, 7347, 1, 0, 0, 0, 686, 7349, 1, 0, 0, 0, 688, 7356, 1, 0,
		0, 0, 690, 7358, 1, 0, 0, 0, 692, 7360, 1, 0, 0, 0, 694, 7362, 1, 0, 0,
		0, 696, 7364, 1, 0, 0, 0, 698, 7366, 1, 0, 0, 0, 700, 7368, 1, 0, 0, 0,
		702, 7370, 1, 0, 0, 0, 704, 706, 3, 2, 1, 0, 705, 704, 1, 0, 0, 0, 705,
		706, 1, 0, 0, 0, 706, 709, 1, 0, 0, 0, 707, 708, 5, 1119, 0, 0, 708, 710,
		5, 1119, 0, 0, 709, 707, 1, 0, 0, 0, 709, 710, 1, 0, 0, 0, 710, 711, 1,
		0, 0, 0, 711, 712, 5, 0, 0, 1, 712, 1, 1, 0, 0, 0, 713, 716, 3, 4, 2, 0,
		714, 715, 5, 1119, 0, 0, 715, 717, 5, 1119, 0, 0, 716, 714, 1, 0, 0, 0,
		716, 717, 1, 0, 0, 0, 717, 719, 1, 0, 0, 0, 718, 720, 5, 1134, 0, 0, 719,
		718, 1, 0, 0, 0, 719, 720, 1, 0, 0, 0, 720, 723, 1, 0, 0, 0, 721, 723,
		3, 6, 3, 0, 722, 713, 1, 0, 0, 0, 722, 721, 1, 0, 0, 0, 723, 726, 1, 0,
		0, 0, 724, 722, 1, 0, 0, 0, 724, 725, 1, 0, 0, 0, 725, 736, 1, 0, 0, 0,
		726, 724, 1, 0, 0, 0, 727, 733, 3, 4, 2, 0, 728, 729, 5, 1119, 0, 0, 729,
		731, 5, 1119, 0, 0, 730, 728, 1, 0, 0, 0, 730, 731, 1, 0, 0, 0, 731, 732,
		1, 0, 0, 0, 732, 734, 5, 1134, 0, 0, 733, 730, 1, 0, 0, 0, 733, 734, 1,
		0, 0, 0, 734, 737, 1, 0, 0, 0, 735, 737, 3, 6, 3, 0, 736, 727, 1, 0, 0,
		0, 736, 735, 1, 0, 0, 0, 737, 3, 1, 0, 0, 0, 738, 746, 3, 8, 4, 0, 739,
		746, 3, 10, 5, 0, 740, 746, 3, 12, 6, 0, 741, 746, 3, 14, 7, 0, 742, 746,
		3, 16, 8, 0, 743, 746, 3, 20, 10, 0, 744, 746, 3, 22, 11, 0, 745, 738,
		1, 0, 0, 0, 745, 739, 1, 0, 0, 0, 745, 740, 1, 0, 0, 0, 745, 741, 1, 0,
		0, 0, 745, 742, 1, 0, 0, 0, 745, 743, 1, 0, 0, 0, 745, 744, 1, 0, 0, 0,
		746, 5, 1, 0, 0, 0, 747, 748, 5, 1134, 0, 0, 748, 7, 1, 0, 0, 0, 749, 788,
		3, 24, 12, 0, 750, 788, 3, 26, 13, 0, 751, 788, 3, 28, 14, 0, 752, 788,
		3, 30, 15, 0, 753, 788, 3, 32, 16, 0, 754, 788, 3, 34, 17, 0, 755, 788,
		3, 38, 19, 0, 756, 788, 3, 40, 20, 0, 757, 788, 3, 42, 21, 0, 758, 788,
		3, 44, 22, 0, 759, 788, 3, 46, 23, 0, 760, 788, 3, 56, 28, 0, 761, 788,
		3, 36, 18, 0, 762, 788, 3, 126, 63, 0, 763, 788, 3, 128, 64, 0, 764, 788,
		3, 130, 65, 0, 765, 788, 3, 132, 66, 0, 766, 788, 3, 134, 67, 0, 767, 788,
		3, 136, 68, 0, 768, 788, 3, 138, 69, 0, 769, 788, 3, 140, 70, 0, 770, 788,
		3, 142, 71, 0, 771, 788, 3, 144, 72, 0, 772, 788, 3, 148, 74, 0, 773, 788,
		3, 150, 75, 0, 774, 788, 3, 152, 76, 0, 775, 788, 3, 154, 77, 0, 776, 788,
		3, 156, 78, 0, 777, 788, 3, 158, 79, 0, 778, 788, 3, 160, 80, 0, 779, 788,
		3, 162, 81, 0, 780, 788, 3, 164, 82, 0, 781, 788, 3, 166, 83, 0, 782, 788,
		3, 168, 84, 0, 783, 788, 3, 170, 85, 0, 784, 788, 3, 172, 86, 0, 785, 788,
		3, 174, 87, 0, 786, 788, 3, 178, 89, 0, 787, 749, 1, 0, 0, 0, 787, 750,
		1, 0, 0, 0, 787, 751, 1, 0, 0, 0, 787, 752, 1, 0, 0, 0, 787, 753, 1, 0,
		0, 0, 787, 754, 1, 0, 0, 0, 787, 755, 1, 0, 0, 0, 787, 756, 1, 0, 0, 0,
		787, 757, 1, 0, 0, 0, 787, 758, 1, 0, 0, 0, 787, 759, 1, 0, 0, 0, 787,
		760, 1, 0, 0, 0, 787, 761, 1, 0, 0, 0, 787, 762, 1, 0, 0, 0, 787, 763,
		1, 0, 0, 0, 787, 764, 1, 0, 0, 0, 787, 765, 1, 0, 0, 0, 787, 766, 1, 0,
		0, 0, 787, 767, 1, 0, 0, 0, 787, 768, 1, 0, 0, 0, 787, 769, 1, 0, 0, 0,
		787, 770, 1, 0, 0, 0, 787, 771, 1, 0, 0, 0, 787, 772, 1, 0, 0, 0, 787,
		773, 1, 0, 0, 0, 787, 774, 1, 0, 0, 0, 787, 775, 1, 0, 0, 0, 787, 776,
		1, 0, 0, 0, 787, 777, 1, 0, 0, 0, 787, 778, 1, 0, 0, 0, 787, 779, 1, 0,
		0, 0, 787, 780, 1, 0, 0, 0, 787, 781, 1, 0, 0, 0, 787, 782, 1, 0, 0, 0,
		787, 783, 1, 0, 0, 0, 787, 784, 1, 0, 0, 0, 787, 785, 1, 0, 0, 0, 787,
		786, 1, 0, 0, 0, 788, 9, 1, 0, 0, 0, 789, 802, 3, 196, 98, 0, 790, 802,
		3, 188, 94, 0, 791, 802, 3, 198, 99, 0, 792, 802, 3, 182, 91, 0, 793, 802,
		3, 194, 97, 0, 794, 802, 3, 180, 90, 0, 795, 802, 3, 190, 95, 0, 796, 802,
		3, 192, 96, 0, 797, 802, 3, 184, 92, 0, 798, 802, 3, 186, 93, 0, 799, 802,
		3, 200, 100, 0, 800, 802, 3, 532, 266, 0, 801, 789, 1, 0, 0, 0, 801, 790,
		1, 0, 0, 0, 801, 791, 1, 0, 0, 0, 801, 792, 1, 0, 0, 0, 801, 793, 1, 0,
		0, 0, 801, 794, 1, 0, 0, 0, 801, 795, 1, 0, 0, 0, 801, 796, 1, 0, 0, 0,
		801, 797, 1, 0, 0, 0, 801, 798, 1, 0, 0, 0, 801, 799, 1, 0, 0, 0, 801,
		800, 1, 0, 0, 0, 802, 11, 1, 0, 0, 0, 803, 813, 3, 292, 146, 0, 804, 813,
		3, 294, 147, 0, 805, 813, 3, 296, 148, 0, 806, 813, 3, 298, 149, 0, 807,
		813, 3, 300, 150, 0, 808, 813, 3, 302, 151, 0, 809, 813, 3, 304, 152, 0,
		810, 813, 3, 306, 153, 0, 811, 813, 3, 308, 154, 0, 812, 803, 1, 0, 0,
		0, 812, 804, 1, 0, 0, 0, 812, 805, 1, 0, 0, 0, 812, 806, 1, 0, 0, 0, 812,
		807, 1, 0, 0, 0, 812, 808, 1, 0, 0, 0, 812, 809, 1, 0, 0, 0, 812, 810,
		1, 0, 0, 0, 812, 811, 1, 0, 0, 0, 813, 13, 1, 0, 0, 0, 814, 830, 3, 324,
		162, 0, 815, 830, 3, 326, 163, 0, 816, 830, 3, 328, 164, 0, 817, 830, 3,
		330, 165, 0, 818, 830, 3, 332, 166, 0, 819, 830, 3, 334, 167, 0, 820, 830,
		3, 336, 168, 0, 821, 830, 3, 338, 169, 0, 822, 830, 3, 340, 170, 0, 823,
		830, 3, 364, 182, 0, 824, 830, 3, 366, 183, 0, 825, 830, 3, 368, 184, 0,
		826, 830, 3, 370, 185, 0, 827, 830, 3, 372, 186, 0, 828, 830, 3, 374, 187,
		0, 829, 814, 1, 0, 0, 0, 829, 815, 1, 0, 0, 0, 829, 816, 1, 0, 0, 0, 829,
		817, 1, 0, 0, 0, 829, 818, 1, 0, 0, 0, 829, 819, 1, 0, 0, 0, 829, 820,
		1, 0, 0, 0, 829, 821, 1, 0, 0, 0, 829, 822, 1, 0, 0, 0, 829, 823, 1, 0,
		0, 0, 829, 824, 1, 0, 0, 0, 829, 825, 1, 0, 0, 0, 829, 826, 1, 0, 0, 0,
		829, 827, 1, 0, 0, 0, 829, 828, 1, 0, 0, 0, 830, 15, 1, 0, 0, 0, 831, 835,
		3, 376, 188, 0, 832, 835, 3, 378, 189, 0, 833, 835, 3, 380, 190, 0, 834,
		831, 1, 0, 0, 0, 834, 832, 1, 0, 0, 0, 834, 833, 1, 0, 0, 0, 835, 17, 1,
		0, 0, 0, 836, 847, 3, 384, 192, 0, 837, 847, 3, 386, 193, 0, 838, 847,
		3, 388, 194, 0, 839, 847, 3, 392, 196, 0, 840, 847, 3, 394, 197, 0, 841,
		847, 3, 396, 198, 0, 842, 847, 3, 400, 200, 0, 843, 847, 3, 390, 195, 0,
		844, 847, 3, 398, 199, 0, 845, 847, 3, 402, 201, 0, 846, 836, 1, 0, 0,
		0, 846, 837, 1, 0, 0, 0, 846, 838, 1, 0, 0, 0, 846, 839, 1, 0, 0, 0, 846,
		840, 1, 0, 0, 0, 846, 841, 1, 0, 0, 0, 846, 842, 1, 0, 0, 0, 846, 843,
		1, 0, 0, 0, 846, 844, 1, 0, 0, 0, 846, 845, 1, 0, 0, 0, 847, 19, 1, 0,
		0, 0, 848, 874, 3, 420, 210, 0, 849, 874, 3, 422, 211, 0, 850, 874, 3,
		424, 212, 0, 851, 874, 3, 426, 213, 0, 852, 874, 3, 430, 215, 0, 853, 874,
		3, 432, 216, 0, 854, 874, 3, 434, 217, 0, 855, 874, 3, 436, 218, 0, 856,
		874, 3, 462, 231, 0, 857, 874, 3, 464, 232, 0, 858, 874, 3, 466, 233, 0,
		859, 874, 3, 468, 234, 0, 860, 874, 3, 470, 235, 0, 861, 874, 3, 474, 237,
		0, 862, 874, 3, 476, 238, 0, 863, 874, 3, 478, 239, 0, 864, 874, 3, 480,
		240, 0, 865, 874, 3, 482, 241, 0, 866, 874, 3, 496, 248, 0, 867, 874, 3,
		498, 249, 0, 868, 874, 3, 500, 250, 0, 869, 874, 3, 502, 251, 0, 870, 874,
		3, 504, 252, 0, 871, 874, 3, 506, 253, 0, 872, 874, 3, 508, 254, 0, 873,
		848, 1, 0, 0, 0, 873, 849, 1, 0, 0, 0, 873, 850, 1, 0, 0, 0, 873, 851,
		1, 0, 0, 0, 873, 852, 1, 0, 0, 0, 873, 853, 1, 0, 0, 0, 873, 854, 1, 0,
		0, 0, 873, 855, 1, 0, 0, 0, 873, 856, 1, 0, 0, 0, 873, 857, 1, 0, 0, 0,
		873, 858, 1, 0, 0, 0, 873, 859, 1, 0, 0, 0, 873, 860, 1, 0, 0, 0, 873,
		861, 1, 0, 0, 0, 873, 862, 1, 0, 0, 0, 873, 863, 1, 0, 0, 0, 873, 864,
		1, 0, 0, 0, 873, 865, 1, 0, 0, 0, 873, 866, 1, 0, 0, 0, 873, 867, 1, 0,
		0, 0, 873, 868, 1, 0, 0, 0, 873, 869, 1, 0, 0, 0, 873, 870, 1, 0, 0, 0,
		873, 871, 1, 0, 0, 0, 873, 872, 1, 0, 0, 0, 874, 21, 1, 0, 0, 0, 875, 883,
		3, 518, 259, 0, 876, 883, 3, 520, 260, 0, 877, 883, 3, 522, 261, 0, 878,
		883, 3, 524, 262, 0, 879, 883, 3, 526, 263, 0, 880, 883, 3, 528, 264, 0,
		881, 883, 3, 534, 267, 0, 882, 875, 1, 0, 0, 0, 882, 876, 1, 0, 0, 0, 882,
		877, 1, 0, 0, 0, 882, 878, 1, 0, 0, 0, 882, 879, 1, 0, 0, 0, 882, 880,
		1, 0, 0, 0, 882, 881, 1, 0, 0, 0, 883, 23, 1, 0, 0, 0, 884, 885, 5, 33,
		0, 0, 885, 887, 7, 0, 0, 0, 886, 888, 3, 626, 313, 0, 887, 886, 1, 0, 0,
		0, 887, 888, 1, 0, 0, 0, 888, 889, 1, 0, 0, 0, 889, 893, 3, 568, 284, 0,
		890, 892, 3, 58, 29, 0, 891, 890, 1, 0, 0, 0, 892, 895, 1, 0, 0, 0, 893,
		891, 1, 0, 0, 0, 893, 894, 1, 0, 0, 0, 894, 25, 1, 0, 0, 0, 895, 893, 1,
		0, 0, 0, 896, 898, 5, 33, 0, 0, 897, 899, 3, 62, 31, 0, 898, 897, 1, 0,
		0, 0, 898, 899, 1, 0, 0, 0, 899, 900, 1, 0, 0, 0, 900, 902, 5, 415, 0,
		0, 901, 903, 3, 626, 313, 0, 902, 901, 1, 0, 0, 0, 902, 903, 1, 0, 0, 0,
		903, 904, 1, 0, 0, 0, 904, 905, 3, 540, 270, 0, 905, 906, 5, 118, 0, 0,
		906, 907, 5, 605, 0, 0, 907, 914, 3, 64, 32, 0, 908, 909, 5, 118, 0, 0,
		909, 911, 5, 371, 0, 0, 910, 912, 5, 114, 0, 0, 911, 910, 1, 0, 0, 0, 911,
		912, 1, 0, 0, 0, 912, 913, 1, 0, 0, 0, 913, 915, 5, 561, 0, 0, 914, 908,
		1, 0, 0, 0, 914, 915, 1, 0, 0, 0, 915, 917, 1, 0, 0, 0, 916, 918, 3, 72,
		36, 0, 917, 916, 1, 0, 0, 0, 917, 918, 1, 0, 0, 0, 918, 921, 1, 0, 0, 0,
		919, 920, 5, 368, 0, 0, 920, 922, 5, 1146, 0, 0, 921, 919, 1, 0, 0, 0,
		921, 922, 1, 0, 0, 0, 922, 923, 1, 0, 0, 0, 923, 924, 5, 399, 0, 0, 924,
		925, 3, 382, 191, 0, 925, 27, 1, 0, 0, 0, 926, 928, 5, 33, 0, 0, 927, 929,
		7, 1, 0, 0, 928, 927, 1, 0, 0, 0, 928, 929, 1, 0, 0, 0, 929, 931, 1, 0,
		0, 0, 930, 932, 7, 2, 0, 0, 931, 930, 1, 0, 0, 0, 931, 932, 1, 0, 0, 0,
		932, 933, 1, 0, 0, 0, 933, 934, 5, 81, 0, 0, 934, 936, 3, 568, 284, 0,
		935, 937, 3, 74, 37, 0, 936, 935, 1, 0, 0, 0, 936, 937, 1, 0, 0, 0, 937,
		938, 1, 0, 0, 0, 938, 939, 5, 118, 0, 0, 939, 940, 3, 542, 271, 0, 940,
		944, 3, 606, 303, 0, 941, 943, 3, 76, 38, 0, 942, 941, 1, 0, 0, 0, 943,
		946, 1, 0, 0, 0, 944, 942, 1, 0, 0, 0, 944, 945, 1, 0, 0, 0, 945, 959,
		1, 0, 0, 0, 946, 944, 1, 0, 0, 0, 947, 949, 5, 336, 0, 0, 948, 950, 5,
		1122, 0, 0, 949, 948, 1, 0, 0, 0, 949, 950, 1, 0, 0, 0, 950, 951, 1, 0,
		0, 0, 951, 958, 7, 3, 0, 0, 952, 954, 5, 103, 0, 0, 953, 955, 5, 1122,
		0, 0, 954, 953, 1, 0, 0, 0, 954, 955, 1, 0, 0, 0, 955, 956, 1, 0, 0, 0,
		956, 958, 7, 4, 0, 0, 957, 947, 1, 0, 0, 0, 957, 952, 1, 0, 0, 0, 958,
		961, 1, 0, 0, 0, 959, 957, 1, 0, 0, 0, 959, 960, 1, 0, 0, 0, 960, 29, 1,
		0, 0, 0, 961, 959, 1, 0, 0, 0, 962, 963, 5, 33, 0, 0, 963, 964, 5, 475,
		0, 0, 964, 965, 5, 73, 0, 0, 965, 966, 3, 568, 284, 0, 966, 967, 5, 5,
		0, 0, 967, 968, 5, 659, 0, 0, 968, 974, 5, 1146, 0, 0, 969, 971, 5, 453,
		0, 0, 970, 972, 5, 1122, 0, 0, 971, 970, 1, 0, 0, 0, 971, 972, 1, 0, 0,
		0, 972, 973, 1, 0, 0, 0, 973, 975, 3, 576, 288, 0, 974, 969, 1, 0, 0, 0,
		974, 975, 1, 0, 0, 0, 975, 981, 1, 0, 0, 0, 976, 978, 5, 660, 0, 0, 977,
		979, 5, 1122, 0, 0, 978, 977, 1, 0, 0, 0, 978, 979, 1, 0, 0, 0, 979, 980,
		1, 0, 0, 0, 980, 982, 3, 576, 288, 0, 981, 976, 1, 0, 0, 0, 981, 982, 1,
		0, 0, 0, 982, 988, 1, 0, 0, 0, 983, 985, 5, 572, 0, 0, 984, 986, 5, 1122,
		0, 0, 985, 984, 1, 0, 0, 0, 985, 986, 1, 0, 0, 0, 986, 987, 1, 0, 0, 0,
		987, 989, 3, 576, 288, 0, 988, 983, 1, 0, 0, 0, 988, 989, 1, 0, 0, 0, 989,
		995, 1, 0, 0, 0, 990, 992, 5, 528, 0, 0, 991, 993, 5, 1122, 0, 0, 992,
		991, 1, 0, 0, 0, 992, 993, 1, 0, 0, 0, 993, 994, 1, 0, 0, 0, 994, 996,
		3, 568, 284, 0, 995, 990, 1, 0, 0, 0, 995, 996, 1, 0, 0, 0, 996, 998, 1,
		0, 0, 0, 997, 999, 5, 674, 0, 0, 998, 997, 1, 0, 0, 0, 998, 999, 1, 0,
		0, 0, 999, 1005, 1, 0, 0, 0, 1000, 1002, 5, 368, 0, 0, 1001, 1003, 5, 1122,
		0, 0, 1002, 1001, 1, 0, 0, 0, 1002, 1003, 1, 0, 0, 0, 1003, 1004, 1, 0,
		0, 0, 1004, 1006, 5, 1146, 0, 0, 1005, 1000, 1, 0, 0, 0, 1005, 1006, 1,
		0, 0, 0, 1006, 1007, 1, 0, 0, 0, 1007, 1009, 5, 409, 0, 0, 1008, 1010,
		5, 1122, 0, 0, 1009, 1008, 1, 0, 0, 0, 1009, 1010, 1, 0, 0, 0, 1010, 1011,
		1, 0, 0, 0, 1011, 1012, 3, 558, 279, 0, 1012, 31, 1, 0, 0, 0, 1013, 1015,
		5, 33, 0, 0, 1014, 1016, 3, 62, 31, 0, 1015, 1014, 1, 0, 0, 0, 1015, 1016,
		1, 0, 0, 0, 1016, 1017, 1, 0, 0, 0, 1017, 1018, 5, 131, 0, 0, 1018, 1019,
		3, 540, 270, 0, 1019, 1021, 5, 1131, 0, 0, 1020, 1022, 3, 78, 39, 0, 1021,
		1020, 1, 0, 0, 0, 1021, 1022, 1, 0, 0, 0, 1022, 1027, 1, 0, 0, 0, 1023,
		1024, 5, 1133, 0, 0, 1024, 1026, 3, 78, 39, 0, 1025, 1023, 1, 0, 0, 0,
		1026, 1029, 1, 0, 0, 0, 1027, 1025, 1, 0, 0, 0, 1027, 1028, 1, 0, 0, 0,
		1028, 1030, 1, 0, 0, 0, 1029, 1027, 1, 0, 0, 0, 1030, 1034, 5, 1132, 0,
		0, 1031, 1033, 3, 82, 41, 0, 1032, 1031, 1, 0, 0, 0, 1033, 1036, 1, 0,
		0, 0, 1034, 1032, 1, 0, 0, 0, 1034, 1035, 1, 0, 0, 0, 1035, 1037, 1, 0,
		0, 0, 1036, 1034, 1, 0, 0, 0, 1037, 1038, 3, 382, 191, 0, 1038, 33, 1,
		0, 0, 0, 1039, 1041, 5, 33, 0, 0, 1040, 1042, 3, 62, 31, 0, 1041, 1040,
		1, 0, 0, 0, 1041, 1042, 1, 0, 0, 0, 1042, 1044, 1, 0, 0, 0, 1043, 1045,
		5, 335, 0, 0, 1044, 1043, 1, 0, 0, 0, 1044, 1045, 1, 0, 0, 0, 1045, 1046,
		1, 0, 0, 0, 1046, 1048, 5, 437, 0, 0, 1047, 1049, 3, 626, 313, 0, 1048,
		1047, 1, 0, 0, 0, 1048, 1049, 1, 0, 0, 0, 1049, 1050, 1, 0, 0, 0, 1050,
		1051, 3, 540, 270, 0, 1051, 1053, 5, 1131, 0, 0, 1052, 1054, 3, 80, 40,
		0, 1053, 1052, 1, 0, 0, 0, 1053, 1054, 1, 0, 0, 0, 1054, 1059, 1, 0, 0,
		0, 1055, 1056, 5, 1133, 0, 0, 1056, 1058, 3, 80, 40, 0, 1057, 1055, 1,
		0, 0, 0, 1058, 1061, 1, 0, 0, 0, 1059, 1057, 1, 0, 0, 0, 1059, 1060, 1,
		0, 0, 0, 1060, 1062, 1, 0, 0, 0, 1061, 1059, 1, 0, 0, 0, 1062, 1063, 5,
		1132, 0, 0, 1063, 1064, 5, 594, 0, 0, 1064, 1068, 3, 588, 294, 0, 1065,
		1067, 3, 82, 41, 0, 1066, 1065, 1, 0, 0, 0, 1067, 1070, 1, 0, 0, 0, 1068,
		1066, 1, 0, 0, 0, 1068, 1069, 1, 0, 0, 0, 1069, 1073, 1, 0, 0, 0, 1070,
		1068, 1, 0, 0, 0, 1071, 1074, 3, 382, 191, 0, 1072, 1074, 3, 398, 199,
		0, 1073, 1071, 1, 0, 0, 0, 1073, 1072, 1, 0, 0, 0, 1074, 35, 1, 0, 0, 0,
		1075, 1076, 5, 33, 0, 0, 1076, 1078, 5, 596, 0, 0, 1077, 1079, 3, 626,
		313, 0, 1078, 1077, 1, 0, 0, 0, 1078, 1079, 1, 0, 0, 0, 1079, 1080, 1,
		0, 0, 0, 1080, 1085, 3, 544, 272, 0, 1081, 1082, 5, 1133, 0, 0, 1082, 1084,
		3, 544, 272, 0, 1083, 1081, 1, 0, 0, 0, 1084, 1087, 1, 0, 0, 0, 1085, 1083,
		1, 0, 0, 0, 1085, 1086, 1, 0, 0, 0, 1086, 37, 1, 0, 0, 0, 1087, 1085, 1,
		0, 0, 0, 1088, 1089, 5, 33, 0, 0, 1089, 1090, 5, 608, 0, 0, 1090, 1091,
		3, 568, 284, 0, 1091, 1092, 5, 67, 0, 0, 1092, 1093, 5, 388, 0, 0, 1093,
		1094, 5, 679, 0, 0, 1094, 1095, 7, 5, 0, 0, 1095, 1096, 5, 541, 0, 0, 1096,
		1097, 5, 1131, 0, 0, 1097, 1102, 3, 84, 42, 0, 1098, 1099, 5, 1133, 0,
		0, 1099, 1101, 3, 84, 42, 0, 1100, 1098, 1, 0, 0, 0, 1101, 1104, 1, 0,
		0, 0, 1102, 1100, 1, 0, 0, 0, 1102, 1103, 1, 0, 0, 0, 1103, 1105, 1, 0,
		0, 0, 1104, 1102, 1, 0, 0, 0, 1105, 1106, 5, 1132, 0, 0, 1106, 39, 1, 0,
		0, 0, 1107, 1109, 5, 33, 0, 0, 1108, 1110, 5, 649, 0, 0, 1109, 1108, 1,
		0, 0, 0, 1109, 1110, 1, 0, 0, 0, 1110, 1111, 1, 0, 0, 0, 1111, 1113, 5,
		172, 0, 0, 1112, 1114, 3, 626, 313, 0, 1113, 1112, 1, 0, 0, 0, 1113, 1114,
		1, 0, 0, 0, 1114, 1115, 1, 0, 0, 0, 1115, 1123, 3, 542, 271, 0, 1116, 1117,
		5, 98, 0, 0, 1117, 1124, 3, 542, 271, 0, 1118, 1119, 5, 1131, 0, 0, 1119,
		1120, 5, 98, 0, 0, 1120, 1121, 3, 542, 271, 0, 1121, 1122, 5, 1132, 0,
		0, 1122, 1124, 1, 0, 0, 0, 1123, 1116, 1, 0, 0, 0, 1123, 1118, 1, 0, 0,
		0, 1124, 1186, 1, 0, 0, 0, 1125, 1127, 5, 33, 0, 0, 1126, 1128, 5, 649,
		0, 0, 1127, 1126, 1, 0, 0, 0, 1127, 1128, 1, 0, 0, 0, 1128, 1129, 1, 0,
		0, 0, 1129, 1131, 5, 172, 0, 0, 1130, 1132, 3, 626, 313, 0, 1131, 1130,
		1, 0, 0, 0, 1131, 1132, 1, 0, 0, 0, 1132, 1133, 1, 0, 0, 0, 1133, 1135,
		3, 542, 271, 0, 1134, 1136, 3, 86, 43, 0, 1135, 1134, 1, 0, 0, 0, 1135,
		1136, 1, 0, 0, 0, 1136, 1147, 1, 0, 0, 0, 1137, 1144, 3, 104, 52, 0, 1138,
		1140, 5, 1133, 0, 0, 1139, 1138, 1, 0, 0, 0, 1139, 1140, 1, 0, 0, 0, 1140,
		1141, 1, 0, 0, 0, 1141, 1143, 3, 104, 52, 0, 1142, 1139, 1, 0, 0, 0, 1143,
		1146, 1, 0, 0, 0, 1144, 1142, 1, 0, 0, 0, 1144, 1145, 1, 0, 0, 0, 1145,
		1148, 1, 0, 0, 0, 1146, 1144, 1, 0, 0, 0, 1147, 1137, 1, 0, 0, 0, 1147,
		1148, 1, 0, 0, 0, 1148, 1150, 1, 0, 0, 0, 1149, 1151, 3, 110, 55, 0, 1150,
		1149, 1, 0, 0, 0, 1150, 1151, 1, 0, 0, 0, 1151, 1153, 1, 0, 0, 0, 1152,
		1154, 7, 6, 0, 0, 1153, 1152, 1, 0, 0, 0, 1153, 1154, 1, 0, 0, 0, 1154,
		1156, 1, 0, 0, 0, 1155, 1157, 5, 12, 0, 0, 1156, 1155, 1, 0, 0, 0, 1156,
		1157, 1, 0, 0, 0, 1157, 1158, 1, 0, 0, 0, 1158, 1159, 3, 196, 98, 0, 1159,
		1186, 1, 0, 0, 0, 1160, 1162, 5, 33, 0, 0, 1161, 1163, 5, 649, 0, 0, 1162,
		1161, 1, 0, 0, 0, 1162, 1163, 1, 0, 0, 0, 1163, 1164, 1, 0, 0, 0, 1164,
		1166, 5, 172, 0, 0, 1165, 1167, 3, 626, 313, 0, 1166, 1165, 1, 0, 0, 0,
		1166, 1167, 1, 0, 0, 0, 1167, 1168, 1, 0, 0, 0, 1168, 1169, 3, 542, 271,
		0, 1169, 1180, 3, 86, 43, 0, 1170, 1177, 3, 104, 52, 0, 1171, 1173, 5,
		1133, 0, 0, 1172, 1171, 1, 0, 0, 0, 1172, 1173, 1, 0, 0, 0, 1173, 1174,
		1, 0, 0, 0, 1174, 1176, 3, 104, 52, 0, 1175, 1172, 1, 0, 0, 0, 1176, 1179,
		1, 0, 0, 0, 1177, 1175, 1, 0, 0, 0, 1177, 1178, 1, 0, 0, 0, 1178, 1181,
		1, 0, 0, 0, 1179, 1177, 1, 0, 0, 0, 1180, 1170, 1, 0, 0, 0, 1180, 1181,
		1, 0, 0, 0, 1181, 1183, 1, 0, 0, 0, 1182, 1184, 3, 110, 55, 0, 1183, 1182,
		1, 0, 0, 0, 1183, 1184, 1, 0, 0, 0, 1184, 1186, 1, 0, 0, 0, 1185, 1107,
		1, 0, 0, 0, 1185, 1125, 1, 0, 0, 0, 1185, 1160, 1, 0, 0, 0, 1186, 41, 1,
		0, 0, 0, 1187, 1188, 5, 33, 0, 0, 1188, 1189, 5, 647, 0, 0, 1189, 1190,
		3, 568, 284, 0, 1190, 1191, 5, 5, 0, 0, 1191, 1192, 5, 389, 0, 0, 1192,
		1196, 5, 1146, 0, 0, 1193, 1194, 5, 428, 0, 0, 1194, 1195, 5, 1122, 0,
		0, 1195, 1197, 3, 576, 288, 0, 1196, 1193, 1, 0, 0, 0, 1196, 1197, 1, 0,
		0, 0, 1197, 1203, 1, 0, 0, 0, 1198, 1200, 5, 409, 0, 0, 1199, 1201, 5,
		1122, 0, 0, 1200, 1199, 1, 0, 0, 0, 1200, 1201, 1, 0, 0, 0, 1201, 1202,
		1, 0, 0, 0, 1202, 1204, 3, 558, 279, 0, 1203, 1198, 1, 0, 0, 0, 1203, 1204,
		1, 0, 0, 0, 1204, 43, 1, 0, 0, 0, 1205, 1206, 5, 33, 0, 0, 1206, 1207,
		5, 647, 0, 0, 1207, 1208, 3, 568, 284, 0, 1208, 1209, 5, 5, 0, 0, 1209,
		1210, 5, 389, 0, 0, 1210, 1211, 5, 1146, 0, 0, 1211, 1212, 5, 186, 0, 0,
		1212, 1213, 5, 475, 0, 0, 1213, 1214, 5, 73, 0, 0, 1214, 1220, 3, 568,
		284, 0, 1215, 1217, 5, 423, 0, 0, 1216, 1218, 5, 1122, 0, 0, 1217, 1216,
		1, 0, 0, 0, 1217, 1218, 1, 0, 0, 0, 1218, 1219, 1, 0, 0, 0, 1219, 1221,
		3, 576, 288, 0, 1220, 1215, 1, 0, 0, 0, 1220, 1221, 1, 0, 0, 0, 1221, 1227,
		1, 0, 0, 0, 1222, 1224, 5, 453, 0, 0, 1223, 1225, 5, 1122, 0, 0, 1224,
		1223, 1, 0, 0, 0, 1224, 1225, 1, 0, 0, 0, 1225, 1226, 1, 0, 0, 0, 1226,
		1228, 3, 576, 288, 0, 1227, 1222, 1, 0, 0, 0, 1227, 1228, 1, 0, 0, 0, 1228,
		1234, 1, 0, 0, 0, 1229, 1231, 5, 341, 0, 0, 1230, 1232, 5, 1122, 0, 0,
		1231, 1230, 1, 0, 0, 0, 1231, 1232, 1, 0, 0, 0, 1232, 1233, 1, 0, 0, 0,
		1233, 1235, 3, 576, 288, 0, 1234, 1229, 1, 0, 0, 0, 1234, 1235, 1, 0, 0,
		0, 1235, 1241, 1, 0, 0, 0, 1236, 1238, 5, 501, 0, 0, 1237, 1239, 5, 1122,
		0, 0, 1238, 1237, 1, 0, 0, 0, 1238, 1239, 1, 0, 0, 0, 1239, 1240, 1, 0,
		0, 0, 1240, 1242, 3, 576, 288, 0, 1241, 1236, 1, 0, 0, 0, 1241, 1242, 1,
		0, 0, 0, 1242, 1248, 1, 0, 0, 0, 1243, 1245, 5, 528, 0, 0, 1244, 1246,
		5, 1122, 0, 0, 1245, 1244, 1, 0, 0, 0, 1245, 1246, 1, 0, 0, 0, 1246, 1247,
		1, 0, 0, 0, 1247, 1249, 3, 568, 284, 0, 1248, 1243, 1, 0, 0, 0, 1248, 1249,
		1, 0, 0, 0, 1249, 1251, 1, 0, 0, 0, 1250, 1252, 5, 674, 0, 0, 1251, 1250,
		1, 0, 0, 0, 1251, 1252, 1, 0, 0, 0, 1252, 1258, 1, 0, 0, 0, 1253, 1255,
		5, 368, 0, 0, 1254, 1256, 5, 1122, 0, 0, 1255, 1254, 1, 0, 0, 0, 1255,
		1256, 1, 0, 0, 0, 1256, 1257, 1, 0, 0, 0, 1257, 1259, 5, 1146, 0, 0, 1258,
		1253, 1, 0, 0, 0, 1258, 1259, 1, 0, 0, 0, 1259, 1260, 1, 0, 0, 0, 1260,
		1262, 5, 409, 0, 0, 1261, 1263, 5, 1122, 0, 0, 1262, 1261, 1, 0, 0, 0,
		1262, 1263, 1, 0, 0, 0, 1263, 1264, 1, 0, 0, 0, 1264, 1265, 3, 558, 279,
		0, 1265, 45, 1, 0, 0, 0, 1266, 1268, 5, 33, 0, 0, 1267, 1269, 3, 62, 31,
		0, 1268, 1267, 1, 0, 0, 0, 1268, 1269, 1, 0, 0, 0, 1269, 1270, 1, 0, 0,
		0, 1270, 1271, 5, 177, 0, 0, 1271, 1272, 3, 540, 270, 0, 1272, 1273, 7,
		7, 0, 0, 1273, 1274, 7, 8, 0, 0, 1274, 1275, 5, 118, 0, 0, 1275, 1276,
		3, 542, 271, 0, 1276, 1277, 5, 65, 0, 0, 1277, 1278, 5, 52, 0, 0, 1278,
		1281, 5, 600, 0, 0, 1279, 1280, 7, 9, 0, 0, 1280, 1282, 3, 540, 270, 0,
		1281, 1279, 1, 0, 0, 0, 1281, 1282, 1, 0, 0, 0, 1282, 1283, 1, 0, 0, 0,
		1283, 1284, 3, 382, 191, 0, 1284, 47, 1, 0, 0, 0, 1285, 1287, 5, 192, 0,
		0, 1286, 1288, 5, 571, 0, 0, 1287, 1286, 1, 0, 0, 0, 1287, 1288, 1, 0,
		0, 0, 1288, 1289, 1, 0, 0, 0, 1289, 1290, 3, 50, 25, 0, 1290, 49, 1, 0,
		0, 0, 1291, 1303, 3, 52, 26, 0, 1292, 1293, 5, 1131, 0, 0, 1293, 1298,
		3, 54, 27, 0, 1294, 1295, 5, 1133, 0, 0, 1295, 1297, 3, 54, 27, 0, 1296,
		1294, 1, 0, 0, 0, 1297, 1300, 1, 0, 0, 0, 1298, 1296, 1, 0, 0, 0, 1298,
		1299, 1, 0, 0, 0, 1299, 1301, 1, 0, 0, 0, 1300, 1298, 1, 0, 0, 0, 1301,
		1302, 5, 1132, 0, 0, 1302, 1304, 1, 0, 0, 0, 1303, 1292, 1, 0, 0, 0, 1303,
		1304, 1, 0, 0, 0, 1304, 1305, 1, 0, 0, 0, 1305, 1306, 5, 12, 0, 0, 1306,
		1307, 5, 1131, 0, 0, 1307, 1308, 3, 10, 5, 0, 1308, 1311, 5, 1132, 0, 0,
		1309, 1310, 5, 1133, 0, 0, 1310, 1312, 3, 50, 25, 0, 1311, 1309, 1, 0,
		0, 0, 1311, 1312, 1, 0, 0, 0, 1312, 51, 1, 0, 0, 0, 1313, 1314, 3, 568,
		284, 0, 1314, 53, 1, 0, 0, 0, 1315, 1316, 3, 568, 284, 0, 1316, 55, 1,
		0, 0, 0, 1317, 1319, 5, 33, 0, 0, 1318, 1320, 3, 628, 314, 0, 1319, 1318,
		1, 0, 0, 0, 1319, 1320, 1, 0, 0, 0, 1320, 1324, 1, 0, 0, 0, 1321, 1322,
		5, 336, 0, 0, 1322, 1323, 5, 1122, 0, 0, 1323, 1325, 7, 10, 0, 0, 1324,
		1321, 1, 0, 0, 0, 1324, 1325, 1, 0, 0, 0, 1325, 1327, 1, 0, 0, 0, 1326,
		1328, 3, 62, 31, 0, 1327, 1326, 1, 0, 0, 0, 1327, 1328, 1, 0, 0, 0, 1328,
		1332, 1, 0, 0, 0, 1329, 1330, 5, 160, 0, 0, 1330, 1331, 5, 606, 0, 0, 1331,
		1333, 7, 11, 0, 0, 1332, 1329, 1, 0, 0, 0, 1332, 1333, 1, 0, 0, 0, 1333,
		1334, 1, 0, 0, 0, 1334, 1335, 5, 671, 0, 0, 1335, 1340, 3, 540, 270, 0,
		1336, 1337, 5, 1131, 0, 0, 1337, 1338, 3, 600, 300, 0, 1338, 1339, 5, 1132,
		0, 0, 1339, 1341, 1, 0, 0, 0, 1340, 1336, 1, 0, 0, 0, 1340, 1341, 1, 0,
		0, 0, 1341, 1342, 1, 0, 0, 0, 1342, 1362, 5, 12, 0, 0, 1343, 1345, 5, 1131,
		0, 0, 1344, 1346, 3, 48, 24, 0, 1345, 1344, 1, 0, 0, 0, 1345, 1346, 1,
		0, 0, 0, 1346, 1347, 1, 0, 0, 0, 1347, 1348, 3, 196, 98, 0, 1348, 1349,
		5, 1132, 0, 0, 1349, 1363, 1, 0, 0, 0, 1350, 1352, 3, 48, 24, 0, 1351,
		1350, 1, 0, 0, 0, 1351, 1352, 1, 0, 0, 0, 1352, 1353, 1, 0, 0, 0, 1353,
		1360, 3, 196, 98, 0, 1354, 1356, 5, 192, 0, 0, 1355, 1357, 7, 12, 0, 0,
		1356, 1355, 1, 0, 0, 0, 1356, 1357, 1, 0, 0, 0, 1357, 1358, 1, 0, 0, 0,
		1358, 1359, 5, 26, 0, 0, 1359, 1361, 5, 120, 0, 0, 1360, 1354, 1, 0, 0,
		0, 1360, 1361, 1, 0, 0, 0, 1361, 1363, 1, 0, 0, 0, 1362, 1343, 1, 0, 0,
		0, 1362, 1351, 1, 0, 0, 0, 1363, 57, 1, 0, 0, 0, 1364, 1366, 5, 42, 0,
		0, 1365, 1364, 1, 0, 0, 0, 1365, 1366, 1, 0, 0, 0, 1366, 1367, 1, 0, 0,
		0, 1367, 1369, 3, 60, 30, 0, 1368, 1370, 5, 1122, 0, 0, 1369, 1368, 1,
		0, 0, 0, 1369, 1370, 1, 0, 0, 0, 1370, 1373, 1, 0, 0, 0, 1371, 1374, 3,
		554, 277, 0, 1372, 1374, 5, 42, 0, 0, 1373, 1371, 1, 0, 0, 0, 1373, 1372,
		1, 0, 0, 0, 1374, 1398, 1, 0, 0, 0, 1375, 1377, 5, 42, 0, 0, 1376, 1375,
		1, 0, 0, 0, 1376, 1377, 1, 0, 0, 0, 1377, 1378, 1, 0, 0, 0, 1378, 1380,
		5, 27, 0, 0, 1379, 1381, 5, 1122, 0, 0, 1380, 1379, 1, 0, 0, 0, 1380, 1381,
		1, 0, 0, 0, 1381, 1382, 1, 0, 0, 0, 1382, 1398, 3, 556, 278, 0, 1383, 1385,
		5, 42, 0, 0, 1384, 1383, 1, 0, 0, 0, 1384, 1385, 1, 0, 0, 0, 1385, 1386,
		1, 0, 0, 0, 1386, 1388, 5, 405, 0, 0, 1387, 1389, 5, 1122, 0, 0, 1388,
		1387, 1, 0, 0, 0, 1388, 1389, 1, 0, 0, 0, 1389, 1390, 1, 0, 0, 0, 1390,
		1398, 5, 1146, 0, 0, 1391, 1392, 5, 134, 0, 0, 1392, 1394, 5, 538, 0, 0,
		1393, 1395, 5, 1122, 0, 0, 1394, 1393, 1, 0, 0, 0, 1394, 1395, 1, 0, 0,
		0, 1395, 1396, 1, 0, 0, 0, 1396, 1398, 7, 13, 0, 0, 1397, 1365, 1, 0, 0,
		0, 1397, 1376, 1, 0, 0, 0, 1397, 1384, 1, 0, 0, 0, 1397, 1391, 1, 0, 0,
		0, 1398, 59, 1, 0, 0, 0, 1399, 1400, 5, 25, 0, 0, 1400, 1405, 5, 153, 0,
		0, 1401, 1405, 5, 840, 0, 0, 1402, 1403, 5, 222, 0, 0, 1403, 1405, 5, 153,
		0, 0, 1404, 1399, 1, 0, 0, 0, 1404, 1401, 1, 0, 0, 0, 1404, 1402, 1, 0,
		0, 0, 1405, 61, 1, 0, 0, 0, 1406, 1407, 5, 392, 0, 0, 1407, 1414, 5, 1122,
		0, 0, 1408, 1415, 3, 550, 275, 0, 1409, 1412, 5, 37, 0, 0, 1410, 1411,
		5, 1131, 0, 0, 1411, 1413, 5, 1132, 0, 0, 1412, 1410, 1, 0, 0, 0, 1412,
		1413, 1, 0, 0, 0, 1413, 1415, 1, 0, 0, 0, 1414, 1408, 1, 0, 0, 0, 1414,
		1409, 1, 0, 0, 0, 1415, 63, 1, 0, 0, 0, 1416, 1417, 5, 338, 0, 0, 1417,
		1421, 3, 66, 33, 0, 1418, 1420, 3, 68, 34, 0, 1419, 1418, 1, 0, 0, 0, 1420,
		1423, 1, 0, 0, 0, 1421, 1419, 1, 0, 0, 0, 1421, 1422, 1, 0, 0, 0, 1422,
		1451, 1, 0, 0, 0, 1423, 1421, 1, 0, 0, 0, 1424, 1427, 5, 417, 0, 0, 1425,
		1428, 3, 574, 287, 0, 1426, 1428, 3, 672, 336, 0, 1427, 1425, 1, 0, 0,
		0, 1427, 1426, 1, 0, 0, 0, 1428, 1429, 1, 0, 0, 0, 1429, 1438, 3, 70, 35,
		0, 1430, 1431, 5, 630, 0, 0, 1431, 1435, 3, 66, 33, 0, 1432, 1434, 3, 68,
		34, 0, 1433, 1432, 1, 0, 0, 0, 1434, 1437, 1, 0, 0, 0, 1435, 1433, 1, 0,
		0, 0, 1435, 1436, 1, 0, 0, 0, 1436, 1439, 1, 0, 0, 0, 1437, 1435, 1, 0,
		0, 0, 1438, 1430, 1, 0, 0, 0, 1438, 1439, 1, 0, 0, 0, 1439, 1448, 1, 0,
		0, 0, 1440, 1441, 5, 408, 0, 0, 1441, 1445, 3, 66, 33, 0, 1442, 1444, 3,
		68, 34, 0, 1443, 1442, 1, 0, 0, 0, 1444, 1447, 1, 0, 0, 0, 1445, 1443,
		1, 0, 0, 0, 1445, 1446, 1, 0, 0, 0, 1446, 1449, 1, 0, 0, 0, 1447, 1445,
		1, 0, 0, 0, 1448, 1440, 1, 0, 0, 0, 1448, 1449, 1, 0, 0, 0, 1449, 1451,
		1, 0, 0, 0, 1450, 1416, 1, 0, 0, 0, 1450, 1424, 1, 0, 0, 0, 1451, 65, 1,
		0, 0, 0, 1452, 1457, 5, 315, 0, 0, 1453, 1457, 3, 578, 289, 0, 1454, 1457,
		3, 574, 287, 0, 1455, 1457, 3, 672, 336, 0, 1456, 1452, 1, 0, 0, 0, 1456,
		1453, 1, 0, 0, 0, 1456, 1454, 1, 0, 0, 0, 1456, 1455, 1, 0, 0, 0, 1457,
		67, 1, 0, 0, 0, 1458, 1459, 5, 1118, 0, 0, 1459, 1462, 5, 86, 0, 0, 1460,
		1463, 3, 574, 287, 0, 1461, 1463, 3, 672, 336, 0, 1462, 1460, 1, 0, 0,
		0, 1462, 1461, 1, 0, 0, 0, 1463, 1464, 1, 0, 0, 0, 1464, 1465, 3, 70, 35,
		0, 1465, 69, 1, 0, 0, 0, 1466, 1480, 3, 696, 348, 0, 1467, 1480, 5, 221,
		0, 0, 1468, 1480, 5, 240, 0, 0, 1469, 1480, 5, 241, 0, 0, 1470, 1480, 5,
		242, 0, 0, 1471, 1480, 5, 243, 0, 0, 1472, 1480, 5, 244, 0, 0, 1473, 1480,
		5, 245, 0, 0, 1474, 1480, 5, 246, 0, 0, 1475, 1480, 5, 247, 0, 0, 1476,
		1480, 5, 248, 0, 0, 1477, 1480, 5, 249, 0, 0, 1478, 1480, 5, 250, 0, 0,
		1479, 1466, 1, 0, 0, 0, 1479, 1467, 1, 0, 0, 0, 1479, 1468, 1, 0, 0, 0,
		1479, 1469, 1, 0, 0, 0, 1479, 1470, 1, 0, 0, 0, 1479, 1471, 1, 0, 0, 0,
		1479, 1472, 1, 0, 0, 0, 1479, 1473, 1, 0, 0, 0, 1479, 1474, 1, 0, 0, 0,
		1479, 1475, 1, 0, 0, 0, 1479, 1476, 1, 0, 0, 0, 1479, 1477, 1, 0, 0, 0,
		1479, 1478, 1, 0, 0, 0, 1480, 71, 1, 0, 0, 0, 1481, 1487, 5, 403, 0, 0,
		1482, 1487, 5, 396, 0, 0, 1483, 1484, 5, 396, 0, 0, 1484, 1485, 5, 118,
		0, 0, 1485, 1487, 5, 614, 0, 0, 1486, 1481, 1, 0, 0, 0, 1486, 1482, 1,
		0, 0, 0, 1486, 1483, 1, 0, 0, 0, 1487, 73, 1, 0, 0, 0, 1488, 1489, 5, 187,
		0, 0, 1489, 1490, 7, 14, 0, 0, 1490, 75, 1, 0, 0, 0, 1491, 1493, 5, 467,
		0, 0, 1492, 1494, 5, 1122, 0, 0, 1493, 1492, 1, 0, 0, 0, 1493, 1494, 1,
		0, 0, 0, 1494, 1495, 1, 0, 0, 0, 1495, 1514, 3, 576, 288, 0, 1496, 1514,
		3, 74, 37, 0, 1497, 1498, 5, 192, 0, 0, 1498, 1499, 5, 547, 0, 0, 1499,
		1514, 3, 568, 284, 0, 1500, 1501, 5, 368, 0, 0, 1501, 1514, 5, 1146, 0,
		0, 1502, 1514, 7, 15, 0, 0, 1503, 1505, 5, 874, 0, 0, 1504, 1506, 5, 1122,
		0, 0, 1505, 1504, 1, 0, 0, 0, 1505, 1506, 1, 0, 0, 0, 1506, 1507, 1, 0,
		0, 0, 1507, 1514, 5, 1146, 0, 0, 1508, 1510, 5, 998, 0, 0, 1509, 1511,
		5, 1122, 0, 0, 1510, 1509, 1, 0, 0, 0, 1510, 1511, 1, 0, 0, 0, 1511, 1512,
		1, 0, 0, 0, 1512, 1514, 5, 1146, 0, 0, 1513, 1491, 1, 0, 0, 0, 1513, 1496,
		1, 0, 0, 0, 1513, 1497, 1, 0, 0, 0, 1513, 1500, 1, 0, 0, 0, 1513, 1502,
		1, 0, 0, 0, 1513, 1503, 1, 0, 0, 0, 1513, 1508, 1, 0, 0, 0, 1514, 77, 1,
		0, 0, 0, 1515, 1517, 7, 16, 0, 0, 1516, 1515, 1, 0, 0, 0, 1516, 1517, 1,
		0, 0, 0, 1517, 1518, 1, 0, 0, 0, 1518, 1519, 3, 568, 284, 0, 1519, 1520,
		3, 588, 294, 0, 1520, 79, 1, 0, 0, 0, 1521, 1522, 3, 568, 284, 0, 1522,
		1523, 3, 588, 294, 0, 1523, 81, 1, 0, 0, 0, 1524, 1525, 5, 368, 0, 0, 1525,
		1548, 5, 1146, 0, 0, 1526, 1527, 5, 468, 0, 0, 1527, 1548, 5, 160, 0, 0,
		1528, 1530, 5, 114, 0, 0, 1529, 1528, 1, 0, 0, 0, 1529, 1530, 1, 0, 0,
		0, 1530, 1531, 1, 0, 0, 0, 1531, 1548, 5, 47, 0, 0, 1532, 1533, 5, 381,
		0, 0, 1533, 1543, 5, 160, 0, 0, 1534, 1535, 5, 521, 0, 0, 1535, 1543, 5,
		160, 0, 0, 1536, 1537, 5, 135, 0, 0, 1537, 1538, 5, 160, 0, 0, 1538, 1543,
		5, 388, 0, 0, 1539, 1540, 5, 112, 0, 0, 1540, 1541, 5, 160, 0, 0, 1541,
		1543, 5, 388, 0, 0, 1542, 1532, 1, 0, 0, 0, 1542, 1534, 1, 0, 0, 0, 1542,
		1536, 1, 0, 0, 0, 1542, 1539, 1, 0, 0, 0, 1543, 1548, 1, 0, 0, 0, 1544,
		1545, 5, 160, 0, 0, 1545, 1546, 5, 606, 0, 0, 1546, 1548, 7, 11, 0, 0,
		1547, 1524, 1, 0, 0, 0, 1547, 1526, 1, 0, 0, 0, 1547, 1529, 1, 0, 0, 0,
		1547, 1542, 1, 0, 0, 0, 1547, 1544, 1, 0, 0, 0, 1548, 83, 1, 0, 0, 0, 1549,
		1550, 5, 446, 0, 0, 1550, 1564, 5, 1146, 0, 0, 1551, 1552, 5, 39, 0, 0,
		1552, 1564, 5, 1146, 0, 0, 1553, 1554, 5, 665, 0, 0, 1554, 1564, 5, 1146,
		0, 0, 1555, 1556, 5, 551, 0, 0, 1556, 1564, 5, 1146, 0, 0, 1557, 1558,
		5, 617, 0, 0, 1558, 1564, 5, 1146, 0, 0, 1559, 1560, 5, 542, 0, 0, 1560,
		1564, 5, 1146, 0, 0, 1561, 1562, 5, 557, 0, 0, 1562, 1564, 3, 574, 287,
		0, 1563, 1549, 1, 0, 0, 0, 1563, 1551, 1, 0, 0, 0, 1563, 1553, 1, 0, 0,
		0, 1563, 1555, 1, 0, 0, 0, 1563, 1557, 1, 0, 0, 0, 1563, 1559, 1, 0, 0,
		0, 1563, 1561, 1, 0, 0, 0, 1564, 85, 1, 0, 0, 0, 1565, 1566, 5, 1131, 0,
		0, 1566, 1571, 3, 88, 44, 0, 1567, 1568, 5, 1133, 0, 0, 1568, 1570, 3,
		88, 44, 0, 1569, 1567, 1, 0, 0, 0, 1570, 1573, 1, 0, 0, 0, 1571, 1569,
		1, 0, 0, 0, 1571, 1572, 1, 0, 0, 0, 1572, 1574, 1, 0, 0, 0, 1573, 1571,
		1, 0, 0, 0, 1574, 1575, 5, 1132, 0, 0, 1575, 87, 1, 0, 0, 0, 1576, 1577,
		3, 546, 273, 0, 1577, 1578, 3, 90, 45, 0, 1578, 1588, 1, 0, 0, 0, 1579,
		1581, 3, 94, 47, 0, 1580, 1582, 5, 114, 0, 0, 1581, 1580, 1, 0, 0, 0, 1581,
		1582, 1, 0, 0, 0, 1582, 1584, 1, 0, 0, 0, 1583, 1585, 5, 57, 0, 0, 1584,
		1583, 1, 0, 0, 0, 1584, 1585, 1, 0, 0, 0, 1585, 1588, 1, 0, 0, 0, 1586,
		1588, 3, 102, 51, 0, 1587, 1576, 1, 0, 0, 0, 1587, 1579, 1, 0, 0, 0, 1587,
		1586, 1, 0, 0, 0, 1588, 89, 1, 0, 0, 0, 1589, 1593, 3, 588, 294, 0, 1590,
		1592, 3, 92, 46, 0, 1591, 1590, 1, 0, 0, 0, 1592, 1595, 1, 0, 0, 0, 1593,
		1591, 1, 0, 0, 0, 1593, 1594, 1, 0, 0, 0, 1594, 1597, 1, 0, 0, 0, 1595,
		1593, 1, 0, 0, 0, 1596, 1598, 5, 114, 0, 0, 1597, 1596, 1, 0, 0, 0, 1597,
		1598, 1, 0, 0, 0, 1598, 1600, 1, 0, 0, 0, 1599, 1601, 5, 57, 0, 0, 1600,
		1599, 1, 0, 0, 0, 1600, 1601, 1, 0, 0, 0, 1601, 91, 1, 0, 0, 0, 1602, 1656,
		3, 584, 292, 0, 1603, 1604, 5, 42, 0, 0, 1604, 1656, 3, 618, 309, 0, 1605,
		1656, 5, 673, 0, 0, 1606, 1656, 5, 459, 0, 0, 1607, 1612, 5, 342, 0, 0,
		1608, 1609, 5, 118, 0, 0, 1609, 1610, 5, 184, 0, 0, 1610, 1612, 3, 620,
		310, 0, 1611, 1607, 1, 0, 0, 0, 1611, 1608, 1, 0, 0, 0, 1612, 1656, 1,
		0, 0, 0, 1613, 1615, 5, 130, 0, 0, 1614, 1613, 1, 0, 0, 0, 1614, 1615,
		1, 0, 0, 0, 1615, 1616, 1, 0, 0, 0, 1616, 1656, 5, 91, 0, 0, 1617, 1619,
		5, 181, 0, 0, 1618, 1620, 5, 91, 0, 0, 1619, 1618, 1, 0, 0, 0, 1619, 1620,
		1, 0, 0, 0, 1620, 1656, 1, 0, 0, 0, 1621, 1622, 5, 368, 0, 0, 1622, 1656,
		5, 1146, 0, 0, 1623, 1624, 5, 366, 0, 0, 1624, 1656, 7, 17, 0, 0, 1625,
		1626, 5, 636, 0, 0, 1626, 1656, 7, 18, 0, 0, 1627, 1656, 3, 96, 48, 0,
		1628, 1629, 5, 27, 0, 0, 1629, 1656, 3, 556, 278, 0, 1630, 1631, 5, 70,
		0, 0, 1631, 1633, 5, 8, 0, 0, 1632, 1630, 1, 0, 0, 0, 1632, 1633, 1, 0,
		0, 0, 1633, 1634, 1, 0, 0, 0, 1634, 1635, 5, 12, 0, 0, 1635, 1636, 5, 1131,
		0, 0, 1636, 1637, 3, 672, 336, 0, 1637, 1639, 5, 1132, 0, 0, 1638, 1640,
		7, 19, 0, 0, 1639, 1638, 1, 0, 0, 0, 1639, 1640, 1, 0, 0, 0, 1640, 1656,
		1, 0, 0, 0, 1641, 1642, 5, 239, 0, 0, 1642, 1643, 5, 42, 0, 0, 1643, 1656,
		5, 669, 0, 0, 1644, 1646, 5, 30, 0, 0, 1645, 1647, 3, 568, 284, 0, 1646,
		1645, 1, 0, 0, 0, 1646, 1647, 1, 0, 0, 0, 1647, 1649, 1, 0, 0, 0, 1648,
		1644, 1, 0, 0, 0, 1648, 1649, 1, 0, 0, 0, 1649, 1650, 1, 0, 0, 0, 1650,
		1651, 5, 26, 0, 0, 1651, 1652, 5, 1131, 0, 0, 1652, 1653, 3, 672, 336,
		0, 1653, 1654, 5, 1132, 0, 0, 1654, 1656, 1, 0, 0, 0, 1655, 1602, 1, 0,
		0, 0, 1655, 1603, 1, 0, 0, 0, 1655, 1605, 1, 0, 0, 0, 1655, 1606, 1, 0,
		0, 0, 1655, 1611, 1, 0, 0, 0, 1655, 1614, 1, 0, 0, 0, 1655, 1617, 1, 0,
		0, 0, 1655, 1621, 1, 0, 0, 0, 1655, 1623, 1, 0, 0, 0, 1655, 1625, 1, 0,
		0, 0, 1655, 1627, 1, 0, 0, 0, 1655, 1628, 1, 0, 0, 0, 1655, 1632, 1, 0,
		0, 0, 1655, 1641, 1, 0, 0, 0, 1655, 1648, 1, 0, 0, 0, 1656, 93, 1, 0, 0,
		0, 1657, 1659, 5, 30, 0, 0, 1658, 1660, 3, 568, 284, 0, 1659, 1658, 1,
		0, 0, 0, 1659, 1660, 1, 0, 0, 0, 1660, 1662, 1, 0, 0, 0, 1661, 1657, 1,
		0, 0, 0, 1661, 1662, 1, 0, 0, 0, 1662, 1663, 1, 0, 0, 0, 1663, 1664, 5,
		130, 0, 0, 1664, 1666, 5, 91, 0, 0, 1665, 1667, 3, 568, 284, 0, 1666, 1665,
		1, 0, 0, 0, 1666, 1667, 1, 0, 0, 0, 1667, 1669, 1, 0, 0, 0, 1668, 1670,
		3, 74, 37, 0, 1669, 1668, 1, 0, 0, 0, 1669, 1670, 1, 0, 0, 0, 1670, 1671,
		1, 0, 0, 0, 1671, 1675, 3, 606, 303, 0, 1672, 1674, 3, 76, 38, 0, 1673,
		1672, 1, 0, 0, 0, 1674, 1677, 1, 0, 0, 0, 1675, 1673, 1, 0, 0, 0, 1675,
		1676, 1, 0, 0, 0, 1676, 1727, 1, 0, 0, 0, 1677, 1675, 1, 0, 0, 0, 1678,
		1680, 5, 30, 0, 0, 1679, 1681, 3, 568, 284, 0, 1680, 1679, 1, 0, 0, 0,
		1680, 1681, 1, 0, 0, 0, 1681, 1683, 1, 0, 0, 0, 1682, 1678, 1, 0, 0, 0,
		1682, 1683, 1, 0, 0, 0, 1683, 1684, 1, 0, 0, 0, 1684, 1686, 5, 181, 0,
		0, 1685, 1687, 7, 20, 0, 0, 1686, 1685, 1, 0, 0, 0, 1686, 1687, 1, 0, 0,
		0, 1687, 1689, 1, 0, 0, 0, 1688, 1690, 3, 568, 284, 0, 1689, 1688, 1, 0,
		0, 0, 1689, 1690, 1, 0, 0, 0, 1690, 1692, 1, 0, 0, 0, 1691, 1693, 3, 74,
		37, 0, 1692, 1691, 1, 0, 0, 0, 1692, 1693, 1, 0, 0, 0, 1693, 1694, 1, 0,
		0, 0, 1694, 1698, 3, 606, 303, 0, 1695, 1697, 3, 76, 38, 0, 1696, 1695,
		1, 0, 0, 0, 1697, 1700, 1, 0, 0, 0, 1698, 1696, 1, 0, 0, 0, 1698, 1699,
		1, 0, 0, 0, 1699, 1727, 1, 0, 0, 0, 1700, 1698, 1, 0, 0, 0, 1701, 1703,
		5, 30, 0, 0, 1702, 1704, 3, 568, 284, 0, 1703, 1702, 1, 0, 0, 0, 1703,
		1704, 1, 0, 0, 0, 1704, 1706, 1, 0, 0, 0, 1705, 1701, 1, 0, 0, 0, 1705,
		1706, 1, 0, 0, 0, 1706, 1707, 1, 0, 0, 0, 1707, 1708, 5, 67, 0, 0, 1708,
		1710, 5, 91, 0, 0, 1709, 1711, 3, 568, 284, 0, 1710, 1709, 1, 0, 0, 0,
		1710, 1711, 1, 0, 0, 0, 1711, 1712, 1, 0, 0, 0, 1712, 1713, 3, 606, 303,
		0, 1713, 1714, 3, 96, 48, 0, 1714, 1727, 1, 0, 0, 0, 1715, 1717, 5, 30,
		0, 0, 1716, 1718, 3, 568, 284, 0, 1717, 1716, 1, 0, 0, 0, 1717, 1718, 1,
		0, 0, 0, 1718, 1720, 1, 0, 0, 0, 1719, 1715, 1, 0, 0, 0, 1719, 1720, 1,
		0, 0, 0, 1720, 1721, 1, 0, 0, 0, 1721, 1722, 5, 26, 0, 0, 1722, 1723, 5,
		1131, 0, 0, 1723, 1724, 3, 672, 336, 0, 1724, 1725, 5, 1132, 0, 0, 1725,
		1727, 1, 0, 0, 0, 1726, 1661, 1, 0, 0, 0, 1726, 1682, 1, 0, 0, 0, 1726,
		1705, 1, 0, 0, 0, 1726, 1719, 1, 0, 0, 0, 1727, 95, 1, 0, 0, 0, 1728, 1729,
		5, 136, 0, 0, 1729, 1731, 3, 542, 271, 0, 1730, 1732, 3, 606, 303, 0, 1731,
		1730, 1, 0, 0, 0, 1731, 1732, 1, 0, 0, 0, 1732, 1735, 1, 0, 0, 0, 1733,
		1734, 5, 109, 0, 0, 1734, 1736, 7, 21, 0, 0, 1735, 1733, 1, 0, 0, 0, 1735,
		1736, 1, 0, 0, 0, 1736, 1738, 1, 0, 0, 0, 1737, 1739, 3, 98, 49, 0, 1738,
		1737, 1, 0, 0, 0, 1738, 1739, 1, 0, 0, 0, 1739, 97, 1, 0, 0, 0, 1740, 1741,
		5, 118, 0, 0, 1741, 1742, 5, 44, 0, 0, 1742, 1746, 3, 100, 50, 0, 1743,
		1744, 5, 118, 0, 0, 1744, 1745, 5, 184, 0, 0, 1745, 1747, 3, 100, 50, 0,
		1746, 1743, 1, 0, 0, 0, 1746, 1747, 1, 0, 0, 0, 1747, 1757, 1, 0, 0, 0,
		1748, 1749, 5, 118, 0, 0, 1749, 1750, 5, 184, 0, 0, 1750, 1754, 3, 100,
		50, 0, 1751, 1752, 5, 118, 0, 0, 1752, 1753, 5, 44, 0, 0, 1753, 1755, 3,
		100, 50, 0, 1754, 1751, 1, 0, 0, 0, 1754, 1755, 1, 0, 0, 0, 1755, 1757,
		1, 0, 0, 0, 1756, 1740, 1, 0, 0, 0, 1756, 1748, 1, 0, 0, 0, 1757, 99, 1,
		0, 0, 0, 1758, 1767, 5, 144, 0, 0, 1759, 1767, 5, 21, 0, 0, 1760, 1761,
		5, 153, 0, 0, 1761, 1767, 5, 116, 0, 0, 1762, 1763, 5, 521, 0, 0, 1763,
		1767, 5, 333, 0, 0, 1764, 1765, 5, 153, 0, 0, 1765, 1767, 5, 42, 0, 0,
		1766, 1758, 1, 0, 0, 0, 1766, 1759, 1, 0, 0, 0, 1766, 1760, 1, 0, 0, 0,
		1766, 1762, 1, 0, 0, 0, 1766, 1764, 1, 0, 0, 0, 1767, 101, 1, 0, 0, 0,
		1768, 1770, 7, 20, 0, 0, 1769, 1771, 3, 568, 284, 0, 1770, 1769, 1, 0,
		0, 0, 1770, 1771, 1, 0, 0, 0, 1771, 1773, 1, 0, 0, 0, 1772, 1774, 3, 74,
		37, 0, 1773, 1772, 1, 0, 0, 0, 1773, 1774, 1, 0, 0, 0, 1774, 1775, 1, 0,
		0, 0, 1775, 1779, 3, 606, 303, 0, 1776, 1778, 3, 76, 38, 0, 1777, 1776,
		1, 0, 0, 0, 1778, 1781, 1, 0, 0, 0, 1779, 1777, 1, 0, 0, 0, 1779, 1780,
		1, 0, 0, 0, 1780, 1797, 1, 0, 0, 0, 1781, 1779, 1, 0, 0, 0, 1782, 1784,
		7, 22, 0, 0, 1783, 1785, 7, 20, 0, 0, 1784, 1783, 1, 0, 0, 0, 1784, 1785,
		1, 0, 0, 0, 1785, 1787, 1, 0, 0, 0, 1786, 1788, 3, 568, 284, 0, 1787, 1786,
		1, 0, 0, 0, 1787, 1788, 1, 0, 0, 0, 1788, 1789, 1, 0, 0, 0, 1789, 1793,
		3, 606, 303, 0, 1790, 1792, 3, 76, 38, 0, 1791, 1790, 1, 0, 0, 0, 1792,
		1795, 1, 0, 0, 0, 1793, 1791, 1, 0, 0, 0, 1793, 1794, 1, 0, 0, 0, 1794,
		1797, 1, 0, 0, 0, 1795, 1793, 1, 0, 0, 0, 1796, 1768, 1, 0, 0, 0, 1796,
		1782, 1, 0, 0, 0, 1797, 103, 1, 0, 0, 0, 1798, 1800, 5, 409, 0, 0, 1799,
		1801, 5, 1122, 0, 0, 1800, 1799, 1, 0, 0, 0, 1800, 1801, 1, 0, 0, 0, 1801,
		1803, 1, 0, 0, 0, 1802, 1804, 3, 558, 279, 0, 1803, 1802, 1, 0, 0, 0, 1803,
		1804, 1, 0, 0, 0, 1804, 1984, 1, 0, 0, 0, 1805, 1807, 5, 874, 0, 0, 1806,
		1808, 5, 1122, 0, 0, 1807, 1806, 1, 0, 0, 0, 1807, 1808, 1, 0, 0, 0, 1808,
		1809, 1, 0, 0, 0, 1809, 1984, 5, 1146, 0, 0, 1810, 1812, 5, 341, 0, 0,
		1811, 1813, 5, 1122, 0, 0, 1812, 1811, 1, 0, 0, 0, 1812, 1813, 1, 0, 0,
		0, 1813, 1814, 1, 0, 0, 0, 1814, 1984, 3, 574, 287, 0, 1815, 1817, 5, 342,
		0, 0, 1816, 1818, 5, 1122, 0, 0, 1817, 1816, 1, 0, 0, 0, 1817, 1818, 1,
		0, 0, 0, 1818, 1819, 1, 0, 0, 0, 1819, 1984, 3, 574, 287, 0, 1820, 1822,
		5, 343, 0, 0, 1821, 1823, 5, 1122, 0, 0, 1822, 1821, 1, 0, 0, 0, 1822,
		1823, 1, 0, 0, 0, 1823, 1824, 1, 0, 0, 0, 1824, 1984, 3, 574, 287, 0, 1825,
		1827, 5, 42, 0, 0, 1826, 1825, 1, 0, 0, 0, 1826, 1827, 1, 0, 0, 0, 1827,
		1828, 1, 0, 0, 0, 1828, 1830, 3, 60, 30, 0, 1829, 1831, 5, 1122, 0, 0,
		1830, 1829, 1, 0, 0, 0, 1830, 1831, 1, 0, 0, 0, 1831, 1834, 1, 0, 0, 0,
		1832, 1835, 3, 554, 277, 0, 1833, 1835, 5, 42, 0, 0, 1834, 1832, 1, 0,
		0, 0, 1834, 1833, 1, 0, 0, 0, 1835, 1984, 1, 0, 0, 0, 1836, 1838, 7, 23,
		0, 0, 1837, 1839, 5, 1122, 0, 0, 1838, 1837, 1, 0, 0, 0, 1838, 1839, 1,
		0, 0, 0, 1839, 1840, 1, 0, 0, 0, 1840, 1984, 7, 24, 0, 0, 1841, 1843, 5,
		42, 0, 0, 1842, 1841, 1, 0, 0, 0, 1842, 1843, 1, 0, 0, 0, 1843, 1844, 1,
		0, 0, 0, 1844, 1846, 5, 27, 0, 0, 1845, 1847, 5, 1122, 0, 0, 1846, 1845,
		1, 0, 0, 0, 1846, 1847, 1, 0, 0, 0, 1847, 1848, 1, 0, 0, 0, 1848, 1984,
		3, 556, 278, 0, 1849, 1851, 5, 368, 0, 0, 1850, 1852, 5, 1122, 0, 0, 1851,
		1850, 1, 0, 0, 0, 1851, 1852, 1, 0, 0, 0, 1852, 1853, 1, 0, 0, 0, 1853,
		1984, 5, 1146, 0, 0, 1854, 1856, 5, 373, 0, 0, 1855, 1857, 5, 1122, 0,
		0, 1856, 1855, 1, 0, 0, 0, 1856, 1857, 1, 0, 0, 0, 1857, 1858, 1, 0, 0,
		0, 1858, 1984, 7, 25, 0, 0, 1859, 1861, 5, 376, 0, 0, 1860, 1862, 5, 1122,
		0, 0, 1861, 1860, 1, 0, 0, 0, 1861, 1862, 1, 0, 0, 0, 1862, 1863, 1, 0,
		0, 0, 1863, 1984, 5, 1146, 0, 0, 1864, 1865, 7, 26, 0, 0, 1865, 1867, 5,
		395, 0, 0, 1866, 1868, 5, 1122, 0, 0, 1867, 1866, 1, 0, 0, 0, 1867, 1868,
		1, 0, 0, 0, 1868, 1869, 1, 0, 0, 0, 1869, 1984, 5, 1146, 0, 0, 1870, 1872,
		5, 393, 0, 0, 1871, 1873, 5, 1122, 0, 0, 1872, 1871, 1, 0, 0, 0, 1872,
		1873, 1, 0, 0, 0, 1873, 1874, 1, 0, 0, 0, 1874, 1984, 7, 24, 0, 0, 1875,
		1877, 5, 405, 0, 0, 1876, 1878, 5, 1122, 0, 0, 1877, 1876, 1, 0, 0, 0,
		1877, 1878, 1, 0, 0, 0, 1878, 1879, 1, 0, 0, 0, 1879, 1984, 5, 1146, 0,
		0, 1880, 1882, 7, 27, 0, 0, 1881, 1883, 5, 1122, 0, 0, 1882, 1881, 1, 0,
		0, 0, 1882, 1883, 1, 0, 0, 0, 1883, 1884, 1, 0, 0, 0, 1884, 1984, 7, 24,
		0, 0, 1885, 1887, 7, 28, 0, 0, 1886, 1888, 5, 1122, 0, 0, 1887, 1886, 1,
		0, 0, 0, 1887, 1888, 1, 0, 0, 0, 1888, 1889, 1, 0, 0, 0, 1889, 1984, 3,
		574, 287, 0, 1890, 1892, 5, 406, 0, 0, 1891, 1893, 5, 1122, 0, 0, 1892,
		1891, 1, 0, 0, 0, 1892, 1893, 1, 0, 0, 0, 1893, 1894, 1, 0, 0, 0, 1894,
		1984, 3, 574, 287, 0, 1895, 1896, 5, 81, 0, 0, 1896, 1898, 5, 395, 0, 0,
		1897, 1899, 5, 1122, 0, 0, 1898, 1897, 1, 0, 0, 0, 1898, 1899, 1, 0, 0,
		0, 1899, 1900, 1, 0, 0, 0, 1900, 1984, 5, 1146, 0, 0, 1901, 1903, 5, 455,
		0, 0, 1902, 1904, 5, 1122, 0, 0, 1903, 1902, 1, 0, 0, 0, 1903, 1904, 1,
		0, 0, 0, 1904, 1905, 1, 0, 0, 0, 1905, 1984, 7, 29, 0, 0, 1906, 1908, 5,
		467, 0, 0, 1907, 1909, 5, 1122, 0, 0, 1908, 1907, 1, 0, 0, 0, 1908, 1909,
		1, 0, 0, 0, 1909, 1910, 1, 0, 0, 0, 1910, 1984, 3, 576, 288, 0, 1911, 1913,
		5, 500, 0, 0, 1912, 1914, 5, 1122, 0, 0, 1913, 1912, 1, 0, 0, 0, 1913,
		1914, 1, 0, 0, 0, 1914, 1915, 1, 0, 0, 0, 1915, 1984, 3, 574, 287, 0, 1916,
		1918, 5, 510, 0, 0, 1917, 1919, 5, 1122, 0, 0, 1918, 1917, 1, 0, 0, 0,
		1918, 1919, 1, 0, 0, 0, 1919, 1920, 1, 0, 0, 0, 1920, 1984, 3, 574, 287,
		0, 1921, 1923, 5, 543, 0, 0, 1922, 1924, 5, 1122, 0, 0, 1923, 1922, 1,
		0, 0, 0, 1923, 1924, 1, 0, 0, 0, 1924, 1925, 1, 0, 0, 0, 1925, 1984, 7,
		13, 0, 0, 1926, 1928, 5, 551, 0, 0, 1927, 1929, 5, 1122, 0, 0, 1928, 1927,
		1, 0, 0, 0, 1928, 1929, 1, 0, 0, 0, 1929, 1930, 1, 0, 0, 0, 1930, 1984,
		5, 1146, 0, 0, 1931, 1933, 5, 602, 0, 0, 1932, 1934, 5, 1122, 0, 0, 1933,
		1932, 1, 0, 0, 0, 1933, 1934, 1, 0, 0, 0, 1934, 1935, 1, 0, 0, 0, 1935,
		1984, 7, 30, 0, 0, 1936, 1937, 5, 629, 0, 0, 1937, 1984, 5, 653, 0, 0,
		1938, 1940, 5, 998, 0, 0, 1939, 1941, 5, 1122, 0, 0, 1940, 1939, 1, 0,
		0, 0, 1940, 1941, 1, 0, 0, 0, 1941, 1942, 1, 0, 0, 0, 1942, 1984, 5, 1146,
		0, 0, 1943, 1945, 5, 631, 0, 0, 1944, 1946, 5, 1122, 0, 0, 1945, 1944,
		1, 0, 0, 0, 1945, 1946, 1, 0, 0, 0, 1946, 1947, 1, 0, 0, 0, 1947, 1984,
		7, 13, 0, 0, 1948, 1950, 5, 632, 0, 0, 1949, 1951, 5, 1122, 0, 0, 1950,
		1949, 1, 0, 0, 0, 1950, 1951, 1, 0, 0, 0, 1951, 1952, 1, 0, 0, 0, 1952,
		1984, 7, 13, 0, 0, 1953, 1955, 5, 633, 0, 0, 1954, 1956, 5, 1122, 0, 0,
		1955, 1954, 1, 0, 0, 0, 1955, 1956, 1, 0, 0, 0, 1956, 1959, 1, 0, 0, 0,
		1957, 1960, 5, 42, 0, 0, 1958, 1960, 3, 574, 287, 0, 1959, 1957, 1, 0,
		0, 0, 1959, 1958, 1, 0, 0, 0, 1960, 1984, 1, 0, 0, 0, 1961, 1962, 5, 647,
		0, 0, 1962, 1964, 3, 568, 284, 0, 1963, 1965, 3, 108, 54, 0, 1964, 1963,
		1, 0, 0, 0, 1964, 1965, 1, 0, 0, 0, 1965, 1984, 1, 0, 0, 0, 1966, 1967,
		5, 648, 0, 0, 1967, 1968, 5, 1122, 0, 0, 1968, 1984, 3, 106, 53, 0, 1969,
		1984, 3, 108, 54, 0, 1970, 1972, 5, 654, 0, 0, 1971, 1973, 5, 1122, 0,
		0, 1972, 1971, 1, 0, 0, 0, 1972, 1973, 1, 0, 0, 0, 1973, 1974, 1, 0, 0,
		0, 1974, 1984, 7, 24, 0, 0, 1975, 1977, 5, 180, 0, 0, 1976, 1978, 5, 1122,
		0, 0, 1977, 1976, 1, 0, 0, 0, 1977, 1978, 1, 0, 0, 0, 1978, 1979, 1, 0,
		0, 0, 1979, 1980, 5, 1131, 0, 0, 1980, 1981, 3, 604, 302, 0, 1981, 1982,
		5, 1132, 0, 0, 1982, 1984, 1, 0, 0, 0, 1983, 1798, 1, 0, 0, 0, 1983, 1805,
		1, 0, 0, 0, 1983, 1810, 1, 0, 0, 0, 1983, 1815, 1, 0, 0, 0, 1983, 1820,
		1, 0, 0, 0, 1983, 1826, 1, 0, 0, 0, 1983, 1836, 1, 0, 0, 0, 1983, 1842,
		1, 0, 0, 0, 1983, 1849, 1, 0, 0, 0, 1983, 1854, 1, 0, 0, 0, 1983, 1859,
		1, 0, 0, 0, 1983, 1864, 1, 0, 0, 0, 1983, 1870, 1, 0, 0, 0, 1983, 1875,
		1, 0, 0, 0, 1983, 1880, 1, 0, 0, 0, 1983, 1885, 1, 0, 0, 0, 1983, 1890,
		1, 0, 0, 0, 1983, 1895, 1, 0, 0, 0, 1983, 1901, 1, 0, 0, 0, 1983, 1906,
		1, 0, 0, 0, 1983, 1911, 1, 0, 0, 0, 1983, 1916, 1, 0, 0, 0, 1983, 1921,
		1, 0, 0, 0, 1983, 1926, 1, 0, 0, 0, 1983, 1931, 1, 0, 0, 0, 1983, 1936,
		1, 0, 0, 0, 1983, 1938, 1, 0, 0, 0, 1983, 1943, 1, 0, 0, 0, 1983, 1948,
		1, 0, 0, 0, 1983, 1953, 1, 0, 0, 0, 1983, 1961, 1, 0, 0, 0, 1983, 1966,
		1, 0, 0, 0, 1983, 1969, 1, 0, 0, 0, 1983, 1970, 1, 0, 0, 0, 1983, 1975,
		1, 0, 0, 0, 1984, 105, 1, 0, 0, 0, 1985, 1986, 7, 31, 0, 0, 1986, 107,
		1, 0, 0, 0, 1987, 1988, 5, 636, 0, 0, 1988, 1989, 7, 18, 0, 0, 1989, 109,
		1, 0, 0, 0, 1990, 1991, 5, 129, 0, 0, 1991, 1992, 5, 19, 0, 0, 1992, 1995,
		3, 112, 56, 0, 1993, 1994, 5, 550, 0, 0, 1994, 1996, 3, 574, 287, 0, 1995,
		1993, 1, 0, 0, 0, 1995, 1996, 1, 0, 0, 0, 1996, 2004, 1, 0, 0, 0, 1997,
		1998, 5, 641, 0, 0, 1998, 1999, 5, 19, 0, 0, 1999, 2002, 3, 114, 57, 0,
		2000, 2001, 5, 642, 0, 0, 2001, 2003, 3, 574, 287, 0, 2002, 2000, 1, 0,
		0, 0, 2002, 2003, 1, 0, 0, 0, 2003, 2005, 1, 0, 0, 0, 2004, 1997, 1, 0,
		0, 0, 2004, 2005, 1, 0, 0, 0, 2005, 2017, 1, 0, 0, 0, 2006, 2007, 5, 1131,
		0, 0, 2007, 2012, 3, 116, 58, 0, 2008, 2009, 5, 1133, 0, 0, 2009, 2011,
		3, 116, 58, 0, 2010, 2008, 1, 0, 0, 0, 2011, 2014, 1, 0, 0, 0, 2012, 2010,
		1, 0, 0, 0, 2012, 2013, 1, 0, 0, 0, 2013, 2015, 1, 0, 0, 0, 2014, 2012,
		1, 0, 0, 0, 2015, 2016, 5, 1132, 0, 0, 2016, 2018, 1, 0, 0, 0, 2017, 2006,
		1, 0, 0, 0, 2017, 2018, 1, 0, 0, 0, 2018, 111, 1, 0, 0, 0, 2019, 2021,
		5, 100, 0, 0, 2020, 2019, 1, 0, 0, 0, 2020, 2021, 1, 0, 0, 0, 2021, 2022,
		1, 0, 0, 0, 2022, 2023, 5, 443, 0, 0, 2023, 2024, 5, 1131, 0, 0, 2024,
		2025, 3, 672, 336, 0, 2025, 2026, 5, 1132, 0, 0, 2026, 2066, 1, 0, 0, 0,
		2027, 2029, 5, 100, 0, 0, 2028, 2027, 1, 0, 0, 0, 2028, 2029, 1, 0, 0,
		0, 2029, 2030, 1, 0, 0, 0, 2030, 2034, 5, 91, 0, 0, 2031, 2032, 5, 336,
		0, 0, 2032, 2033, 5, 1122, 0, 0, 2033, 2035, 7, 32, 0, 0, 2034, 2031, 1,
		0, 0, 0, 2034, 2035, 1, 0, 0, 0, 2035, 2036, 1, 0, 0, 0, 2036, 2038, 5,
		1131, 0, 0, 2037, 2039, 3, 600, 300, 0, 2038, 2037, 1, 0, 0, 0, 2038, 2039,
		1, 0, 0, 0, 2039, 2040, 1, 0, 0, 0, 2040, 2066, 5, 1132, 0, 0, 2041, 2051,
		5, 133, 0, 0, 2042, 2043, 5, 1131, 0, 0, 2043, 2044, 3, 672, 336, 0, 2044,
		2045, 5, 1132, 0, 0, 2045, 2052, 1, 0, 0, 0, 2046, 2047, 5, 365, 0, 0,
		2047, 2048, 5, 1131, 0, 0, 2048, 2049, 3, 600, 300, 0, 2049, 2050, 5, 1132,
		0, 0, 2050, 2052, 1, 0, 0, 0, 2051, 2042, 1, 0, 0, 0, 2051, 2046, 1, 0,
		0, 0, 2052, 2066, 1, 0, 0, 0, 2053, 2063, 5, 473, 0, 0, 2054, 2055, 5,
		1131, 0, 0, 2055, 2056, 3, 672, 336, 0, 2056, 2057, 5, 1132, 0, 0, 2057,
		2064, 1, 0, 0, 0, 2058, 2059, 5, 365, 0, 0, 2059, 2060, 5, 1131, 0, 0,
		2060, 2061, 3, 600, 300, 0, 2061, 2062, 5, 1132, 0, 0, 2062, 2064, 1, 0,
		0, 0, 2063, 2054, 1, 0, 0, 0, 2063, 2058, 1, 0, 0, 0, 2064, 2066, 1, 0,
		0, 0, 2065, 2020, 1, 0, 0, 0, 2065, 2028, 1, 0, 0, 0, 2065, 2041, 1, 0,
		0, 0, 2065, 2053, 1, 0, 0, 0, 2066, 113, 1, 0, 0, 0, 2067, 2069, 5, 100,
		0, 0, 2068, 2067, 1, 0, 0, 0, 2068, 2069, 1, 0, 0, 0, 2069, 2070, 1, 0,
		0, 0, 2070, 2071, 5, 443, 0, 0, 2071, 2072, 5, 1131, 0, 0, 2072, 2073,
		3, 672, 336, 0, 2073, 2074, 5, 1132, 0, 0, 2074, 2089, 1, 0, 0, 0, 2075,
		2077, 5, 100, 0, 0, 2076, 2075, 1, 0, 0, 0, 2076, 2077, 1, 0, 0, 0, 2077,
		2078, 1, 0, 0, 0, 2078, 2082, 5, 91, 0, 0, 2079, 2080, 5, 336, 0, 0, 2080,
		2081, 5, 1122, 0, 0, 2081, 2083, 7, 32, 0, 0, 2082, 2079, 1, 0, 0, 0, 2082,
		2083, 1, 0, 0, 0, 2083, 2084, 1, 0, 0, 0, 2084, 2085, 5, 1131, 0, 0, 2085,
		2086, 3, 600, 300, 0, 2086, 2087, 5, 1132, 0, 0, 2087, 2089, 1, 0, 0, 0,
		2088, 2068, 1, 0, 0, 0, 2088, 2076, 1, 0, 0, 0, 2089, 115, 1, 0, 0, 0,
		2090, 2091, 5, 129, 0, 0, 2091, 2092, 3, 568, 284, 0, 2092, 2093, 5, 188,
		0, 0, 2093, 2094, 5, 471, 0, 0, 2094, 2095, 5, 651, 0, 0, 2095, 2096, 5,
		1131, 0, 0, 2096, 2101, 3, 118, 59, 0, 2097, 2098, 5, 1133, 0, 0, 2098,
		2100, 3, 118, 59, 0, 2099, 2097, 1, 0, 0, 0, 2100, 2103, 1, 0, 0, 0, 2101,
		2099, 1, 0, 0, 0, 2101, 2102, 1, 0, 0, 0, 2102, 2104, 1, 0, 0, 0, 2103,
		2101, 1, 0, 0, 0, 2104, 2108, 5, 1132, 0, 0, 2105, 2107, 3, 124, 62, 0,
		2106, 2105, 1, 0, 0, 0, 2107, 2110, 1, 0, 0, 0, 2108, 2106, 1, 0, 0, 0,
		2108, 2109, 1, 0, 0, 0, 2109, 2122, 1, 0, 0, 0, 2110, 2108, 1, 0, 0, 0,
		2111, 2112, 5, 1131, 0, 0, 2112, 2117, 3, 122, 61, 0, 2113, 2114, 5, 1133,
		0, 0, 2114, 2116, 3, 122, 61, 0, 2115, 2113, 1, 0, 0, 0, 2116, 2119, 1,
		0, 0, 0, 2117, 2115, 1, 0, 0, 0, 2117, 2118, 1, 0, 0, 0, 2118, 2120, 1,
		0, 0, 0, 2119, 2117, 1, 0, 0, 0, 2120, 2121, 5, 1132, 0, 0, 2121, 2123,
		1, 0, 0, 0, 2122, 2111, 1, 0, 0, 0, 2122, 2123, 1, 0, 0, 0, 2123, 2237,
		1, 0, 0, 0, 2124, 2125, 5, 129, 0, 0, 2125, 2126, 3, 568, 284, 0, 2126,
		2127, 5, 188, 0, 0, 2127, 2128, 5, 471, 0, 0, 2128, 2129, 5, 651, 0, 0,
		2129, 2133, 3, 118, 59, 0, 2130, 2132, 3, 124, 62, 0, 2131, 2130, 1, 0,
		0, 0, 2132, 2135, 1, 0, 0, 0, 2133, 2131, 1, 0, 0, 0, 2133, 2134, 1, 0,
		0, 0, 2134, 2147, 1, 0, 0, 0, 2135, 2133, 1, 0, 0, 0, 2136, 2137, 5, 1131,
		0, 0, 2137, 2142, 3, 122, 61, 0, 2138, 2139, 5, 1133, 0, 0, 2139, 2141,
		3, 122, 61, 0, 2140, 2138, 1, 0, 0, 0, 2141, 2144, 1, 0, 0, 0, 2142, 2140,
		1, 0, 0, 0, 2142, 2143, 1, 0, 0, 0, 2143, 2145, 1, 0, 0, 0, 2144, 2142,
		1, 0, 0, 0, 2145, 2146, 5, 1132, 0, 0, 2146, 2148, 1, 0, 0, 0, 2147, 2136,
		1, 0, 0, 0, 2147, 2148, 1, 0, 0, 0, 2148, 2237, 1, 0, 0, 0, 2149, 2150,
		5, 129, 0, 0, 2150, 2151, 3, 568, 284, 0, 2151, 2152, 5, 188, 0, 0, 2152,
		2153, 5, 80, 0, 0, 2153, 2154, 5, 1131, 0, 0, 2154, 2159, 3, 118, 59, 0,
		2155, 2156, 5, 1133, 0, 0, 2156, 2158, 3, 118, 59, 0, 2157, 2155, 1, 0,
		0, 0, 2158, 2161, 1, 0, 0, 0, 2159, 2157, 1, 0, 0, 0, 2159, 2160, 1, 0,
		0, 0, 2160, 2162, 1, 0, 0, 0, 2161, 2159, 1, 0, 0, 0, 2162, 2166, 5, 1132,
		0, 0, 2163, 2165, 3, 124, 62, 0, 2164, 2163, 1, 0, 0, 0, 2165, 2168, 1,
		0, 0, 0, 2166, 2164, 1, 0, 0, 0, 2166, 2167, 1, 0, 0, 0, 2167, 2180, 1,
		0, 0, 0, 2168, 2166, 1, 0, 0, 0, 2169, 2170, 5, 1131, 0, 0, 2170, 2175,
		3, 122, 61, 0, 2171, 2172, 5, 1133, 0, 0, 2172, 2174, 3, 122, 61, 0, 2173,
		2171, 1, 0, 0, 0, 2174, 2177, 1, 0, 0, 0, 2175, 2173, 1, 0, 0, 0, 2175,
		2176, 1, 0, 0, 0, 2176, 2178, 1, 0, 0, 0, 2177, 2175, 1, 0, 0, 0, 2178,
		2179, 5, 1132, 0, 0, 2179, 2181, 1, 0, 0, 0, 2180, 2169, 1, 0, 0, 0, 2180,
		2181, 1, 0, 0, 0, 2181, 2237, 1, 0, 0, 0, 2182, 2183, 5, 129, 0, 0, 2183,
		2184, 3, 568, 284, 0, 2184, 2185, 5, 188, 0, 0, 2185, 2186, 5, 80, 0, 0,
		2186, 2187, 5, 1131, 0, 0, 2187, 2192, 3, 120, 60, 0, 2188, 2189, 5, 1133,
		0, 0, 2189, 2191, 3, 120, 60, 0, 2190, 2188, 1, 0, 0, 0, 2191, 2194, 1,
		0, 0, 0, 2192, 2190, 1, 0, 0, 0, 2192, 2193, 1, 0, 0, 0, 2193, 2195, 1,
		0, 0, 0, 2194, 2192, 1, 0, 0, 0, 2195, 2199, 5, 1132, 0, 0, 2196, 2198,
		3, 124, 62, 0, 2197, 2196, 1, 0, 0, 0, 2198, 2201, 1, 0, 0, 0, 2199, 2197,
		1, 0, 0, 0, 2199, 2200, 1, 0, 0, 0, 2200, 2213, 1, 0, 0, 0, 2201, 2199,
		1, 0, 0, 0, 2202, 2203, 5, 1131, 0, 0, 2203, 2208, 3, 122, 61, 0, 2204,
		2205, 5, 1133, 0, 0, 2205, 2207, 3, 122, 61, 0, 2206, 2204, 1, 0, 0, 0,
		2207, 2210, 1, 0, 0, 0, 2208, 2206, 1, 0, 0, 0, 2208, 2209, 1, 0, 0, 0,
		2209, 2211, 1, 0, 0, 0, 2210, 2208, 1, 0, 0, 0, 2211, 2212, 5, 1132, 0,
		0, 2212, 2214, 1, 0, 0, 0, 2213, 2202, 1, 0, 0, 0, 2213, 2214, 1, 0, 0,
		0, 2214, 2237, 1, 0, 0, 0, 2215, 2216, 5, 129, 0, 0, 2216, 2220, 3, 568,
		284, 0, 2217, 2219, 3, 124, 62, 0, 2218, 2217, 1, 0, 0, 0, 2219, 2222,
		1, 0, 0, 0, 2220, 2218, 1, 0, 0, 0, 2220, 2221, 1, 0, 0, 0, 2221, 2234,
		1, 0, 0, 0, 2222, 2220, 1, 0, 0, 0, 2223, 2224, 5, 1131, 0, 0, 2224, 2229,
		3, 122, 61, 0, 2225, 2226, 5, 1133, 0, 0, 2226, 2228, 3, 122, 61, 0, 2227,
		2225, 1, 0, 0, 0, 2228, 2231, 1, 0, 0, 0, 2229, 2227, 1, 0, 0, 0, 2229,
		2230, 1, 0, 0, 0, 2230, 2232, 1, 0, 0, 0, 2231, 2229, 1, 0, 0, 0, 2232,
		2233, 5, 1132, 0, 0, 2233, 2235, 1, 0, 0, 0, 2234, 2223, 1, 0, 0, 0, 2234,
		2235, 1, 0, 0, 0, 2235, 2237, 1, 0, 0, 0, 2236, 2090, 1, 0, 0, 0, 2236,
		2124, 1, 0, 0, 0, 2236, 2149, 1, 0, 0, 0, 2236, 2182, 1, 0, 0, 0, 2236,
		2215, 1, 0, 0, 0, 2237, 117, 1, 0, 0, 0, 2238, 2242, 3, 586, 293, 0, 2239,
		2242, 3, 672, 336, 0, 2240, 2242, 5, 110, 0, 0, 2241, 2238, 1, 0, 0, 0,
		2241, 2239, 1, 0, 0, 0, 2241, 2240, 1, 0, 0, 0, 2242, 119, 1, 0, 0, 0,
		2243, 2244, 5, 1131, 0, 0, 2244, 2247, 3, 118, 59, 0, 2245, 2246, 5, 1133,
		0, 0, 2246, 2248, 3, 118, 59, 0, 2247, 2245, 1, 0, 0, 0, 2248, 2249, 1,
		0, 0, 0, 2249, 2247, 1, 0, 0, 0, 2249, 2250, 1, 0, 0, 0, 2250, 2251, 1,
		0, 0, 0, 2251, 2252, 5, 1132, 0, 0, 2252, 121, 1, 0, 0, 0, 2253, 2254,
		5, 641, 0, 0, 2254, 2258, 3, 568, 284, 0, 2255, 2257, 3, 124, 62, 0, 2256,
		2255, 1, 0, 0, 0, 2257, 2260, 1, 0, 0, 0, 2258, 2256, 1, 0, 0, 0, 2258,
		2259, 1, 0, 0, 0, 2259, 123, 1, 0, 0, 0, 2260, 2258, 1, 0, 0, 0, 2261,
		2263, 5, 42, 0, 0, 2262, 2261, 1, 0, 0, 0, 2262, 2263, 1, 0, 0, 0, 2263,
		2265, 1, 0, 0, 0, 2264, 2266, 5, 636, 0, 0, 2265, 2264, 1, 0, 0, 0, 2265,
		2266, 1, 0, 0, 0, 2266, 2267, 1, 0, 0, 0, 2267, 2269, 5, 409, 0, 0, 2268,
		2270, 5, 1122, 0, 0, 2269, 2268, 1, 0, 0, 0, 2269, 2270, 1, 0, 0, 0, 2270,
		2271, 1, 0, 0, 0, 2271, 2310, 3, 558, 279, 0, 2272, 2274, 5, 368, 0, 0,
		2273, 2275, 5, 1122, 0, 0, 2274, 2273, 1, 0, 0, 0, 2274, 2275, 1, 0, 0,
		0, 2275, 2276, 1, 0, 0, 0, 2276, 2310, 5, 1146, 0, 0, 2277, 2278, 5, 388,
		0, 0, 2278, 2280, 5, 395, 0, 0, 2279, 2281, 5, 1122, 0, 0, 2280, 2279,
		1, 0, 0, 0, 2280, 2281, 1, 0, 0, 0, 2281, 2282, 1, 0, 0, 0, 2282, 2310,
		5, 1146, 0, 0, 2283, 2284, 5, 81, 0, 0, 2284, 2286, 5, 395, 0, 0, 2285,
		2287, 5, 1122, 0, 0, 2286, 2285, 1, 0, 0, 0, 2286, 2287, 1, 0, 0, 0, 2287,
		2288, 1, 0, 0, 0, 2288, 2310, 5, 1146, 0, 0, 2289, 2291, 5, 500, 0, 0,
		2290, 2292, 5, 1122, 0, 0, 2291, 2290, 1, 0, 0, 0, 2291, 2292, 1, 0, 0,
		0, 2292, 2293, 1, 0, 0, 0, 2293, 2310, 3, 574, 287, 0, 2294, 2296, 5, 510,
		0, 0, 2295, 2297, 5, 1122, 0, 0, 2296, 2295, 1, 0, 0, 0, 2296, 2297, 1,
		0, 0, 0, 2297, 2298, 1, 0, 0, 0, 2298, 2310, 3, 574, 287, 0, 2299, 2301,
		5, 647, 0, 0, 2300, 2302, 5, 1122, 0, 0, 2301, 2300, 1, 0, 0, 0, 2301,
		2302, 1, 0, 0, 0, 2302, 2303, 1, 0, 0, 0, 2303, 2310, 3, 568, 284, 0, 2304,
		2306, 5, 528, 0, 0, 2305, 2307, 5, 1122, 0, 0, 2306, 2305, 1, 0, 0, 0,
		2306, 2307, 1, 0, 0, 0, 2307, 2308, 1, 0, 0, 0, 2308, 2310, 3, 568, 284,
		0, 2309, 2262, 1, 0, 0, 0, 2309, 2272, 1, 0, 0, 0, 2309, 2277, 1, 0, 0,
		0, 2309, 2283, 1, 0, 0, 0, 2309, 2289, 1, 0, 0, 0, 2309, 2294, 1, 0, 0,
		0, 2309, 2299, 1, 0, 0, 0, 2309, 2304, 1, 0, 0, 0, 2310, 125, 1, 0, 0,
		0, 2311, 2312, 5, 7, 0, 0, 2312, 2314, 7, 0, 0, 0, 2313, 2315, 3, 568,
		284, 0, 2314, 2313, 1, 0, 0, 0, 2314, 2315, 1, 0, 0, 0, 2315, 2317, 1,
		0, 0, 0, 2316, 2318, 3, 58, 29, 0, 2317, 2316, 1, 0, 0, 0, 2318, 2319,
		1, 0, 0, 0, 2319, 2317, 1, 0, 0, 0, 2319, 2320, 1, 0, 0, 0, 2320, 2330,
		1, 0, 0, 0, 2321, 2322, 5, 7, 0, 0, 2322, 2323, 7, 0, 0, 0, 2323, 2324,
		3, 568, 284, 0, 2324, 2325, 5, 664, 0, 0, 2325, 2326, 5, 388, 0, 0, 2326,
		2327, 5, 395, 0, 0, 2327, 2328, 5, 516, 0, 0, 2328, 2330, 1, 0, 0, 0, 2329,
		2311, 1, 0, 0, 0, 2329, 2321, 1, 0, 0, 0, 2330, 127, 1, 0, 0, 0, 2331,
		2333, 5, 7, 0, 0, 2332, 2334, 3, 62, 31, 0, 2333, 2332, 1, 0, 0, 0, 2333,
		2334, 1, 0, 0, 0, 2334, 2335, 1, 0, 0, 0, 2335, 2336, 5, 415, 0, 0, 2336,
		2340, 3, 540, 270, 0, 2337, 2338, 5, 118, 0, 0, 2338, 2339, 5, 605, 0,
		0, 2339, 2341, 3, 64, 32, 0, 2340, 2337, 1, 0, 0, 0, 2340, 2341, 1, 0,
		0, 0, 2341, 2348, 1, 0, 0, 0, 2342, 2343, 5, 118, 0, 0, 2343, 2345, 5,
		371, 0, 0, 2344, 2346, 5, 114, 0, 0, 2345, 2344, 1, 0, 0, 0, 2345, 2346,
		1, 0, 0, 0, 2346, 2347, 1, 0, 0, 0, 2347, 2349, 5, 561, 0, 0, 2348, 2342,
		1, 0, 0, 0, 2348, 2349, 1, 0, 0, 0, 2349, 2353, 1, 0, 0, 0, 2350, 2351,
		5, 139, 0, 0, 2351, 2352, 5, 175, 0, 0, 2352, 2354, 3, 540, 270, 0, 2353,
		2350, 1, 0, 0, 0, 2353, 2354, 1, 0, 0, 0, 2354, 2356, 1, 0, 0, 0, 2355,
		2357, 3, 72, 36, 0, 2356, 2355, 1, 0, 0, 0, 2356, 2357, 1, 0, 0, 0, 2357,
		2360, 1, 0, 0, 0, 2358, 2359, 5, 368, 0, 0, 2359, 2361, 5, 1146, 0, 0,
		2360, 2358, 1, 0, 0, 0, 2360, 2361, 1, 0, 0, 0, 2361, 2364, 1, 0, 0, 0,
		2362, 2363, 5, 399, 0, 0, 2363, 2365, 3, 382, 191, 0, 2364, 2362, 1, 0,
		0, 0, 2364, 2365, 1, 0, 0, 0, 2365, 129, 1, 0, 0, 0, 2366, 2367, 5, 7,
		0, 0, 2367, 2368, 5, 437, 0, 0, 2368, 2372, 3, 540, 270, 0, 2369, 2371,
		3, 82, 41, 0, 2370, 2369, 1, 0, 0, 0, 2371, 2374, 1, 0, 0, 0, 2372, 2370,
		1, 0, 0, 0, 2372, 2373, 1, 0, 0, 0, 2373, 131, 1, 0, 0, 0, 2374, 2372,
		1, 0, 0, 0, 2375, 2376, 5, 7, 0, 0, 2376, 2377, 5, 457, 0, 0, 2377, 2378,
		5, 599, 0, 0, 2378, 2379, 5, 790, 0, 0, 2379, 2380, 5, 477, 0, 0, 2380,
		2381, 5, 91, 0, 0, 2381, 133, 1, 0, 0, 0, 2382, 2383, 5, 7, 0, 0, 2383,
		2384, 5, 475, 0, 0, 2384, 2385, 5, 73, 0, 0, 2385, 2386, 3, 568, 284, 0,
		2386, 2387, 5, 5, 0, 0, 2387, 2388, 5, 659, 0, 0, 2388, 2394, 5, 1146,
		0, 0, 2389, 2391, 5, 453, 0, 0, 2390, 2392, 5, 1122, 0, 0, 2391, 2390,
		1, 0, 0, 0, 2391, 2392, 1, 0, 0, 0, 2392, 2393, 1, 0, 0, 0, 2393, 2395,
		3, 576, 288, 0, 2394, 2389, 1, 0, 0, 0, 2394, 2395, 1, 0, 0, 0, 2395, 2397,
		1, 0, 0, 0, 2396, 2398, 5, 674, 0, 0, 2397, 2396, 1, 0, 0, 0, 2397, 2398,
		1, 0, 0, 0, 2398, 2399, 1, 0, 0, 0, 2399, 2401, 5, 409, 0, 0, 2400, 2402,
		5, 1122, 0, 0, 2401, 2400, 1, 0, 0, 0, 2401, 2402, 1, 0, 0, 0, 2402, 2403,
		1, 0, 0, 0, 2403, 2404, 3, 558, 279, 0, 2404, 135, 1, 0, 0, 0, 2405, 2406,
		5, 7, 0, 0, 2406, 2407, 5, 131, 0, 0, 2407, 2411, 3, 540, 270, 0, 2408,
		2410, 3, 82, 41, 0, 2409, 2408, 1, 0, 0, 0, 2410, 2413, 1, 0, 0, 0, 2411,
		2409, 1, 0, 0, 0, 2411, 2412, 1, 0, 0, 0, 2412, 137, 1, 0, 0, 0, 2413,
		2411, 1, 0, 0, 0, 2414, 2415, 5, 7, 0, 0, 2415, 2416, 5, 608, 0, 0, 2416,
		2417, 3, 568, 284, 0, 2417, 2418, 5, 541, 0, 0, 2418, 2419, 5, 1131, 0,
		0, 2419, 2424, 3, 84, 42, 0, 2420, 2421, 5, 1133, 0, 0, 2421, 2423, 3,
		84, 42, 0, 2422, 2420, 1, 0, 0, 0, 2423, 2426, 1, 0, 0, 0, 2424, 2422,
		1, 0, 0, 0, 2424, 2425, 1, 0, 0, 0, 2425, 2427, 1, 0, 0, 0, 2426, 2424,
		1, 0, 0, 0, 2427, 2428, 5, 1132, 0, 0, 2428, 139, 1, 0, 0, 0, 2429, 2431,
		5, 7, 0, 0, 2430, 2432, 7, 1, 0, 0, 2431, 2430, 1, 0, 0, 0, 2431, 2432,
		1, 0, 0, 0, 2432, 2434, 1, 0, 0, 0, 2433, 2435, 5, 78, 0, 0, 2434, 2433,
		1, 0, 0, 0, 2434, 2435, 1, 0, 0, 0, 2435, 2436, 1, 0, 0, 0, 2436, 2437,
		5, 172, 0, 0, 2437, 2439, 3, 542, 271, 0, 2438, 2440, 3, 630, 315, 0, 2439,
		2438, 1, 0, 0, 0, 2439, 2440, 1, 0, 0, 0, 2440, 2449, 1, 0, 0, 0, 2441,
		2446, 3, 146, 73, 0, 2442, 2443, 5, 1133, 0, 0, 2443, 2445, 3, 146, 73,
		0, 2444, 2442, 1, 0, 0, 0, 2445, 2448, 1, 0, 0, 0, 2446, 2444, 1, 0, 0,
		0, 2446, 2447, 1, 0, 0, 0, 2447, 2450, 1, 0, 0, 0, 2448, 2446, 1, 0, 0,
		0, 2449, 2441, 1, 0, 0, 0, 2449, 2450, 1, 0, 0, 0, 2450, 2452, 1, 0, 0,
		0, 2451, 2453, 3, 110, 55, 0, 2452, 2451, 1, 0, 0, 0, 2452, 2453, 1, 0,
		0, 0, 2453, 141, 1, 0, 0, 0, 2454, 2455, 5, 7, 0, 0, 2455, 2456, 5, 647,
		0, 0, 2456, 2457, 3, 568, 284, 0, 2457, 2458, 7, 33, 0, 0, 2458, 2459,
		5, 389, 0, 0, 2459, 2463, 5, 1146, 0, 0, 2460, 2461, 5, 453, 0, 0, 2461,
		2462, 5, 1122, 0, 0, 2462, 2464, 3, 576, 288, 0, 2463, 2460, 1, 0, 0, 0,
		2463, 2464, 1, 0, 0, 0, 2464, 2466, 1, 0, 0, 0, 2465, 2467, 5, 674, 0,
		0, 2466, 2465, 1, 0, 0, 0, 2466, 2467, 1, 0, 0, 0, 2467, 2468, 1, 0, 0,
		0, 2468, 2470, 5, 409, 0, 0, 2469, 2471, 5, 1122, 0, 0, 2470, 2469, 1,
		0, 0, 0, 2470, 2471, 1, 0, 0, 0, 2471, 2472, 1, 0, 0, 0, 2472, 2473, 3,
		558, 279, 0, 2473, 143, 1, 0, 0, 0, 2474, 2478, 5, 7, 0, 0, 2475, 2476,
		5, 336, 0, 0, 2476, 2477, 5, 1122, 0, 0, 2477, 2479, 7, 10, 0, 0, 2478,
		2475, 1, 0, 0, 0, 2478, 2479, 1, 0, 0, 0, 2479, 2481, 1, 0, 0, 0, 2480,
		2482, 3, 62, 31, 0, 2481, 2480, 1, 0, 0, 0, 2481, 2482, 1, 0, 0, 0, 2482,
		2486, 1, 0, 0, 0, 2483, 2484, 5, 160, 0, 0, 2484, 2485, 5, 606, 0, 0, 2485,
		2487, 7, 11, 0, 0, 2486, 2483, 1, 0, 0, 0, 2486, 2487, 1, 0, 0, 0, 2487,
		2488, 1, 0, 0, 0, 2488, 2489, 5, 671, 0, 0, 2489, 2494, 3, 540, 270, 0,
		2490, 2491, 5, 1131, 0, 0, 2491, 2492, 3, 600, 300, 0, 2492, 2493, 5, 1132,
		0, 0, 2493, 2495, 1, 0, 0, 0, 2494, 2490, 1, 0, 0, 0, 2494, 2495, 1, 0,
		0, 0, 2495, 2496, 1, 0, 0, 0, 2496, 2497, 5, 12, 0, 0, 2497, 2504, 3, 196,
		98, 0, 2498, 2500, 5, 192, 0, 0, 2499, 2501, 7, 12, 0, 0, 2500, 2499, 1,
		0, 0, 0, 2500, 2501, 1, 0, 0, 0, 2501, 2502, 1, 0, 0, 0, 2502, 2503, 5,
		26, 0, 0, 2503, 2505, 5, 120, 0, 0, 2504, 2498, 1, 0, 0, 0, 2504, 2505,
		1, 0, 0, 0, 2505, 145, 1, 0, 0, 0, 2506, 2513, 3, 104, 52, 0, 2507, 2509,
		5, 1133, 0, 0, 2508, 2507, 1, 0, 0, 0, 2508, 2509, 1, 0, 0, 0, 2509, 2510,
		1, 0, 0, 0, 2510, 2512, 3, 104, 52, 0, 2511, 2508, 1, 0, 0, 0, 2512, 2515,
		1, 0, 0, 0, 2513, 2511, 1, 0, 0, 0, 2513, 2514, 1, 0, 0, 0, 2514, 2955,
		1, 0, 0, 0, 2515, 2513, 1, 0, 0, 0, 2516, 2518, 5, 5, 0, 0, 2517, 2519,
		5, 28, 0, 0, 2518, 2517, 1, 0, 0, 0, 2518, 2519, 1, 0, 0, 0, 2519, 2520,
		1, 0, 0, 0, 2520, 2521, 3, 568, 284, 0, 2521, 2525, 3, 90, 45, 0, 2522,
		2526, 5, 430, 0, 0, 2523, 2524, 5, 334, 0, 0, 2524, 2526, 3, 568, 284,
		0, 2525, 2522, 1, 0, 0, 0, 2525, 2523, 1, 0, 0, 0, 2525, 2526, 1, 0, 0,
		0, 2526, 2955, 1, 0, 0, 0, 2527, 2529, 5, 5, 0, 0, 2528, 2530, 5, 28, 0,
		0, 2529, 2528, 1, 0, 0, 0, 2529, 2530, 1, 0, 0, 0, 2530, 2531, 1, 0, 0,
		0, 2531, 2532, 5, 1131, 0, 0, 2532, 2533, 3, 568, 284, 0, 2533, 2540, 3,
		90, 45, 0, 2534, 2535, 5, 1133, 0, 0, 2535, 2536, 3, 568, 284, 0, 2536,
		2537, 3, 90, 45, 0, 2537, 2539, 1, 0, 0, 0, 2538, 2534, 1, 0, 0, 0, 2539,
		2542, 1, 0, 0, 0, 2540, 2538, 1, 0, 0, 0, 2540, 2541, 1, 0, 0, 0, 2541,
		2543, 1, 0, 0, 0, 2542, 2540, 1, 0, 0, 0, 2543, 2544, 5, 1132, 0, 0, 2544,
		2955, 1, 0, 0, 0, 2545, 2546, 5, 5, 0, 0, 2546, 2548, 7, 20, 0, 0, 2547,
		2549, 3, 568, 284, 0, 2548, 2547, 1, 0, 0, 0, 2548, 2549, 1, 0, 0, 0, 2549,
		2551, 1, 0, 0, 0, 2550, 2552, 3, 74, 37, 0, 2551, 2550, 1, 0, 0, 0, 2551,
		2552, 1, 0, 0, 0, 2552, 2553, 1, 0, 0, 0, 2553, 2557, 3, 606, 303, 0, 2554,
		2556, 3, 76, 38, 0, 2555, 2554, 1, 0, 0, 0, 2556, 2559, 1, 0, 0, 0, 2557,
		2555, 1, 0, 0, 0, 2557, 2558, 1, 0, 0, 0, 2558, 2955, 1, 0, 0, 0, 2559,
		2557, 1, 0, 0, 0, 2560, 2565, 5, 5, 0, 0, 2561, 2563, 5, 30, 0, 0, 2562,
		2564, 3, 568, 284, 0, 2563, 2562, 1, 0, 0, 0, 2563, 2564, 1, 0, 0, 0, 2564,
		2566, 1, 0, 0, 0, 2565, 2561, 1, 0, 0, 0, 2565, 2566, 1, 0, 0, 0, 2566,
		2567, 1, 0, 0, 0, 2567, 2568, 5, 130, 0, 0, 2568, 2570, 5, 91, 0, 0, 2569,
		2571, 3, 568, 284, 0, 2570, 2569, 1, 0, 0, 0, 2570, 2571, 1, 0, 0, 0, 2571,
		2573, 1, 0, 0, 0, 2572, 2574, 3, 74, 37, 0, 2573, 2572, 1, 0, 0, 0, 2573,
		2574, 1, 0, 0, 0, 2574, 2575, 1, 0, 0, 0, 2575, 2579, 3, 606, 303, 0, 2576,
		2578, 3, 76, 38, 0, 2577, 2576, 1, 0, 0, 0, 2578, 2581, 1, 0, 0, 0, 2579,
		2577, 1, 0, 0, 0, 2579, 2580, 1, 0, 0, 0, 2580, 2955, 1, 0, 0, 0, 2581,
		2579, 1, 0, 0, 0, 2582, 2587, 5, 5, 0, 0, 2583, 2585, 5, 30, 0, 0, 2584,
		2586, 3, 568, 284, 0, 2585, 2584, 1, 0, 0, 0, 2585, 2586, 1, 0, 0, 0, 2586,
		2588, 1, 0, 0, 0, 2587, 2583, 1, 0, 0, 0, 2587, 2588, 1, 0, 0, 0, 2588,
		2589, 1, 0, 0, 0, 2589, 2591, 5, 181, 0, 0, 2590, 2592, 7, 20, 0, 0, 2591,
		2590, 1, 0, 0, 0, 2591, 2592, 1, 0, 0, 0, 2592, 2594, 1, 0, 0, 0, 2593,
		2595, 3, 568, 284, 0, 2594, 2593, 1, 0, 0, 0, 2594, 2595, 1, 0, 0, 0, 2595,
		2597, 1, 0, 0, 0, 2596, 2598, 3, 74, 37, 0, 2597, 2596, 1, 0, 0, 0, 2597,
		2598, 1, 0, 0, 0, 2598, 2599, 1, 0, 0, 0, 2599, 2603, 3, 606, 303, 0, 2600,
		2602, 3, 76, 38, 0, 2601, 2600, 1, 0, 0, 0, 2602, 2605, 1, 0, 0, 0, 2603,
		2601, 1, 0, 0, 0, 2603, 2604, 1, 0, 0, 0, 2604, 2955, 1, 0, 0, 0, 2605,
		2603, 1, 0, 0, 0, 2606, 2607, 5, 5, 0, 0, 2607, 2609, 7, 22, 0, 0, 2608,
		2610, 7, 20, 0, 0, 2609, 2608, 1, 0, 0, 0, 2609, 2610, 1, 0, 0, 0, 2610,
		2612, 1, 0, 0, 0, 2611, 2613, 3, 568, 284, 0, 2612, 2611, 1, 0, 0, 0, 2612,
		2613, 1, 0, 0, 0, 2613, 2614, 1, 0, 0, 0, 2614, 2618, 3, 606, 303, 0, 2615,
		2617, 3, 76, 38, 0, 2616, 2615, 1, 0, 0, 0, 2617, 2620, 1, 0, 0, 0, 2618,
		2616, 1, 0, 0, 0, 2618, 2619, 1, 0, 0, 0, 2619, 2955, 1, 0, 0, 0, 2620,
		2618, 1, 0, 0, 0, 2621, 2626, 5, 5, 0, 0, 2622, 2624, 5, 30, 0, 0, 2623,
		2625, 3, 568, 284, 0, 2624, 2623, 1, 0, 0, 0, 2624, 2625, 1, 0, 0, 0, 2625,
		2627, 1, 0, 0, 0, 2626, 2622, 1, 0, 0, 0, 2626, 2627, 1, 0, 0, 0, 2627,
		2628, 1, 0, 0, 0, 2628, 2629, 5, 67, 0, 0, 2629, 2631, 5, 91, 0, 0, 2630,
		2632, 3, 568, 284, 0, 2631, 2630, 1, 0, 0, 0, 2631, 2632, 1, 0, 0, 0, 2632,
		2633, 1, 0, 0, 0, 2633, 2634, 3, 606, 303, 0, 2634, 2635, 3, 96, 48, 0,
		2635, 2955, 1, 0, 0, 0, 2636, 2641, 5, 5, 0, 0, 2637, 2639, 5, 30, 0, 0,
		2638, 2640, 3, 568, 284, 0, 2639, 2638, 1, 0, 0, 0, 2639, 2640, 1, 0, 0,
		0, 2640, 2642, 1, 0, 0, 0, 2641, 2637, 1, 0, 0, 0, 2641, 2642, 1, 0, 0,
		0, 2642, 2643, 1, 0, 0, 0, 2643, 2650, 5, 26, 0, 0, 2644, 2651, 3, 568,
		284, 0, 2645, 2651, 3, 578, 289, 0, 2646, 2647, 5, 1131, 0, 0, 2647, 2648,
		3, 672, 336, 0, 2648, 2649, 5, 1132, 0, 0, 2649, 2651, 1, 0, 0, 0, 2650,
		2644, 1, 0, 0, 0, 2650, 2645, 1, 0, 0, 0, 2650, 2646, 1, 0, 0, 0, 2651,
		2653, 1, 0, 0, 0, 2652, 2654, 5, 114, 0, 0, 2653, 2652, 1, 0, 0, 0, 2653,
		2654, 1, 0, 0, 0, 2654, 2656, 1, 0, 0, 0, 2655, 2657, 5, 57, 0, 0, 2656,
		2655, 1, 0, 0, 0, 2656, 2657, 1, 0, 0, 0, 2657, 2955, 1, 0, 0, 0, 2658,
		2663, 5, 7, 0, 0, 2659, 2661, 5, 30, 0, 0, 2660, 2662, 3, 568, 284, 0,
		2661, 2660, 1, 0, 0, 0, 2661, 2662, 1, 0, 0, 0, 2662, 2664, 1, 0, 0, 0,
		2663, 2659, 1, 0, 0, 0, 2663, 2664, 1, 0, 0, 0, 2664, 2665, 1, 0, 0, 0,
		2665, 2672, 5, 26, 0, 0, 2666, 2673, 3, 568, 284, 0, 2667, 2673, 3, 578,
		289, 0, 2668, 2669, 5, 1131, 0, 0, 2669, 2670, 3, 672, 336, 0, 2670, 2671,
		5, 1132, 0, 0, 2671, 2673, 1, 0, 0, 0, 2672, 2666, 1, 0, 0, 0, 2672, 2667,
		1, 0, 0, 0, 2672, 2668, 1, 0, 0, 0, 2673, 2675, 1, 0, 0, 0, 2674, 2676,
		5, 114, 0, 0, 2675, 2674, 1, 0, 0, 0, 2675, 2676, 1, 0, 0, 0, 2676, 2678,
		1, 0, 0, 0, 2677, 2679, 5, 57, 0, 0, 2678, 2677, 1, 0, 0, 0, 2678, 2679,
		1, 0, 0, 0, 2679, 2955, 1, 0, 0, 0, 2680, 2685, 5, 5, 0, 0, 2681, 2683,
		5, 30, 0, 0, 2682, 2684, 3, 568, 284, 0, 2683, 2682, 1, 0, 0, 0, 2683,
		2684, 1, 0, 0, 0, 2684, 2686, 1, 0, 0, 0, 2685, 2681, 1, 0, 0, 0, 2685,
		2686, 1, 0, 0, 0, 2686, 2687, 1, 0, 0, 0, 2687, 2688, 5, 26, 0, 0, 2688,
		2689, 5, 1131, 0, 0, 2689, 2690, 3, 672, 336, 0, 2690, 2691, 5, 1132, 0,
		0, 2691, 2955, 1, 0, 0, 0, 2692, 2694, 5, 336, 0, 0, 2693, 2695, 5, 1122,
		0, 0, 2694, 2693, 1, 0, 0, 0, 2694, 2695, 1, 0, 0, 0, 2695, 2696, 1, 0,
		0, 0, 2696, 2955, 7, 34, 0, 0, 2697, 2699, 5, 7, 0, 0, 2698, 2700, 5, 28,
		0, 0, 2699, 2698, 1, 0, 0, 0, 2699, 2700, 1, 0, 0, 0, 2700, 2701, 1, 0,
		0, 0, 2701, 2707, 3, 568, 284, 0, 2702, 2703, 5, 153, 0, 0, 2703, 2704,
		5, 42, 0, 0, 2704, 2708, 3, 618, 309, 0, 2705, 2706, 5, 51, 0, 0, 2706,
		2708, 5, 42, 0, 0, 2707, 2702, 1, 0, 0, 0, 2707, 2705, 1, 0, 0, 0, 2708,
		2955, 1, 0, 0, 0, 2709, 2711, 5, 24, 0, 0, 2710, 2712, 5, 28, 0, 0, 2711,
		2710, 1, 0, 0, 0, 2711, 2712, 1, 0, 0, 0, 2712, 2713, 1, 0, 0, 0, 2713,
		2714, 3, 568, 284, 0, 2714, 2715, 3, 568, 284, 0, 2715, 2719, 3, 90, 45,
		0, 2716, 2720, 5, 430, 0, 0, 2717, 2718, 5, 334, 0, 0, 2718, 2720, 3, 568,
		284, 0, 2719, 2716, 1, 0, 0, 0, 2719, 2717, 1, 0, 0, 0, 2719, 2720, 1,
		0, 0, 0, 2720, 2955, 1, 0, 0, 0, 2721, 2722, 5, 139, 0, 0, 2722, 2723,
		5, 28, 0, 0, 2723, 2724, 3, 568, 284, 0, 2724, 2725, 5, 175, 0, 0, 2725,
		2726, 3, 568, 284, 0, 2726, 2955, 1, 0, 0, 0, 2727, 2729, 5, 103, 0, 0,
		2728, 2730, 5, 1122, 0, 0, 2729, 2728, 1, 0, 0, 0, 2729, 2730, 1, 0, 0,
		0, 2730, 2731, 1, 0, 0, 0, 2731, 2955, 7, 4, 0, 0, 2732, 2734, 5, 512,
		0, 0, 2733, 2735, 5, 28, 0, 0, 2734, 2733, 1, 0, 0, 0, 2734, 2735, 1, 0,
		0, 0, 2735, 2736, 1, 0, 0, 0, 2736, 2737, 3, 568, 284, 0, 2737, 2741, 3,
		90, 45, 0, 2738, 2742, 5, 430, 0, 0, 2739, 2740, 5, 334, 0, 0, 2740, 2742,
		3, 568, 284, 0, 2741, 2738, 1, 0, 0, 0, 2741, 2739, 1, 0, 0, 0, 2741, 2742,
		1, 0, 0, 0, 2742, 2955, 1, 0, 0, 0, 2743, 2745, 5, 51, 0, 0, 2744, 2746,
		5, 28, 0, 0, 2745, 2744, 1, 0, 0, 0, 2745, 2746, 1, 0, 0, 0, 2746, 2747,
		1, 0, 0, 0, 2747, 2749, 3, 568, 284, 0, 2748, 2750, 5, 144, 0, 0, 2749,
		2748, 1, 0, 0, 0, 2749, 2750, 1, 0, 0, 0, 2750, 2955, 1, 0, 0, 0, 2751,
		2752, 5, 51, 0, 0, 2752, 2753, 7, 35, 0, 0, 2753, 2955, 3, 568, 284, 0,
		2754, 2755, 5, 51, 0, 0, 2755, 2756, 5, 130, 0, 0, 2756, 2955, 5, 91, 0,
		0, 2757, 2758, 5, 51, 0, 0, 2758, 2759, 7, 20, 0, 0, 2759, 2955, 3, 568,
		284, 0, 2760, 2761, 5, 139, 0, 0, 2761, 2762, 7, 20, 0, 0, 2762, 2763,
		3, 568, 284, 0, 2763, 2764, 5, 175, 0, 0, 2764, 2765, 3, 568, 284, 0, 2765,
		2955, 1, 0, 0, 0, 2766, 2768, 5, 7, 0, 0, 2767, 2769, 5, 28, 0, 0, 2768,
		2767, 1, 0, 0, 0, 2768, 2769, 1, 0, 0, 0, 2769, 2770, 1, 0, 0, 0, 2770,
		2784, 3, 568, 284, 0, 2771, 2772, 5, 153, 0, 0, 2772, 2778, 5, 42, 0, 0,
		2773, 2779, 3, 578, 289, 0, 2774, 2775, 5, 1131, 0, 0, 2775, 2776, 3, 672,
		336, 0, 2776, 2777, 5, 1132, 0, 0, 2777, 2779, 1, 0, 0, 0, 2778, 2773,
		1, 0, 0, 0, 2778, 2774, 1, 0, 0, 0, 2779, 2785, 1, 0, 0, 0, 2780, 2781,
		5, 153, 0, 0, 2781, 2785, 7, 15, 0, 0, 2782, 2783, 5, 51, 0, 0, 2783, 2785,
		5, 42, 0, 0, 2784, 2771, 1, 0, 0, 0, 2784, 2780, 1, 0, 0, 0, 2784, 2782,
		1, 0, 0, 0, 2785, 2955, 1, 0, 0, 0, 2786, 2787, 5, 7, 0, 0, 2787, 2788,
		5, 81, 0, 0, 2788, 2789, 3, 568, 284, 0, 2789, 2790, 7, 15, 0, 0, 2790,
		2955, 1, 0, 0, 0, 2791, 2792, 5, 51, 0, 0, 2792, 2793, 5, 67, 0, 0, 2793,
		2794, 5, 91, 0, 0, 2794, 2955, 3, 568, 284, 0, 2795, 2796, 5, 396, 0, 0,
		2796, 2955, 5, 92, 0, 0, 2797, 2798, 5, 403, 0, 0, 2798, 2955, 5, 92, 0,
		0, 2799, 2801, 5, 139, 0, 0, 2800, 2802, 7, 36, 0, 0, 2801, 2800, 1, 0,
		0, 0, 2801, 2802, 1, 0, 0, 0, 2802, 2805, 1, 0, 0, 0, 2803, 2806, 3, 568,
		284, 0, 2804, 2806, 3, 540, 270, 0, 2805, 2803, 1, 0, 0, 0, 2805, 2804,
		1, 0, 0, 0, 2806, 2955, 1, 0, 0, 0, 2807, 2808, 5, 124, 0, 0, 2808, 2809,
		5, 19, 0, 0, 2809, 2955, 3, 600, 300, 0, 2810, 2811, 5, 32, 0, 0, 2811,
		2815, 5, 175, 0, 0, 2812, 2816, 5, 840, 0, 0, 2813, 2814, 5, 25, 0, 0,
		2814, 2816, 5, 153, 0, 0, 2815, 2812, 1, 0, 0, 0, 2815, 2813, 1, 0, 0,
		0, 2816, 2817, 1, 0, 0, 0, 2817, 2820, 3, 554, 277, 0, 2818, 2819, 5, 27,
		0, 0, 2819, 2821, 3, 556, 278, 0, 2820, 2818, 1, 0, 0, 0, 2820, 2821, 1,
		0, 0, 0, 2821, 2955, 1, 0, 0, 0, 2822, 2824, 5, 42, 0, 0, 2823, 2822, 1,
		0, 0, 0, 2823, 2824, 1, 0, 0, 0, 2824, 2825, 1, 0, 0, 0, 2825, 2826, 5,
		25, 0, 0, 2826, 2827, 5, 153, 0, 0, 2827, 2828, 5, 1122, 0, 0, 2828, 2832,
		3, 554, 277, 0, 2829, 2830, 5, 27, 0, 0, 2830, 2831, 5, 1122, 0, 0, 2831,
		2833, 3, 556, 278, 0, 2832, 2829, 1, 0, 0, 0, 2832, 2833, 1, 0, 0, 0, 2833,
		2955, 1, 0, 0, 0, 2834, 2835, 5, 397, 0, 0, 2835, 2955, 5, 647, 0, 0, 2836,
		2837, 5, 450, 0, 0, 2837, 2955, 5, 647, 0, 0, 2838, 2955, 5, 66, 0, 0,
		2839, 2840, 7, 37, 0, 0, 2840, 2955, 5, 668, 0, 0, 2841, 2842, 5, 5, 0,
		0, 2842, 2843, 5, 129, 0, 0, 2843, 2844, 5, 1131, 0, 0, 2844, 2849, 3,
		116, 58, 0, 2845, 2846, 5, 1133, 0, 0, 2846, 2848, 3, 116, 58, 0, 2847,
		2845, 1, 0, 0, 0, 2848, 2851, 1, 0, 0, 0, 2849, 2847, 1, 0, 0, 0, 2849,
		2850, 1, 0, 0, 0, 2850, 2852, 1, 0, 0, 0, 2851, 2849, 1, 0, 0, 0, 2852,
		2853, 5, 1132, 0, 0, 2853, 2955, 1, 0, 0, 0, 2854, 2855, 5, 51, 0, 0, 2855,
		2856, 5, 129, 0, 0, 2856, 2955, 3, 600, 300, 0, 2857, 2858, 5, 397, 0,
		0, 2858, 2861, 5, 129, 0, 0, 2859, 2862, 3, 600, 300, 0, 2860, 2862, 5,
		6, 0, 0, 2861, 2859, 1, 0, 0, 0, 2861, 2860, 1, 0, 0, 0, 2862, 2863, 1,
		0, 0, 0, 2863, 2955, 5, 647, 0, 0, 2864, 2865, 5, 450, 0, 0, 2865, 2868,
		5, 129, 0, 0, 2866, 2869, 3, 600, 300, 0, 2867, 2869, 5, 6, 0, 0, 2868,
		2866, 1, 0, 0, 0, 2868, 2867, 1, 0, 0, 0, 2869, 2870, 1, 0, 0, 0, 2870,
		2955, 5, 647, 0, 0, 2871, 2872, 5, 656, 0, 0, 2872, 2875, 5, 129, 0, 0,
		2873, 2876, 3, 600, 300, 0, 2874, 2876, 5, 6, 0, 0, 2875, 2873, 1, 0, 0,
		0, 2875, 2874, 1, 0, 0, 0, 2876, 2955, 1, 0, 0, 0, 2877, 2878, 5, 363,
		0, 0, 2878, 2879, 5, 129, 0, 0, 2879, 2955, 3, 574, 287, 0, 2880, 2881,
		5, 579, 0, 0, 2881, 2882, 5, 129, 0, 0, 2882, 2883, 3, 600, 300, 0, 2883,
		2884, 5, 87, 0, 0, 2884, 2885, 5, 1131, 0, 0, 2885, 2890, 3, 116, 58, 0,
		2886, 2887, 5, 1133, 0, 0, 2887, 2889, 3, 116, 58, 0, 2888, 2886, 1, 0,
		0, 0, 2889, 2892, 1, 0, 0, 0, 2890, 2888, 1, 0, 0, 0, 2890, 2891, 1, 0,
		0, 0, 2891, 2893, 1, 0, 0, 0, 2892, 2890, 1, 0, 0, 0, 2893, 2894, 5, 1132,
		0, 0, 2894, 2955, 1, 0, 0, 0, 2895, 2896, 5, 418, 0, 0, 2896, 2897, 5,
		129, 0, 0, 2897, 2898, 3, 568, 284, 0, 2898, 2899, 5, 192, 0, 0, 2899,
		2900, 5, 172, 0, 0, 2900, 2903, 3, 542, 271, 0, 2901, 2902, 7, 37, 0, 0,
		2902, 2904, 5, 668, 0, 0, 2903, 2901, 1, 0, 0, 0, 2903, 2904, 1, 0, 0,
		0, 2904, 2955, 1, 0, 0, 0, 2905, 2906, 5, 9, 0, 0, 2906, 2909, 5, 129,
		0, 0, 2907, 2910, 3, 600, 300, 0, 2908, 2910, 5, 6, 0, 0, 2909, 2907, 1,
		0, 0, 0, 2909, 2908, 1, 0, 0, 0, 2910, 2955, 1, 0, 0, 0, 2911, 2912, 5,
		26, 0, 0, 2912, 2915, 5, 129, 0, 0, 2913, 2916, 3, 600, 300, 0, 2914, 2916,
		5, 6, 0, 0, 2915, 2913, 1, 0, 0, 0, 2915, 2914, 1, 0, 0, 0, 2916, 2955,
		1, 0, 0, 0, 2917, 2918, 5, 119, 0, 0, 2918, 2921, 5, 129, 0, 0, 2919, 2922,
		3, 600, 300, 0, 2920, 2922, 5, 6, 0, 0, 2921, 2919, 1, 0, 0, 0, 2921, 2920,
		1, 0, 0, 0, 2922, 2955, 1, 0, 0, 0, 2923, 2924, 5, 569, 0, 0, 2924, 2927,
		5, 129, 0, 0, 2925, 2928, 3, 600, 300, 0, 2926, 2928, 5, 6, 0, 0, 2927,
		2925, 1, 0, 0, 0, 2927, 2926, 1, 0, 0, 0, 2928, 2955, 1, 0, 0, 0, 2929,
		2930, 5, 580, 0, 0, 2930, 2933, 5, 129, 0, 0, 2931, 2934, 3, 600, 300,
		0, 2932, 2934, 5, 6, 0, 0, 2933, 2931, 1, 0, 0, 0, 2933, 2932, 1, 0, 0,
		0, 2934, 2955, 1, 0, 0, 0, 2935, 2936, 5, 578, 0, 0, 2936, 2955, 5, 549,
		0, 0, 2937, 2938, 5, 664, 0, 0, 2938, 2955, 5, 549, 0, 0, 2939, 2941, 5,
		5, 0, 0, 2940, 2942, 5, 28, 0, 0, 2941, 2940, 1, 0, 0, 0, 2941, 2942, 1,
		0, 0, 0, 2942, 2943, 1, 0, 0, 0, 2943, 2944, 5, 1131, 0, 0, 2944, 2949,
		3, 88, 44, 0, 2945, 2946, 5, 1133, 0, 0, 2946, 2948, 3, 88, 44, 0, 2947,
		2945, 1, 0, 0, 0, 2948, 2951, 1, 0, 0, 0, 2949, 2947, 1, 0, 0, 0, 2949,
		2950, 1, 0, 0, 0, 2950, 2952, 1, 0, 0, 0, 2951, 2949, 1, 0, 0, 0, 2952,
		2953, 5, 1132, 0, 0, 2953, 2955, 1, 0, 0, 0, 2954, 2506, 1, 0, 0, 0, 2954,
		2516, 1, 0, 0, 0, 2954, 2527, 1, 0, 0, 0, 2954, 2545, 1, 0, 0, 0, 2954,
		2560, 1, 0, 0, 0, 2954, 2582, 1, 0, 0, 0, 2954, 2606, 1, 0, 0, 0, 2954,
		2621, 1, 0, 0, 0, 2954, 2636, 1, 0, 0, 0, 2954, 2658, 1, 0, 0, 0, 2954,
		2680, 1, 0, 0, 0, 2954, 2692, 1, 0, 0, 0, 2954, 2697, 1, 0, 0, 0, 2954,
		2709, 1, 0, 0, 0, 2954, 2721, 1, 0, 0, 0, 2954, 2727, 1, 0, 0, 0, 2954,
		2732, 1, 0, 0, 0, 2954, 2743, 1, 0, 0, 0, 2954, 2751, 1, 0, 0, 0, 2954,
		2754, 1, 0, 0, 0, 2954, 2757, 1, 0, 0, 0, 2954, 2760, 1, 0, 0, 0, 2954,
		2766, 1, 0, 0, 0, 2954, 2786, 1, 0, 0, 0, 2954, 2791, 1, 0, 0, 0, 2954,
		2795, 1, 0, 0, 0, 2954, 2797, 1, 0, 0, 0, 2954, 2799, 1, 0, 0, 0, 2954,
		2807, 1, 0, 0, 0, 2954, 2810, 1, 0, 0, 0, 2954, 2823, 1, 0, 0, 0, 2954,
		2834, 1, 0, 0, 0, 2954, 2836, 1, 0, 0, 0, 2954, 2838, 1, 0, 0, 0, 2954,
		2839, 1, 0, 0, 0, 2954, 2841, 1, 0, 0, 0, 2954, 2854, 1, 0, 0, 0, 2954,
		2857, 1, 0, 0, 0, 2954, 2864, 1, 0, 0, 0, 2954, 2871, 1, 0, 0, 0, 2954,
		2877, 1, 0, 0, 0, 2954, 2880, 1, 0, 0, 0, 2954, 2895, 1, 0, 0, 0, 2954,
		2905, 1, 0, 0, 0, 2954, 2911, 1, 0, 0, 0, 2954, 2917, 1, 0, 0, 0, 2954,
		2923, 1, 0, 0, 0, 2954, 2929, 1, 0, 0, 0, 2954, 2935, 1, 0, 0, 0, 2954,
		2937, 1, 0, 0, 0, 2954, 2939, 1, 0, 0, 0, 2955, 147, 1, 0, 0, 0, 2956,
		2957, 5, 51, 0, 0, 2957, 2959, 7, 0, 0, 0, 2958, 2960, 3, 624, 312, 0,
		2959, 2958, 1, 0, 0, 0, 2959, 2960, 1, 0, 0, 0, 2960, 2961, 1, 0, 0, 0,
		2961, 2962, 3, 568, 284, 0, 2962, 149, 1, 0, 0, 0, 2963, 2964, 5, 51, 0,
		0, 2964, 2966, 5, 415, 0, 0, 2965, 2967, 3, 624, 312, 0, 2966, 2965, 1,
		0, 0, 0, 2966, 2967, 1, 0, 0, 0, 2967, 2968, 1, 0, 0, 0, 2968, 2969, 3,
		540, 270, 0, 2969, 151, 1, 0, 0, 0, 2970, 2971, 5, 51, 0, 0, 2971, 2973,
		5, 81, 0, 0, 2972, 2974, 7, 1, 0, 0, 2973, 2972, 1, 0, 0, 0, 2973, 2974,
		1, 0, 0, 0, 2974, 2975, 1, 0, 0, 0, 2975, 2976, 3, 568, 284, 0, 2976, 2977,
		5, 118, 0, 0, 2977, 2990, 3, 542, 271, 0, 2978, 2980, 5, 336, 0, 0, 2979,
		2981, 5, 1122, 0, 0, 2980, 2979, 1, 0, 0, 0, 2980, 2981, 1, 0, 0, 0, 2981,
		2982, 1, 0, 0, 0, 2982, 2989, 7, 3, 0, 0, 2983, 2985, 5, 103, 0, 0, 2984,
		2986, 5, 1122, 0, 0, 2985, 2984, 1, 0, 0, 0, 2985, 2986, 1, 0, 0, 0, 2986,
		2987, 1, 0, 0, 0, 2987, 2989, 7, 4, 0, 0, 2988, 2978, 1, 0, 0, 0, 2988,
		2983, 1, 0, 0, 0, 2989, 2992, 1, 0, 0, 0, 2990, 2988, 1, 0, 0, 0, 2990,
		2991, 1, 0, 0, 0, 2991, 153, 1, 0, 0, 0, 2992, 2990, 1, 0, 0, 0, 2993,
		2994, 5, 51, 0, 0, 2994, 2995, 5, 475, 0, 0, 2995, 2996, 5, 73, 0, 0, 2996,
		2997, 3, 568, 284, 0, 2997, 2998, 5, 409, 0, 0, 2998, 2999, 5, 1122, 0,
		0, 2999, 3000, 3, 558, 279, 0, 3000, 155, 1, 0, 0, 0, 3001, 3002, 5, 51,
		0, 0, 3002, 3004, 5, 131, 0, 0, 3003, 3005, 3, 624, 312, 0, 3004, 3003,
		1, 0, 0, 0, 3004, 3005, 1, 0, 0, 0, 3005, 3006, 1, 0, 0, 0, 3006, 3007,
		3, 540, 270, 0, 3007, 157, 1, 0, 0, 0, 3008, 3009, 5, 51, 0, 0, 3009, 3011,
		5, 437, 0, 0, 3010, 3012, 3, 624, 312, 0, 3011, 3010, 1, 0, 0, 0, 3011,
		3012, 1, 0, 0, 0, 3012, 3013, 1, 0, 0, 0, 3013, 3014, 3, 540, 270, 0, 3014,
		159, 1, 0, 0, 0, 3015, 3016, 5, 51, 0, 0, 3016, 3018, 5, 608, 0, 0, 3017,
		3019, 3, 624, 312, 0, 3018, 3017, 1, 0, 0, 0, 3018, 3019, 1, 0, 0, 0, 3019,
		3020, 1, 0, 0, 0, 3020, 3021, 3, 568, 284, 0, 3021, 161, 1, 0, 0, 0, 3022,
		3024, 5, 51, 0, 0, 3023, 3025, 5, 649, 0, 0, 3024, 3023, 1, 0, 0, 0, 3024,
		3025, 1, 0, 0, 0, 3025, 3026, 1, 0, 0, 0, 3026, 3028, 5, 172, 0, 0, 3027,
		3029, 3, 624, 312, 0, 3028, 3027, 1, 0, 0, 0, 3028, 3029, 1, 0, 0, 0, 3029,
		3030, 1, 0, 0, 0, 3030, 3032, 3, 604, 302, 0, 3031, 3033, 7, 38, 0, 0,
		3032, 3031, 1, 0, 0, 0, 3032, 3033, 1, 0, 0, 0, 3033, 163, 1, 0, 0, 0,
		3034, 3035, 5, 51, 0, 0, 3035, 3036, 5, 647, 0, 0, 3036, 3042, 3, 568,
		284, 0, 3037, 3039, 5, 409, 0, 0, 3038, 3040, 5, 1122, 0, 0, 3039, 3038,
		1, 0, 0, 0, 3039, 3040, 1, 0, 0, 0, 3040, 3041, 1, 0, 0, 0, 3041, 3043,
		3, 558, 279, 0, 3042, 3037, 1, 0, 0, 0, 3042, 3043, 1, 0, 0, 0, 3043, 165,
		1, 0, 0, 0, 3044, 3045, 5, 51, 0, 0, 3045, 3047, 5, 177, 0, 0, 3046, 3048,
		3, 624, 312, 0, 3047, 3046, 1, 0, 0, 0, 3047, 3048, 1, 0, 0, 0, 3048, 3049,
		1, 0, 0, 0, 3049, 3050, 3, 540, 270, 0, 3050, 167, 1, 0, 0, 0, 3051, 3052,
		5, 51, 0, 0, 3052, 3054, 5, 671, 0, 0, 3053, 3055, 3, 624, 312, 0, 3054,
		3053, 1, 0, 0, 0, 3054, 3055, 1, 0, 0, 0, 3055, 3056, 1, 0, 0, 0, 3056,
		3061, 3, 540, 270, 0, 3057, 3058, 5, 1133, 0, 0, 3058, 3060, 3, 540, 270,
		0, 3059, 3057, 1, 0, 0, 0, 3060, 3063, 1, 0, 0, 0, 3061, 3059, 1, 0, 0,
		0, 3061, 3062, 1, 0, 0, 0, 3062, 3065, 1, 0, 0, 0, 3063, 3061, 1, 0, 0,
		0, 3064, 3066, 7, 38, 0, 0, 3065, 3064, 1, 0, 0, 0, 3065, 3066, 1, 0, 0,
		0, 3066, 169, 1, 0, 0, 0, 3067, 3068, 5, 51, 0, 0, 3068, 3070, 5, 596,
		0, 0, 3069, 3071, 3, 624, 312, 0, 3070, 3069, 1, 0, 0, 0, 3070, 3071, 1,
		0, 0, 0, 3071, 3072, 1, 0, 0, 0, 3072, 3077, 3, 544, 272, 0, 3073, 3074,
		5, 1133, 0, 0, 3074, 3076, 3, 544, 272, 0, 3075, 3073, 1, 0, 0, 0, 3076,
		3079, 1, 0, 0, 0, 3077, 3075, 1, 0, 0, 0, 3077, 3078, 1, 0, 0, 0, 3078,
		171, 1, 0, 0, 0, 3079, 3077, 1, 0, 0, 0, 3080, 3081, 5, 153, 0, 0, 3081,
		3082, 5, 42, 0, 0, 3082, 3093, 5, 596, 0, 0, 3083, 3094, 5, 529, 0, 0,
		3084, 3094, 5, 6, 0, 0, 3085, 3090, 3, 544, 272, 0, 3086, 3087, 5, 1133,
		0, 0, 3087, 3089, 3, 544, 272, 0, 3088, 3086, 1, 0, 0, 0, 3089, 3092, 1,
		0, 0, 0, 3090, 3088, 1, 0, 0, 0, 3090, 3091, 1, 0, 0, 0, 3091, 3094, 1,
		0, 0, 0, 3092, 3090, 1, 0, 0, 0, 3093, 3083, 1, 0, 0, 0, 3093, 3084, 1,
		0, 0, 0, 3093, 3085, 1, 0, 0, 0, 3094, 3095, 1, 0, 0, 0, 3095, 3098, 5,
		175, 0, 0, 3096, 3099, 3, 550, 275, 0, 3097, 3099, 3, 568, 284, 0, 3098,
		3096, 1, 0, 0, 0, 3098, 3097, 1, 0, 0, 0, 3099, 3107, 1, 0, 0, 0, 3100,
		3103, 5, 1133, 0, 0, 3101, 3104, 3, 550, 275, 0, 3102, 3104, 3, 568, 284,
		0, 3103, 3101, 1, 0, 0, 0, 3103, 3102, 1, 0, 0, 0, 3104, 3106, 1, 0, 0,
		0, 3105, 3100, 1, 0, 0, 0, 3106, 3109, 1, 0, 0, 0, 3107, 3105, 1, 0, 0,
		0, 3107, 3108, 1, 0, 0, 0, 3108, 3114, 1, 0, 0, 0, 3109, 3107, 1, 0, 0,
		0, 3110, 3111, 5, 153, 0, 0, 3111, 3112, 5, 596, 0, 0, 3112, 3114, 3, 428,
		214, 0, 3113, 3080, 1, 0, 0, 0, 3113, 3110, 1, 0, 0, 0, 3114, 173, 1, 0,
		0, 0, 3115, 3116, 5, 139, 0, 0, 3116, 3117, 5, 172, 0, 0, 3117, 3122, 3,
		176, 88, 0, 3118, 3119, 5, 1133, 0, 0, 3119, 3121, 3, 176, 88, 0, 3120,
		3118, 1, 0, 0, 0, 3121, 3124, 1, 0, 0, 0, 3122, 3120, 1, 0, 0, 0, 3122,
		3123, 1, 0, 0, 0, 3123, 175, 1, 0, 0, 0, 3124, 3122, 1, 0, 0, 0, 3125,
		3126, 3, 542, 271, 0, 3126, 3127, 5, 175, 0, 0, 3127, 3128, 3, 542, 271,
		0, 3128, 177, 1, 0, 0, 0, 3129, 3131, 5, 656, 0, 0, 3130, 3132, 5, 172,
		0, 0, 3131, 3130, 1, 0, 0, 0, 3131, 3132, 1, 0, 0, 0, 3132, 3133, 1, 0,
		0, 0, 3133, 3134, 3, 542, 271, 0, 3134, 179, 1, 0, 0, 0, 3135, 3136, 5,
		20, 0, 0, 3136, 3143, 3, 540, 270, 0, 3137, 3140, 5, 1131, 0, 0, 3138,
		3141, 3, 612, 306, 0, 3139, 3141, 3, 608, 304, 0, 3140, 3138, 1, 0, 0,
		0, 3140, 3139, 1, 0, 0, 0, 3140, 3141, 1, 0, 0, 0, 3141, 3142, 1, 0, 0,
		0, 3142, 3144, 5, 1132, 0, 0, 3143, 3137, 1, 0, 0, 0, 3143, 3144, 1, 0,
		0, 0, 3144, 181, 1, 0, 0, 0, 3145, 3148, 3, 210, 105, 0, 3146, 3148, 3,
		212, 106, 0, 3147, 3145, 1, 0, 0, 0, 3147, 3146, 1, 0, 0, 0, 3148, 183,
		1, 0, 0, 0, 3149, 3150, 5, 399, 0, 0, 3150, 3151, 3, 608, 304, 0, 3151,
		185, 1, 0, 0, 0, 3152, 3157, 3, 214, 107, 0, 3153, 3157, 3, 216, 108, 0,
		3154, 3157, 3, 218, 109, 0, 3155, 3157, 3, 220, 110, 0, 3156, 3152, 1,
		0, 0, 0, 3156, 3153, 1, 0, 0, 0, 3156, 3154, 1, 0, 0, 0, 3156, 3155, 1,
		0, 0, 0, 3157, 187, 1, 0, 0, 0, 3158, 3160, 5, 85, 0, 0, 3159, 3161, 7,
		39, 0, 0, 3160, 3159, 1, 0, 0, 0, 3160, 3161, 1, 0, 0, 0, 3161, 3163, 1,
		0, 0, 0, 3162, 3164, 5, 78, 0, 0, 3163, 3162, 1, 0, 0, 0, 3163, 3164, 1,
		0, 0, 0, 3164, 3166, 1, 0, 0, 0, 3165, 3167, 5, 87, 0, 0, 3166, 3165, 1,
		0, 0, 0, 3166, 3167, 1, 0, 0, 0, 3167, 3168, 1, 0, 0, 0, 3168, 3175, 3,
		542, 271, 0, 3169, 3170, 5, 129, 0, 0, 3170, 3172, 5, 1131, 0, 0, 3171,
		3173, 3, 600, 300, 0, 3172, 3171, 1, 0, 0, 0, 3172, 3173, 1, 0, 0, 0, 3173,
		3174, 1, 0, 0, 0, 3174, 3176, 5, 1132, 0, 0, 3175, 3169, 1, 0, 0, 0, 3175,
		3176, 1, 0, 0, 0, 3176, 3193, 1, 0, 0, 0, 3177, 3178, 5, 1131, 0, 0, 3178,
		3179, 3, 602, 301, 0, 3179, 3180, 5, 1132, 0, 0, 3180, 3182, 1, 0, 0, 0,
		3181, 3177, 1, 0, 0, 0, 3181, 3182, 1, 0, 0, 0, 3182, 3183, 1, 0, 0, 0,
		3183, 3194, 3, 202, 101, 0, 3184, 3185, 5, 153, 0, 0, 3185, 3190, 3, 204,
		102, 0, 3186, 3187, 5, 1133, 0, 0, 3187, 3189, 3, 204, 102, 0, 3188, 3186,
		1, 0, 0, 0, 3189, 3192, 1, 0, 0, 0, 3190, 3188, 1, 0, 0, 0, 3190, 3191,
		1, 0, 0, 0, 3191, 3194, 1, 0, 0, 0, 3192, 3190, 1, 0, 0, 0, 3193, 3181,
		1, 0, 0, 0, 3193, 3184, 1, 0, 0, 0, 3194, 3210, 1, 0, 0, 0, 3195, 3196,
		5, 12, 0, 0, 3196, 3208, 3, 568, 284, 0, 3197, 3198, 5, 1131, 0, 0, 3198,
		3203, 3, 568, 284, 0, 3199, 3200, 5, 1133, 0, 0, 3200, 3202, 3, 568, 284,
		0, 3201, 3199, 1, 0, 0, 0, 3202, 3205, 1, 0, 0, 0, 3203, 3201, 1, 0, 0,
		0, 3203, 3204, 1, 0, 0, 0, 3204, 3206, 1, 0, 0, 0, 3205, 3203, 1, 0, 0,
		0, 3206, 3207, 5, 1132, 0, 0, 3207, 3209, 1, 0, 0, 0, 3208, 3197, 1, 0,
		0, 0, 3208, 3209, 1, 0, 0, 0, 3209, 3211, 1, 0, 0, 0, 3210, 3195, 1, 0,
		0, 0, 3210, 3211, 1, 0, 0, 0, 3211, 3224, 1, 0, 0, 0, 3212, 3213, 5, 118,
		0, 0, 3213, 3214, 5, 401, 0, 0, 3214, 3215, 5, 91, 0, 0, 3215, 3216, 5,
		184, 0, 0, 3216, 3221, 3, 204, 102, 0, 3217, 3218, 5, 1133, 0, 0, 3218,
		3220, 3, 204, 102, 0, 3219, 3217, 1, 0, 0, 0, 3220, 3223, 1, 0, 0, 0, 3221,
		3219, 1, 0, 0, 0, 3221, 3222, 1, 0, 0, 0, 3222, 3225, 1, 0, 0, 0, 3223,
		3221, 1, 0, 0, 0, 3224, 3212, 1, 0, 0, 0, 3224, 3225, 1, 0, 0, 0, 3225,
		189, 1, 0, 0, 0, 3226, 3227, 5, 102, 0, 0, 3227, 3229, 5, 388, 0, 0, 3228,
		3230, 7, 40, 0, 0, 3229, 3228, 1, 0, 0, 0, 3229, 3230, 1, 0, 0, 0, 3230,
		3232, 1, 0, 0, 0, 3231, 3233, 5, 474, 0, 0, 3232, 3231, 1, 0, 0, 0, 3232,
		3233, 1, 0, 0, 0, 3233, 3234, 1, 0, 0, 0, 3234, 3235, 5, 82, 0, 0, 3235,
		3237, 5, 1146, 0, 0, 3236, 3238, 7, 6, 0, 0, 3237, 3236, 1, 0, 0, 0, 3237,
		3238, 1, 0, 0, 0, 3238, 3239, 1, 0, 0, 0, 3239, 3240, 5, 87, 0, 0, 3240,
		3241, 5, 172, 0, 0, 3241, 3247, 3, 542, 271, 0, 3242, 3243, 5, 129, 0,
		0, 3243, 3244, 5, 1131, 0, 0, 3244, 3245, 3, 600, 300, 0, 3245, 3246, 5,
		1132, 0, 0, 3246, 3248, 1, 0, 0, 0, 3247, 3242, 1, 0, 0, 0, 3247, 3248,
		1, 0, 0, 0, 3248, 3252, 1, 0, 0, 0, 3249, 3250, 5, 25, 0, 0, 3250, 3251,
		5, 153, 0, 0, 3251, 3253, 3, 554, 277, 0, 3252, 3249, 1, 0, 0, 0, 3252,
		3253, 1, 0, 0, 0, 3253, 3260, 1, 0, 0, 0, 3254, 3256, 7, 41, 0, 0, 3255,
		3257, 3, 274, 137, 0, 3256, 3255, 1, 0, 0, 0, 3257, 3258, 1, 0, 0, 0, 3258,
		3256, 1, 0, 0, 0, 3258, 3259, 1, 0, 0, 0, 3259, 3261, 1, 0, 0, 0, 3260,
		3254, 1, 0, 0, 0, 3260, 3261, 1, 0, 0, 0, 3261, 3268, 1, 0, 0, 0, 3262,
		3264, 5, 101, 0, 0, 3263, 3265, 3, 276, 138, 0, 3264, 3263, 1, 0, 0, 0,
		3265, 3266, 1, 0, 0, 0, 3266, 3264, 1, 0, 0, 0, 3266, 3267, 1, 0, 0, 0,
		3267, 3269, 1, 0, 0, 0, 3268, 3262, 1, 0, 0, 0, 3268, 3269, 1, 0, 0, 0,
		3269, 3274, 1, 0, 0, 0, 3270, 3271, 5, 78, 0, 0, 3271, 3272, 3, 574, 287,
		0, 3272, 3273, 7, 42, 0, 0, 3273, 3275, 1, 0, 0, 0, 3274, 3270, 1, 0, 0,
		0, 3274, 3275, 1, 0, 0, 0, 3275, 3287, 1, 0, 0, 0, 3276, 3277, 5, 1131,
		0, 0, 3277, 3282, 3, 206, 103, 0, 3278, 3279, 5, 1133, 0, 0, 3279, 3281,
		3, 206, 103, 0, 3280, 3278, 1, 0, 0, 0, 3281, 3284, 1, 0, 0, 0, 3282, 3280,
		1, 0, 0, 0, 3282, 3283, 1, 0, 0, 0, 3283, 3285, 1, 0, 0, 0, 3284, 3282,
		1, 0, 0, 0, 3285, 3286, 5, 1132, 0, 0, 3286, 3288, 1, 0, 0, 0, 3287, 3276,
		1, 0, 0, 0, 3287, 3288, 1, 0, 0, 0, 3288, 3298, 1, 0, 0, 0, 3289, 3290,
		5, 153, 0, 0, 3290, 3295, 3, 204, 102, 0, 3291, 3292, 5, 1133, 0, 0, 3292,
		3294, 3, 204, 102, 0, 3293, 3291, 1, 0, 0, 0, 3294, 3297, 1, 0, 0, 0, 3295,
		3293, 1, 0, 0, 0, 3295, 3296, 1, 0, 0, 0, 3296, 3299, 1, 0, 0, 0, 3297,
		3295, 1, 0, 0, 0, 3298, 3289, 1, 0, 0, 0, 3298, 3299, 1, 0, 0, 0, 3299,
		191, 1, 0, 0, 0, 3300, 3301, 5, 102, 0, 0, 3301, 3303, 5, 682, 0, 0, 3302,
		3304, 7, 40, 0, 0, 3303, 3302, 1, 0, 0, 0, 3303, 3304, 1, 0, 0, 0, 3304,
		3306, 1, 0, 0, 0, 3305, 3307, 5, 474, 0, 0, 3306, 3305, 1, 0, 0, 0, 3306,
		3307, 1, 0, 0, 0, 3307, 3308, 1, 0, 0, 0, 3308, 3309, 5, 82, 0, 0, 3309,
		3311, 5, 1146, 0, 0, 3310, 3312, 7, 6, 0, 0, 3311, 3310, 1, 0, 0, 0, 3311,
		3312, 1, 0, 0, 0, 3312, 3313, 1, 0, 0, 0, 3313, 3314, 5, 87, 0, 0, 3314,
		3315, 5, 172, 0, 0, 3315, 3319, 3, 542, 271, 0, 3316, 3317, 5, 25, 0, 0,
		3317, 3318, 5, 153, 0, 0, 3318, 3320, 3, 554, 277, 0, 3319, 3316, 1, 0,
		0, 0, 3319, 3320, 1, 0, 0, 0, 3320, 3327, 1, 0, 0, 0, 3321, 3322, 5, 601,
		0, 0, 3322, 3323, 5, 448, 0, 0, 3323, 3324, 5, 19, 0, 0, 3324, 3325, 5,
		1124, 0, 0, 3325, 3326, 5, 1146, 0, 0, 3326, 3328, 5, 1123, 0, 0, 3327,
		3321, 1, 0, 0, 0, 3327, 3328, 1, 0, 0, 0, 3328, 3333, 1, 0, 0, 0, 3329,
		3330, 5, 78, 0, 0, 3330, 3331, 3, 574, 287, 0, 3331, 3332, 7, 42, 0, 0,
		3332, 3334, 1, 0, 0, 0, 3333, 3329, 1, 0, 0, 0, 3333, 3334, 1, 0, 0, 0,
		3334, 3346, 1, 0, 0, 0, 3335, 3336, 5, 1131, 0, 0, 3336, 3341, 3, 206,
		103, 0, 3337, 3338, 5, 1133, 0, 0, 3338, 3340, 3, 206, 103, 0, 3339, 3337,
		1, 0, 0, 0, 3340, 3343, 1, 0, 0, 0, 3341, 3339, 1, 0, 0, 0, 3341, 3342,
		1, 0, 0, 0, 3342, 3344, 1, 0, 0, 0, 3343, 3341, 1, 0, 0, 0, 3344, 3345,
		5, 1132, 0, 0, 3345, 3347, 1, 0, 0, 0, 3346, 3335, 1, 0, 0, 0, 3346, 3347,
		1, 0, 0, 0, 3347, 3357, 1, 0, 0, 0, 3348, 3349, 5, 153, 0, 0, 3349, 3354,
		3, 204, 102, 0, 3350, 3351, 5, 1133, 0, 0, 3351, 3353, 3, 204, 102, 0,
		3352, 3350, 1, 0, 0, 0, 3353, 3356, 1, 0, 0, 0, 3354, 3352, 1, 0, 0, 0,
		3354, 3355, 1, 0, 0, 0, 3355, 3358, 1, 0, 0, 0, 3356, 3354, 1, 0, 0, 0,
		3357, 3348, 1, 0, 0, 0, 3357, 3358, 1, 0, 0, 0, 3358, 193, 1, 0, 0, 0,
		3359, 3361, 5, 141, 0, 0, 3360, 3362, 7, 43, 0, 0, 3361, 3360, 1, 0, 0,
		0, 3361, 3362, 1, 0, 0, 0, 3362, 3364, 1, 0, 0, 0, 3363, 3365, 5, 87, 0,
		0, 3364, 3363, 1, 0, 0, 0, 3364, 3365, 1, 0, 0, 0, 3365, 3366, 1, 0, 0,
		0, 3366, 3372, 3, 542, 271, 0, 3367, 3368, 5, 129, 0, 0, 3368, 3369, 5,
		1131, 0, 0, 3369, 3370, 3, 600, 300, 0, 3370, 3371, 5, 1132, 0, 0, 3371,
		3373, 1, 0, 0, 0, 3372, 3367, 1, 0, 0, 0, 3372, 3373, 1, 0, 0, 0, 3373,
		3390, 1, 0, 0, 0, 3374, 3375, 5, 1131, 0, 0, 3375, 3376, 3, 600, 300, 0,
		3376, 3377, 5, 1132, 0, 0, 3377, 3379, 1, 0, 0, 0, 3378, 3374, 1, 0, 0,
		0, 3378, 3379, 1, 0, 0, 0, 3379, 3380, 1, 0, 0, 0, 3380, 3391, 3, 202,
		101, 0, 3381, 3382, 5, 153, 0, 0, 3382, 3387, 3, 204, 102, 0, 3383, 3384,
		5, 1133, 0, 0, 3384, 3386, 3, 204, 102, 0, 3385, 3383, 1, 0, 0, 0, 3386,
		3389, 1, 0, 0, 0, 3387, 3385, 1, 0, 0, 0, 3387, 3388, 1, 0, 0, 0, 3388,
		3391, 1, 0, 0, 0, 3389, 3387, 1, 0, 0, 0, 3390, 3378, 1, 0, 0, 0, 3390,
		3381, 1, 0, 0, 0, 3391, 195, 1, 0, 0, 0, 3392, 3394, 3, 246, 123, 0, 3393,
		3395, 3, 208, 104, 0, 3394, 3393, 1, 0, 0, 0, 3394, 3395, 1, 0, 0, 0, 3395,
		3455, 1, 0, 0, 0, 3396, 3398, 3, 242, 121, 0, 3397, 3399, 3, 208, 104,
		0, 3398, 3397, 1, 0, 0, 0, 3398, 3399, 1, 0, 0, 0, 3399, 3455, 1, 0, 0,
		0, 3400, 3402, 3, 248, 124, 0, 3401, 3403, 3, 252, 126, 0, 3402, 3401,
		1, 0, 0, 0, 3403, 3404, 1, 0, 0, 0, 3404, 3402, 1, 0, 0, 0, 3404, 3405,
		1, 0, 0, 0, 3405, 3414, 1, 0, 0, 0, 3406, 3408, 5, 180, 0, 0, 3407, 3409,
		7, 44, 0, 0, 3408, 3407, 1, 0, 0, 0, 3408, 3409, 1, 0, 0, 0, 3409, 3412,
		1, 0, 0, 0, 3410, 3413, 3, 246, 123, 0, 3411, 3413, 3, 242, 121, 0, 3412,
		3410, 1, 0, 0, 0, 3412, 3411, 1, 0, 0, 0, 3413, 3415, 1, 0, 0, 0, 3414,
		3406, 1, 0, 0, 0, 3414, 3415, 1, 0, 0, 0, 3415, 3417, 1, 0, 0, 0, 3416,
		3418, 3, 226, 113, 0, 3417, 3416, 1, 0, 0, 0, 3417, 3418, 1, 0, 0, 0, 3418,
		3420, 1, 0, 0, 0, 3419, 3421, 3, 288, 144, 0, 3420, 3419, 1, 0, 0, 0, 3420,
		3421, 1, 0, 0, 0, 3421, 3423, 1, 0, 0, 0, 3422, 3424, 3, 208, 104, 0, 3423,
		3422, 1, 0, 0, 0, 3423, 3424, 1, 0, 0, 0, 3424, 3455, 1, 0, 0, 0, 3425,
		3427, 3, 244, 122, 0, 3426, 3428, 3, 250, 125, 0, 3427, 3426, 1, 0, 0,
		0, 3428, 3429, 1, 0, 0, 0, 3429, 3427, 1, 0, 0, 0, 3429, 3430, 1, 0, 0,
		0, 3430, 3436, 1, 0, 0, 0, 3431, 3433, 5, 180, 0, 0, 3432, 3434, 7, 44,
		0, 0, 3433, 3432, 1, 0, 0, 0, 3433, 3434, 1, 0, 0, 0, 3434, 3435, 1, 0,
		0, 0, 3435, 3437, 3, 242, 121, 0, 3436, 3431, 1, 0, 0, 0, 3436, 3437, 1,
		0, 0, 0, 3437, 3439, 1, 0, 0, 0, 3438, 3440, 3, 226, 113, 0, 3439, 3438,
		1, 0, 0, 0, 3439, 3440, 1, 0, 0, 0, 3440, 3442, 1, 0, 0, 0, 3441, 3443,
		3, 288, 144, 0, 3442, 3441, 1, 0, 0, 0, 3442, 3443, 1, 0, 0, 0, 3443, 3445,
		1, 0, 0, 0, 3444, 3446, 3, 208, 104, 0, 3445, 3444, 1, 0, 0, 0, 3445, 3446,
		1, 0, 0, 0, 3446, 3455, 1, 0, 0, 0, 3447, 3450, 3, 248, 124, 0, 3448, 3449,
		5, 1133, 0, 0, 3449, 3451, 3, 254, 127, 0, 3450, 3448, 1, 0, 0, 0, 3451,
		3452, 1, 0, 0, 0, 3452, 3450, 1, 0, 0, 0, 3452, 3453, 1, 0, 0, 0, 3453,
		3455, 1, 0, 0, 0, 3454, 3392, 1, 0, 0, 0, 3454, 3396, 1, 0, 0, 0, 3454,
		3400, 1, 0, 0, 0, 3454, 3425, 1, 0, 0, 0, 3454, 3447, 1, 0, 0, 0, 3455,
		197, 1, 0, 0, 0, 3456, 3459, 3, 222, 111, 0, 3457, 3459, 3, 224, 112, 0,
		3458, 3456, 1, 0, 0, 0, 3458, 3457, 1, 0, 0, 0, 3459, 199, 1, 0, 0, 0,
		3460, 3461, 5, 188, 0, 0, 3461, 3463, 5, 1131, 0, 0, 3462, 3464, 3, 610,
		305, 0, 3463, 3462, 1, 0, 0, 0, 3463, 3464, 1, 0, 0, 0, 3464, 3465, 1,
		0, 0, 0, 3465, 3474, 5, 1132, 0, 0, 3466, 3467, 5, 1133, 0, 0, 3467, 3469,
		5, 1131, 0, 0, 3468, 3470, 3, 610, 305, 0, 3469, 3468, 1, 0, 0, 0, 3469,
		3470, 1, 0, 0, 0, 3470, 3471, 1, 0, 0, 0, 3471, 3473, 5, 1132, 0, 0, 3472,
		3466, 1, 0, 0, 0, 3473, 3476, 1, 0, 0, 0, 3474, 3472, 1, 0, 0, 0, 3474,
		3475, 1, 0, 0, 0, 3475, 201, 1, 0, 0, 0, 3476, 3474, 1, 0, 0, 0, 3477,
		3496, 3, 196, 98, 0, 3478, 3479, 7, 45, 0, 0, 3479, 3481, 5, 1131, 0, 0,
		3480, 3482, 3, 610, 305, 0, 3481, 3480, 1, 0, 0, 0, 3481, 3482, 1, 0, 0,
		0, 3482, 3483, 1, 0, 0, 0, 3483, 3492, 5, 1132, 0, 0, 3484, 3485, 5, 1133,
		0, 0, 3485, 3487, 5, 1131, 0, 0, 3486, 3488, 3, 610, 305, 0, 3487, 3486,
		1, 0, 0, 0, 3487, 3488, 1, 0, 0, 0, 3488, 3489, 1, 0, 0, 0, 3489, 3491,
		5, 1132, 0, 0, 3490, 3484, 1, 0, 0, 0, 3491, 3494, 1, 0, 0, 0, 3492, 3490,
		1, 0, 0, 0, 3492, 3493, 1, 0, 0, 0, 3493, 3496, 1, 0, 0, 0, 3494, 3492,
		1, 0, 0, 0, 3495, 3477, 1, 0, 0, 0, 3495, 3478, 1, 0, 0, 0, 3496, 203,
		1, 0, 0, 0, 3497, 3498, 3, 546, 273, 0, 3498, 3501, 5, 1122, 0, 0, 3499,
		3502, 3, 672, 336, 0, 3500, 3502, 5, 42, 0, 0, 3501, 3499, 1, 0, 0, 0,
		3501, 3500, 1, 0, 0, 0, 3502, 205, 1, 0, 0, 0, 3503, 3506, 3, 568, 284,
		0, 3504, 3506, 5, 1158, 0, 0, 3505, 3503, 1, 0, 0, 0, 3505, 3504, 1, 0,
		0, 0, 3506, 207, 1, 0, 0, 0, 3507, 3508, 5, 65, 0, 0, 3508, 3514, 5, 184,
		0, 0, 3509, 3510, 5, 103, 0, 0, 3510, 3511, 5, 80, 0, 0, 3511, 3512, 5,
		610, 0, 0, 3512, 3514, 5, 511, 0, 0, 3513, 3507, 1, 0, 0, 0, 3513, 3509,
		1, 0, 0, 0, 3514, 209, 1, 0, 0, 0, 3515, 3517, 5, 44, 0, 0, 3516, 3518,
		5, 106, 0, 0, 3517, 3516, 1, 0, 0, 0, 3517, 3518, 1, 0, 0, 0, 3518, 3520,
		1, 0, 0, 0, 3519, 3521, 5, 568, 0, 0, 3520, 3519, 1, 0, 0, 0, 3520, 3521,
		1, 0, 0, 0, 3521, 3523, 1, 0, 0, 0, 3522, 3524, 5, 78, 0, 0, 3523, 3522,
		1, 0, 0, 0, 3523, 3524, 1, 0, 0, 0, 3524, 3525, 1, 0, 0, 0, 3525, 3526,
		5, 68, 0, 0, 3526, 3531, 3, 542, 271, 0, 3527, 3529, 5, 12, 0, 0, 3528,
		3527, 1, 0, 0, 0, 3528, 3529, 1, 0, 0, 0, 3529, 3530, 1, 0, 0, 0, 3530,
		3532, 3, 568, 284, 0, 3531, 3528, 1, 0, 0, 0, 3531, 3532, 1, 0, 0, 0, 3532,
		3538, 1, 0, 0, 0, 3533, 3534, 5, 129, 0, 0, 3534, 3535, 5, 1131, 0, 0,
		3535, 3536, 3, 600, 300, 0, 3536, 3537, 5, 1132, 0, 0, 3537, 3539, 1, 0,
		0, 0, 3538, 3533, 1, 0, 0, 0, 3538, 3539, 1, 0, 0, 0, 3539, 3542, 1, 0,
		0, 0, 3540, 3541, 5, 190, 0, 0, 3541, 3543, 3, 672, 336, 0, 3542, 3540,
		1, 0, 0, 0, 3542, 3543, 1, 0, 0, 0, 3543, 3545, 1, 0, 0, 0, 3544, 3546,
		3, 226, 113, 0, 3545, 3544, 1, 0, 0, 0, 3545, 3546, 1, 0, 0, 0, 3546, 3549,
		1, 0, 0, 0, 3547, 3548, 5, 99, 0, 0, 3548, 3550, 3, 290, 145, 0, 3549,
		3547, 1, 0, 0, 0, 3549, 3550, 1, 0, 0, 0, 3550, 211, 1, 0, 0, 0, 3551,
		3553, 5, 44, 0, 0, 3552, 3554, 5, 106, 0, 0, 3553, 3552, 1, 0, 0, 0, 3553,
		3554, 1, 0, 0, 0, 3554, 3556, 1, 0, 0, 0, 3555, 3557, 5, 568, 0, 0, 3556,
		3555, 1, 0, 0, 0, 3556, 3557, 1, 0, 0, 0, 3557, 3559, 1, 0, 0, 0, 3558,
		3560, 5, 78, 0, 0, 3559, 3558, 1, 0, 0, 0, 3559, 3560, 1, 0, 0, 0, 3560,
		3600, 1, 0, 0, 0, 3561, 3564, 3, 542, 271, 0, 3562, 3563, 5, 1130, 0, 0,
		3563, 3565, 5, 1115, 0, 0, 3564, 3562, 1, 0, 0, 0, 3564, 3565, 1, 0, 0,
		0, 3565, 3574, 1, 0, 0, 0, 3566, 3567, 5, 1133, 0, 0, 3567, 3570, 3, 542,
		271, 0, 3568, 3569, 5, 1130, 0, 0, 3569, 3571, 5, 1115, 0, 0, 3570, 3568,
		1, 0, 0, 0, 3570, 3571, 1, 0, 0, 0, 3571, 3573, 1, 0, 0, 0, 3572, 3566,
		1, 0, 0, 0, 3573, 3576, 1, 0, 0, 0, 3574, 3572, 1, 0, 0, 0, 3574, 3575,
		1, 0, 0, 0, 3575, 3577, 1, 0, 0, 0, 3576, 3574, 1, 0, 0, 0, 3577, 3578,
		5, 68, 0, 0, 3578, 3579, 3, 230, 115, 0, 3579, 3601, 1, 0, 0, 0, 3580,
		3581, 5, 68, 0, 0, 3581, 3584, 3, 542, 271, 0, 3582, 3583, 5, 1130, 0,
		0, 3583, 3585, 5, 1115, 0, 0, 3584, 3582, 1, 0, 0, 0, 3584, 3585, 1, 0,
		0, 0, 3585, 3594, 1, 0, 0, 0, 3586, 3587, 5, 1133, 0, 0, 3587, 3590, 3,
		542, 271, 0, 3588, 3589, 5, 1130, 0, 0, 3589, 3591, 5, 1115, 0, 0, 3590,
		3588, 1, 0, 0, 0, 3590, 3591, 1, 0, 0, 0, 3591, 3593, 1, 0, 0, 0, 3592,
		3586, 1, 0, 0, 0, 3593, 3596, 1, 0, 0, 0, 3594, 3592, 1, 0, 0, 0, 3594,
		3595, 1, 0, 0, 0, 3595, 3597, 1, 0, 0, 0, 3596, 3594, 1, 0, 0, 0, 3597,
		3598, 5, 187, 0, 0, 3598, 3599, 3, 230, 115, 0, 3599, 3601, 1, 0, 0, 0,
		3600, 3561, 1, 0, 0, 0, 3600, 3580, 1, 0, 0, 0, 3601, 3604, 1, 0, 0, 0,
		3602, 3603, 5, 190, 0, 0, 3603, 3605, 3, 672, 336, 0, 3604, 3602, 1, 0,
		0, 0, 3604, 3605, 1, 0, 0, 0, 3605, 213, 1, 0, 0, 0, 3606, 3607, 5, 442,
		0, 0, 3607, 3608, 3, 542, 271, 0, 3608, 3613, 5, 539, 0, 0, 3609, 3611,
		5, 12, 0, 0, 3610, 3609, 1, 0, 0, 0, 3610, 3611, 1, 0, 0, 0, 3611, 3612,
		1, 0, 0, 0, 3612, 3614, 3, 568, 284, 0, 3613, 3610, 1, 0, 0, 0, 3613, 3614,
		1, 0, 0, 0, 3614, 215, 1, 0, 0, 0, 3615, 3616, 5, 442, 0, 0, 3616, 3617,
		3, 542, 271, 0, 3617, 3618, 5, 134, 0, 0, 3618, 3625, 3, 568, 284, 0, 3619,
		3620, 3, 680, 340, 0, 3620, 3621, 5, 1131, 0, 0, 3621, 3622, 3, 612, 306,
		0, 3622, 3623, 5, 1132, 0, 0, 3623, 3626, 1, 0, 0, 0, 3624, 3626, 7, 46,
		0, 0, 3625, 3619, 1, 0, 0, 0, 3625, 3624, 1, 0, 0, 0, 3626, 3629, 1, 0,
		0, 0, 3627, 3628, 5, 190, 0, 0, 3628, 3630, 3, 672, 336, 0, 3629, 3627,
		1, 0, 0, 0, 3629, 3630, 1, 0, 0, 0, 3630, 3633, 1, 0, 0, 0, 3631, 3632,
		5, 99, 0, 0, 3632, 3634, 3, 290, 145, 0, 3633, 3631, 1, 0, 0, 0, 3633,
		3634, 1, 0, 0, 0, 3634, 217, 1, 0, 0, 0, 3635, 3636, 5, 442, 0, 0, 3636,
		3637, 3, 542, 271, 0, 3637, 3638, 5, 134, 0, 0, 3638, 3641, 7, 47, 0, 0,
		3639, 3640, 5, 190, 0, 0, 3640, 3642, 3, 672, 336, 0, 3641, 3639, 1, 0,
		0, 0, 3641, 3642, 1, 0, 0, 0, 3642, 3645, 1, 0, 0, 0, 3643, 3644, 5, 99,
		0, 0, 3644, 3646, 3, 290, 145, 0, 3645, 3643, 1, 0, 0, 0, 3645, 3646, 1,
		0, 0, 0, 3646, 219, 1, 0, 0, 0, 3647, 3648, 5, 442, 0, 0, 3648, 3649, 3,
		542, 271, 0, 3649, 3650, 5, 361, 0, 0, 3650, 221, 1, 0, 0, 0, 3651, 3653,
		5, 184, 0, 0, 3652, 3654, 5, 106, 0, 0, 3653, 3652, 1, 0, 0, 0, 3653, 3654,
		1, 0, 0, 0, 3654, 3656, 1, 0, 0, 0, 3655, 3657, 5, 78, 0, 0, 3656, 3655,
		1, 0, 0, 0, 3656, 3657, 1, 0, 0, 0, 3657, 3658, 1, 0, 0, 0, 3658, 3663,
		3, 542, 271, 0, 3659, 3661, 5, 12, 0, 0, 3660, 3659, 1, 0, 0, 0, 3660,
		3661, 1, 0, 0, 0, 3661, 3662, 1, 0, 0, 0, 3662, 3664, 3, 568, 284, 0, 3663,
		3660, 1, 0, 0, 0, 3663, 3664, 1, 0, 0, 0, 3664, 3665, 1, 0, 0, 0, 3665,
		3666, 5, 153, 0, 0, 3666, 3671, 3, 204, 102, 0, 3667, 3668, 5, 1133, 0,
		0, 3668, 3670, 3, 204, 102, 0, 3669, 3667, 1, 0, 0, 0, 3670, 3673, 1, 0,
		0, 0, 3671, 3669, 1, 0, 0, 0, 3671, 3672, 1, 0, 0, 0, 3672, 3676, 1, 0,
		0, 0, 3673, 3671, 1, 0, 0, 0, 3674, 3675, 5, 190, 0, 0, 3675, 3677, 3,
		672, 336, 0, 3676, 3674, 1, 0, 0, 0, 3676, 3677, 1, 0, 0, 0, 3677, 3679,
		1, 0, 0, 0, 3678, 3680, 3, 226, 113, 0, 3679, 3678, 1, 0, 0, 0, 3679, 3680,
		1, 0, 0, 0, 3680, 3682, 1, 0, 0, 0, 3681, 3683, 3, 288, 144, 0, 3682, 3681,
		1, 0, 0, 0, 3682, 3683, 1, 0, 0, 0, 3683, 223, 1, 0, 0, 0, 3684, 3686,
		5, 184, 0, 0, 3685, 3687, 5, 106, 0, 0, 3686, 3685, 1, 0, 0, 0, 3686, 3687,
		1, 0, 0, 0, 3687, 3689, 1, 0, 0, 0, 3688, 3690, 5, 78, 0, 0, 3689, 3688,
		1, 0, 0, 0, 3689, 3690, 1, 0, 0, 0, 3690, 3691, 1, 0, 0, 0, 3691, 3692,
		3, 230, 115, 0, 3692, 3693, 5, 153, 0, 0, 3693, 3698, 3, 204, 102, 0, 3694,
		3695, 5, 1133, 0, 0, 3695, 3697, 3, 204, 102, 0, 3696, 3694, 1, 0, 0, 0,
		3697, 3700, 1, 0, 0, 0, 3698, 3696, 1, 0, 0, 0, 3698, 3699, 1, 0, 0, 0,
		3699, 3703, 1, 0, 0, 0, 3700, 3698, 1, 0, 0, 0, 3701, 3702, 5, 190, 0,
		0, 3702, 3704, 3, 672, 336, 0, 3703, 3701, 1, 0, 0, 0, 3703, 3704, 1, 0,
		0, 0, 3704, 225, 1, 0, 0, 0, 3705, 3706, 5, 124, 0, 0, 3706, 3707, 5, 19,
		0, 0, 3707, 3712, 3, 228, 114, 0, 3708, 3709, 5, 1133, 0, 0, 3709, 3711,
		3, 228, 114, 0, 3710, 3708, 1, 0, 0, 0, 3711, 3714, 1, 0, 0, 0, 3712, 3710,
		1, 0, 0, 0, 3712, 3713, 1, 0, 0, 0, 3713, 227, 1, 0, 0, 0, 3714, 3712,
		1, 0, 0, 0, 3715, 3717, 3, 672, 336, 0, 3716, 3718, 7, 48, 0, 0, 3717,
		3716, 1, 0, 0, 0, 3717, 3718, 1, 0, 0, 0, 3718, 229, 1, 0, 0, 0, 3719,
		3724, 3, 232, 116, 0, 3720, 3721, 5, 1133, 0, 0, 3721, 3723, 3, 232, 116,
		0, 3722, 3720, 1, 0, 0, 0, 3723, 3726, 1, 0, 0, 0, 3724, 3722, 1, 0, 0,
		0, 3724, 3725, 1, 0, 0, 0, 3725, 231, 1, 0, 0, 0, 3726, 3724, 1, 0, 0,
		0, 3727, 3731, 3, 234, 117, 0, 3728, 3730, 3, 240, 120, 0, 3729, 3728,
		1, 0, 0, 0, 3730, 3733, 1, 0, 0, 0, 3731, 3729, 1, 0, 0, 0, 3731, 3732,
		1, 0, 0, 0, 3732, 3746, 1, 0, 0, 0, 3733, 3731, 1, 0, 0, 0, 3734, 3735,
		5, 1131, 0, 0, 3735, 3739, 3, 234, 117, 0, 3736, 3738, 3, 240, 120, 0,
		3737, 3736, 1, 0, 0, 0, 3738, 3741, 1, 0, 0, 0, 3739, 3737, 1, 0, 0, 0,
		3739, 3740, 1, 0, 0, 0, 3740, 3742, 1, 0, 0, 0, 3741, 3739, 1, 0, 0, 0,
		3742, 3743, 5, 1132, 0, 0, 3743, 3746, 1, 0, 0, 0, 3744, 3746, 3, 256,
		128, 0, 3745, 3727, 1, 0, 0, 0, 3745, 3734, 1, 0, 0, 0, 3745, 3744, 1,
		0, 0, 0, 3746, 233, 1, 0, 0, 0, 3747, 3753, 3, 542, 271, 0, 3748, 3749,
		5, 129, 0, 0, 3749, 3750, 5, 1131, 0, 0, 3750, 3751, 3, 600, 300, 0, 3751,
		3752, 5, 1132, 0, 0, 3752, 3754, 1, 0, 0, 0, 3753, 3748, 1, 0, 0, 0, 3753,
		3754, 1, 0, 0, 0, 3754, 3759, 1, 0, 0, 0, 3755, 3757, 5, 12, 0, 0, 3756,
		3755, 1, 0, 0, 0, 3756, 3757, 1, 0, 0, 0, 3757, 3758, 1, 0, 0, 0, 3758,
		3760, 3, 568, 284, 0, 3759, 3756, 1, 0, 0, 0, 3759, 3760, 1, 0, 0, 0, 3760,
		3769, 1, 0, 0, 0, 3761, 3766, 3, 236, 118, 0, 3762, 3763, 5, 1133, 0, 0,
		3763, 3765, 3, 236, 118, 0, 3764, 3762, 1, 0, 0, 0, 3765, 3768, 1, 0, 0,
		0, 3766, 3764, 1, 0, 0, 0, 3766, 3767, 1, 0, 0, 0, 3767, 3770, 1, 0, 0,
		0, 3768, 3766, 1, 0, 0, 0, 3769, 3761, 1, 0, 0, 0, 3769, 3770, 1, 0, 0,
		0, 3770, 3788, 1, 0, 0, 0, 3771, 3777, 3, 196, 98, 0, 3772, 3773, 5, 1131,
		0, 0, 3773, 3774, 3, 196, 98, 0, 3774, 3775, 5, 1132, 0, 0, 3775, 3777,
		1, 0, 0, 0, 3776, 3771, 1, 0, 0, 0, 3776, 3772, 1, 0, 0, 0, 3777, 3779,
		1, 0, 0, 0, 3778, 3780, 5, 12, 0, 0, 3779, 3778, 1, 0, 0, 0, 3779, 3780,
		1, 0, 0, 0, 3780, 3781, 1, 0, 0, 0, 3781, 3782, 3, 568, 284, 0, 3782, 3788,
		1, 0, 0, 0, 3783, 3784, 5, 1131, 0, 0, 3784, 3785, 3, 230, 115, 0, 3785,
		3786, 5, 1132, 0, 0, 3786, 3788, 1, 0, 0, 0, 3787, 3747, 1, 0, 0, 0, 3787,
		3776, 1, 0, 0, 0, 3787, 3783, 1, 0, 0, 0, 3788, 235, 1, 0, 0, 0, 3789,
		3790, 7, 49, 0, 0, 3790, 3793, 7, 20, 0, 0, 3791, 3792, 5, 65, 0, 0, 3792,
		3794, 3, 238, 119, 0, 3793, 3791, 1, 0, 0, 0, 3793, 3794, 1, 0, 0, 0, 3794,
		3795, 1, 0, 0, 0, 3795, 3796, 5, 1131, 0, 0, 3796, 3797, 3, 600, 300, 0,
		3797, 3798, 5, 1132, 0, 0, 3798, 237, 1, 0, 0, 0, 3799, 3805, 5, 90, 0,
		0, 3800, 3801, 5, 124, 0, 0, 3801, 3805, 5, 19, 0, 0, 3802, 3803, 5, 73,
		0, 0, 3803, 3805, 5, 19, 0, 0, 3804, 3799, 1, 0, 0, 0, 3804, 3800, 1, 0,
		0, 0, 3804, 3802, 1, 0, 0, 0, 3805, 239, 1, 0, 0, 0, 3806, 3808, 7, 50,
		0, 0, 3807, 3806, 1, 0, 0, 0, 3807, 3808, 1, 0, 0, 0, 3808, 3809, 1, 0,
		0, 0, 3809, 3811, 5, 90, 0, 0, 3810, 3812, 5, 94, 0, 0, 3811, 3810, 1,
		0, 0, 0, 3811, 3812, 1, 0, 0, 0, 3812, 3813, 1, 0, 0, 0, 3813, 3821, 3,
		234, 117, 0, 3814, 3815, 5, 118, 0, 0, 3815, 3822, 3, 672, 336, 0, 3816,
		3817, 5, 187, 0, 0, 3817, 3818, 5, 1131, 0, 0, 3818, 3819, 3, 600, 300,
		0, 3819, 3820, 5, 1132, 0, 0, 3820, 3822, 1, 0, 0, 0, 3821, 3814, 1, 0,
		0, 0, 3821, 3816, 1, 0, 0, 0, 3821, 3822, 1, 0, 0, 0, 3822, 3857, 1, 0,
		0, 0, 3823, 3824, 5, 171, 0, 0, 3824, 3827, 3, 234, 117, 0, 3825, 3826,
		5, 118, 0, 0, 3826, 3828, 3, 672, 336, 0, 3827, 3825, 1, 0, 0, 0, 3827,
		3828, 1, 0, 0, 0, 3828, 3857, 1, 0, 0, 0, 3829, 3831, 7, 51, 0, 0, 3830,
		3832, 5, 126, 0, 0, 3831, 3830, 1, 0, 0, 0, 3831, 3832, 1, 0, 0, 0, 3832,
		3833, 1, 0, 0, 0, 3833, 3835, 5, 90, 0, 0, 3834, 3836, 5, 94, 0, 0, 3835,
		3834, 1, 0, 0, 0, 3835, 3836, 1, 0, 0, 0, 3836, 3837, 1, 0, 0, 0, 3837,
		3845, 3, 234, 117, 0, 3838, 3839, 5, 118, 0, 0, 3839, 3846, 3, 672, 336,
		0, 3840, 3841, 5, 187, 0, 0, 3841, 3842, 5, 1131, 0, 0, 3842, 3843, 3,
		600, 300, 0, 3843, 3844, 5, 1132, 0, 0, 3844, 3846, 1, 0, 0, 0, 3845, 3838,
		1, 0, 0, 0, 3845, 3840, 1, 0, 0, 0, 3846, 3857, 1, 0, 0, 0, 3847, 3852,
		5, 113, 0, 0, 3848, 3850, 7, 51, 0, 0, 3849, 3851, 5, 126, 0, 0, 3850,
		3849, 1, 0, 0, 0, 3850, 3851, 1, 0, 0, 0, 3851, 3853, 1, 0, 0, 0, 3852,
		3848, 1, 0, 0, 0, 3852, 3853, 1, 0, 0, 0, 3853, 3854, 1, 0, 0, 0, 3854,
		3855, 5, 90, 0, 0, 3855, 3857, 3, 234, 117, 0, 3856, 3807, 1, 0, 0, 0,
		3856, 3823, 1, 0, 0, 0, 3856, 3829, 1, 0, 0, 0, 3856, 3847, 1, 0, 0, 0,
		3857, 241, 1, 0, 0, 0, 3858, 3859, 5, 1131, 0, 0, 3859, 3860, 3, 246, 123,
		0, 3860, 3861, 5, 1132, 0, 0, 3861, 3867, 1, 0, 0, 0, 3862, 3863, 5, 1131,
		0, 0, 3863, 3864, 3, 242, 121, 0, 3864, 3865, 5, 1132, 0, 0, 3865, 3867,
		1, 0, 0, 0, 3866, 3858, 1, 0, 0, 0, 3866, 3862, 1, 0, 0, 0, 3867, 243,
		1, 0, 0, 0, 3868, 3869, 5, 1131, 0, 0, 3869, 3870, 3, 248, 124, 0, 3870,
		3871, 5, 1132, 0, 0, 3871, 3877, 1, 0, 0, 0, 3872, 3873, 5, 1131, 0, 0,
		3873, 3874, 3, 244, 122, 0, 3874, 3875, 5, 1132, 0, 0, 3875, 3877, 1, 0,
		0, 0, 3876, 3868, 1, 0, 0, 0, 3876, 3872, 1, 0, 0, 0, 3877, 245, 1, 0,
		0, 0, 3878, 3882, 5, 152, 0, 0, 3879, 3881, 3, 266, 133, 0, 3880, 3879,
		1, 0, 0, 0, 3881, 3884, 1, 0, 0, 0, 3882, 3880, 1, 0, 0, 0, 3882, 3883,
		1, 0, 0, 0, 3883, 3885, 1, 0, 0, 0, 3884, 3882, 1, 0, 0, 0, 3885, 3887,
		3, 268, 134, 0, 3886, 3888, 3, 272, 136, 0, 3887, 3886, 1, 0, 0, 0, 3887,
		3888, 1, 0, 0, 0, 3888, 3889, 1, 0, 0, 0, 3889, 3891, 3, 278, 139, 0, 3890,
		3892, 3, 280, 140, 0, 3891, 3890, 1, 0, 0, 0, 3891, 3892, 1, 0, 0, 0, 3892,
		3894, 1, 0, 0, 0, 3893, 3895, 3, 282, 141, 0, 3894, 3893, 1, 0, 0, 0, 3894,
		3895, 1, 0, 0, 0, 3895, 3897, 1, 0, 0, 0, 3896, 3898, 3, 284, 142, 0, 3897,
		3896, 1, 0, 0, 0, 3897, 3898, 1, 0, 0, 0, 3898, 3900, 1, 0, 0, 0, 3899,
		3901, 3, 226, 113, 0, 3900, 3899, 1, 0, 0, 0, 3900, 3901, 1, 0, 0, 0, 3901,
		3903, 1, 0, 0, 0, 3902, 3904, 3, 288, 144, 0, 3903, 3902, 1, 0, 0, 0, 3903,
		3904, 1, 0, 0, 0, 3904, 3933, 1, 0, 0, 0, 3905, 3909, 5, 152, 0, 0, 3906,
		3908, 3, 266, 133, 0, 3907, 3906, 1, 0, 0, 0, 3908, 3911, 1, 0, 0, 0, 3909,
		3907, 1, 0, 0, 0, 3909, 3910, 1, 0, 0, 0, 3910, 3912, 1, 0, 0, 0, 3911,
		3909, 1, 0, 0, 0, 3912, 3913, 3, 268, 134, 0, 3913, 3915, 3, 278, 139,
		0, 3914, 3916, 3, 280, 140, 0, 3915, 3914, 1, 0, 0, 0, 3915, 3916, 1, 0,
		0, 0, 3916, 3918, 1, 0, 0, 0, 3917, 3919, 3, 282, 141, 0, 3918, 3917, 1,
		0, 0, 0, 3918, 3919, 1, 0, 0, 0, 3919, 3921, 1, 0, 0, 0, 3920, 3922, 3,
		284, 142, 0, 3921, 3920, 1, 0, 0, 0, 3921, 3922, 1, 0, 0, 0, 3922, 3924,
		1, 0, 0, 0, 3923, 3925, 3, 226, 113, 0, 3924, 3923, 1, 0, 0, 0, 3924, 3925,
		1, 0, 0, 0, 3925, 3927, 1, 0, 0, 0, 3926, 3928, 3, 288, 144, 0, 3927, 3926,
		1, 0, 0, 0, 3927, 3928, 1, 0, 0, 0, 3928, 3930, 1, 0, 0, 0, 3929, 3931,
		3, 272, 136, 0, 3930, 3929, 1, 0, 0, 0, 3930, 3931, 1, 0, 0, 0, 3931, 3933,
		1, 0, 0, 0, 3932, 3878, 1, 0, 0, 0, 3932, 3905, 1, 0, 0, 0, 3933, 247,
		1, 0, 0, 0, 3934, 3938, 5, 152, 0, 0, 3935, 3937, 3, 266, 133, 0, 3936,
		3935, 1, 0, 0, 0, 3937, 3940, 1, 0, 0, 0, 3938, 3936, 1, 0, 0, 0, 3938,
		3939, 1, 0, 0, 0, 3939, 3941, 1, 0, 0, 0, 3940, 3938, 1, 0, 0, 0, 3941,
		3942, 3, 268, 134, 0, 3942, 3944, 3, 278, 139, 0, 3943, 3945, 3, 280, 140,
		0, 3944, 3943, 1, 0, 0, 0, 3944, 3945, 1, 0, 0, 0, 3945, 3947, 1, 0, 0,
		0, 3946, 3948, 3, 282, 141, 0, 3947, 3946, 1, 0, 0, 0, 3947, 3948, 1, 0,
		0, 0, 3948, 3950, 1, 0, 0, 0, 3949, 3951, 3, 284, 142, 0, 3950, 3949, 1,
		0, 0, 0, 3950, 3951, 1, 0, 0, 0, 3951, 3953, 1, 0, 0, 0, 3952, 3954, 3,
		226, 113, 0, 3953, 3952, 1, 0, 0, 0, 3953, 3954, 1, 0, 0, 0, 3954, 3956,
		1, 0, 0, 0, 3955, 3957, 3, 288, 144, 0, 3956, 3955, 1, 0, 0, 0, 3956, 3957,
		1, 0, 0, 0, 3957, 249, 1, 0, 0, 0, 3958, 3960, 5, 180, 0, 0, 3959, 3961,
		7, 44, 0, 0, 3960, 3959, 1, 0, 0, 0, 3960, 3961, 1, 0, 0, 0, 3961, 3962,
		1, 0, 0, 0, 3962, 3963, 3, 244, 122, 0, 3963, 251, 1, 0, 0, 0, 3964, 3966,
		5, 180, 0, 0, 3965, 3967, 7, 44, 0, 0, 3966, 3965, 1, 0, 0, 0, 3966, 3967,
		1, 0, 0, 0, 3967, 3970, 1, 0, 0, 0, 3968, 3971, 3, 248, 124, 0, 3969, 3971,
		3, 244, 122, 0, 3970, 3968, 1, 0, 0, 0, 3970, 3969, 1, 0, 0, 0, 3971, 253,
		1, 0, 0, 0, 3972, 3987, 5, 94, 0, 0, 3973, 3988, 3, 248, 124, 0, 3974,
		3988, 3, 244, 122, 0, 3975, 3978, 5, 1131, 0, 0, 3976, 3979, 3, 248, 124,
		0, 3977, 3979, 3, 244, 122, 0, 3978, 3976, 1, 0, 0, 0, 3978, 3977, 1, 0,
		0, 0, 3979, 3980, 1, 0, 0, 0, 3980, 3985, 5, 1132, 0, 0, 3981, 3983, 5,
		12, 0, 0, 3982, 3981, 1, 0, 0, 0, 3982, 3983, 1, 0, 0, 0, 3983, 3984, 1,
		0, 0, 0, 3984, 3986, 3, 568, 284, 0, 3985, 3982, 1, 0, 0, 0, 3985, 3986,
		1, 0, 0, 0, 3986, 3988, 1, 0, 0, 0, 3987, 3973, 1, 0, 0, 0, 3987, 3974,
		1, 0, 0, 0, 3987, 3975, 1, 0, 0, 0, 3988, 255, 1, 0, 0, 0, 3989, 3990,
		5, 278, 0, 0, 3990, 3991, 5, 1131, 0, 0, 3991, 3992, 5, 1146, 0, 0, 3992,
		3993, 5, 1133, 0, 0, 3993, 3994, 5, 1146, 0, 0, 3994, 3995, 5, 365, 0,
		0, 3995, 3996, 5, 1131, 0, 0, 3996, 3997, 3, 258, 129, 0, 3997, 3998, 5,
		1132, 0, 0, 3998, 4003, 5, 1132, 0, 0, 3999, 4001, 5, 12, 0, 0, 4000, 3999,
		1, 0, 0, 0, 4000, 4001, 1, 0, 0, 0, 4001, 4002, 1, 0, 0, 0, 4002, 4004,
		3, 568, 284, 0, 4003, 4000, 1, 0, 0, 0, 4003, 4004, 1, 0, 0, 0, 4004, 257,
		1, 0, 0, 0, 4005, 4010, 3, 260, 130, 0, 4006, 4007, 5, 1133, 0, 0, 4007,
		4009, 3, 260, 130, 0, 4008, 4006, 1, 0, 0, 0, 4009, 4012, 1, 0, 0, 0, 4010,
		4008, 1, 0, 0, 0, 4010, 4011, 1, 0, 0, 0, 4011, 259, 1, 0, 0, 0, 4012,
		4010, 1, 0, 0, 0, 4013, 4030, 3, 546, 273, 0, 4014, 4015, 5, 65, 0, 0,
		4015, 4031, 5, 284, 0, 0, 4016, 4028, 3, 588, 294, 0, 4017, 4018, 5, 285,
		0, 0, 4018, 4020, 5, 1146, 0, 0, 4019, 4021, 3, 262, 131, 0, 4020, 4019,
		1, 0, 0, 0, 4020, 4021, 1, 0, 0, 0, 4021, 4023, 1, 0, 0, 0, 4022, 4024,
		3, 264, 132, 0, 4023, 4022, 1, 0, 0, 0, 4023, 4024, 1, 0, 0, 0, 4024, 4029,
		1, 0, 0, 0, 4025, 4026, 5, 60, 0, 0, 4026, 4027, 5, 285, 0, 0, 4027, 4029,
		5, 1146, 0, 0, 4028, 4017, 1, 0, 0, 0, 4028, 4025, 1, 0, 0, 0, 4029, 4031,
		1, 0, 0, 0, 4030, 4014, 1, 0, 0, 0, 4030, 4016, 1, 0, 0, 0, 4031, 4043,
		1, 0, 0, 0, 4032, 4034, 5, 283, 0, 0, 4033, 4035, 5, 285, 0, 0, 4034, 4033,
		1, 0, 0, 0, 4034, 4035, 1, 0, 0, 0, 4035, 4036, 1, 0, 0, 0, 4036, 4037,
		5, 1146, 0, 0, 4037, 4038, 5, 365, 0, 0, 4038, 4039, 5, 1131, 0, 0, 4039,
		4040, 3, 258, 129, 0, 4040, 4041, 5, 1132, 0, 0, 4041, 4043, 1, 0, 0, 0,
		4042, 4013, 1, 0, 0, 0, 4042, 4032, 1, 0, 0, 0, 4043, 261, 1, 0, 0, 0,
		4044, 4049, 5, 116, 0, 0, 4045, 4049, 5, 411, 0, 0, 4046, 4047, 5, 42,
		0, 0, 4047, 4049, 3, 618, 309, 0, 4048, 4044, 1, 0, 0, 0, 4048, 4045, 1,
		0, 0, 0, 4048, 4046, 1, 0, 0, 0, 4049, 4050, 1, 0, 0, 0, 4050, 4051, 5,
		118, 0, 0, 4051, 4052, 5, 55, 0, 0, 4052, 263, 1, 0, 0, 0, 4053, 4058,
		5, 116, 0, 0, 4054, 4058, 5, 411, 0, 0, 4055, 4056, 5, 42, 0, 0, 4056,
		4058, 3, 618, 309, 0, 4057, 4053, 1, 0, 0, 0, 4057, 4054, 1, 0, 0, 0, 4057,
		4055, 1, 0, 0, 0, 4058, 4059, 1, 0, 0, 0, 4059, 4060, 5, 118, 0, 0, 4060,
		4061, 5, 411, 0, 0, 4061, 265, 1, 0, 0, 0, 4062, 4071, 7, 52, 0, 0, 4063,
		4071, 5, 75, 0, 0, 4064, 4071, 5, 171, 0, 0, 4065, 4071, 5, 166, 0, 0,
		4066, 4071, 5, 164, 0, 0, 4067, 4071, 5, 625, 0, 0, 4068, 4071, 7, 53,
		0, 0, 4069, 4071, 5, 165, 0, 0, 4070, 4062, 1, 0, 0, 0, 4070, 4063, 1,
		0, 0, 0, 4070, 4064, 1, 0, 0, 0, 4070, 4065, 1, 0, 0, 0, 4070, 4066, 1,
		0, 0, 0, 4070, 4067, 1, 0, 0, 0, 4070, 4068, 1, 0, 0, 0, 4070, 4069, 1,
		0, 0, 0, 4071, 267, 1, 0, 0, 0, 4072, 4075, 5, 1115, 0, 0, 4073, 4075,
		3, 270, 135, 0, 4074, 4072, 1, 0, 0, 0, 4074, 4073, 1, 0, 0, 0, 4075, 4080,
		1, 0, 0, 0, 4076, 4077, 5, 1133, 0, 0, 4077, 4079, 3, 270, 135, 0, 4078,
		4076, 1, 0, 0, 0, 4079, 4082, 1, 0, 0, 0, 4080, 4078, 1, 0, 0, 0, 4080,
		4081, 1, 0, 0, 0, 4081, 269, 1, 0, 0, 0, 4082, 4080, 1, 0, 0, 0, 4083,
		4084, 3, 540, 270, 0, 4084, 4085, 5, 1130, 0, 0, 4085, 4086, 5, 1115, 0,
		0, 4086, 4113, 1, 0, 0, 0, 4087, 4092, 3, 546, 273, 0, 4088, 4090, 5, 12,
		0, 0, 4089, 4088, 1, 0, 0, 0, 4089, 4090, 1, 0, 0, 0, 4090, 4091, 1, 0,
		0, 0, 4091, 4093, 3, 568, 284, 0, 4092, 4089, 1, 0, 0, 0, 4092, 4093, 1,
		0, 0, 0, 4093, 4113, 1, 0, 0, 0, 4094, 4099, 3, 632, 316, 0, 4095, 4097,
		5, 12, 0, 0, 4096, 4095, 1, 0, 0, 0, 4096, 4097, 1, 0, 0, 0, 4097, 4098,
		1, 0, 0, 0, 4098, 4100, 3, 568, 284, 0, 4099, 4096, 1, 0, 0, 0, 4099, 4100,
		1, 0, 0, 0, 4100, 4113, 1, 0, 0, 0, 4101, 4102, 5, 1158, 0, 0, 4102, 4104,
		5, 1106, 0, 0, 4103, 4101, 1, 0, 0, 0, 4103, 4104, 1, 0, 0, 0, 4104, 4105,
		1, 0, 0, 0, 4105, 4110, 3, 672, 336, 0, 4106, 4108, 5, 12, 0, 0, 4107,
		4106, 1, 0, 0, 0, 4107, 4108, 1, 0, 0, 0, 4108, 4109, 1, 0, 0, 0, 4109,
		4111, 3, 568, 284, 0, 4110, 4107, 1, 0, 0, 0, 4110, 4111, 1, 0, 0, 0, 4111,
		4113, 1, 0, 0, 0, 4112, 4083, 1, 0, 0, 0, 4112, 4087, 1, 0, 0, 0, 4112,
		4094, 1, 0, 0, 0, 4112, 4103, 1, 0, 0, 0, 4113, 271, 1, 0, 0, 0, 4114,
		4115, 5, 87, 0, 0, 4115, 4120, 3, 206, 103, 0, 4116, 4117, 5, 1133, 0,
		0, 4117, 4119, 3, 206, 103, 0, 4118, 4116, 1, 0, 0, 0, 4119, 4122, 1, 0,
		0, 0, 4120, 4118, 1, 0, 0, 0, 4120, 4121, 1, 0, 0, 0, 4121, 4151, 1, 0,
		0, 0, 4122, 4120, 1, 0, 0, 0, 4123, 4124, 5, 87, 0, 0, 4124, 4125, 5, 400,
		0, 0, 4125, 4151, 5, 1146, 0, 0, 4126, 4127, 5, 87, 0, 0, 4127, 4128, 5,
		127, 0, 0, 4128, 4132, 5, 1146, 0, 0, 4129, 4130, 5, 25, 0, 0, 4130, 4131,
		5, 153, 0, 0, 4131, 4133, 3, 554, 277, 0, 4132, 4129, 1, 0, 0, 0, 4132,
		4133, 1, 0, 0, 0, 4133, 4140, 1, 0, 0, 0, 4134, 4136, 7, 41, 0, 0, 4135,
		4137, 3, 274, 137, 0, 4136, 4135, 1, 0, 0, 0, 4137, 4138, 1, 0, 0, 0, 4138,
		4136, 1, 0, 0, 0, 4138, 4139, 1, 0, 0, 0, 4139, 4141, 1, 0, 0, 0, 4140,
		4134, 1, 0, 0, 0, 4140, 4141, 1, 0, 0, 0, 4141, 4148, 1, 0, 0, 0, 4142,
		4144, 5, 101, 0, 0, 4143, 4145, 3, 276, 138, 0, 4144, 4143, 1, 0, 0, 0,
		4145, 4146, 1, 0, 0, 0, 4146, 4144, 1, 0, 0, 0, 4146, 4147, 1, 0, 0, 0,
		4147, 4149, 1, 0, 0, 0, 4148, 4142, 1, 0, 0, 0, 4148, 4149, 1, 0, 0, 0,
		4149, 4151, 1, 0, 0, 0, 4150, 4114, 1, 0, 0, 0, 4150, 4123, 1, 0, 0, 0,
		4150, 4126, 1, 0, 0, 0, 4151, 273, 1, 0, 0, 0, 4152, 4153, 5, 173, 0, 0,
		4153, 4154, 5, 19, 0, 0, 4154, 4165, 5, 1146, 0, 0, 4155, 4157, 5, 122,
		0, 0, 4156, 4155, 1, 0, 0, 0, 4156, 4157, 1, 0, 0, 0, 4157, 4158, 1, 0,
		0, 0, 4158, 4159, 5, 56, 0, 0, 4159, 4160, 5, 19, 0, 0, 4160, 4165, 5,
		1146, 0, 0, 4161, 4162, 5, 58, 0, 0, 4162, 4163, 5, 19, 0, 0, 4163, 4165,
		5, 1146, 0, 0, 4164, 4152, 1, 0, 0, 0, 4164, 4156, 1, 0, 0, 0, 4164, 4161,
		1, 0, 0, 0, 4165, 275, 1, 0, 0, 0, 4166, 4167, 5, 169, 0, 0, 4167, 4168,
		5, 19, 0, 0, 4168, 4173, 5, 1146, 0, 0, 4169, 4170, 5, 173, 0, 0, 4170,
		4171, 5, 19, 0, 0, 4171, 4173, 5, 1146, 0, 0, 4172, 4166, 1, 0, 0, 0, 4172,
		4169, 1, 0, 0, 0, 4173, 277, 1, 0, 0, 0, 4174, 4175, 5, 68, 0, 0, 4175,
		4177, 3, 230, 115, 0, 4176, 4174, 1, 0, 0, 0, 4176, 4177, 1, 0, 0, 0, 4177,
		4180, 1, 0, 0, 0, 4178, 4179, 5, 190, 0, 0, 4179, 4181, 3, 672, 336, 0,
		4180, 4178, 1, 0, 0, 0, 4180, 4181, 1, 0, 0, 0, 4181, 279, 1, 0, 0, 0,
		4182, 4183, 5, 73, 0, 0, 4183, 4184, 5, 19, 0, 0, 4184, 4189, 3, 286, 143,
		0, 4185, 4186, 5, 1133, 0, 0, 4186, 4188, 3, 286, 143, 0, 4187, 4185, 1,
		0, 0, 0, 4188, 4191, 1, 0, 0, 0, 4189, 4187, 1, 0, 0, 0, 4189, 4190, 1,
		0, 0, 0, 4190, 4194, 1, 0, 0, 0, 4191, 4189, 1, 0, 0, 0, 4192, 4193, 5,
		192, 0, 0, 4193, 4195, 5, 598, 0, 0, 4194, 4192, 1, 0, 0, 0, 4194, 4195,
		1, 0, 0, 0, 4195, 281, 1, 0, 0, 0, 4196, 4197, 5, 74, 0, 0, 4197, 4198,
		3, 672, 336, 0, 4198, 283, 1, 0, 0, 0, 4199, 4200, 5, 676, 0, 0, 4200,
		4201, 3, 650, 325, 0, 4201, 4202, 5, 12, 0, 0, 4202, 4203, 5, 1131, 0,
		0, 4203, 4204, 3, 648, 324, 0, 4204, 4214, 5, 1132, 0, 0, 4205, 4206, 5,
		1133, 0, 0, 4206, 4207, 3, 650, 325, 0, 4207, 4208, 5, 12, 0, 0, 4208,
		4209, 5, 1131, 0, 0, 4209, 4210, 3, 648, 324, 0, 4210, 4211, 5, 1132, 0,
		0, 4211, 4213, 1, 0, 0, 0, 4212, 4205, 1, 0, 0, 0, 4213, 4216, 1, 0, 0,
		0, 4214, 4212, 1, 0, 0, 0, 4214, 4215, 1, 0, 0, 0, 4215, 285, 1, 0, 0,
		0, 4216, 4214, 1, 0, 0, 0, 4217, 4219, 3, 672, 336, 0, 4218, 4220, 7, 48,
		0, 0, 4219, 4218, 1, 0, 0, 0, 4219, 4220, 1, 0, 0, 0, 4220, 287, 1, 0,
		0, 0, 4221, 4232, 5, 99, 0, 0, 4222, 4223, 3, 290, 145, 0, 4223, 4224,
		5, 1133, 0, 0, 4224, 4226, 1, 0, 0, 0, 4225, 4222, 1, 0, 0, 0, 4225, 4226,
		1, 0, 0, 0, 4226, 4227, 1, 0, 0, 0, 4227, 4233, 3, 290, 145, 0, 4228, 4229,
		3, 290, 145, 0, 4229, 4230, 5, 532, 0, 0, 4230, 4231, 3, 290, 145, 0, 4231,
		4233, 1, 0, 0, 0, 4232, 4225, 1, 0, 0, 0, 4232, 4228, 1, 0, 0, 0, 4233,
		289, 1, 0, 0, 0, 4234, 4238, 3, 574, 287, 0, 4235, 4238, 3, 552, 276, 0,
		4236, 4238, 3, 570, 285, 0, 4237, 4234, 1, 0, 0, 0, 4237, 4235, 1, 0, 0,
		0, 4237, 4236, 1, 0, 0, 0, 4238, 291, 1, 0, 0, 0, 4239, 4240, 5, 629, 0,
		0, 4240, 4249, 5, 653, 0, 0, 4241, 4246, 3, 314, 157, 0, 4242, 4243, 5,
		1133, 0, 0, 4243, 4245, 3, 314, 157, 0, 4244, 4242, 1, 0, 0, 0, 4245, 4248,
		1, 0, 0, 0, 4246, 4244, 1, 0, 0, 0, 4246, 4247, 1, 0, 0, 0, 4247, 4250,
		1, 0, 0, 0, 4248, 4246, 1, 0, 0, 0, 4249, 4241, 1, 0, 0, 0, 4249, 4250,
		1, 0, 0, 0, 4250, 293, 1, 0, 0, 0, 4251, 4253, 5, 344, 0, 0, 4252, 4254,
		5, 678, 0, 0, 4253, 4252, 1, 0, 0, 0, 4253, 4254, 1, 0, 0, 0, 4254, 295,
		1, 0, 0, 0, 4255, 4257, 5, 369, 0, 0, 4256, 4258, 5, 678, 0, 0, 4257, 4256,
		1, 0, 0, 0, 4257, 4258, 1, 0, 0, 0, 4258, 4264, 1, 0, 0, 0, 4259, 4261,
		5, 10, 0, 0, 4260, 4262, 5, 521, 0, 0, 4261, 4260, 1, 0, 0, 0, 4261, 4262,
		1, 0, 0, 0, 4262, 4263, 1, 0, 0, 0, 4263, 4265, 5, 353, 0, 0, 4264, 4259,
		1, 0, 0, 0, 4264, 4265, 1, 0, 0, 0, 4265, 4270, 1, 0, 0, 0, 4266, 4268,
		5, 521, 0, 0, 4267, 4266, 1, 0, 0, 0, 4267, 4268, 1, 0, 0, 0, 4268, 4269,
		1, 0, 0, 0, 4269, 4271, 5, 138, 0, 0, 4270, 4267, 1, 0, 0, 0, 4270, 4271,
		1, 0, 0, 0, 4271, 297, 1, 0, 0, 0, 4272, 4274, 5, 597, 0, 0, 4273, 4275,
		5, 678, 0, 0, 4274, 4273, 1, 0, 0, 0, 4274, 4275, 1, 0, 0, 0, 4275, 4281,
		1, 0, 0, 0, 4276, 4278, 5, 10, 0, 0, 4277, 4279, 5, 521, 0, 0, 4278, 4277,
		1, 0, 0, 0, 4278, 4279, 1, 0, 0, 0, 4279, 4280, 1, 0, 0, 0, 4280, 4282,
		5, 353, 0, 0, 4281, 4276, 1, 0, 0, 0, 4281, 4282, 1, 0, 0, 0, 4282, 4287,
		1, 0, 0, 0, 4283, 4285, 5, 521, 0, 0, 4284, 4283, 1, 0, 0, 0, 4284, 4285,
		1, 0, 0, 0, 4285, 4286, 1, 0, 0, 0, 4286, 4288, 5, 138, 0, 0, 4287, 4284,
		1, 0, 0, 0, 4287, 4288, 1, 0, 0, 0, 4288, 299, 1, 0, 0, 0, 4289, 4290,
		5, 604, 0, 0, 4290, 4291, 3, 568, 284, 0, 4291, 301, 1, 0, 0, 0, 4292,
		4294, 5, 597, 0, 0, 4293, 4295, 5, 678, 0, 0, 4294, 4293, 1, 0, 0, 0, 4294,
		4295, 1, 0, 0, 0, 4295, 4296, 1, 0, 0, 0, 4296, 4298, 5, 175, 0, 0, 4297,
		4299, 5, 604, 0, 0, 4298, 4297, 1, 0, 0, 0, 4298, 4299, 1, 0, 0, 0, 4299,
		4300, 1, 0, 0, 0, 4300, 4301, 3, 568, 284, 0, 4301, 303, 1, 0, 0, 0, 4302,
		4303, 5, 138, 0, 0, 4303, 4304, 5, 604, 0, 0, 4304, 4305, 3, 568, 284,
		0, 4305, 305, 1, 0, 0, 0, 4306, 4307, 5, 103, 0, 0, 4307, 4308, 7, 54,
		0, 0, 4308, 4313, 3, 316, 158, 0, 4309, 4310, 5, 1133, 0, 0, 4310, 4312,
		3, 316, 158, 0, 4311, 4309, 1, 0, 0, 0, 4312, 4315, 1, 0, 0, 0, 4313, 4311,
		1, 0, 0, 0, 4313, 4314, 1, 0, 0, 0, 4314, 4317, 1, 0, 0, 0, 4315, 4313,
		1, 0, 0, 0, 4316, 4318, 3, 630, 315, 0, 4317, 4316, 1, 0, 0, 0, 4317, 4318,
		1, 0, 0, 0, 4318, 307, 1, 0, 0, 0, 4319, 4320, 5, 182, 0, 0, 4320, 4321,
		5, 741, 0, 0, 4321, 309, 1, 0, 0, 0, 4322, 4323, 5, 153, 0, 0, 4323, 4324,
		5, 340, 0, 0, 4324, 4325, 5, 1122, 0, 0, 4325, 4326, 7, 24, 0, 0, 4326,
		311, 1, 0, 0, 0, 4327, 4329, 5, 153, 0, 0, 4328, 4330, 7, 55, 0, 0, 4329,
		4328, 1, 0, 0, 0, 4329, 4330, 1, 0, 0, 0, 4330, 4331, 1, 0, 0, 0, 4331,
		4332, 5, 653, 0, 0, 4332, 4337, 3, 320, 160, 0, 4333, 4334, 5, 1133, 0,
		0, 4334, 4336, 3, 320, 160, 0, 4335, 4333, 1, 0, 0, 0, 4336, 4339, 1, 0,
		0, 0, 4337, 4335, 1, 0, 0, 0, 4337, 4338, 1, 0, 0, 0, 4338, 313, 1, 0,
		0, 0, 4339, 4337, 1, 0, 0, 0, 4340, 4341, 5, 192, 0, 0, 4341, 4342, 5,
		377, 0, 0, 4342, 4348, 5, 616, 0, 0, 4343, 4344, 5, 134, 0, 0, 4344, 4348,
		5, 193, 0, 0, 4345, 4346, 5, 134, 0, 0, 4346, 4348, 5, 538, 0, 0, 4347,
		4340, 1, 0, 0, 0, 4347, 4343, 1, 0, 0, 0, 4347, 4345, 1, 0, 0, 0, 4348,
		315, 1, 0, 0, 0, 4349, 4354, 3, 542, 271, 0, 4350, 4352, 5, 12, 0, 0, 4351,
		4350, 1, 0, 0, 0, 4351, 4352, 1, 0, 0, 0, 4352, 4353, 1, 0, 0, 0, 4353,
		4355, 3, 568, 284, 0, 4354, 4351, 1, 0, 0, 0, 4354, 4355, 1, 0, 0, 0, 4355,
		4356, 1, 0, 0, 0, 4356, 4357, 3, 318, 159, 0, 4357, 317, 1, 0, 0, 0, 4358,
		4360, 5, 134, 0, 0, 4359, 4361, 5, 474, 0, 0, 4360, 4359, 1, 0, 0, 0, 4360,
		4361, 1, 0, 0, 0, 4361, 4367, 1, 0, 0, 0, 4362, 4364, 5, 106, 0, 0, 4363,
		4362, 1, 0, 0, 0, 4363, 4364, 1, 0, 0, 0, 4364, 4365, 1, 0, 0, 0, 4365,
		4367, 5, 193, 0, 0, 4366, 4358, 1, 0, 0, 0, 4366, 4363, 1, 0, 0, 0, 4367,
		319, 1, 0, 0, 0, 4368, 4369, 5, 464, 0, 0, 4369, 4370, 5, 472, 0, 0, 4370,
		4376, 3, 322, 161, 0, 4371, 4372, 5, 134, 0, 0, 4372, 4376, 5, 193, 0,
		0, 4373, 4374, 5, 134, 0, 0, 4374, 4376, 5, 538, 0, 0, 4375, 4368, 1, 0,
		0, 0, 4375, 4371, 1, 0, 0, 0, 4375, 4373, 1, 0, 0, 0, 4376, 321, 1, 0,
		0, 0, 4377, 4378, 5, 798, 0, 0, 4378, 4385, 5, 134, 0, 0, 4379, 4380, 5,
		134, 0, 0, 4380, 4385, 5, 799, 0, 0, 4381, 4382, 5, 134, 0, 0, 4382, 4385,
		5, 800, 0, 0, 4383, 4385, 5, 801, 0, 0, 4384, 4377, 1, 0, 0, 0, 4384, 4379,
		1, 0, 0, 0, 4384, 4381, 1, 0, 0, 0, 4384, 4383, 1, 0, 0, 0, 4385, 323,
		1, 0, 0, 0, 4386, 4387, 5, 24, 0, 0, 4387, 4388, 5, 477, 0, 0, 4388, 4389,
		5, 175, 0, 0, 4389, 4394, 3, 342, 171, 0, 4390, 4391, 5, 1133, 0, 0, 4391,
		4393, 3, 342, 171, 0, 4392, 4390, 1, 0, 0, 0, 4393, 4396, 1, 0, 0, 0, 4394,
		4392, 1, 0, 0, 0, 4394, 4395, 1, 0, 0, 0, 4395, 4398, 1, 0, 0, 0, 4396,
		4394, 1, 0, 0, 0, 4397, 4399, 3, 350, 175, 0, 4398, 4397, 1, 0, 0, 0, 4398,
		4399, 1, 0, 0, 0, 4399, 325, 1, 0, 0, 0, 4400, 4401, 5, 24, 0, 0, 4401,
		4402, 5, 588, 0, 0, 4402, 4403, 5, 429, 0, 0, 4403, 4408, 3, 352, 176,
		0, 4404, 4405, 5, 1133, 0, 0, 4405, 4407, 3, 352, 176, 0, 4406, 4404, 1,
		0, 0, 0, 4407, 4410, 1, 0, 0, 0, 4408, 4406, 1, 0, 0, 0, 4408, 4409, 1,
		0, 0, 0, 4409, 327, 1, 0, 0, 0, 4410, 4408, 1, 0, 0, 0, 4411, 4412, 5,
		132, 0, 0, 4412, 4413, 7, 56, 0, 0, 4413, 4418, 5, 476, 0, 0, 4414, 4415,
		5, 175, 0, 0, 4415, 4419, 5, 1146, 0, 0, 4416, 4417, 5, 15, 0, 0, 4417,
		4419, 5, 1146, 0, 0, 4418, 4414, 1, 0, 0, 0, 4418, 4416, 1, 0, 0, 0, 4419,
		329, 1, 0, 0, 0, 4420, 4421, 5, 589, 0, 0, 4421, 4422, 5, 477, 0, 0, 4422,
		331, 1, 0, 0, 0, 4423, 4424, 5, 589, 0, 0, 4424, 4426, 5, 614, 0, 0, 4425,
		4427, 5, 6, 0, 0, 4426, 4425, 1, 0, 0, 0, 4426, 4427, 1, 0, 0, 0, 4427,
		4429, 1, 0, 0, 0, 4428, 4430, 3, 350, 175, 0, 4429, 4428, 1, 0, 0, 0, 4429,
		4430, 1, 0, 0, 0, 4430, 333, 1, 0, 0, 0, 4431, 4432, 5, 629, 0, 0, 4432,
		4441, 5, 614, 0, 0, 4433, 4438, 3, 356, 178, 0, 4434, 4435, 5, 1133, 0,
		0, 4435, 4437, 3, 356, 178, 0, 4436, 4434, 1, 0, 0, 0, 4437, 4440, 1, 0,
		0, 0, 4438, 4436, 1, 0, 0, 0, 4438, 4439, 1, 0, 0, 0, 4439, 4442, 1, 0,
		0, 0, 4440, 4438, 1, 0, 0, 0, 4441, 4433, 1, 0, 0, 0, 4441, 4442, 1, 0,
		0, 0, 4442, 4445, 1, 0, 0, 0, 4443, 4444, 5, 663, 0, 0, 4444, 4446, 3,
		358, 179, 0, 4445, 4443, 1, 0, 0, 0, 4445, 4446, 1, 0, 0, 0, 4446, 4450,
		1, 0, 0, 0, 4447, 4449, 3, 360, 180, 0, 4448, 4447, 1, 0, 0, 0, 4449, 4452,
		1, 0, 0, 0, 4450, 4448, 1, 0, 0, 0, 4450, 4451, 1, 0, 0, 0, 4451, 4454,
		1, 0, 0, 0, 4452, 4450, 1, 0, 0, 0, 4453, 4455, 3, 350, 175, 0, 4454, 4453,
		1, 0, 0, 0, 4454, 4455, 1, 0, 0, 0, 4455, 335, 1, 0, 0, 0, 4456, 4457,
		5, 635, 0, 0, 4457, 4466, 5, 614, 0, 0, 4458, 4463, 3, 356, 178, 0, 4459,
		4460, 5, 1133, 0, 0, 4460, 4462, 3, 356, 178, 0, 4461, 4459, 1, 0, 0, 0,
		4462, 4465, 1, 0, 0, 0, 4463, 4461, 1, 0, 0, 0, 4463, 4464, 1, 0, 0, 0,
		4464, 4467, 1, 0, 0, 0, 4465, 4463, 1, 0, 0, 0, 4466, 4458, 1, 0, 0, 0,
		4466, 4467, 1, 0, 0, 0, 4467, 337, 1, 0, 0, 0, 4468, 4469, 5, 629, 0, 0,
		4469, 4470, 5, 441, 0, 0, 4470, 339, 1, 0, 0, 0, 4471, 4472, 5, 635, 0,
		0, 4472, 4473, 5, 441, 0, 0, 4473, 341, 1, 0, 0, 0, 4474, 4475, 3, 344,
		172, 0, 4475, 4476, 5, 1122, 0, 0, 4476, 4477, 5, 1146, 0, 0, 4477, 4504,
		1, 0, 0, 0, 4478, 4479, 3, 346, 173, 0, 4479, 4480, 5, 1122, 0, 0, 4480,
		4481, 3, 574, 287, 0, 4481, 4504, 1, 0, 0, 0, 4482, 4483, 3, 348, 174,
		0, 4483, 4484, 5, 1122, 0, 0, 4484, 4485, 7, 24, 0, 0, 4485, 4504, 1, 0,
		0, 0, 4486, 4487, 5, 481, 0, 0, 4487, 4488, 5, 1122, 0, 0, 4488, 4504,
		5, 1149, 0, 0, 4489, 4490, 5, 449, 0, 0, 4490, 4491, 5, 1122, 0, 0, 4491,
		4500, 5, 1131, 0, 0, 4492, 4497, 3, 568, 284, 0, 4493, 4494, 5, 1133, 0,
		0, 4494, 4496, 3, 568, 284, 0, 4495, 4493, 1, 0, 0, 0, 4496, 4499, 1, 0,
		0, 0, 4497, 4495, 1, 0, 0, 0, 4497, 4498, 1, 0, 0, 0, 4498, 4501, 1, 0,
		0, 0, 4499, 4497, 1, 0, 0, 0, 4500, 4492, 1, 0, 0, 0, 4500, 4501, 1, 0,
		0, 0, 4501, 4502, 1, 0, 0, 0, 4502, 4504, 5, 1132, 0, 0, 4503, 4474, 1,
		0, 0, 0, 4503, 4478, 1, 0, 0, 0, 4503, 4482, 1, 0, 0, 0, 4503, 4486, 1,
		0, 0, 0, 4503, 4489, 1, 0, 0, 0, 4504, 343, 1, 0, 0, 0, 4505, 4506, 7,
		57, 0, 0, 4506, 345, 1, 0, 0, 0, 4507, 4508, 7, 58, 0, 0, 4508, 347, 1,
		0, 0, 0, 4509, 4510, 7, 59, 0, 0, 4510, 349, 1, 0, 0, 0, 4511, 4512, 5,
		65, 0, 0, 4512, 4513, 5, 355, 0, 0, 4513, 4514, 5, 1146, 0, 0, 4514, 351,
		1, 0, 0, 0, 4515, 4516, 5, 581, 0, 0, 4516, 4517, 5, 1122, 0, 0, 4517,
		4518, 5, 1131, 0, 0, 4518, 4519, 3, 600, 300, 0, 4519, 4520, 5, 1132, 0,
		0, 4520, 4565, 1, 0, 0, 0, 4521, 4522, 5, 583, 0, 0, 4522, 4523, 5, 1122,
		0, 0, 4523, 4524, 5, 1131, 0, 0, 4524, 4525, 3, 600, 300, 0, 4525, 4526,
		5, 1132, 0, 0, 4526, 4565, 1, 0, 0, 0, 4527, 4528, 5, 582, 0, 0, 4528,
		4529, 5, 1122, 0, 0, 4529, 4530, 5, 1131, 0, 0, 4530, 4531, 3, 604, 302,
		0, 4531, 4532, 5, 1132, 0, 0, 4532, 4565, 1, 0, 0, 0, 4533, 4534, 5, 584,
		0, 0, 4534, 4535, 5, 1122, 0, 0, 4535, 4536, 5, 1131, 0, 0, 4536, 4537,
		3, 604, 302, 0, 4537, 4538, 5, 1132, 0, 0, 4538, 4565, 1, 0, 0, 0, 4539,
		4540, 5, 586, 0, 0, 4540, 4541, 5, 1122, 0, 0, 4541, 4542, 5, 1131, 0,
		0, 4542, 4543, 3, 614, 307, 0, 4543, 4544, 5, 1132, 0, 0, 4544, 4565, 1,
		0, 0, 0, 4545, 4546, 5, 587, 0, 0, 4546, 4547, 5, 1122, 0, 0, 4547, 4548,
		5, 1131, 0, 0, 4548, 4549, 3, 614, 307, 0, 4549, 4550, 5, 1132, 0, 0, 4550,
		4565, 1, 0, 0, 0, 4551, 4552, 5, 585, 0, 0, 4552, 4553, 5, 1122, 0, 0,
		4553, 4554, 5, 1131, 0, 0, 4554, 4559, 3, 354, 177, 0, 4555, 4556, 5, 1133,
		0, 0, 4556, 4558, 3, 354, 177, 0, 4557, 4555, 1, 0, 0, 0, 4558, 4561, 1,
		0, 0, 0, 4559, 4557, 1, 0, 0, 0, 4559, 4560, 1, 0, 0, 0, 4560, 4562, 1,
		0, 0, 0, 4561, 4559, 1, 0, 0, 0, 4562, 4563, 5, 1132, 0, 0, 4563, 4565,
		1, 0, 0, 0, 4564, 4515, 1, 0, 0, 0, 4564, 4521, 1, 0, 0, 0, 4564, 4527,
		1, 0, 0, 0, 4564, 4533, 1, 0, 0, 0, 4564, 4539, 1, 0, 0, 0, 4564, 4545,
		1, 0, 0, 0, 4564, 4551, 1, 0, 0, 0, 4565, 353, 1, 0, 0, 0, 4566, 4567,
		5, 1131, 0, 0, 4567, 4568, 3, 542, 271, 0, 4568, 4569, 5, 1133, 0, 0, 4569,
		4570, 3, 542, 271, 0, 4570, 4571, 5, 1132, 0, 0, 4571, 355, 1, 0, 0, 0,
		4572, 4573, 7, 60, 0, 0, 4573, 357, 1, 0, 0, 0, 4574, 4575, 7, 61, 0, 0,
		4575, 4576, 5, 1122, 0, 0, 4576, 4593, 3, 362, 181, 0, 4577, 4578, 5, 483,
		0, 0, 4578, 4579, 5, 1122, 0, 0, 4579, 4580, 5, 1146, 0, 0, 4580, 4581,
		5, 1133, 0, 0, 4581, 4582, 5, 484, 0, 0, 4582, 4583, 5, 1122, 0, 0, 4583,
		4593, 3, 574, 287, 0, 4584, 4585, 5, 575, 0, 0, 4585, 4586, 5, 1122, 0,
		0, 4586, 4587, 5, 1146, 0, 0, 4587, 4588, 5, 1133, 0, 0, 4588, 4589, 5,
		576, 0, 0, 4589, 4590, 5, 1122, 0, 0, 4590, 4593, 3, 574, 287, 0, 4591,
		4593, 5, 623, 0, 0, 4592, 4574, 1, 0, 0, 0, 4592, 4577, 1, 0, 0, 0, 4592,
		4584, 1, 0, 0, 0, 4592, 4591, 1, 0, 0, 0, 4593, 359, 1, 0, 0, 0, 4594,
		4595, 5, 665, 0, 0, 4595, 4596, 5, 1122, 0, 0, 4596, 4607, 5, 1146, 0,
		0, 4597, 4598, 5, 551, 0, 0, 4598, 4599, 5, 1122, 0, 0, 4599, 4607, 5,
		1146, 0, 0, 4600, 4601, 5, 391, 0, 0, 4601, 4602, 5, 1122, 0, 0, 4602,
		4607, 5, 1146, 0, 0, 4603, 4604, 5, 555, 0, 0, 4604, 4605, 5, 1122, 0,
		0, 4605, 4607, 5, 1146, 0, 0, 4606, 4594, 1, 0, 0, 0, 4606, 4597, 1, 0,
		0, 0, 4606, 4600, 1, 0, 0, 0, 4606, 4603, 1, 0, 0, 0, 4607, 361, 1, 0,
		0, 0, 4608, 4613, 3, 560, 280, 0, 4609, 4610, 5, 1133, 0, 0, 4610, 4612,
		3, 560, 280, 0, 4611, 4609, 1, 0, 0, 0, 4612, 4615, 1, 0, 0, 0, 4613, 4611,
		1, 0, 0, 0, 4613, 4614, 1, 0, 0, 0, 4614, 4618, 1, 0, 0, 0, 4615, 4613,
		1, 0, 0, 0, 4616, 4618, 5, 1146, 0, 0, 4617, 4608, 1, 0, 0, 0, 4617, 4616,
		1, 0, 0, 0, 4618, 363, 1, 0, 0, 0, 4619, 4620, 5, 681, 0, 0, 4620, 4621,
		7, 62, 0, 0, 4621, 4623, 3, 562, 281, 0, 4622, 4624, 7, 63, 0, 0, 4623,
		4622, 1, 0, 0, 0, 4623, 4624, 1, 0, 0, 0, 4624, 365, 1, 0, 0, 0, 4625,
		4626, 5, 681, 0, 0, 4626, 4627, 5, 407, 0, 0, 4627, 4633, 3, 562, 281,
		0, 4628, 4631, 5, 643, 0, 0, 4629, 4630, 5, 65, 0, 0, 4630, 4632, 5, 509,
		0, 0, 4631, 4629, 1, 0, 0, 0, 4631, 4632, 1, 0, 0, 0, 4632, 4634, 1, 0,
		0, 0, 4633, 4628, 1, 0, 0, 0, 4633, 4634, 1, 0, 0, 0, 4634, 367, 1, 0,
		0, 0, 4635, 4636, 5, 681, 0, 0, 4636, 4637, 5, 560, 0, 0, 4637, 4638, 3,
		562, 281, 0, 4638, 369, 1, 0, 0, 0, 4639, 4640, 5, 681, 0, 0, 4640, 4641,
		5, 369, 0, 0, 4641, 4644, 3, 562, 281, 0, 4642, 4643, 5, 536, 0, 0, 4643,
		4645, 5, 553, 0, 0, 4644, 4642, 1, 0, 0, 0, 4644, 4645, 1, 0, 0, 0, 4645,
		371, 1, 0, 0, 0, 4646, 4647, 5, 681, 0, 0, 4647, 4648, 5, 597, 0, 0, 4648,
		4649, 3, 562, 281, 0, 4649, 373, 1, 0, 0, 0, 4650, 4651, 5, 681, 0, 0,
		4651, 4654, 5, 570, 0, 0, 4652, 4653, 5, 32, 0, 0, 4653, 4655, 3, 562,
		281, 0, 4654, 4652, 1, 0, 0, 0, 4654, 4655, 1, 0, 0, 0, 4655, 375, 1, 0,
		0, 0, 4656, 4657, 5, 560, 0, 0, 4657, 4658, 3, 568, 284, 0, 4658, 4661,
		5, 68, 0, 0, 4659, 4662, 5, 1146, 0, 0, 4660, 4662, 5, 1158, 0, 0, 4661,
		4659, 1, 0, 0, 0, 4661, 4660, 1, 0, 0, 0, 4662, 377, 1, 0, 0, 0, 4663,
		4664, 5, 707, 0, 0, 4664, 4667, 3, 568, 284, 0, 4665, 4666, 5, 187, 0,
		0, 4666, 4668, 3, 616, 308, 0, 4667, 4665, 1, 0, 0, 0, 4667, 4668, 1, 0,
		0, 0, 4668, 379, 1, 0, 0, 0, 4669, 4670, 7, 64, 0, 0, 4670, 4671, 5, 560,
		0, 0, 4671, 4672, 3, 568, 284, 0, 4672, 381, 1, 0, 0, 0, 4673, 4676, 3,
		384, 192, 0, 4674, 4676, 3, 4, 2, 0, 4675, 4673, 1, 0, 0, 0, 4675, 4674,
		1, 0, 0, 0, 4676, 383, 1, 0, 0, 0, 4677, 4678, 3, 568, 284, 0, 4678, 4679,
		5, 1142, 0, 0, 4679, 4681, 1, 0, 0, 0, 4680, 4677, 1, 0, 0, 0, 4680, 4681,
		1, 0, 0, 0, 4681, 4682, 1, 0, 0, 0, 4682, 4688, 5, 344, 0, 0, 4683, 4684,
		3, 404, 202, 0, 4684, 4685, 5, 1134, 0, 0, 4685, 4687, 1, 0, 0, 0, 4686,
		4683, 1, 0, 0, 0, 4687, 4690, 1, 0, 0, 0, 4688, 4686, 1, 0, 0, 0, 4688,
		4689, 1, 0, 0, 0, 4689, 4696, 1, 0, 0, 0, 4690, 4688, 1, 0, 0, 0, 4691,
		4692, 3, 406, 203, 0, 4692, 4693, 5, 1134, 0, 0, 4693, 4695, 1, 0, 0, 0,
		4694, 4691, 1, 0, 0, 0, 4695, 4698, 1, 0, 0, 0, 4696, 4694, 1, 0, 0, 0,
		4696, 4697, 1, 0, 0, 0, 4697, 4704, 1, 0, 0, 0, 4698, 4696, 1, 0, 0, 0,
		4699, 4700, 3, 408, 204, 0, 4700, 4701, 5, 1134, 0, 0, 4701, 4703, 1, 0,
		0, 0, 4702, 4699, 1, 0, 0, 0, 4703, 4706, 1, 0, 0, 0, 4704, 4702, 1, 0,
		0, 0, 4704, 4705, 1, 0, 0, 0, 4705, 4712, 1, 0, 0, 0, 4706, 4704, 1, 0,
		0, 0, 4707, 4708, 3, 410, 205, 0, 4708, 4709, 5, 1134, 0, 0, 4709, 4711,
		1, 0, 0, 0, 4710, 4707, 1, 0, 0, 0, 4711, 4714, 1, 0, 0, 0, 4712, 4710,
		1, 0, 0, 0, 4712, 4713, 1, 0, 0, 0, 4713, 4718, 1, 0, 0, 0, 4714, 4712,
		1, 0, 0, 0, 4715, 4717, 3, 414, 207, 0, 4716, 4715, 1, 0, 0, 0, 4717, 4720,
		1, 0, 0, 0, 4718, 4716, 1, 0, 0, 0, 4718, 4719, 1, 0, 0, 0, 4719, 4721,
		1, 0, 0, 0, 4720, 4718, 1, 0, 0, 0, 4721, 4723, 5, 407, 0, 0, 4722, 4724,
		3, 568, 284, 0, 4723, 4722, 1, 0, 0, 0, 4723, 4724, 1, 0, 0, 0, 4724, 385,
		1, 0, 0, 0, 4725, 4728, 5, 22, 0, 0, 4726, 4729, 3, 568, 284, 0, 4727,
		4729, 3, 672, 336, 0, 4728, 4726, 1, 0, 0, 0, 4728, 4727, 1, 0, 0, 0, 4728,
		4729, 1, 0, 0, 0, 4729, 4731, 1, 0, 0, 0, 4730, 4732, 3, 416, 208, 0, 4731,
		4730, 1, 0, 0, 0, 4732, 4733, 1, 0, 0, 0, 4733, 4731, 1, 0, 0, 0, 4733,
		4734, 1, 0, 0, 0, 4734, 4741, 1, 0, 0, 0, 4735, 4737, 5, 53, 0, 0, 4736,
		4738, 3, 414, 207, 0, 4737, 4736, 1, 0, 0, 0, 4738, 4739, 1, 0, 0, 0, 4739,
		4737, 1, 0, 0, 0, 4739, 4740, 1, 0, 0, 0, 4740, 4742, 1, 0, 0, 0, 4741,
		4735, 1, 0, 0, 0, 4741, 4742, 1, 0, 0, 0, 4742, 4743, 1, 0, 0, 0, 4743,
		4744, 5, 407, 0, 0, 4744, 4745, 5, 22, 0, 0, 4745, 387, 1, 0, 0, 0, 4746,
		4747, 5, 77, 0, 0, 4747, 4748, 3, 672, 336, 0, 4748, 4750, 5, 174, 0, 0,
		4749, 4751, 3, 414, 207, 0, 4750, 4749, 1, 0, 0, 0, 4751, 4752, 1, 0, 0,
		0, 4752, 4750, 1, 0, 0, 0, 4752, 4753, 1, 0, 0, 0, 4753, 4757, 1, 0, 0,
		0, 4754, 4756, 3, 418, 209, 0, 4755, 4754, 1, 0, 0, 0, 4756, 4759, 1, 0,
		0, 0, 4757, 4755, 1, 0, 0, 0, 4757, 4758, 1, 0, 0, 0, 4758, 4766, 1, 0,
		0, 0, 4759, 4757, 1, 0, 0, 0, 4760, 4762, 5, 53, 0, 0, 4761, 4763, 3, 414,
		207, 0, 4762, 4761, 1, 0, 0, 0, 4763, 4764, 1, 0, 0, 0, 4764, 4762, 1,
		0, 0, 0, 4764, 4765, 1, 0, 0, 0, 4765, 4767, 1, 0, 0, 0, 4766, 4760, 1,
		0, 0, 0, 4766, 4767, 1, 0, 0, 0, 4767, 4768, 1, 0, 0, 0, 4768, 4769, 5,
		407, 0, 0, 4769, 4770, 5, 77, 0, 0, 4770, 389, 1, 0, 0, 0, 4771, 4772,
		5, 89, 0, 0, 4772, 4773, 3, 568, 284, 0, 4773, 391, 1, 0, 0, 0, 4774, 4775,
		5, 96, 0, 0, 4775, 4776, 3, 568, 284, 0, 4776, 393, 1, 0, 0, 0, 4777, 4778,
		3, 568, 284, 0, 4778, 4779, 5, 1142, 0, 0, 4779, 4781, 1, 0, 0, 0, 4780,
		4777, 1, 0, 0, 0, 4780, 4781, 1, 0, 0, 0, 4781, 4782, 1, 0, 0, 0, 4782,
		4784, 5, 105, 0, 0, 4783, 4785, 3, 414, 207, 0, 4784, 4783, 1, 0, 0, 0,
		4785, 4786, 1, 0, 0, 0, 4786, 4784, 1, 0, 0, 0, 4786, 4787, 1, 0, 0, 0,
		4787, 4788, 1, 0, 0, 0, 4788, 4789, 5, 407, 0, 0, 4789, 4791, 5, 105, 0,
		0, 4790, 4792, 3, 568, 284, 0, 4791, 4790, 1, 0, 0, 0, 4791, 4792, 1, 0,
		0, 0, 4792, 395, 1, 0, 0, 0, 4793, 4794, 3, 568, 284, 0, 4794, 4795, 5,
		1142, 0, 0, 4795, 4797, 1, 0, 0, 0, 4796, 4793, 1, 0, 0, 0, 4796, 4797,
		1, 0, 0, 0, 4797, 4798, 1, 0, 0, 0, 4798, 4800, 5, 140, 0, 0, 4799, 4801,
		3, 414, 207, 0, 4800, 4799, 1, 0, 0, 0, 4801, 4802, 1, 0, 0, 0, 4802, 4800,
		1, 0, 0, 0, 4802, 4803, 1, 0, 0, 0, 4803, 4804, 1, 0, 0, 0, 4804, 4805,
		5, 663, 0, 0, 4805, 4806, 3, 672, 336, 0, 4806, 4807, 5, 407, 0, 0, 4807,
		4809, 5, 140, 0, 0, 4808, 4810, 3, 568, 284, 0, 4809, 4808, 1, 0, 0, 0,
		4809, 4810, 1, 0, 0, 0, 4810, 397, 1, 0, 0, 0, 4811, 4812, 5, 146, 0, 0,
		4812, 4813, 3, 672, 336, 0, 4813, 399, 1, 0, 0, 0, 4814, 4815, 3, 568,
		284, 0, 4815, 4816, 5, 1142, 0, 0, 4816, 4818, 1, 0, 0, 0, 4817, 4814,
		1, 0, 0, 0, 4817, 4818, 1, 0, 0, 0, 4818, 4819, 1, 0, 0, 0, 4819, 4820,
		5, 191, 0, 0, 4820, 4821, 3, 672, 336, 0, 4821, 4823, 5, 399, 0, 0, 4822,
		4824, 3, 414, 207, 0, 4823, 4822, 1, 0, 0, 0, 4824, 4825, 1, 0, 0, 0, 4825,
		4823, 1, 0, 0, 0, 4825, 4826, 1, 0, 0, 0, 4826, 4827, 1, 0, 0, 0, 4827,
		4828, 5, 407, 0, 0, 4828, 4830, 5, 191, 0, 0, 4829, 4831, 3, 568, 284,
		0, 4830, 4829, 1, 0, 0, 0, 4830, 4831, 1, 0, 0, 0, 4831, 401, 1, 0, 0,
		0, 4832, 4833, 5, 361, 0, 0, 4833, 4848, 3, 568, 284, 0, 4834, 4839, 5,
		64, 0, 0, 4835, 4837, 5, 520, 0, 0, 4836, 4835, 1, 0, 0, 0, 4836, 4837,
		1, 0, 0, 0, 4837, 4838, 1, 0, 0, 0, 4838, 4840, 5, 68, 0, 0, 4839, 4836,
		1, 0, 0, 0, 4839, 4840, 1, 0, 0, 0, 4840, 4841, 1, 0, 0, 0, 4841, 4842,
		3, 568, 284, 0, 4842, 4843, 5, 87, 0, 0, 4843, 4844, 3, 600, 300, 0, 4844,
		4848, 1, 0, 0, 0, 4845, 4846, 5, 539, 0, 0, 4846, 4848, 3, 568, 284, 0,
		4847, 4832, 1, 0, 0, 0, 4847, 4834, 1, 0, 0, 0, 4847, 4845, 1, 0, 0, 0,
		4848, 403, 1, 0, 0, 0, 4849, 4850, 5, 41, 0, 0, 4850, 4851, 3, 600, 300,
		0, 4851, 4854, 3, 588, 294, 0, 4852, 4853, 5, 42, 0, 0, 4853, 4855, 3,
		672, 336, 0, 4854, 4852, 1, 0, 0, 0, 4854, 4855, 1, 0, 0, 0, 4855, 405,
		1, 0, 0, 0, 4856, 4857, 5, 41, 0, 0, 4857, 4858, 3, 568, 284, 0, 4858,
		4859, 5, 29, 0, 0, 4859, 4866, 5, 65, 0, 0, 4860, 4867, 3, 574, 287, 0,
		4861, 4863, 5, 162, 0, 0, 4862, 4864, 5, 669, 0, 0, 4863, 4862, 1, 0, 0,
		0, 4863, 4864, 1, 0, 0, 0, 4864, 4865, 1, 0, 0, 0, 4865, 4867, 5, 1146,
		0, 0, 4866, 4860, 1, 0, 0, 0, 4866, 4861, 1, 0, 0, 0, 4867, 407, 1, 0,
		0, 0, 4868, 4869, 5, 41, 0, 0, 4869, 4870, 3, 568, 284, 0, 4870, 4871,
		5, 38, 0, 0, 4871, 4872, 5, 65, 0, 0, 4872, 4873, 3, 196, 98, 0, 4873,
		409, 1, 0, 0, 0, 4874, 4875, 5, 41, 0, 0, 4875, 4876, 7, 65, 0, 0, 4876,
		4877, 5, 442, 0, 0, 4877, 4878, 5, 65, 0, 0, 4878, 4883, 3, 412, 206, 0,
		4879, 4880, 5, 1133, 0, 0, 4880, 4882, 3, 412, 206, 0, 4881, 4879, 1, 0,
		0, 0, 4882, 4885, 1, 0, 0, 0, 4883, 4881, 1, 0, 0, 0, 4883, 4884, 1, 0,
		0, 0, 4884, 4886, 1, 0, 0, 0, 4885, 4883, 1, 0, 0, 0, 4886, 4887, 3, 382,
		191, 0, 4887, 411, 1, 0, 0, 0, 4888, 4900, 3, 574, 287, 0, 4889, 4891,
		5, 162, 0, 0, 4890, 4892, 5, 669, 0, 0, 4891, 4890, 1, 0, 0, 0, 4891, 4892,
		1, 0, 0, 0, 4892, 4893, 1, 0, 0, 0, 4893, 4900, 5, 1146, 0, 0, 4894, 4900,
		3, 568, 284, 0, 4895, 4900, 5, 163, 0, 0, 4896, 4897, 5, 114, 0, 0, 4897,
		4900, 5, 435, 0, 0, 4898, 4900, 5, 161, 0, 0, 4899, 4888, 1, 0, 0, 0, 4899,
		4889, 1, 0, 0, 0, 4899, 4894, 1, 0, 0, 0, 4899, 4895, 1, 0, 0, 0, 4899,
		4896, 1, 0, 0, 0, 4899, 4898, 1, 0, 0, 0, 4900, 413, 1, 0, 0, 0, 4901,
		4904, 3, 18, 9, 0, 4902, 4904, 3, 4, 2, 0, 4903, 4901, 1, 0, 0, 0, 4903,
		4902, 1, 0, 0, 0, 4904, 4905, 1, 0, 0, 0, 4905, 4906, 5, 1134, 0, 0, 4906,
		415, 1, 0, 0, 0, 4907, 4910, 5, 189, 0, 0, 4908, 4911, 3, 586, 293, 0,
		4909, 4911, 3, 672, 336, 0, 4910, 4908, 1, 0, 0, 0, 4910, 4909, 1, 0, 0,
		0, 4911, 4912, 1, 0, 0, 0, 4912, 4914, 5, 174, 0, 0, 4913, 4915, 3, 414,
		207, 0, 4914, 4913, 1, 0, 0, 0, 4915, 4916, 1, 0, 0, 0, 4916, 4914, 1,
		0, 0, 0, 4916, 4917, 1, 0, 0, 0, 4917, 417, 1, 0, 0, 0, 4918, 4919, 5,
		54, 0, 0, 4919, 4920, 3, 672, 336, 0, 4920, 4922, 5, 174, 0, 0, 4921, 4923,
		3, 414, 207, 0, 4922, 4921, 1, 0, 0, 0, 4923, 4924, 1, 0, 0, 0, 4924, 4922,
		1, 0, 0, 0, 4924, 4925, 1, 0, 0, 0, 4925, 419, 1, 0, 0, 0, 4926, 4927,
		5, 7, 0, 0, 4927, 4928, 5, 665, 0, 0, 4928, 4933, 3, 440, 220, 0, 4929,
		4930, 5, 1133, 0, 0, 4930, 4932, 3, 440, 220, 0, 4931, 4929, 1, 0, 0, 0,
		4932, 4935, 1, 0, 0, 0, 4933, 4931, 1, 0, 0, 0, 4933, 4934, 1, 0, 0, 0,
		4934, 5000, 1, 0, 0, 0, 4935, 4933, 1, 0, 0, 0, 4936, 4937, 5, 7, 0, 0,
		4937, 4939, 5, 665, 0, 0, 4938, 4940, 3, 624, 312, 0, 4939, 4938, 1, 0,
		0, 0, 4939, 4940, 1, 0, 0, 0, 4940, 4941, 1, 0, 0, 0, 4941, 4946, 3, 442,
		221, 0, 4942, 4943, 5, 1133, 0, 0, 4943, 4945, 3, 442, 221, 0, 4944, 4942,
		1, 0, 0, 0, 4945, 4948, 1, 0, 0, 0, 4946, 4944, 1, 0, 0, 0, 4946, 4947,
		1, 0, 0, 0, 4947, 4963, 1, 0, 0, 0, 4948, 4946, 1, 0, 0, 0, 4949, 4961,
		5, 142, 0, 0, 4950, 4962, 5, 529, 0, 0, 4951, 4958, 3, 446, 223, 0, 4952,
		4954, 5, 10, 0, 0, 4953, 4952, 1, 0, 0, 0, 4953, 4954, 1, 0, 0, 0, 4954,
		4955, 1, 0, 0, 0, 4955, 4957, 3, 446, 223, 0, 4956, 4953, 1, 0, 0, 0, 4957,
		4960, 1, 0, 0, 0, 4958, 4956, 1, 0, 0, 0, 4958, 4959, 1, 0, 0, 0, 4959,
		4962, 1, 0, 0, 0, 4960, 4958, 1, 0, 0, 0, 4961, 4950, 1, 0, 0, 0, 4961,
		4951, 1, 0, 0, 0, 4962, 4964, 1, 0, 0, 0, 4963, 4949, 1, 0, 0, 0, 4963,
		4964, 1, 0, 0, 0, 4964, 4971, 1, 0, 0, 0, 4965, 4967, 5, 192, 0, 0, 4966,
		4968, 3, 448, 224, 0, 4967, 4966, 1, 0, 0, 0, 4968, 4969, 1, 0, 0, 0, 4969,
		4967, 1, 0, 0, 0, 4969, 4970, 1, 0, 0, 0, 4970, 4972, 1, 0, 0, 0, 4971,
		4965, 1, 0, 0, 0, 4971, 4972, 1, 0, 0, 0, 4972, 4977, 1, 0, 0, 0, 4973,
		4976, 3, 450, 225, 0, 4974, 4976, 3, 452, 226, 0, 4975, 4973, 1, 0, 0,
		0, 4975, 4974, 1, 0, 0, 0, 4976, 4979, 1, 0, 0, 0, 4977, 4975, 1, 0, 0,
		0, 4977, 4978, 1, 0, 0, 0, 4978, 4984, 1, 0, 0, 0, 4979, 4977, 1, 0, 0,
		0, 4980, 4981, 5, 368, 0, 0, 4981, 4985, 5, 1146, 0, 0, 4982, 4983, 5,
		14, 0, 0, 4983, 4985, 5, 1146, 0, 0, 4984, 4980, 1, 0, 0, 0, 4984, 4982,
		1, 0, 0, 0, 4984, 4985, 1, 0, 0, 0, 4985, 5000, 1, 0, 0, 0, 4986, 4987,
		5, 7, 0, 0, 4987, 4989, 5, 665, 0, 0, 4988, 4990, 3, 624, 312, 0, 4989,
		4988, 1, 0, 0, 0, 4989, 4990, 1, 0, 0, 0, 4990, 4993, 1, 0, 0, 0, 4991,
		4994, 3, 550, 275, 0, 4992, 4994, 3, 568, 284, 0, 4993, 4991, 1, 0, 0,
		0, 4993, 4992, 1, 0, 0, 0, 4994, 4995, 1, 0, 0, 0, 4995, 4996, 5, 42, 0,
		0, 4996, 4997, 5, 596, 0, 0, 4997, 4998, 3, 428, 214, 0, 4998, 5000, 1,
		0, 0, 0, 4999, 4926, 1, 0, 0, 0, 4999, 4936, 1, 0, 0, 0, 4999, 4986, 1,
		0, 0, 0, 5000, 421, 1, 0, 0, 0, 5001, 5002, 5, 33, 0, 0, 5002, 5003, 5,
		665, 0, 0, 5003, 5008, 3, 442, 221, 0, 5004, 5005, 5, 1133, 0, 0, 5005,
		5007, 3, 442, 221, 0, 5006, 5004, 1, 0, 0, 0, 5007, 5010, 1, 0, 0, 0, 5008,
		5006, 1, 0, 0, 0, 5008, 5009, 1, 0, 0, 0, 5009, 5067, 1, 0, 0, 0, 5010,
		5008, 1, 0, 0, 0, 5011, 5012, 5, 33, 0, 0, 5012, 5014, 5, 665, 0, 0, 5013,
		5015, 3, 626, 313, 0, 5014, 5013, 1, 0, 0, 0, 5014, 5015, 1, 0, 0, 0, 5015,
		5016, 1, 0, 0, 0, 5016, 5021, 3, 442, 221, 0, 5017, 5018, 5, 1133, 0, 0,
		5018, 5020, 3, 442, 221, 0, 5019, 5017, 1, 0, 0, 0, 5020, 5023, 1, 0, 0,
		0, 5021, 5019, 1, 0, 0, 0, 5021, 5022, 1, 0, 0, 0, 5022, 5027, 1, 0, 0,
		0, 5023, 5021, 1, 0, 0, 0, 5024, 5025, 5, 42, 0, 0, 5025, 5026, 5, 596,
		0, 0, 5026, 5028, 3, 428, 214, 0, 5027, 5024, 1, 0, 0, 0, 5027, 5028, 1,
		0, 0, 0, 5028, 5043, 1, 0, 0, 0, 5029, 5041, 5, 142, 0, 0, 5030, 5042,
		5, 529, 0, 0, 5031, 5038, 3, 446, 223, 0, 5032, 5034, 5, 10, 0, 0, 5033,
		5032, 1, 0, 0, 0, 5033, 5034, 1, 0, 0, 0, 5034, 5035, 1, 0, 0, 0, 5035,
		5037, 3, 446, 223, 0, 5036, 5033, 1, 0, 0, 0, 5037, 5040, 1, 0, 0, 0, 5038,
		5036, 1, 0, 0, 0, 5038, 5039, 1, 0, 0, 0, 5039, 5042, 1, 0, 0, 0, 5040,
		5038, 1, 0, 0, 0, 5041, 5030, 1, 0, 0, 0, 5041, 5031, 1, 0, 0, 0, 5042,
		5044, 1, 0, 0, 0, 5043, 5029, 1, 0, 0, 0, 5043, 5044, 1, 0, 0, 0, 5044,
		5051, 1, 0, 0, 0, 5045, 5047, 5, 192, 0, 0, 5046, 5048, 3, 448, 224, 0,
		5047, 5046, 1, 0, 0, 0, 5048, 5049, 1, 0, 0, 0, 5049, 5047, 1, 0, 0, 0,
		5049, 5050, 1, 0, 0, 0, 5050, 5052, 1, 0, 0, 0, 5051, 5045, 1, 0, 0, 0,
		5051, 5052, 1, 0, 0, 0, 5052, 5057, 1, 0, 0, 0, 5053, 5056, 3, 450, 225,
		0, 5054, 5056, 3, 452, 226, 0, 5055, 5053, 1, 0, 0, 0, 5055, 5054, 1, 0,
		0, 0, 5056, 5059, 1, 0, 0, 0, 5057, 5055, 1, 0, 0, 0, 5057, 5058, 1, 0,
		0, 0, 5058, 5064, 1, 0, 0, 0, 5059, 5057, 1, 0, 0, 0, 5060, 5061, 5, 368,
		0, 0, 5061, 5065, 5, 1146, 0, 0, 5062, 5063, 5, 14, 0, 0, 5063, 5065, 5,
		1146, 0, 0, 5064, 5060, 1, 0, 0, 0, 5064, 5062, 1, 0, 0, 0, 5064, 5065,
		1, 0, 0, 0, 5065, 5067, 1, 0, 0, 0, 5066, 5001, 1, 0, 0, 0, 5066, 5011,
		1, 0, 0, 0, 5067, 423, 1, 0, 0, 0, 5068, 5069, 5, 51, 0, 0, 5069, 5071,
		5, 665, 0, 0, 5070, 5072, 3, 624, 312, 0, 5071, 5070, 1, 0, 0, 0, 5071,
		5072, 1, 0, 0, 0, 5072, 5073, 1, 0, 0, 0, 5073, 5078, 3, 550, 275, 0, 5074,
		5075, 5, 1133, 0, 0, 5075, 5077, 3, 550, 275, 0, 5076, 5074, 1, 0, 0, 0,
		5077, 5080, 1, 0, 0, 0, 5078, 5076, 1, 0, 0, 0, 5078, 5079, 1, 0, 0, 0,
		5079, 425, 1, 0, 0, 0, 5080, 5078, 1, 0, 0, 0, 5081, 5082, 5, 72, 0, 0,
		5082, 5087, 3, 454, 227, 0, 5083, 5084, 5, 1133, 0, 0, 5084, 5086, 3, 454,
		227, 0, 5085, 5083, 1, 0, 0, 0, 5086, 5089, 1, 0, 0, 0, 5087, 5085, 1,
		0, 0, 0, 5087, 5088, 1, 0, 0, 0, 5088, 5090, 1, 0, 0, 0, 5089, 5087, 1,
		0, 0, 0, 5090, 5092, 5, 118, 0, 0, 5091, 5093, 7, 66, 0, 0, 5092, 5091,
		1, 0, 0, 0, 5092, 5093, 1, 0, 0, 0, 5093, 5094, 1, 0, 0, 0, 5094, 5095,
		3, 458, 229, 0, 5095, 5096, 5, 175, 0, 0, 5096, 5101, 3, 442, 221, 0, 5097,
		5098, 5, 1133, 0, 0, 5098, 5100, 3, 442, 221, 0, 5099, 5097, 1, 0, 0, 0,
		5100, 5103, 1, 0, 0, 0, 5101, 5099, 1, 0, 0, 0, 5101, 5102, 1, 0, 0, 0,
		5102, 5118, 1, 0, 0, 0, 5103, 5101, 1, 0, 0, 0, 5104, 5116, 5, 142, 0,
		0, 5105, 5117, 5, 529, 0, 0, 5106, 5113, 3, 446, 223, 0, 5107, 5109, 5,
		10, 0, 0, 5108, 5107, 1, 0, 0, 0, 5108, 5109, 1, 0, 0, 0, 5109, 5110, 1,
		0, 0, 0, 5110, 5112, 3, 446, 223, 0, 5111, 5108, 1, 0, 0, 0, 5112, 5115,
		1, 0, 0, 0, 5113, 5111, 1, 0, 0, 0, 5113, 5114, 1, 0, 0, 0, 5114, 5117,
		1, 0, 0, 0, 5115, 5113, 1, 0, 0, 0, 5116, 5105, 1, 0, 0, 0, 5116, 5106,
		1, 0, 0, 0, 5117, 5119, 1, 0, 0, 0, 5118, 5104, 1, 0, 0, 0, 5118, 5119,
		1, 0, 0, 0, 5119, 5129, 1, 0, 0, 0, 5120, 5126, 5, 192, 0, 0, 5121, 5122,
		5, 72, 0, 0, 5122, 5125, 5, 120, 0, 0, 5123, 5125, 3, 448, 224, 0, 5124,
		5121, 1, 0, 0, 0, 5124, 5123, 1, 0, 0, 0, 5125, 5128, 1, 0, 0, 0, 5126,
		5124, 1, 0, 0, 0, 5126, 5127, 1, 0, 0, 0, 5127, 5130, 1, 0, 0, 0, 5128,
		5126, 1, 0, 0, 0, 5129, 5120, 1, 0, 0, 0, 5129, 5130, 1, 0, 0, 0, 5130,
		5137, 1, 0, 0, 0, 5131, 5132, 5, 12, 0, 0, 5132, 5133, 3, 550, 275, 0,
		5133, 5134, 5, 192, 0, 0, 5134, 5135, 5, 596, 0, 0, 5135, 5136, 3, 428,
		214, 0, 5136, 5138, 1, 0, 0, 0, 5137, 5131, 1, 0, 0, 0, 5137, 5138, 1,
		0, 0, 0, 5138, 5175, 1, 0, 0, 0, 5139, 5142, 5, 72, 0, 0, 5140, 5143, 3,
		550, 275, 0, 5141, 5143, 3, 568, 284, 0, 5142, 5140, 1, 0, 0, 0, 5142,
		5141, 1, 0, 0, 0, 5143, 5151, 1, 0, 0, 0, 5144, 5147, 5, 1133, 0, 0, 5145,
		5148, 3, 550, 275, 0, 5146, 5148, 3, 568, 284, 0, 5147, 5145, 1, 0, 0,
		0, 5147, 5146, 1, 0, 0, 0, 5148, 5150, 1, 0, 0, 0, 5149, 5144, 1, 0, 0,
		0, 5150, 5153, 1, 0, 0, 0, 5151, 5149, 1, 0, 0, 0, 5151, 5152, 1, 0, 0,
		0, 5152, 5154, 1, 0, 0, 0, 5153, 5151, 1, 0, 0, 0, 5154, 5157, 5, 175,
		0, 0, 5155, 5158, 3, 550, 275, 0, 5156, 5158, 3, 568, 284, 0, 5157, 5155,
		1, 0, 0, 0, 5157, 5156, 1, 0, 0, 0, 5158, 5166, 1, 0, 0, 0, 5159, 5162,
		5, 1133, 0, 0, 5160, 5163, 3, 550, 275, 0, 5161, 5163, 3, 568, 284, 0,
		5162, 5160, 1, 0, 0, 0, 5162, 5161, 1, 0, 0, 0, 5163, 5165, 1, 0, 0, 0,
		5164, 5159, 1, 0, 0, 0, 5165, 5168, 1, 0, 0, 0, 5166, 5164, 1, 0, 0, 0,
		5166, 5167, 1, 0, 0, 0, 5167, 5172, 1, 0, 0, 0, 5168, 5166, 1, 0, 0, 0,
		5169, 5170, 5, 192, 0, 0, 5170, 5171, 5, 697, 0, 0, 5171, 5173, 5, 120,
		0, 0, 5172, 5169, 1, 0, 0, 0, 5172, 5173, 1, 0, 0, 0, 5173, 5175, 1, 0,
		0, 0, 5174, 5081, 1, 0, 0, 0, 5174, 5139, 1, 0, 0, 0, 5175, 427, 1, 0,
		0, 0, 5176, 5199, 5, 42, 0, 0, 5177, 5199, 5, 529, 0, 0, 5178, 5188, 5,
		6, 0, 0, 5179, 5180, 5, 59, 0, 0, 5180, 5185, 3, 550, 275, 0, 5181, 5182,
		5, 1133, 0, 0, 5182, 5184, 3, 550, 275, 0, 5183, 5181, 1, 0, 0, 0, 5184,
		5187, 1, 0, 0, 0, 5185, 5183, 1, 0, 0, 0, 5185, 5186, 1, 0, 0, 0, 5186,
		5189, 1, 0, 0, 0, 5187, 5185, 1, 0, 0, 0, 5188, 5179, 1, 0, 0, 0, 5188,
		5189, 1, 0, 0, 0, 5189, 5199, 1, 0, 0, 0, 5190, 5195, 3, 550, 275, 0, 5191,
		5192, 5, 1133, 0, 0, 5192, 5194, 3, 550, 275, 0, 5193, 5191, 1, 0, 0, 0,
		5194, 5197, 1, 0, 0, 0, 5195, 5193, 1, 0, 0, 0, 5195, 5196, 1, 0, 0, 0,
		5196, 5199, 1, 0, 0, 0, 5197, 5195, 1, 0, 0, 0, 5198, 5176, 1, 0, 0, 0,
		5198, 5177, 1, 0, 0, 0, 5198, 5178, 1, 0, 0, 0, 5198, 5190, 1, 0, 0, 0,
		5199, 429, 1, 0, 0, 0, 5200, 5201, 5, 72, 0, 0, 5201, 5202, 5, 566, 0,
		0, 5202, 5203, 5, 118, 0, 0, 5203, 5204, 3, 550, 275, 0, 5204, 5205, 5,
		175, 0, 0, 5205, 5210, 3, 550, 275, 0, 5206, 5207, 5, 1133, 0, 0, 5207,
		5209, 3, 550, 275, 0, 5208, 5206, 1, 0, 0, 0, 5209, 5212, 1, 0, 0, 0, 5210,
		5208, 1, 0, 0, 0, 5210, 5211, 1, 0, 0, 0, 5211, 5216, 1, 0, 0, 0, 5212,
		5210, 1, 0, 0, 0, 5213, 5214, 5, 192, 0, 0, 5214, 5215, 5, 72, 0, 0, 5215,
		5217, 5, 120, 0, 0, 5216, 5213, 1, 0, 0, 0, 5216, 5217, 1, 0, 0, 0, 5217,
		431, 1, 0, 0, 0, 5218, 5219, 5, 139, 0, 0, 5219, 5220, 5, 665, 0, 0, 5220,
		5225, 3, 460, 230, 0, 5221, 5222, 5, 1133, 0, 0, 5222, 5224, 3, 460, 230,
		0, 5223, 5221, 1, 0, 0, 0, 5224, 5227, 1, 0, 0, 0, 5225, 5223, 1, 0, 0,
		0, 5225, 5226, 1, 0, 0, 0, 5226, 433, 1, 0, 0, 0, 5227, 5225, 1, 0, 0,
		0, 5228, 5229, 5, 147, 0, 0, 5229, 5234, 3, 454, 227, 0, 5230, 5231, 5,
		1133, 0, 0, 5231, 5233, 3, 454, 227, 0, 5232, 5230, 1, 0, 0, 0, 5233, 5236,
		1, 0, 0, 0, 5234, 5232, 1, 0, 0, 0, 5234, 5235, 1, 0, 0, 0, 5235, 5237,
		1, 0, 0, 0, 5236, 5234, 1, 0, 0, 0, 5237, 5239, 5, 118, 0, 0, 5238, 5240,
		7, 66, 0, 0, 5239, 5238, 1, 0, 0, 0, 5239, 5240, 1, 0, 0, 0, 5240, 5241,
		1, 0, 0, 0, 5241, 5242, 3, 458, 229, 0, 5242, 5243, 5, 68, 0, 0, 5243,
		5248, 3, 550, 275, 0, 5244, 5245, 5, 1133, 0, 0, 5245, 5247, 3, 550, 275,
		0, 5246, 5244, 1, 0, 0, 0, 5247, 5250, 1, 0, 0, 0, 5248, 5246, 1, 0, 0,
		0, 5248, 5249, 1, 0, 0, 0, 5249, 5299, 1, 0, 0, 0, 5250, 5248, 1, 0, 0,
		0, 5251, 5252, 5, 147, 0, 0, 5252, 5254, 5, 6, 0, 0, 5253, 5255, 5, 724,
		0, 0, 5254, 5253, 1, 0, 0, 0, 5254, 5255, 1, 0, 0, 0, 5255, 5256, 1, 0,
		0, 0, 5256, 5257, 5, 1133, 0, 0, 5257, 5258, 5, 72, 0, 0, 5258, 5259, 5,
		120, 0, 0, 5259, 5260, 5, 68, 0, 0, 5260, 5265, 3, 550, 275, 0, 5261, 5262,
		5, 1133, 0, 0, 5262, 5264, 3, 550, 275, 0, 5263, 5261, 1, 0, 0, 0, 5264,
		5267, 1, 0, 0, 0, 5265, 5263, 1, 0, 0, 0, 5265, 5266, 1, 0, 0, 0, 5266,
		5299, 1, 0, 0, 0, 5267, 5265, 1, 0, 0, 0, 5268, 5271, 5, 147, 0, 0, 5269,
		5272, 3, 550, 275, 0, 5270, 5272, 3, 568, 284, 0, 5271, 5269, 1, 0, 0,
		0, 5271, 5270, 1, 0, 0, 0, 5272, 5280, 1, 0, 0, 0, 5273, 5276, 5, 1133,
		0, 0, 5274, 5277, 3, 550, 275, 0, 5275, 5277, 3, 568, 284, 0, 5276, 5274,
		1, 0, 0, 0, 5276, 5275, 1, 0, 0, 0, 5277, 5279, 1, 0, 0, 0, 5278, 5273,
		1, 0, 0, 0, 5279, 5282, 1, 0, 0, 0, 5280, 5278, 1, 0, 0, 0, 5280, 5281,
		1, 0, 0, 0, 5281, 5283, 1, 0, 0, 0, 5282, 5280, 1, 0, 0, 0, 5283, 5286,
		5, 68, 0, 0, 5284, 5287, 3, 550, 275, 0, 5285, 5287, 3, 568, 284, 0, 5286,
		5284, 1, 0, 0, 0, 5286, 5285, 1, 0, 0, 0, 5287, 5295, 1, 0, 0, 0, 5288,
		5291, 5, 1133, 0, 0, 5289, 5292, 3, 550, 275, 0, 5290, 5292, 3, 568, 284,
		0, 5291, 5289, 1, 0, 0, 0, 5291, 5290, 1, 0, 0, 0, 5292, 5294, 1, 0, 0,
		0, 5293, 5288, 1, 0, 0, 0, 5294, 5297, 1, 0, 0, 0, 5295, 5293, 1, 0, 0,
		0, 5295, 5296, 1, 0, 0, 0, 5296, 5299, 1, 0, 0, 0, 5297, 5295, 1, 0, 0,
		0, 5298, 5228, 1, 0, 0, 0, 5298, 5251, 1, 0, 0, 0, 5298, 5268, 1, 0, 0,
		0, 5299, 435, 1, 0, 0, 0, 5300, 5301, 5, 147, 0, 0, 5301, 5302, 5, 566,
		0, 0, 5302, 5303, 5, 118, 0, 0, 5303, 5304, 3, 550, 275, 0, 5304, 5305,
		5, 68, 0, 0, 5305, 5310, 3, 550, 275, 0, 5306, 5307, 5, 1133, 0, 0, 5307,
		5309, 3, 550, 275, 0, 5308, 5306, 1, 0, 0, 0, 5309, 5312, 1, 0, 0, 0, 5310,
		5308, 1, 0, 0, 0, 5310, 5311, 1, 0, 0, 0, 5311, 437, 1, 0, 0, 0, 5312,
		5310, 1, 0, 0, 0, 5313, 5314, 5, 153, 0, 0, 5314, 5317, 5, 551, 0, 0, 5315,
		5316, 5, 65, 0, 0, 5316, 5318, 3, 550, 275, 0, 5317, 5315, 1, 0, 0, 0,
		5317, 5318, 1, 0, 0, 0, 5318, 5319, 1, 0, 0, 0, 5319, 5322, 5, 1122, 0,
		0, 5320, 5323, 3, 666, 333, 0, 5321, 5323, 5, 1146, 0, 0, 5322, 5320, 1,
		0, 0, 0, 5322, 5321, 1, 0, 0, 0, 5323, 439, 1, 0, 0, 0, 5324, 5325, 3,
		550, 275, 0, 5325, 5326, 3, 450, 225, 0, 5326, 441, 1, 0, 0, 0, 5327, 5328,
		3, 550, 275, 0, 5328, 5329, 5, 448, 0, 0, 5329, 5330, 5, 19, 0, 0, 5330,
		5331, 5, 551, 0, 0, 5331, 5332, 5, 1146, 0, 0, 5332, 5349, 1, 0, 0, 0,
		5333, 5334, 3, 550, 275, 0, 5334, 5335, 5, 448, 0, 0, 5335, 5336, 5, 19,
		0, 0, 5336, 5340, 5, 1146, 0, 0, 5337, 5338, 5, 145, 0, 0, 5338, 5339,
		5, 35, 0, 0, 5339, 5341, 5, 551, 0, 0, 5340, 5337, 1, 0, 0, 0, 5340, 5341,
		1, 0, 0, 0, 5341, 5349, 1, 0, 0, 0, 5342, 5343, 3, 550, 275, 0, 5343, 5344,
		5, 448, 0, 0, 5344, 5345, 5, 192, 0, 0, 5345, 5346, 3, 444, 222, 0, 5346,
		5349, 1, 0, 0, 0, 5347, 5349, 3, 550, 275, 0, 5348, 5327, 1, 0, 0, 0, 5348,
		5333, 1, 0, 0, 0, 5348, 5342, 1, 0, 0, 0, 5348, 5347, 1, 0, 0, 0, 5349,
		443, 1, 0, 0, 0, 5350, 5353, 3, 566, 283, 0, 5351, 5352, 7, 67, 0, 0, 5352,
		5354, 5, 1146, 0, 0, 5353, 5351, 1, 0, 0, 0, 5353, 5354, 1, 0, 0, 0, 5354,
		5360, 1, 0, 0, 0, 5355, 5356, 3, 566, 283, 0, 5356, 5357, 5, 187, 0, 0,
		5357, 5358, 3, 666, 333, 0, 5358, 5360, 1, 0, 0, 0, 5359, 5350, 1, 0, 0,
		0, 5359, 5355, 1, 0, 0, 0, 5360, 445, 1, 0, 0, 0, 5361, 5370, 5, 167, 0,
		0, 5362, 5370, 5, 680, 0, 0, 5363, 5364, 5, 358, 0, 0, 5364, 5370, 5, 1146,
		0, 0, 5365, 5366, 5, 465, 0, 0, 5366, 5370, 5, 1146, 0, 0, 5367, 5368,
		5, 640, 0, 0, 5368, 5370, 5, 1146, 0, 0, 5369, 5361, 1, 0, 0, 0, 5369,
		5362, 1, 0, 0, 0, 5369, 5363, 1, 0, 0, 0, 5369, 5365, 1, 0, 0, 0, 5369,
		5367, 1, 0, 0, 0, 5370, 447, 1, 0, 0, 0, 5371, 5372, 5, 499, 0, 0, 5372,
		5380, 3, 574, 287, 0, 5373, 5374, 5, 502, 0, 0, 5374, 5380, 3, 574, 287,
		0, 5375, 5376, 5, 498, 0, 0, 5376, 5380, 3, 574, 287, 0, 5377, 5378, 5,
		503, 0, 0, 5378, 5380, 3, 574, 287, 0, 5379, 5371, 1, 0, 0, 0, 5379, 5373,
		1, 0, 0, 0, 5379, 5375, 1, 0, 0, 0, 5379, 5377, 1, 0, 0, 0, 5380, 449,
		1, 0, 0, 0, 5381, 5382, 5, 551, 0, 0, 5382, 5389, 5, 420, 0, 0, 5383, 5390,
		5, 42, 0, 0, 5384, 5390, 5, 519, 0, 0, 5385, 5386, 5, 86, 0, 0, 5386, 5387,
		3, 574, 287, 0, 5387, 5388, 5, 691, 0, 0, 5388, 5390, 1, 0, 0, 0, 5389,
		5383, 1, 0, 0, 0, 5389, 5384, 1, 0, 0, 0, 5389, 5385, 1, 0, 0, 0, 5389,
		5390, 1, 0, 0, 0, 5390, 5420, 1, 0, 0, 0, 5391, 5392, 5, 551, 0, 0, 5392,
		5395, 5, 445, 0, 0, 5393, 5396, 5, 42, 0, 0, 5394, 5396, 3, 574, 287, 0,
		5395, 5393, 1, 0, 0, 0, 5395, 5394, 1, 0, 0, 0, 5396, 5420, 1, 0, 0, 0,
		5397, 5398, 5, 551, 0, 0, 5398, 5399, 5, 595, 0, 0, 5399, 5404, 5, 86,
		0, 0, 5400, 5405, 5, 42, 0, 0, 5401, 5402, 3, 574, 287, 0, 5402, 5403,
		5, 691, 0, 0, 5403, 5405, 1, 0, 0, 0, 5404, 5400, 1, 0, 0, 0, 5404, 5401,
		1, 0, 0, 0, 5405, 5420, 1, 0, 0, 0, 5406, 5407, 5, 551, 0, 0, 5407, 5408,
		5, 142, 0, 0, 5408, 5410, 5, 35, 0, 0, 5409, 5411, 7, 68, 0, 0, 5410, 5409,
		1, 0, 0, 0, 5410, 5411, 1, 0, 0, 0, 5411, 5420, 1, 0, 0, 0, 5412, 5413,
		5, 424, 0, 0, 5413, 5420, 3, 574, 287, 0, 5414, 5417, 5, 552, 0, 0, 5415,
		5418, 3, 574, 287, 0, 5416, 5418, 5, 657, 0, 0, 5417, 5415, 1, 0, 0, 0,
		5417, 5416, 1, 0, 0, 0, 5418, 5420, 1, 0, 0, 0, 5419, 5381, 1, 0, 0, 0,
		5419, 5391, 1, 0, 0, 0, 5419, 5397, 1, 0, 0, 0, 5419, 5406, 1, 0, 0, 0,
		5419, 5412, 1, 0, 0, 0, 5419, 5414, 1, 0, 0, 0, 5420, 451, 1, 0, 0, 0,
		5421, 5422, 5, 332, 0, 0, 5422, 5423, 7, 69, 0, 0, 5423, 453, 1, 0, 0,
		0, 5424, 5429, 3, 456, 228, 0, 5425, 5426, 5, 1131, 0, 0, 5426, 5427, 3,
		600, 300, 0, 5427, 5428, 5, 1132, 0, 0, 5428, 5430, 1, 0, 0, 0, 5429, 5425,
		1, 0, 0, 0, 5429, 5430, 1, 0, 0, 0, 5430, 455, 1, 0, 0, 0, 5431, 5433,
		5, 6, 0, 0, 5432, 5434, 5, 724, 0, 0, 5433, 5432, 1, 0, 0, 0, 5433, 5434,
		1, 0, 0, 0, 5434, 5524, 1, 0, 0, 0, 5435, 5437, 5, 7, 0, 0, 5436, 5438,
		5, 732, 0, 0, 5437, 5436, 1, 0, 0, 0, 5437, 5438, 1, 0, 0, 0, 5438, 5524,
		1, 0, 0, 0, 5439, 5447, 5, 33, 0, 0, 5440, 5441, 5, 649, 0, 0, 5441, 5448,
		5, 741, 0, 0, 5442, 5448, 5, 732, 0, 0, 5443, 5448, 5, 671, 0, 0, 5444,
		5448, 5, 665, 0, 0, 5445, 5448, 5, 647, 0, 0, 5446, 5448, 5, 596, 0, 0,
		5447, 5440, 1, 0, 0, 0, 5447, 5442, 1, 0, 0, 0, 5447, 5443, 1, 0, 0, 0,
		5447, 5444, 1, 0, 0, 0, 5447, 5445, 1, 0, 0, 0, 5447, 5446, 1, 0, 0, 0,
		5447, 5448, 1, 0, 0, 0, 5448, 5524, 1, 0, 0, 0, 5449, 5524, 5, 44, 0, 0,
		5450, 5452, 5, 51, 0, 0, 5451, 5453, 5, 596, 0, 0, 5452, 5451, 1, 0, 0,
		0, 5452, 5453, 1, 0, 0, 0, 5453, 5524, 1, 0, 0, 0, 5454, 5524, 5, 415,
		0, 0, 5455, 5524, 5, 707, 0, 0, 5456, 5524, 5, 708, 0, 0, 5457, 5458, 5,
		72, 0, 0, 5458, 5524, 5, 120, 0, 0, 5459, 5524, 5, 81, 0, 0, 5460, 5524,
		5, 85, 0, 0, 5461, 5462, 5, 103, 0, 0, 5462, 5524, 5, 741, 0, 0, 5463,
		5524, 5, 725, 0, 0, 5464, 5524, 5, 566, 0, 0, 5465, 5524, 5, 136, 0, 0,
		5466, 5524, 5, 726, 0, 0, 5467, 5468, 5, 588, 0, 0, 5468, 5524, 7, 70,
		0, 0, 5469, 5524, 5, 152, 0, 0, 5470, 5471, 5, 155, 0, 0, 5471, 5524, 7,
		71, 0, 0, 5472, 5524, 5, 738, 0, 0, 5473, 5524, 5, 739, 0, 0, 5474, 5524,
		5, 177, 0, 0, 5475, 5524, 5, 184, 0, 0, 5476, 5524, 5, 185, 0, 0, 5477,
		5524, 5, 698, 0, 0, 5478, 5524, 5, 699, 0, 0, 5479, 5524, 5, 700, 0, 0,
		5480, 5524, 5, 701, 0, 0, 5481, 5524, 5, 702, 0, 0, 5482, 5524, 5, 703,
		0, 0, 5483, 5524, 5, 704, 0, 0, 5484, 5524, 5, 705, 0, 0, 5485, 5524, 5,
		706, 0, 0, 5486, 5524, 5, 709, 0, 0, 5487, 5524, 5, 710, 0, 0, 5488, 5524,
		5, 711, 0, 0, 5489, 5524, 5, 712, 0, 0, 5490, 5524, 5, 713, 0, 0, 5491,
		5524, 5, 714, 0, 0, 5492, 5524, 5, 715, 0, 0, 5493, 5524, 5, 716, 0, 0,
		5494, 5524, 5, 717, 0, 0, 5495, 5524, 5, 718, 0, 0, 5496, 5524, 5, 721,
		0, 0, 5497, 5524, 5, 722, 0, 0, 5498, 5524, 5, 723, 0, 0, 5499, 5524, 5,
		727, 0, 0, 5500, 5524, 5, 728, 0, 0, 5501, 5524, 5, 729, 0, 0, 5502, 5524,
		5, 730, 0, 0, 5503, 5524, 5, 731, 0, 0, 5504, 5524, 5, 734, 0, 0, 5505,
		5524, 5, 735, 0, 0, 5506, 5524, 5, 736, 0, 0, 5507, 5524, 5, 158, 0, 0,
		5508, 5524, 5, 737, 0, 0, 5509, 5524, 5, 1075, 0, 0, 5510, 5524, 5, 740,
		0, 0, 5511, 5524, 5, 742, 0, 0, 5512, 5524, 5, 1086, 0, 0, 5513, 5524,
		5, 743, 0, 0, 5514, 5524, 5, 744, 0, 0, 5515, 5516, 5, 102, 0, 0, 5516,
		5517, 5, 68, 0, 0, 5517, 5524, 5, 733, 0, 0, 5518, 5519, 5, 152, 0, 0,
		5519, 5520, 5, 87, 0, 0, 5520, 5524, 5, 733, 0, 0, 5521, 5522, 5, 719,
		0, 0, 5522, 5524, 5, 720, 0, 0, 5523, 5431, 1, 0, 0, 0, 5523, 5435, 1,
		0, 0, 0, 5523, 5439, 1, 0, 0, 0, 5523, 5449, 1, 0, 0, 0, 5523, 5450, 1,
		0, 0, 0, 5523, 5454, 1, 0, 0, 0, 5523, 5455, 1, 0, 0, 0, 5523, 5456, 1,
		0, 0, 0, 5523, 5457, 1, 0, 0, 0, 5523, 5459, 1, 0, 0, 0, 5523, 5460, 1,
		0, 0, 0, 5523, 5461, 1, 0, 0, 0, 5523, 5463, 1, 0, 0, 0, 5523, 5464, 1,
		0, 0, 0, 5523, 5465, 1, 0, 0, 0, 5523, 5466, 1, 0, 0, 0, 5523, 5467, 1,
		0, 0, 0, 5523, 5469, 1, 0, 0, 0, 5523, 5470, 1, 0, 0, 0, 5523, 5472, 1,
		0, 0, 0, 5523, 5473, 1, 0, 0, 0, 5523, 5474, 1, 0, 0, 0, 5523, 5475, 1,
		0, 0, 0, 5523, 5476, 1, 0, 0, 0, 5523, 5477, 1, 0, 0, 0, 5523, 5478, 1,
		0, 0, 0, 5523, 5479, 1, 0, 0, 0, 5523, 5480, 1, 0, 0, 0, 5523, 5481, 1,
		0, 0, 0, 5523, 5482, 1, 0, 0, 0, 5523, 5483, 1, 0, 0, 0, 5523, 5484, 1,
		0, 0, 0, 5523, 5485, 1, 0, 0, 0, 5523, 5486, 1, 0, 0, 0, 5523, 5487, 1,
		0, 0, 0, 5523, 5488, 1, 0, 0, 0, 5523, 5489, 1, 0, 0, 0, 5523, 5490, 1,
		0, 0, 0, 5523, 5491, 1, 0, 0, 0, 5523, 5492, 1, 0, 0, 0, 5523, 5493, 1,
		0, 0, 0, 5523, 5494, 1, 0, 0, 0, 5523, 5495, 1, 0, 0, 0, 5523, 5496, 1,
		0, 0, 0, 5523, 5497, 1, 0, 0, 0, 5523, 5498, 1, 0, 0, 0, 5523, 5499, 1,
		0, 0, 0, 5523, 5500, 1, 0, 0, 0, 5523, 5501, 1, 0, 0, 0, 5523, 5502, 1,
		0, 0, 0, 5523, 5503, 1, 0, 0, 0, 5523, 5504, 1, 0, 0, 0, 5523, 5505, 1,
		0, 0, 0, 5523, 5506, 1, 0, 0, 0, 5523, 5507, 1, 0, 0, 0, 5523, 5508, 1,
		0, 0, 0, 5523, 5509, 1, 0, 0, 0, 5523, 5510, 1, 0, 0, 0, 5523, 5511, 1,
		0, 0, 0, 5523, 5512, 1, 0, 0, 0, 5523, 5513, 1, 0, 0, 0, 5523, 5514, 1,
		0, 0, 0, 5523, 5515, 1, 0, 0, 0, 5523, 5518, 1, 0, 0, 0, 5523, 5521, 1,
		0, 0, 0, 5524, 457, 1, 0, 0, 0, 5525, 5542, 5, 1115, 0, 0, 5526, 5527,
		5, 1115, 0, 0, 5527, 5528, 5, 1130, 0, 0, 5528, 5542, 5, 1115, 0, 0, 5529,
		5530, 3, 568, 284, 0, 5530, 5531, 5, 1130, 0, 0, 5531, 5532, 5, 1115, 0,
		0, 5532, 5542, 1, 0, 0, 0, 5533, 5534, 3, 568, 284, 0, 5534, 5535, 5, 1130,
		0, 0, 5535, 5536, 3, 568, 284, 0, 5536, 5542, 1, 0, 0, 0, 5537, 5538, 3,
		568, 284, 0, 5538, 5539, 3, 572, 286, 0, 5539, 5542, 1, 0, 0, 0, 5540,
		5542, 3, 568, 284, 0, 5541, 5525, 1, 0, 0, 0, 5541, 5526, 1, 0, 0, 0, 5541,
		5529, 1, 0, 0, 0, 5541, 5533, 1, 0, 0, 0, 5541, 5537, 1, 0, 0, 0, 5541,
		5540, 1, 0, 0, 0, 5542, 459, 1, 0, 0, 0, 5543, 5544, 3, 550, 275, 0, 5544,
		5545, 5, 175, 0, 0, 5545, 5546, 3, 550, 275, 0, 5546, 461, 1, 0, 0, 0,
		5547, 5549, 5, 9, 0, 0, 5548, 5550, 7, 72, 0, 0, 5549, 5548, 1, 0, 0, 0,
		5549, 5550, 1, 0, 0, 0, 5550, 5551, 1, 0, 0, 0, 5551, 5552, 7, 54, 0, 0,
		5552, 5570, 3, 604, 302, 0, 5553, 5554, 5, 184, 0, 0, 5554, 5555, 5, 76,
		0, 0, 5555, 5556, 5, 118, 0, 0, 5556, 5561, 3, 546, 273, 0, 5557, 5558,
		5, 1133, 0, 0, 5558, 5560, 3, 546, 273, 0, 5559, 5557, 1, 0, 0, 0, 5560,
		5563, 1, 0, 0, 0, 5561, 5559, 1, 0, 0, 0, 5561, 5562, 1, 0, 0, 0, 5562,
		5568, 1, 0, 0, 0, 5563, 5561, 1, 0, 0, 0, 5564, 5565, 5, 192, 0, 0, 5565,
		5566, 3, 574, 287, 0, 5566, 5567, 5, 18, 0, 0, 5567, 5569, 1, 0, 0, 0,
		5568, 5564, 1, 0, 0, 0, 5568, 5569, 1, 0, 0, 0, 5569, 5571, 1, 0, 0, 0,
		5570, 5553, 1, 0, 0, 0, 5570, 5571, 1, 0, 0, 0, 5571, 5583, 1, 0, 0, 0,
		5572, 5573, 5, 51, 0, 0, 5573, 5574, 5, 76, 0, 0, 5574, 5575, 5, 118, 0,
		0, 5575, 5580, 3, 546, 273, 0, 5576, 5577, 5, 1133, 0, 0, 5577, 5579, 3,
		546, 273, 0, 5578, 5576, 1, 0, 0, 0, 5579, 5582, 1, 0, 0, 0, 5580, 5578,
		1, 0, 0, 0, 5580, 5581, 1, 0, 0, 0, 5581, 5584, 1, 0, 0, 0, 5582, 5580,
		1, 0, 0, 0, 5583, 5572, 1, 0, 0, 0, 5583, 5584, 1, 0, 0, 0, 5584, 463,
		1, 0, 0, 0, 5585, 5586, 5, 26, 0, 0, 5586, 5587, 5, 172, 0, 0, 5587, 5591,
		3, 604, 302, 0, 5588, 5590, 3, 472, 236, 0, 5589, 5588, 1, 0, 0, 0, 5590,
		5593, 1, 0, 0, 0, 5591, 5589, 1, 0, 0, 0, 5591, 5592, 1, 0, 0, 0, 5592,
		465, 1, 0, 0, 0, 5593, 5591, 1, 0, 0, 0, 5594, 5595, 5, 356, 0, 0, 5595,
		5596, 5, 172, 0, 0, 5596, 5598, 3, 604, 302, 0, 5597, 5599, 7, 73, 0, 0,
		5598, 5597, 1, 0, 0, 0, 5598, 5599, 1, 0, 0, 0, 5599, 467, 1, 0, 0, 0,
		5600, 5602, 5, 119, 0, 0, 5601, 5603, 7, 72, 0, 0, 5602, 5601, 1, 0, 0,
		0, 5602, 5603, 1, 0, 0, 0, 5603, 5604, 1, 0, 0, 0, 5604, 5605, 7, 54, 0,
		0, 5605, 5606, 3, 604, 302, 0, 5606, 469, 1, 0, 0, 0, 5607, 5609, 5, 580,
		0, 0, 5608, 5610, 7, 72, 0, 0, 5609, 5608, 1, 0, 0, 0, 5609, 5610, 1, 0,
		0, 0, 5610, 5611, 1, 0, 0, 0, 5611, 5612, 5, 172, 0, 0, 5612, 5614, 3,
		604, 302, 0, 5613, 5615, 5, 568, 0, 0, 5614, 5613, 1, 0, 0, 0, 5614, 5615,
		1, 0, 0, 0, 5615, 5617, 1, 0, 0, 0, 5616, 5618, 5, 422, 0, 0, 5617, 5616,
		1, 0, 0, 0, 5617, 5618, 1, 0, 0, 0, 5618, 5620, 1, 0, 0, 0, 5619, 5621,
		5, 666, 0, 0, 5620, 5619, 1, 0, 0, 0, 5620, 5621, 1, 0, 0, 0, 5621, 471,
		1, 0, 0, 0, 5622, 5623, 5, 65, 0, 0, 5623, 5630, 5, 664, 0, 0, 5624, 5630,
		5, 568, 0, 0, 5625, 5630, 5, 425, 0, 0, 5626, 5630, 5, 504, 0, 0, 5627,
		5630, 5, 422, 0, 0, 5628, 5630, 5, 354, 0, 0, 5629, 5622, 1, 0, 0, 0, 5629,
		5624, 1, 0, 0, 0, 5629, 5625, 1, 0, 0, 0, 5629, 5626, 1, 0, 0, 0, 5629,
		5627, 1, 0, 0, 0, 5629, 5628, 1, 0, 0, 0, 5630, 473, 1, 0, 0, 0, 5631,
		5633, 5, 33, 0, 0, 5632, 5634, 5, 335, 0, 0, 5633, 5632, 1, 0, 0, 0, 5633,
		5634, 1, 0, 0, 0, 5634, 5635, 1, 0, 0, 0, 5635, 5637, 5, 437, 0, 0, 5636,
		5638, 3, 626, 313, 0, 5637, 5636, 1, 0, 0, 0, 5637, 5638, 1, 0, 0, 0, 5638,
		5639, 1, 0, 0, 0, 5639, 5640, 3, 568, 284, 0, 5640, 5641, 5, 594, 0, 0,
		5641, 5642, 7, 74, 0, 0, 5642, 5643, 5, 619, 0, 0, 5643, 5644, 5, 1146,
		0, 0, 5644, 475, 1, 0, 0, 0, 5645, 5646, 5, 456, 0, 0, 5646, 5647, 5, 554,
		0, 0, 5647, 5648, 3, 568, 284, 0, 5648, 5649, 5, 619, 0, 0, 5649, 5650,
		5, 1146, 0, 0, 5650, 477, 1, 0, 0, 0, 5651, 5652, 5, 661, 0, 0, 5652, 5653,
		5, 554, 0, 0, 5653, 5654, 3, 568, 284, 0, 5654, 479, 1, 0, 0, 0, 5655,
		5656, 5, 153, 0, 0, 5656, 5657, 3, 484, 242, 0, 5657, 5660, 7, 75, 0, 0,
		5658, 5661, 3, 672, 336, 0, 5659, 5661, 5, 118, 0, 0, 5660, 5658, 1, 0,
		0, 0, 5660, 5659, 1, 0, 0, 0, 5661, 5671, 1, 0, 0, 0, 5662, 5663, 5, 1133,
		0, 0, 5663, 5664, 3, 484, 242, 0, 5664, 5667, 7, 75, 0, 0, 5665, 5668,
		3, 672, 336, 0, 5666, 5668, 5, 118, 0, 0, 5667, 5665, 1, 0, 0, 0, 5667,
		5666, 1, 0, 0, 0, 5668, 5670, 1, 0, 0, 0, 5669, 5662, 1, 0, 0, 0, 5670,
		5673, 1, 0, 0, 0, 5671, 5669, 1, 0, 0, 0, 5671, 5672, 1, 0, 0, 0, 5672,
		5708, 1, 0, 0, 0, 5673, 5671, 1, 0, 0, 0, 5674, 5675, 5, 153, 0, 0, 5675,
		5678, 3, 60, 30, 0, 5676, 5679, 3, 554, 277, 0, 5677, 5679, 5, 42, 0, 0,
		5678, 5676, 1, 0, 0, 0, 5678, 5677, 1, 0, 0, 0, 5679, 5708, 1, 0, 0, 0,
		5680, 5681, 5, 153, 0, 0, 5681, 5688, 5, 517, 0, 0, 5682, 5685, 3, 554,
		277, 0, 5683, 5684, 5, 27, 0, 0, 5684, 5686, 3, 556, 278, 0, 5685, 5683,
		1, 0, 0, 0, 5685, 5686, 1, 0, 0, 0, 5686, 5689, 1, 0, 0, 0, 5687, 5689,
		5, 42, 0, 0, 5688, 5682, 1, 0, 0, 0, 5688, 5687, 1, 0, 0, 0, 5689, 5708,
		1, 0, 0, 0, 5690, 5708, 3, 438, 219, 0, 5691, 5708, 3, 312, 156, 0, 5692,
		5708, 3, 310, 155, 0, 5693, 5694, 5, 153, 0, 0, 5694, 5695, 3, 540, 270,
		0, 5695, 5696, 7, 75, 0, 0, 5696, 5704, 3, 672, 336, 0, 5697, 5698, 5,
		1133, 0, 0, 5698, 5699, 3, 540, 270, 0, 5699, 5700, 7, 75, 0, 0, 5700,
		5701, 3, 672, 336, 0, 5701, 5703, 1, 0, 0, 0, 5702, 5697, 1, 0, 0, 0, 5703,
		5706, 1, 0, 0, 0, 5704, 5702, 1, 0, 0, 0, 5704, 5705, 1, 0, 0, 0, 5705,
		5708, 1, 0, 0, 0, 5706, 5704, 1, 0, 0, 0, 5707, 5655, 1, 0, 0, 0, 5707,
		5674, 1, 0, 0, 0, 5707, 5680, 1, 0, 0, 0, 5707, 5690, 1, 0, 0, 0, 5707,
		5691, 1, 0, 0, 0, 5707, 5692, 1, 0, 0, 0, 5707, 5693, 1, 0, 0, 0, 5708,
		481, 1, 0, 0, 0, 5709, 5710, 5, 155, 0, 0, 5710, 5711, 7, 56, 0, 0, 5711,
		5863, 5, 476, 0, 0, 5712, 5713, 5, 155, 0, 0, 5713, 5714, 7, 76, 0, 0,
		5714, 5717, 5, 416, 0, 0, 5715, 5716, 5, 80, 0, 0, 5716, 5718, 5, 1146,
		0, 0, 5717, 5715, 1, 0, 0, 0, 5717, 5718, 1, 0, 0, 0, 5718, 5721, 1, 0,
		0, 0, 5719, 5720, 5, 68, 0, 0, 5720, 5722, 3, 574, 287, 0, 5721, 5719,
		1, 0, 0, 0, 5721, 5722, 1, 0, 0, 0, 5722, 5730, 1, 0, 0, 0, 5723, 5727,
		5, 99, 0, 0, 5724, 5725, 3, 574, 287, 0, 5725, 5726, 5, 1133, 0, 0, 5726,
		5728, 1, 0, 0, 0, 5727, 5724, 1, 0, 0, 0, 5727, 5728, 1, 0, 0, 0, 5728,
		5729, 1, 0, 0, 0, 5729, 5731, 3, 574, 287, 0, 5730, 5723, 1, 0, 0, 0, 5730,
		5731, 1, 0, 0, 0, 5731, 5863, 1, 0, 0, 0, 5732, 5733, 5, 155, 0, 0, 5733,
		5735, 3, 486, 243, 0, 5734, 5736, 3, 488, 244, 0, 5735, 5734, 1, 0, 0,
		0, 5735, 5736, 1, 0, 0, 0, 5736, 5863, 1, 0, 0, 0, 5737, 5739, 5, 155,
		0, 0, 5738, 5740, 5, 436, 0, 0, 5739, 5738, 1, 0, 0, 0, 5739, 5740, 1,
		0, 0, 0, 5740, 5741, 1, 0, 0, 0, 5741, 5742, 7, 41, 0, 0, 5742, 5743, 7,
		77, 0, 0, 5743, 5746, 3, 542, 271, 0, 5744, 5745, 7, 77, 0, 0, 5745, 5747,
		3, 568, 284, 0, 5746, 5744, 1, 0, 0, 0, 5746, 5747, 1, 0, 0, 0, 5747, 5749,
		1, 0, 0, 0, 5748, 5750, 3, 488, 244, 0, 5749, 5748, 1, 0, 0, 0, 5749, 5750,
		1, 0, 0, 0, 5750, 5863, 1, 0, 0, 0, 5751, 5752, 5, 155, 0, 0, 5752, 5753,
		5, 33, 0, 0, 5753, 5755, 7, 0, 0, 0, 5754, 5756, 3, 626, 313, 0, 5755,
		5754, 1, 0, 0, 0, 5755, 5756, 1, 0, 0, 0, 5756, 5757, 1, 0, 0, 0, 5757,
		5863, 3, 568, 284, 0, 5758, 5759, 5, 155, 0, 0, 5759, 5760, 5, 33, 0, 0,
		5760, 5761, 7, 78, 0, 0, 5761, 5863, 3, 540, 270, 0, 5762, 5763, 5, 155,
		0, 0, 5763, 5764, 5, 33, 0, 0, 5764, 5765, 5, 665, 0, 0, 5765, 5863, 3,
		550, 275, 0, 5766, 5767, 5, 155, 0, 0, 5767, 5768, 5, 409, 0, 0, 5768,
		5769, 3, 558, 279, 0, 5769, 5770, 7, 79, 0, 0, 5770, 5863, 1, 0, 0, 0,
		5771, 5772, 5, 155, 0, 0, 5772, 5863, 3, 490, 245, 0, 5773, 5774, 5, 155,
		0, 0, 5774, 5782, 7, 80, 0, 0, 5775, 5779, 5, 99, 0, 0, 5776, 5777, 3,
		574, 287, 0, 5777, 5778, 5, 1133, 0, 0, 5778, 5780, 1, 0, 0, 0, 5779, 5776,
		1, 0, 0, 0, 5779, 5780, 1, 0, 0, 0, 5780, 5781, 1, 0, 0, 0, 5781, 5783,
		3, 574, 287, 0, 5782, 5775, 1, 0, 0, 0, 5782, 5783, 1, 0, 0, 0, 5783, 5863,
		1, 0, 0, 0, 5784, 5785, 5, 155, 0, 0, 5785, 5786, 5, 290, 0, 0, 5786, 5787,
		5, 1131, 0, 0, 5787, 5788, 5, 1115, 0, 0, 5788, 5789, 5, 1132, 0, 0, 5789,
		5863, 7, 80, 0, 0, 5790, 5791, 5, 155, 0, 0, 5791, 5794, 3, 492, 246, 0,
		5792, 5793, 7, 77, 0, 0, 5793, 5795, 3, 568, 284, 0, 5794, 5792, 1, 0,
		0, 0, 5794, 5795, 1, 0, 0, 0, 5795, 5797, 1, 0, 0, 0, 5796, 5798, 3, 488,
		244, 0, 5797, 5796, 1, 0, 0, 0, 5797, 5798, 1, 0, 0, 0, 5798, 5863, 1,
		0, 0, 0, 5799, 5800, 5, 155, 0, 0, 5800, 5801, 7, 81, 0, 0, 5801, 5802,
		5, 364, 0, 0, 5802, 5863, 3, 540, 270, 0, 5803, 5804, 5, 155, 0, 0, 5804,
		5807, 5, 440, 0, 0, 5805, 5806, 5, 65, 0, 0, 5806, 5808, 3, 550, 275, 0,
		5807, 5805, 1, 0, 0, 0, 5807, 5808, 1, 0, 0, 0, 5808, 5863, 1, 0, 0, 0,
		5809, 5810, 5, 155, 0, 0, 5810, 5811, 7, 82, 0, 0, 5811, 5812, 7, 77, 0,
		0, 5812, 5815, 3, 542, 271, 0, 5813, 5814, 7, 77, 0, 0, 5814, 5816, 3,
		568, 284, 0, 5815, 5813, 1, 0, 0, 0, 5815, 5816, 1, 0, 0, 0, 5816, 5819,
		1, 0, 0, 0, 5817, 5818, 5, 190, 0, 0, 5818, 5820, 3, 672, 336, 0, 5819,
		5817, 1, 0, 0, 0, 5819, 5820, 1, 0, 0, 0, 5820, 5863, 1, 0, 0, 0, 5821,
		5822, 5, 155, 0, 0, 5822, 5823, 5, 539, 0, 0, 5823, 5826, 5, 741, 0, 0,
		5824, 5825, 7, 77, 0, 0, 5825, 5827, 3, 568, 284, 0, 5826, 5824, 1, 0,
		0, 0, 5826, 5827, 1, 0, 0, 0, 5827, 5829, 1, 0, 0, 0, 5828, 5830, 3, 488,
		244, 0, 5829, 5828, 1, 0, 0, 0, 5829, 5830, 1, 0, 0, 0, 5830, 5863, 1,
		0, 0, 0, 5831, 5832, 5, 155, 0, 0, 5832, 5833, 5, 564, 0, 0, 5833, 5838,
		3, 494, 247, 0, 5834, 5835, 5, 1133, 0, 0, 5835, 5837, 3, 494, 247, 0,
		5836, 5834, 1, 0, 0, 0, 5837, 5840, 1, 0, 0, 0, 5838, 5836, 1, 0, 0, 0,
		5838, 5839, 1, 0, 0, 0, 5839, 5844, 1, 0, 0, 0, 5840, 5838, 1, 0, 0, 0,
		5841, 5842, 5, 65, 0, 0, 5842, 5843, 5, 567, 0, 0, 5843, 5845, 3, 574,
		287, 0, 5844, 5841, 1, 0, 0, 0, 5844, 5845, 1, 0, 0, 0, 5845, 5846, 1,
		0, 0, 0, 5846, 5850, 5, 99, 0, 0, 5847, 5848, 3, 574, 287, 0, 5848, 5849,
		5, 1133, 0, 0, 5849, 5851, 1, 0, 0, 0, 5850, 5847, 1, 0, 0, 0, 5850, 5851,
		1, 0, 0, 0, 5851, 5852, 1, 0, 0, 0, 5852, 5853, 3, 574, 287, 0, 5853, 5863,
		1, 0, 0, 0, 5854, 5855, 5, 155, 0, 0, 5855, 5856, 5, 614, 0, 0, 5856, 5860,
		5, 634, 0, 0, 5857, 5858, 5, 65, 0, 0, 5858, 5859, 5, 355, 0, 0, 5859,
		5861, 5, 1146, 0, 0, 5860, 5857, 1, 0, 0, 0, 5860, 5861, 1, 0, 0, 0, 5861,
		5863, 1, 0, 0, 0, 5862, 5709, 1, 0, 0, 0, 5862, 5712, 1, 0, 0, 0, 5862,
		5732, 1, 0, 0, 0, 5862, 5737, 1, 0, 0, 0, 5862, 5751, 1, 0, 0, 0, 5862,
		5758, 1, 0, 0, 0, 5862, 5762, 1, 0, 0, 0, 5862, 5766, 1, 0, 0, 0, 5862,
		5771, 1, 0, 0, 0, 5862, 5773, 1, 0, 0, 0, 5862, 5784, 1, 0, 0, 0, 5862,
		5790, 1, 0, 0, 0, 5862, 5799, 1, 0, 0, 0, 5862, 5803, 1, 0, 0, 0, 5862,
		5809, 1, 0, 0, 0, 5862, 5821, 1, 0, 0, 0, 5862, 5831, 1, 0, 0, 0, 5862,
		5854, 1, 0, 0, 0, 5863, 483, 1, 0, 0, 0, 5864, 5875, 5, 1158, 0, 0, 5865,
		5875, 5, 1159, 0, 0, 5866, 5867, 5, 1135, 0, 0, 5867, 5869, 5, 1135, 0,
		0, 5868, 5866, 1, 0, 0, 0, 5868, 5869, 1, 0, 0, 0, 5869, 5870, 1, 0, 0,
		0, 5870, 5872, 7, 83, 0, 0, 5871, 5868, 1, 0, 0, 0, 5871, 5872, 1, 0, 0,
		0, 5872, 5873, 1, 0, 0, 0, 5873, 5875, 3, 568, 284, 0, 5874, 5864, 1, 0,
		0, 0, 5874, 5865, 1, 0, 0, 0, 5874, 5871, 1, 0, 0, 0, 5875, 485, 1, 0,
		0, 0, 5876, 5877, 5, 25, 0, 0, 5877, 5890, 5, 153, 0, 0, 5878, 5890, 5,
		843, 0, 0, 5879, 5890, 5, 40, 0, 0, 5880, 5890, 5, 151, 0, 0, 5881, 5882,
		5, 437, 0, 0, 5882, 5890, 5, 634, 0, 0, 5883, 5884, 5, 131, 0, 0, 5884,
		5890, 5, 634, 0, 0, 5885, 5887, 7, 55, 0, 0, 5886, 5885, 1, 0, 0, 0, 5886,
		5887, 1, 0, 0, 0, 5887, 5888, 1, 0, 0, 0, 5888, 5890, 7, 84, 0, 0, 5889,
		5876, 1, 0, 0, 0, 5889, 5878, 1, 0, 0, 0, 5889, 5879, 1, 0, 0, 0, 5889,
		5880, 1, 0, 0, 0, 5889, 5881, 1, 0, 0, 0, 5889, 5883, 1, 0, 0, 0, 5889,
		5886, 1, 0, 0, 0, 5890, 487, 1, 0, 0, 0, 5891, 5892, 5, 98, 0, 0, 5892,
		5896, 5, 1146, 0, 0, 5893, 5894, 5, 190, 0, 0, 5894, 5896, 3, 672, 336,
		0, 5895, 5891, 1, 0, 0, 0, 5895, 5893, 1, 0, 0, 0, 5896, 489, 1, 0, 0,
		0, 5897, 5899, 5, 636, 0, 0, 5898, 5897, 1, 0, 0, 0, 5898, 5899, 1, 0,
		0, 0, 5899, 5900, 1, 0, 0, 0, 5900, 5915, 5, 410, 0, 0, 5901, 5902, 5,
		477, 0, 0, 5902, 5915, 5, 634, 0, 0, 5903, 5915, 5, 556, 0, 0, 5904, 5915,
		5, 724, 0, 0, 5905, 5907, 5, 436, 0, 0, 5906, 5905, 1, 0, 0, 0, 5906, 5907,
		1, 0, 0, 0, 5907, 5908, 1, 0, 0, 0, 5908, 5915, 5, 563, 0, 0, 5909, 5915,
		5, 565, 0, 0, 5910, 5911, 5, 614, 0, 0, 5911, 5915, 5, 447, 0, 0, 5912,
		5915, 5, 339, 0, 0, 5913, 5915, 5, 383, 0, 0, 5914, 5898, 1, 0, 0, 0, 5914,
		5901, 1, 0, 0, 0, 5914, 5903, 1, 0, 0, 0, 5914, 5904, 1, 0, 0, 0, 5914,
		5906, 1, 0, 0, 0, 5914, 5909, 1, 0, 0, 0, 5914, 5910, 1, 0, 0, 0, 5914,
		5912, 1, 0, 0, 0, 5914, 5913, 1, 0, 0, 0, 5915, 491, 1, 0, 0, 0, 5916,
		5925, 5, 416, 0, 0, 5917, 5918, 5, 172, 0, 0, 5918, 5925, 5, 634, 0, 0,
		5919, 5921, 5, 436, 0, 0, 5920, 5919, 1, 0, 0, 0, 5920, 5921, 1, 0, 0,
		0, 5921, 5922, 1, 0, 0, 0, 5922, 5925, 5, 741, 0, 0, 5923, 5925, 5, 655,
		0, 0, 5924, 5916, 1, 0, 0, 0, 5924, 5917, 1, 0, 0, 0, 5924, 5920, 1, 0,
		0, 0, 5924, 5923, 1, 0, 0, 0, 5925, 493, 1, 0, 0, 0, 5926, 5939, 5, 6,
		0, 0, 5927, 5928, 5, 347, 0, 0, 5928, 5939, 5, 461, 0, 0, 5929, 5930, 5,
		382, 0, 0, 5930, 5939, 5, 645, 0, 0, 5931, 5939, 5, 385, 0, 0, 5932, 5939,
		5, 463, 0, 0, 5933, 5939, 5, 791, 0, 0, 5934, 5935, 5, 544, 0, 0, 5935,
		5939, 5, 426, 0, 0, 5936, 5939, 5, 621, 0, 0, 5937, 5939, 5, 644, 0, 0,
		5938, 5926, 1, 0, 0, 0, 5938, 5927, 1, 0, 0, 0, 5938, 5929, 1, 0, 0, 0,
		5938, 5931, 1, 0, 0, 0, 5938, 5932, 1, 0, 0, 0, 5938, 5933, 1, 0, 0, 0,
		5938, 5934, 1, 0, 0, 0, 5938, 5936, 1, 0, 0, 0, 5938, 5937, 1, 0, 0, 0,
		5939, 495, 1, 0, 0, 0, 5940, 5941, 5, 345, 0, 0, 5941, 5942, 5, 1146, 0,
		0, 5942, 497, 1, 0, 0, 0, 5943, 5944, 5, 351, 0, 0, 5944, 5945, 5, 81,
		0, 0, 5945, 5950, 3, 510, 255, 0, 5946, 5947, 5, 1133, 0, 0, 5947, 5949,
		3, 510, 255, 0, 5948, 5946, 1, 0, 0, 0, 5949, 5952, 1, 0, 0, 0, 5950, 5948,
		1, 0, 0, 0, 5950, 5951, 1, 0, 0, 0, 5951, 5960, 1, 0, 0, 0, 5952, 5950,
		1, 0, 0, 0, 5953, 5954, 5, 129, 0, 0, 5954, 5957, 5, 1131, 0, 0, 5955,
		5958, 3, 600, 300, 0, 5956, 5958, 5, 6, 0, 0, 5957, 5955, 1, 0, 0, 0, 5957,
		5956, 1, 0, 0, 0, 5958, 5959, 1, 0, 0, 0, 5959, 5961, 5, 1132, 0, 0, 5960,
		5953, 1, 0, 0, 0, 5960, 5961, 1, 0, 0, 0, 5961, 5962, 1, 0, 0, 0, 5962,
		5963, 5, 80, 0, 0, 5963, 5964, 3, 568, 284, 0, 5964, 499, 1, 0, 0, 0, 5965,
		5967, 5, 432, 0, 0, 5966, 5968, 7, 72, 0, 0, 5967, 5966, 1, 0, 0, 0, 5967,
		5968, 1, 0, 0, 0, 5968, 5969, 1, 0, 0, 0, 5969, 5974, 3, 512, 256, 0, 5970,
		5971, 5, 1133, 0, 0, 5971, 5973, 3, 512, 256, 0, 5972, 5970, 1, 0, 0, 0,
		5973, 5976, 1, 0, 0, 0, 5974, 5972, 1, 0, 0, 0, 5974, 5975, 1, 0, 0, 0,
		5975, 501, 1, 0, 0, 0, 5976, 5974, 1, 0, 0, 0, 5977, 5979, 5, 93, 0, 0,
		5978, 5980, 7, 85, 0, 0, 5979, 5978, 1, 0, 0, 0, 5979, 5980, 1, 0, 0, 0,
		5980, 5981, 1, 0, 0, 0, 5981, 5982, 3, 672, 336, 0, 5982, 503, 1, 0, 0,
		0, 5983, 5984, 5, 102, 0, 0, 5984, 5985, 5, 81, 0, 0, 5985, 5986, 5, 87,
		0, 0, 5986, 5987, 5, 351, 0, 0, 5987, 5992, 3, 516, 258, 0, 5988, 5989,
		5, 1133, 0, 0, 5989, 5991, 3, 516, 258, 0, 5990, 5988, 1, 0, 0, 0, 5991,
		5994, 1, 0, 0, 0, 5992, 5990, 1, 0, 0, 0, 5992, 5993, 1, 0, 0, 0, 5993,
		505, 1, 0, 0, 0, 5994, 5992, 1, 0, 0, 0, 5995, 5996, 5, 589, 0, 0, 5996,
		5997, 5, 567, 0, 0, 5997, 5998, 5, 351, 0, 0, 5998, 507, 1, 0, 0, 0, 5999,
		6000, 5, 738, 0, 0, 6000, 509, 1, 0, 0, 0, 6001, 6009, 3, 542, 271, 0,
		6002, 6004, 7, 20, 0, 0, 6003, 6002, 1, 0, 0, 0, 6003, 6004, 1, 0, 0, 0,
		6004, 6005, 1, 0, 0, 0, 6005, 6006, 5, 1131, 0, 0, 6006, 6007, 3, 600,
		300, 0, 6007, 6008, 5, 1132, 0, 0, 6008, 6010, 1, 0, 0, 0, 6009, 6003,
		1, 0, 0, 0, 6009, 6010, 1, 0, 0, 0, 6010, 511, 1, 0, 0, 0, 6011, 6030,
		5, 394, 0, 0, 6012, 6030, 5, 447, 0, 0, 6013, 6015, 7, 86, 0, 0, 6014,
		6013, 1, 0, 0, 0, 6014, 6015, 1, 0, 0, 0, 6015, 6016, 1, 0, 0, 0, 6016,
		6030, 5, 476, 0, 0, 6017, 6030, 5, 540, 0, 0, 6018, 6030, 5, 724, 0, 0,
		6019, 6020, 5, 567, 0, 0, 6020, 6030, 5, 351, 0, 0, 6021, 6030, 5, 634,
		0, 0, 6022, 6030, 5, 667, 0, 0, 6023, 6027, 5, 741, 0, 0, 6024, 6025, 5,
		192, 0, 0, 6025, 6026, 5, 134, 0, 0, 6026, 6028, 5, 103, 0, 0, 6027, 6024,
		1, 0, 0, 0, 6027, 6028, 1, 0, 0, 0, 6028, 6030, 1, 0, 0, 0, 6029, 6011,
		1, 0, 0, 0, 6029, 6012, 1, 0, 0, 0, 6029, 6014, 1, 0, 0, 0, 6029, 6017,
		1, 0, 0, 0, 6029, 6018, 1, 0, 0, 0, 6029, 6019, 1, 0, 0, 0, 6029, 6021,
		1, 0, 0, 0, 6029, 6022, 1, 0, 0, 0, 6029, 6023, 1, 0, 0, 0, 6030, 6044,
		1, 0, 0, 0, 6031, 6032, 5, 574, 0, 0, 6032, 6034, 5, 476, 0, 0, 6033, 6035,
		3, 350, 175, 0, 6034, 6033, 1, 0, 0, 0, 6034, 6035, 1, 0, 0, 0, 6035, 6044,
		1, 0, 0, 0, 6036, 6038, 7, 54, 0, 0, 6037, 6039, 3, 604, 302, 0, 6038,
		6037, 1, 0, 0, 0, 6038, 6039, 1, 0, 0, 0, 6039, 6041, 1, 0, 0, 0, 6040,
		6042, 3, 514, 257, 0, 6041, 6040, 1, 0, 0, 0, 6041, 6042, 1, 0, 0, 0, 6042,
		6044, 1, 0, 0, 0, 6043, 6029, 1, 0, 0, 0, 6043, 6031, 1, 0, 0, 0, 6043,
		6036, 1, 0, 0, 0, 6044, 513, 1, 0, 0, 0, 6045, 6046, 5, 192, 0, 0, 6046,
		6047, 5, 134, 0, 0, 6047, 6051, 5, 103, 0, 0, 6048, 6049, 5, 65, 0, 0,
		6049, 6051, 5, 421, 0, 0, 6050, 6045, 1, 0, 0, 0, 6050, 6048, 1, 0, 0,
		0, 6051, 515, 1, 0, 0, 0, 6052, 6060, 3, 542, 271, 0, 6053, 6054, 5, 129,
		0, 0, 6054, 6057, 5, 1131, 0, 0, 6055, 6058, 3, 600, 300, 0, 6056, 6058,
		5, 6, 0, 0, 6057, 6055, 1, 0, 0, 0, 6057, 6056, 1, 0, 0, 0, 6058, 6059,
		1, 0, 0, 0, 6059, 6061, 5, 1132, 0, 0, 6060, 6053, 1, 0, 0, 0, 6060, 6061,
		1, 0, 0, 0, 6061, 6069, 1, 0, 0, 0, 6062, 6064, 7, 20, 0, 0, 6063, 6062,
		1, 0, 0, 0, 6063, 6064, 1, 0, 0, 0, 6064, 6065, 1, 0, 0, 0, 6065, 6066,
		5, 1131, 0, 0, 6066, 6067, 3, 600, 300, 0, 6067, 6068, 5, 1132, 0, 0, 6068,
		6070, 1, 0, 0, 0, 6069, 6063, 1, 0, 0, 0, 6069, 6070, 1, 0, 0, 0, 6070,
		6073, 1, 0, 0, 0, 6071, 6072, 5, 78, 0, 0, 6072, 6074, 5, 470, 0, 0, 6073,
		6071, 1, 0, 0, 0, 6073, 6074, 1, 0, 0, 0, 6074, 517, 1, 0, 0, 0, 6075,
		6076, 7, 87, 0, 0, 6076, 6079, 3, 542, 271, 0, 6077, 6080, 3, 568, 284,
		0, 6078, 6080, 5, 1146, 0, 0, 6079, 6077, 1, 0, 0, 0, 6079, 6078, 1, 0,
		0, 0, 6079, 6080, 1, 0, 0, 0, 6080, 519, 1, 0, 0, 0, 6081, 6085, 7, 87,
		0, 0, 6082, 6083, 7, 88, 0, 0, 6083, 6084, 5, 1122, 0, 0, 6084, 6086, 7,
		89, 0, 0, 6085, 6082, 1, 0, 0, 0, 6085, 6086, 1, 0, 0, 0, 6086, 6087, 1,
		0, 0, 0, 6087, 6088, 3, 538, 269, 0, 6088, 521, 1, 0, 0, 0, 6089, 6090,
		5, 444, 0, 0, 6090, 6091, 5, 1146, 0, 0, 6091, 523, 1, 0, 0, 0, 6092, 6093,
		5, 186, 0, 0, 6093, 6094, 3, 568, 284, 0, 6094, 525, 1, 0, 0, 0, 6095,
		6103, 5, 156, 0, 0, 6096, 6098, 5, 162, 0, 0, 6097, 6099, 5, 669, 0, 0,
		6098, 6097, 1, 0, 0, 0, 6098, 6099, 1, 0, 0, 0, 6099, 6100, 1, 0, 0, 0,
		6100, 6104, 3, 578, 289, 0, 6101, 6104, 5, 1154, 0, 0, 6102, 6104, 5, 1155,
		0, 0, 6103, 6096, 1, 0, 0, 0, 6103, 6101, 1, 0, 0, 0, 6103, 6102, 1, 0,
		0, 0, 6104, 6114, 1, 0, 0, 0, 6105, 6106, 5, 153, 0, 0, 6106, 6111, 3,
		530, 265, 0, 6107, 6108, 5, 1133, 0, 0, 6108, 6110, 3, 530, 265, 0, 6109,
		6107, 1, 0, 0, 0, 6110, 6113, 1, 0, 0, 0, 6111, 6109, 1, 0, 0, 0, 6111,
		6112, 1, 0, 0, 0, 6112, 6115, 1, 0, 0, 0, 6113, 6111, 1, 0, 0, 0, 6114,
		6105, 1, 0, 0, 0, 6114, 6115, 1, 0, 0, 0, 6115, 527, 1, 0, 0, 0, 6116,
		6124, 5, 143, 0, 0, 6117, 6119, 5, 162, 0, 0, 6118, 6120, 5, 669, 0, 0,
		6119, 6118, 1, 0, 0, 0, 6119, 6120, 1, 0, 0, 0, 6120, 6121, 1, 0, 0, 0,
		6121, 6125, 3, 578, 289, 0, 6122, 6125, 5, 1154, 0, 0, 6123, 6125, 5, 1155,
		0, 0, 6124, 6117, 1, 0, 0, 0, 6124, 6122, 1, 0, 0, 0, 6124, 6123, 1, 0,
		0, 0, 6124, 6125, 1, 0, 0, 0, 6125, 6135, 1, 0, 0, 0, 6126, 6127, 5, 153,
		0, 0, 6127, 6132, 3, 530, 265, 0, 6128, 6129, 5, 1133, 0, 0, 6129, 6131,
		3, 530, 265, 0, 6130, 6128, 1, 0, 0, 0, 6131, 6134, 1, 0, 0, 0, 6132, 6130,
		1, 0, 0, 0, 6132, 6133, 1, 0, 0, 0, 6133, 6136, 1, 0, 0, 0, 6134, 6132,
		1, 0, 0, 0, 6135, 6126, 1, 0, 0, 0, 6135, 6136, 1, 0, 0, 0, 6136, 529,
		1, 0, 0, 0, 6137, 6138, 7, 90, 0, 0, 6138, 6143, 5, 1122, 0, 0, 6139, 6144,
		3, 578, 289, 0, 6140, 6144, 5, 1147, 0, 0, 6141, 6144, 3, 552, 276, 0,
		6142, 6144, 3, 570, 285, 0, 6143, 6139, 1, 0, 0, 0, 6143, 6140, 1, 0, 0,
		0, 6143, 6141, 1, 0, 0, 0, 6143, 6142, 1, 0, 0, 0, 6144, 531, 1, 0, 0,
		0, 6145, 6147, 5, 192, 0, 0, 6146, 6148, 5, 571, 0, 0, 6147, 6146, 1, 0,
		0, 0, 6147, 6148, 1, 0, 0, 0, 6148, 6149, 1, 0, 0, 0, 6149, 6154, 3, 50,
		25, 0, 6150, 6151, 5, 1133, 0, 0, 6151, 6153, 3, 50, 25, 0, 6152, 6150,
		1, 0, 0, 0, 6153, 6156, 1, 0, 0, 0, 6154, 6152, 1, 0, 0, 0, 6154, 6155,
		1, 0, 0, 0, 6155, 533, 1, 0, 0, 0, 6156, 6154, 1, 0, 0, 0, 6157, 6159,
		5, 71, 0, 0, 6158, 6160, 7, 91, 0, 0, 6159, 6158, 1, 0, 0, 0, 6159, 6160,
		1, 0, 0, 0, 6160, 6161, 1, 0, 0, 0, 6161, 6193, 5, 48, 0, 0, 6162, 6163,
		3, 484, 242, 0, 6163, 6164, 5, 1122, 0, 0, 6164, 6172, 7, 92, 0, 0, 6165,
		6166, 5, 1133, 0, 0, 6166, 6167, 3, 484, 242, 0, 6167, 6168, 5, 1122, 0,
		0, 6168, 6169, 7, 92, 0, 0, 6169, 6171, 1, 0, 0, 0, 6170, 6165, 1, 0, 0,
		0, 6171, 6174, 1, 0, 0, 0, 6172, 6170, 1, 0, 0, 0, 6172, 6173, 1, 0, 0,
		0, 6173, 6194, 1, 0, 0, 0, 6174, 6172, 1, 0, 0, 0, 6175, 6178, 5, 29, 0,
		0, 6176, 6179, 3, 574, 287, 0, 6177, 6179, 3, 484, 242, 0, 6178, 6176,
		1, 0, 0, 0, 6178, 6177, 1, 0, 0, 0, 6179, 6180, 1, 0, 0, 0, 6180, 6181,
		3, 484, 242, 0, 6181, 6182, 5, 1122, 0, 0, 6182, 6190, 3, 536, 268, 0,
		6183, 6184, 5, 1133, 0, 0, 6184, 6185, 3, 484, 242, 0, 6185, 6186, 5, 1122,
		0, 0, 6186, 6187, 3, 536, 268, 0, 6187, 6189, 1, 0, 0, 0, 6188, 6183, 1,
		0, 0, 0, 6189, 6192, 1, 0, 0, 0, 6190, 6188, 1, 0, 0, 0, 6190, 6191, 1,
		0, 0, 0, 6191, 6194, 1, 0, 0, 0, 6192, 6190, 1, 0, 0, 0, 6193, 6162, 1,
		0, 0, 0, 6193, 6175, 1, 0, 0, 0, 6194, 535, 1, 0, 0, 0, 6195, 6196, 7,
		93, 0, 0, 6196, 537, 1, 0, 0, 0, 6197, 6203, 3, 196, 98, 0, 6198, 6203,
		3, 182, 91, 0, 6199, 6203, 3, 188, 94, 0, 6200, 6203, 3, 194, 97, 0, 6201,
		6203, 3, 198, 99, 0, 6202, 6197, 1, 0, 0, 0, 6202, 6198, 1, 0, 0, 0, 6202,
		6199, 1, 0, 0, 0, 6202, 6200, 1, 0, 0, 0, 6202, 6201, 1, 0, 0, 0, 6203,
		6208, 1, 0, 0, 0, 6204, 6205, 5, 65, 0, 0, 6205, 6206, 5, 376, 0, 0, 6206,
		6208, 3, 568, 284, 0, 6207, 6202, 1, 0, 0, 0, 6207, 6204, 1, 0, 0, 0, 6208,
		539, 1, 0, 0, 0, 6209, 6213, 3, 568, 284, 0, 6210, 6214, 5, 1153, 0, 0,
		6211, 6212, 5, 1130, 0, 0, 6212, 6214, 3, 568, 284, 0, 6213, 6210, 1, 0,
		0, 0, 6213, 6211, 1, 0, 0, 0, 6213, 6214, 1, 0, 0, 0, 6214, 541, 1, 0,
		0, 0, 6215, 6216, 3, 540, 270, 0, 6216, 543, 1, 0, 0, 0, 6217, 6220, 3,
		550, 275, 0, 6218, 6220, 3, 568, 284, 0, 6219, 6217, 1, 0, 0, 0, 6219,
		6218, 1, 0, 0, 0, 6220, 545, 1, 0, 0, 0, 6221, 6226, 3, 568, 284, 0, 6222,
		6224, 3, 572, 286, 0, 6223, 6225, 3, 572, 286, 0, 6224, 6223, 1, 0, 0,
		0, 6224, 6225, 1, 0, 0, 0, 6225, 6227, 1, 0, 0, 0, 6226, 6222, 1, 0, 0,
		0, 6226, 6227, 1, 0, 0, 0, 6227, 6236, 1, 0, 0, 0, 6228, 6230, 9, 0, 0,
		0, 6229, 6228, 1, 0, 0, 0, 6229, 6230, 1, 0, 0, 0, 6230, 6231, 1, 0, 0,
		0, 6231, 6233, 3, 572, 286, 0, 6232, 6234, 3, 572, 286, 0, 6233, 6232,
		1, 0, 0, 0, 6233, 6234, 1, 0, 0, 0, 6234, 6236, 1, 0, 0, 0, 6235, 6221,
		1, 0, 0, 0, 6235, 6229, 1, 0, 0, 0, 6236, 547, 1, 0, 0, 0, 6237, 6240,
		3, 568, 284, 0, 6238, 6240, 5, 1146, 0, 0, 6239, 6237, 1, 0, 0, 0, 6239,
		6238, 1, 0, 0, 0, 6240, 6245, 1, 0, 0, 0, 6241, 6242, 5, 1131, 0, 0, 6242,
		6243, 3, 574, 287, 0, 6243, 6244, 5, 1132, 0, 0, 6244, 6246, 1, 0, 0, 0,
		6245, 6241, 1, 0, 0, 0, 6245, 6246, 1, 0, 0, 0, 6246, 6249, 1, 0, 0, 0,
		6247, 6249, 3, 672, 336, 0, 6248, 6239, 1, 0, 0, 0, 6248, 6247, 1, 0, 0,
		0, 6249, 6251, 1, 0, 0, 0, 6250, 6252, 7, 48, 0, 0, 6251, 6250, 1, 0, 0,
		0, 6251, 6252, 1, 0, 0, 0, 6252, 549, 1, 0, 0, 0, 6253, 6259, 5, 1156,
		0, 0, 6254, 6259, 5, 1154, 0, 0, 6255, 6259, 5, 1146, 0, 0, 6256, 6259,
		5, 697, 0, 0, 6257, 6259, 3, 700, 350, 0, 6258, 6253, 1, 0, 0, 0, 6258,
		6254, 1, 0, 0, 0, 6258, 6255, 1, 0, 0, 0, 6258, 6256, 1, 0, 0, 0, 6258,
		6257, 1, 0, 0, 0, 6259, 551, 1, 0, 0, 0, 6260, 6261, 7, 94, 0, 0, 6261,
		553, 1, 0, 0, 0, 6262, 6267, 5, 226, 0, 0, 6263, 6267, 3, 690, 345, 0,
		6264, 6267, 5, 1146, 0, 0, 6265, 6267, 5, 1143, 0, 0, 6266, 6262, 1, 0,
		0, 0, 6266, 6263, 1, 0, 0, 0, 6266, 6264, 1, 0, 0, 0, 6266, 6265, 1, 0,
		0, 0, 6267, 555, 1, 0, 0, 0, 6268, 6271, 3, 568, 284, 0, 6269, 6271, 5,
		1146, 0, 0, 6270, 6268, 1, 0, 0, 0, 6270, 6269, 1, 0, 0, 0, 6271, 557,
		1, 0, 0, 0, 6272, 6273, 7, 95, 0, 0, 6273, 559, 1, 0, 0, 0, 6274, 6275,
		3, 574, 287, 0, 6275, 6276, 5, 1119, 0, 0, 6276, 6277, 3, 574, 287, 0,
		6277, 6278, 5, 1119, 0, 0, 6278, 6279, 3, 574, 287, 0, 6279, 6280, 5, 1119,
		0, 0, 6280, 6281, 3, 574, 287, 0, 6281, 6282, 5, 1119, 0, 0, 6282, 6288,
		3, 574, 287, 0, 6283, 6284, 5, 1142, 0, 0, 6284, 6285, 3, 574, 287, 0,
		6285, 6286, 5, 1119, 0, 0, 6286, 6287, 3, 574, 287, 0, 6287, 6289, 1, 0,
		0, 0, 6288, 6283, 1, 0, 0, 0, 6289, 6290, 1, 0, 0, 0, 6290, 6288, 1, 0,
		0, 0, 6290, 6291, 1, 0, 0, 0, 6291, 561, 1, 0, 0, 0, 6292, 6299, 3, 564,
		282, 0, 6293, 6294, 5, 1133, 0, 0, 6294, 6297, 3, 564, 282, 0, 6295, 6296,
		5, 1133, 0, 0, 6296, 6298, 3, 574, 287, 0, 6297, 6295, 1, 0, 0, 0, 6297,
		6298, 1, 0, 0, 0, 6298, 6300, 1, 0, 0, 0, 6299, 6293, 1, 0, 0, 0, 6299,
		6300, 1, 0, 0, 0, 6300, 563, 1, 0, 0, 0, 6301, 6309, 5, 1146, 0, 0, 6302,
		6309, 5, 1151, 0, 0, 6303, 6305, 5, 1148, 0, 0, 6304, 6303, 1, 0, 0, 0,
		6305, 6306, 1, 0, 0, 0, 6306, 6304, 1, 0, 0, 0, 6306, 6307, 1, 0, 0, 0,
		6307, 6309, 1, 0, 0, 0, 6308, 6301, 1, 0, 0, 0, 6308, 6302, 1, 0, 0, 0,
		6308, 6304, 1, 0, 0, 0, 6309, 565, 1, 0, 0, 0, 6310, 6313, 3, 568, 284,
		0, 6311, 6313, 5, 1146, 0, 0, 6312, 6310, 1, 0, 0, 0, 6312, 6311, 1, 0,
		0, 0, 6313, 567, 1, 0, 0, 0, 6314, 6318, 3, 570, 285, 0, 6315, 6318, 5,
		1155, 0, 0, 6316, 6318, 5, 1143, 0, 0, 6317, 6314, 1, 0, 0, 0, 6317, 6315,
		1, 0, 0, 0, 6317, 6316, 1, 0, 0, 0, 6318, 569, 1, 0, 0, 0, 6319, 6329,
		5, 1154, 0, 0, 6320, 6329, 3, 690, 345, 0, 6321, 6329, 3, 692, 346, 0,
		6322, 6329, 3, 558, 279, 0, 6323, 6329, 3, 694, 347, 0, 6324, 6329, 3,
		696, 348, 0, 6325, 6329, 3, 698, 349, 0, 6326, 6329, 3, 700, 350, 0, 6327,
		6329, 3, 664, 332, 0, 6328, 6319, 1, 0, 0, 0, 6328, 6320, 1, 0, 0, 0, 6328,
		6321, 1, 0, 0, 0, 6328, 6322, 1, 0, 0, 0, 6328, 6323, 1, 0, 0, 0, 6328,
		6324, 1, 0, 0, 0, 6328, 6325, 1, 0, 0, 0, 6328, 6326, 1, 0, 0, 0, 6328,
		6327, 1, 0, 0, 0, 6329, 571, 1, 0, 0, 0, 6330, 6334, 5, 1153, 0, 0, 6331,
		6332, 5, 1130, 0, 0, 6332, 6334, 3, 568, 284, 0, 6333, 6330, 1, 0, 0, 0,
		6333, 6331, 1, 0, 0, 0, 6334, 573, 1, 0, 0, 0, 6335, 6336, 7, 96, 0, 0,
		6336, 575, 1, 0, 0, 0, 6337, 6340, 5, 1144, 0, 0, 6338, 6340, 3, 574, 287,
		0, 6339, 6337, 1, 0, 0, 0, 6339, 6338, 1, 0, 0, 0, 6340, 577, 1, 0, 0,
		0, 6341, 6343, 5, 1152, 0, 0, 6342, 6341, 1, 0, 0, 0, 6342, 6343, 1, 0,
		0, 0, 6343, 6344, 1, 0, 0, 0, 6344, 6347, 5, 1146, 0, 0, 6345, 6347, 5,
		1145, 0, 0, 6346, 6342, 1, 0, 0, 0, 6346, 6345, 1, 0, 0, 0, 6347, 6349,
		1, 0, 0, 0, 6348, 6350, 5, 1146, 0, 0, 6349, 6348, 1, 0, 0, 0, 6350, 6351,
		1, 0, 0, 0, 6351, 6349, 1, 0, 0, 0, 6351, 6352, 1, 0, 0, 0, 6352, 6365,
		1, 0, 0, 0, 6353, 6355, 5, 1152, 0, 0, 6354, 6353, 1, 0, 0, 0, 6354, 6355,
		1, 0, 0, 0, 6355, 6356, 1, 0, 0, 0, 6356, 6359, 5, 1146, 0, 0, 6357, 6359,
		5, 1145, 0, 0, 6358, 6354, 1, 0, 0, 0, 6358, 6357, 1, 0, 0, 0, 6359, 6362,
		1, 0, 0, 0, 6360, 6361, 5, 27, 0, 0, 6361, 6363, 3, 556, 278, 0, 6362,
		6360, 1, 0, 0, 0, 6362, 6363, 1, 0, 0, 0, 6363, 6365, 1, 0, 0, 0, 6364,
		6346, 1, 0, 0, 0, 6364, 6358, 1, 0, 0, 0, 6365, 579, 1, 0, 0, 0, 6366,
		6367, 7, 97, 0, 0, 6367, 581, 1, 0, 0, 0, 6368, 6370, 5, 1152, 0, 0, 6369,
		6368, 1, 0, 0, 0, 6369, 6370, 1, 0, 0, 0, 6370, 6371, 1, 0, 0, 0, 6371,
		6372, 5, 1148, 0, 0, 6372, 583, 1, 0, 0, 0, 6373, 6375, 5, 114, 0, 0, 6374,
		6373, 1, 0, 0, 0, 6374, 6375, 1, 0, 0, 0, 6375, 6376, 1, 0, 0, 0, 6376,
		6377, 7, 98, 0, 0, 6377, 585, 1, 0, 0, 0, 6378, 6391, 3, 578, 289, 0, 6379,
		6391, 3, 574, 287, 0, 6380, 6381, 5, 1119, 0, 0, 6381, 6391, 3, 574, 287,
		0, 6382, 6391, 3, 582, 291, 0, 6383, 6391, 3, 580, 290, 0, 6384, 6391,
		5, 1149, 0, 0, 6385, 6391, 5, 1151, 0, 0, 6386, 6388, 5, 114, 0, 0, 6387,
		6386, 1, 0, 0, 0, 6387, 6388, 1, 0, 0, 0, 6388, 6389, 1, 0, 0, 0, 6389,
		6391, 7, 98, 0, 0, 6390, 6378, 1, 0, 0, 0, 6390, 6379, 1, 0, 0, 0, 6390,
		6380, 1, 0, 0, 0, 6390, 6382, 1, 0, 0, 0, 6390, 6383, 1, 0, 0, 0, 6390,
		6384, 1, 0, 0, 0, 6390, 6385, 1, 0, 0, 0, 6390, 6387, 1, 0, 0, 0, 6391,
		587, 1, 0, 0, 0, 6392, 6394, 7, 99, 0, 0, 6393, 6395, 5, 238, 0, 0, 6394,
		6393, 1, 0, 0, 0, 6394, 6395, 1, 0, 0, 0, 6395, 6397, 1, 0, 0, 0, 6396,
		6398, 3, 594, 297, 0, 6397, 6396, 1, 0, 0, 0, 6397, 6398, 1, 0, 0, 0, 6398,
		6400, 1, 0, 0, 0, 6399, 6401, 5, 226, 0, 0, 6400, 6399, 1, 0, 0, 0, 6400,
		6401, 1, 0, 0, 0, 6401, 6405, 1, 0, 0, 0, 6402, 6403, 3, 60, 30, 0, 6403,
		6404, 3, 554, 277, 0, 6404, 6406, 1, 0, 0, 0, 6405, 6402, 1, 0, 0, 0, 6405,
		6406, 1, 0, 0, 0, 6406, 6410, 1, 0, 0, 0, 6407, 6408, 5, 27, 0, 0, 6408,
		6411, 3, 556, 278, 0, 6409, 6411, 5, 226, 0, 0, 6410, 6407, 1, 0, 0, 0,
		6410, 6409, 1, 0, 0, 0, 6410, 6411, 1, 0, 0, 0, 6411, 6519, 1, 0, 0, 0,
		6412, 6413, 5, 225, 0, 0, 6413, 6414, 7, 100, 0, 0, 6414, 6416, 5, 238,
		0, 0, 6415, 6417, 3, 594, 297, 0, 6416, 6415, 1, 0, 0, 0, 6416, 6417, 1,
		0, 0, 0, 6417, 6419, 1, 0, 0, 0, 6418, 6420, 5, 226, 0, 0, 6419, 6418,
		1, 0, 0, 0, 6419, 6420, 1, 0, 0, 0, 6420, 6519, 1, 0, 0, 0, 6421, 6422,
		5, 225, 0, 0, 6422, 6424, 7, 101, 0, 0, 6423, 6425, 3, 594, 297, 0, 6424,
		6423, 1, 0, 0, 0, 6424, 6425, 1, 0, 0, 0, 6425, 6427, 1, 0, 0, 0, 6426,
		6428, 5, 226, 0, 0, 6427, 6426, 1, 0, 0, 0, 6427, 6428, 1, 0, 0, 0, 6428,
		6519, 1, 0, 0, 0, 6429, 6430, 5, 518, 0, 0, 6430, 6432, 5, 223, 0, 0, 6431,
		6433, 3, 594, 297, 0, 6432, 6431, 1, 0, 0, 0, 6432, 6433, 1, 0, 0, 0, 6433,
		6435, 1, 0, 0, 0, 6434, 6436, 5, 226, 0, 0, 6435, 6434, 1, 0, 0, 0, 6435,
		6436, 1, 0, 0, 0, 6436, 6519, 1, 0, 0, 0, 6437, 6439, 7, 102, 0, 0, 6438,
		6440, 3, 594, 297, 0, 6439, 6438, 1, 0, 0, 0, 6439, 6440, 1, 0, 0, 0, 6440,
		6444, 1, 0, 0, 0, 6441, 6443, 7, 103, 0, 0, 6442, 6441, 1, 0, 0, 0, 6443,
		6446, 1, 0, 0, 0, 6444, 6442, 1, 0, 0, 0, 6444, 6445, 1, 0, 0, 0, 6445,
		6519, 1, 0, 0, 0, 6446, 6444, 1, 0, 0, 0, 6447, 6449, 5, 208, 0, 0, 6448,
		6450, 3, 596, 298, 0, 6449, 6448, 1, 0, 0, 0, 6449, 6450, 1, 0, 0, 0, 6450,
		6454, 1, 0, 0, 0, 6451, 6453, 7, 103, 0, 0, 6452, 6451, 1, 0, 0, 0, 6453,
		6456, 1, 0, 0, 0, 6454, 6452, 1, 0, 0, 0, 6454, 6455, 1, 0, 0, 0, 6455,
		6519, 1, 0, 0, 0, 6456, 6454, 1, 0, 0, 0, 6457, 6459, 5, 209, 0, 0, 6458,
		6460, 5, 210, 0, 0, 6459, 6458, 1, 0, 0, 0, 6459, 6460, 1, 0, 0, 0, 6460,
		6462, 1, 0, 0, 0, 6461, 6463, 3, 596, 298, 0, 6462, 6461, 1, 0, 0, 0, 6462,
		6463, 1, 0, 0, 0, 6463, 6467, 1, 0, 0, 0, 6464, 6466, 7, 103, 0, 0, 6465,
		6464, 1, 0, 0, 0, 6466, 6469, 1, 0, 0, 0, 6467, 6465, 1, 0, 0, 0, 6467,
		6468, 1, 0, 0, 0, 6468, 6519, 1, 0, 0, 0, 6469, 6467, 1, 0, 0, 0, 6470,
		6472, 7, 104, 0, 0, 6471, 6473, 3, 598, 299, 0, 6472, 6471, 1, 0, 0, 0,
		6472, 6473, 1, 0, 0, 0, 6473, 6477, 1, 0, 0, 0, 6474, 6476, 7, 103, 0,
		0, 6475, 6474, 1, 0, 0, 0, 6476, 6479, 1, 0, 0, 0, 6477, 6475, 1, 0, 0,
		0, 6477, 6478, 1, 0, 0, 0, 6478, 6519, 1, 0, 0, 0, 6479, 6477, 1, 0, 0,
		0, 6480, 6519, 7, 105, 0, 0, 6481, 6483, 7, 106, 0, 0, 6482, 6484, 3, 594,
		297, 0, 6483, 6482, 1, 0, 0, 0, 6483, 6484, 1, 0, 0, 0, 6484, 6519, 1,
		0, 0, 0, 6485, 6486, 7, 107, 0, 0, 6486, 6488, 3, 590, 295, 0, 6487, 6489,
		5, 226, 0, 0, 6488, 6487, 1, 0, 0, 0, 6488, 6489, 1, 0, 0, 0, 6489, 6493,
		1, 0, 0, 0, 6490, 6491, 3, 60, 30, 0, 6491, 6492, 3, 554, 277, 0, 6492,
		6494, 1, 0, 0, 0, 6493, 6490, 1, 0, 0, 0, 6493, 6494, 1, 0, 0, 0, 6494,
		6519, 1, 0, 0, 0, 6495, 6498, 7, 108, 0, 0, 6496, 6497, 5, 1010, 0, 0,
		6497, 6499, 3, 574, 287, 0, 6498, 6496, 1, 0, 0, 0, 6498, 6499, 1, 0, 0,
		0, 6499, 6519, 1, 0, 0, 0, 6500, 6502, 5, 231, 0, 0, 6501, 6503, 5, 223,
		0, 0, 6502, 6501, 1, 0, 0, 0, 6502, 6503, 1, 0, 0, 0, 6503, 6505, 1, 0,
		0, 0, 6504, 6506, 5, 226, 0, 0, 6505, 6504, 1, 0, 0, 0, 6505, 6506, 1,
		0, 0, 0, 6506, 6510, 1, 0, 0, 0, 6507, 6508, 3, 60, 30, 0, 6508, 6509,
		3, 554, 277, 0, 6509, 6511, 1, 0, 0, 0, 6510, 6507, 1, 0, 0, 0, 6510, 6511,
		1, 0, 0, 0, 6511, 6514, 1, 0, 0, 0, 6512, 6513, 5, 27, 0, 0, 6513, 6515,
		3, 556, 278, 0, 6514, 6512, 1, 0, 0, 0, 6514, 6515, 1, 0, 0, 0, 6515, 6519,
		1, 0, 0, 0, 6516, 6517, 5, 231, 0, 0, 6517, 6519, 5, 227, 0, 0, 6518, 6392,
		1, 0, 0, 0, 6518, 6412, 1, 0, 0, 0, 6518, 6421, 1, 0, 0, 0, 6518, 6429,
		1, 0, 0, 0, 6518, 6437, 1, 0, 0, 0, 6518, 6447, 1, 0, 0, 0, 6518, 6457,
		1, 0, 0, 0, 6518, 6470, 1, 0, 0, 0, 6518, 6480, 1, 0, 0, 0, 6518, 6481,
		1, 0, 0, 0, 6518, 6485, 1, 0, 0, 0, 6518, 6495, 1, 0, 0, 0, 6518, 6500,
		1, 0, 0, 0, 6518, 6516, 1, 0, 0, 0, 6519, 589, 1, 0, 0, 0, 6520, 6521,
		5, 1131, 0, 0, 6521, 6526, 5, 1146, 0, 0, 6522, 6523, 5, 1133, 0, 0, 6523,
		6525, 5, 1146, 0, 0, 6524, 6522, 1, 0, 0, 0, 6525, 6528, 1, 0, 0, 0, 6526,
		6524, 1, 0, 0, 0, 6526, 6527, 1, 0, 0, 0, 6527, 6529, 1, 0, 0, 0, 6528,
		6526, 1, 0, 0, 0, 6529, 6530, 5, 1132, 0, 0, 6530, 591, 1, 0, 0, 0, 6531,
		6533, 7, 109, 0, 0, 6532, 6534, 3, 594, 297, 0, 6533, 6532, 1, 0, 0, 0,
		6533, 6534, 1, 0, 0, 0, 6534, 6554, 1, 0, 0, 0, 6535, 6537, 5, 222, 0,
		0, 6536, 6538, 3, 594, 297, 0, 6537, 6536, 1, 0, 0, 0, 6537, 6538, 1, 0,
		0, 0, 6538, 6542, 1, 0, 0, 0, 6539, 6540, 3, 60, 30, 0, 6540, 6541, 3,
		554, 277, 0, 6541, 6543, 1, 0, 0, 0, 6542, 6539, 1, 0, 0, 0, 6542, 6543,
		1, 0, 0, 0, 6543, 6554, 1, 0, 0, 0, 6544, 6554, 7, 110, 0, 0, 6545, 6547,
		5, 214, 0, 0, 6546, 6548, 3, 598, 299, 0, 6547, 6546, 1, 0, 0, 0, 6547,
		6548, 1, 0, 0, 0, 6548, 6554, 1, 0, 0, 0, 6549, 6551, 7, 111, 0, 0, 6550,
		6552, 5, 206, 0, 0, 6551, 6550, 1, 0, 0, 0, 6551, 6552, 1, 0, 0, 0, 6552,
		6554, 1, 0, 0, 0, 6553, 6531, 1, 0, 0, 0, 6553, 6535, 1, 0, 0, 0, 6553,
		6544, 1, 0, 0, 0, 6553, 6545, 1, 0, 0, 0, 6553, 6549, 1, 0, 0, 0, 6554,
		6556, 1, 0, 0, 0, 6555, 6557, 5, 11, 0, 0, 6556, 6555, 1, 0, 0, 0, 6556,
		6557, 1, 0, 0, 0, 6557, 593, 1, 0, 0, 0, 6558, 6559, 5, 1131, 0, 0, 6559,
		6560, 3, 574, 287, 0, 6560, 6561, 5, 1132, 0, 0, 6561, 595, 1, 0, 0, 0,
		6562, 6563, 5, 1131, 0, 0, 6563, 6564, 3, 574, 287, 0, 6564, 6565, 5, 1133,
		0, 0, 6565, 6566, 3, 574, 287, 0, 6566, 6567, 5, 1132, 0, 0, 6567, 597,
		1, 0, 0, 0, 6568, 6569, 5, 1131, 0, 0, 6569, 6572, 3, 574, 287, 0, 6570,
		6571, 5, 1133, 0, 0, 6571, 6573, 3, 574, 287, 0, 6572, 6570, 1, 0, 0, 0,
		6572, 6573, 1, 0, 0, 0, 6573, 6574, 1, 0, 0, 0, 6574, 6575, 5, 1132, 0,
		0, 6575, 599, 1, 0, 0, 0, 6576, 6581, 3, 568, 284, 0, 6577, 6578, 5, 1133,
		0, 0, 6578, 6580, 3, 568, 284, 0, 6579, 6577, 1, 0, 0, 0, 6580, 6583, 1,
		0, 0, 0, 6581, 6579, 1, 0, 0, 0, 6581, 6582, 1, 0, 0, 0, 6582, 601, 1,
		0, 0, 0, 6583, 6581, 1, 0, 0, 0, 6584, 6589, 3, 546, 273, 0, 6585, 6586,
		5, 1133, 0, 0, 6586, 6588, 3, 546, 273, 0, 6587, 6585, 1, 0, 0, 0, 6588,
		6591, 1, 0, 0, 0, 6589, 6587, 1, 0, 0, 0, 6589, 6590, 1, 0, 0, 0, 6590,
		603, 1, 0, 0, 0, 6591, 6589, 1, 0, 0, 0, 6592, 6597, 3, 542, 271, 0, 6593,
		6594, 5, 1133, 0, 0, 6594, 6596, 3, 542, 271, 0, 6595, 6593, 1, 0, 0, 0,
		6596, 6599, 1, 0, 0, 0, 6597, 6595, 1, 0, 0, 0, 6597, 6598, 1, 0, 0, 0,
		6598, 605, 1, 0, 0, 0, 6599, 6597, 1, 0, 0, 0, 6600, 6601, 5, 1131, 0,
		0, 6601, 6606, 3, 548, 274, 0, 6602, 6603, 5, 1133, 0, 0, 6603, 6605, 3,
		548, 274, 0, 6604, 6602, 1, 0, 0, 0, 6605, 6608, 1, 0, 0, 0, 6606, 6604,
		1, 0, 0, 0, 6606, 6607, 1, 0, 0, 0, 6607, 6609, 1, 0, 0, 0, 6608, 6606,
		1, 0, 0, 0, 6609, 6610, 5, 1132, 0, 0, 6610, 607, 1, 0, 0, 0, 6611, 6616,
		3, 672, 336, 0, 6612, 6613, 5, 1133, 0, 0, 6613, 6615, 3, 672, 336, 0,
		6614, 6612, 1, 0, 0, 0, 6615, 6618, 1, 0, 0, 0, 6616, 6614, 1, 0, 0, 0,
		6616, 6617, 1, 0, 0, 0, 6617, 609, 1, 0, 0, 0, 6618, 6616, 1, 0, 0, 0,
		6619, 6624, 3, 622, 311, 0, 6620, 6621, 5, 1133, 0, 0, 6621, 6623, 3, 622,
		311, 0, 6622, 6620, 1, 0, 0, 0, 6623, 6626, 1, 0, 0, 0, 6624, 6622, 1,
		0, 0, 0, 6624, 6625, 1, 0, 0, 0, 6625, 611, 1, 0, 0, 0, 6626, 6624, 1,
		0, 0, 0, 6627, 6632, 3, 586, 293, 0, 6628, 6629, 5, 1133, 0, 0, 6629, 6631,
		3, 586, 293, 0, 6630, 6628, 1, 0, 0, 0, 6631, 6634, 1, 0, 0, 0, 6632, 6630,
		1, 0, 0, 0, 6632, 6633, 1, 0, 0, 0, 6633, 613, 1, 0, 0, 0, 6634, 6632,
		1, 0, 0, 0, 6635, 6640, 5, 1146, 0, 0, 6636, 6637, 5, 1133, 0, 0, 6637,
		6639, 5, 1146, 0, 0, 6638, 6636, 1, 0, 0, 0, 6639, 6642, 1, 0, 0, 0, 6640,
		6638, 1, 0, 0, 0, 6640, 6641, 1, 0, 0, 0, 6641, 615, 1, 0, 0, 0, 6642,
		6640, 1, 0, 0, 0, 6643, 6648, 5, 1158, 0, 0, 6644, 6645, 5, 1133, 0, 0,
		6645, 6647, 5, 1158, 0, 0, 6646, 6644, 1, 0, 0, 0, 6647, 6650, 1, 0, 0,
		0, 6648, 6646, 1, 0, 0, 0, 6648, 6649, 1, 0, 0, 0, 6649, 617, 1, 0, 0,
		0, 6650, 6648, 1, 0, 0, 0, 6651, 6678, 5, 116, 0, 0, 6652, 6653, 5, 23,
		0, 0, 6653, 6654, 5, 1131, 0, 0, 6654, 6655, 3, 672, 336, 0, 6655, 6656,
		5, 12, 0, 0, 6656, 6657, 3, 592, 296, 0, 6657, 6658, 5, 1132, 0, 0, 6658,
		6678, 1, 0, 0, 0, 6659, 6661, 3, 678, 339, 0, 6660, 6659, 1, 0, 0, 0, 6660,
		6661, 1, 0, 0, 0, 6661, 6662, 1, 0, 0, 0, 6662, 6678, 3, 586, 293, 0, 6663,
		6667, 3, 620, 310, 0, 6664, 6665, 5, 118, 0, 0, 6665, 6666, 5, 184, 0,
		0, 6666, 6668, 3, 620, 310, 0, 6667, 6664, 1, 0, 0, 0, 6667, 6668, 1, 0,
		0, 0, 6668, 6678, 1, 0, 0, 0, 6669, 6670, 5, 1131, 0, 0, 6670, 6671, 3,
		672, 336, 0, 6671, 6672, 5, 1132, 0, 0, 6672, 6678, 1, 0, 0, 0, 6673, 6674,
		5, 1131, 0, 0, 6674, 6675, 3, 540, 270, 0, 6675, 6676, 5, 1132, 0, 0, 6676,
		6678, 1, 0, 0, 0, 6677, 6651, 1, 0, 0, 0, 6677, 6652, 1, 0, 0, 0, 6677,
		6660, 1, 0, 0, 0, 6677, 6663, 1, 0, 0, 0, 6677, 6669, 1, 0, 0, 0, 6677,
		6673, 1, 0, 0, 0, 6678, 619, 1, 0, 0, 0, 6679, 6685, 7, 112, 0, 0, 6680,
		6682, 5, 1131, 0, 0, 6681, 6683, 3, 574, 287, 0, 6682, 6681, 1, 0, 0, 0,
		6682, 6683, 1, 0, 0, 0, 6683, 6684, 1, 0, 0, 0, 6684, 6686, 5, 1132, 0,
		0, 6685, 6680, 1, 0, 0, 0, 6685, 6686, 1, 0, 0, 0, 6686, 6694, 1, 0, 0,
		0, 6687, 6688, 5, 323, 0, 0, 6688, 6690, 5, 1131, 0, 0, 6689, 6691, 3,
		574, 287, 0, 6690, 6689, 1, 0, 0, 0, 6690, 6691, 1, 0, 0, 0, 6691, 6692,
		1, 0, 0, 0, 6692, 6694, 5, 1132, 0, 0, 6693, 6679, 1, 0, 0, 0, 6693, 6687,
		1, 0, 0, 0, 6694, 621, 1, 0, 0, 0, 6695, 6698, 3, 672, 336, 0, 6696, 6698,
		5, 42, 0, 0, 6697, 6695, 1, 0, 0, 0, 6697, 6696, 1, 0, 0, 0, 6698, 623,
		1, 0, 0, 0, 6699, 6700, 5, 77, 0, 0, 6700, 6701, 5, 60, 0, 0, 6701, 625,
		1, 0, 0, 0, 6702, 6703, 5, 77, 0, 0, 6703, 6704, 5, 114, 0, 0, 6704, 6705,
		5, 60, 0, 0, 6705, 627, 1, 0, 0, 0, 6706, 6707, 5, 123, 0, 0, 6707, 6708,
		5, 141, 0, 0, 6708, 629, 1, 0, 0, 0, 6709, 6710, 5, 674, 0, 0, 6710, 6713,
		3, 574, 287, 0, 6711, 6713, 5, 527, 0, 0, 6712, 6709, 1, 0, 0, 0, 6712,
		6711, 1, 0, 0, 0, 6713, 631, 1, 0, 0, 0, 6714, 6733, 3, 634, 317, 0, 6715,
		6733, 3, 642, 321, 0, 6716, 6733, 3, 644, 322, 0, 6717, 6718, 3, 664, 332,
		0, 6718, 6720, 5, 1131, 0, 0, 6719, 6721, 3, 668, 334, 0, 6720, 6719, 1,
		0, 0, 0, 6720, 6721, 1, 0, 0, 0, 6721, 6722, 1, 0, 0, 0, 6722, 6723, 5,
		1132, 0, 0, 6723, 6733, 1, 0, 0, 0, 6724, 6725, 3, 540, 270, 0, 6725, 6727,
		5, 1131, 0, 0, 6726, 6728, 3, 668, 334, 0, 6727, 6726, 1, 0, 0, 0, 6727,
		6728, 1, 0, 0, 0, 6728, 6729, 1, 0, 0, 0, 6729, 6730, 5, 1132, 0, 0, 6730,
		6733, 1, 0, 0, 0, 6731, 6733, 3, 666, 333, 0, 6732, 6714, 1, 0, 0, 0, 6732,
		6715, 1, 0, 0, 0, 6732, 6716, 1, 0, 0, 0, 6732, 6717, 1, 0, 0, 0, 6732,
		6724, 1, 0, 0, 0, 6732, 6731, 1, 0, 0, 0, 6733, 633, 1, 0, 0, 0, 6734,
		6737, 7, 113, 0, 0, 6735, 6736, 5, 1131, 0, 0, 6736, 6738, 5, 1132, 0,
		0, 6737, 6735, 1, 0, 0, 0, 6737, 6738, 1, 0, 0, 0, 6738, 6913, 1, 0, 0,
		0, 6739, 6740, 5, 32, 0, 0, 6740, 6741, 5, 1131, 0, 0, 6741, 6742, 3, 672,
		336, 0, 6742, 6743, 5, 1133, 0, 0, 6743, 6744, 3, 592, 296, 0, 6744, 6745,
		5, 1132, 0, 0, 6745, 6913, 1, 0, 0, 0, 6746, 6747, 5, 32, 0, 0, 6747, 6748,
		5, 1131, 0, 0, 6748, 6749, 3, 672, 336, 0, 6749, 6750, 5, 187, 0, 0, 6750,
		6751, 3, 554, 277, 0, 6751, 6752, 5, 1132, 0, 0, 6752, 6913, 1, 0, 0, 0,
		6753, 6754, 5, 23, 0, 0, 6754, 6755, 5, 1131, 0, 0, 6755, 6756, 3, 672,
		336, 0, 6756, 6757, 5, 12, 0, 0, 6757, 6758, 3, 592, 296, 0, 6758, 6759,
		5, 1132, 0, 0, 6759, 6913, 1, 0, 0, 0, 6760, 6761, 5, 188, 0, 0, 6761,
		6762, 5, 1131, 0, 0, 6762, 6763, 3, 546, 273, 0, 6763, 6764, 5, 1132, 0,
		0, 6764, 6913, 1, 0, 0, 0, 6765, 6766, 5, 22, 0, 0, 6766, 6768, 3, 672,
		336, 0, 6767, 6769, 3, 636, 318, 0, 6768, 6767, 1, 0, 0, 0, 6769, 6770,
		1, 0, 0, 0, 6770, 6768, 1, 0, 0, 0, 6770, 6771, 1, 0, 0, 0, 6771, 6774,
		1, 0, 0, 0, 6772, 6773, 5, 53, 0, 0, 6773, 6775, 3, 670, 335, 0, 6774,
		6772, 1, 0, 0, 0, 6774, 6775, 1, 0, 0, 0, 6775, 6776, 1, 0, 0, 0, 6776,
		6777, 5, 407, 0, 0, 6777, 6913, 1, 0, 0, 0, 6778, 6780, 5, 22, 0, 0, 6779,
		6781, 3, 636, 318, 0, 6780, 6779, 1, 0, 0, 0, 6781, 6782, 1, 0, 0, 0, 6782,
		6780, 1, 0, 0, 0, 6782, 6783, 1, 0, 0, 0, 6783, 6786, 1, 0, 0, 0, 6784,
		6785, 5, 53, 0, 0, 6785, 6787, 3, 670, 335, 0, 6786, 6784, 1, 0, 0, 0,
		6786, 6787, 1, 0, 0, 0, 6787, 6788, 1, 0, 0, 0, 6788, 6789, 5, 407, 0,
		0, 6789, 6913, 1, 0, 0, 0, 6790, 6791, 5, 222, 0, 0, 6791, 6792, 5, 1131,
		0, 0, 6792, 6795, 3, 668, 334, 0, 6793, 6794, 5, 187, 0, 0, 6794, 6796,
		3, 554, 277, 0, 6795, 6793, 1, 0, 0, 0, 6795, 6796, 1, 0, 0, 0, 6796, 6797,
		1, 0, 0, 0, 6797, 6798, 5, 1132, 0, 0, 6798, 6913, 1, 0, 0, 0, 6799, 6800,
		5, 324, 0, 0, 6800, 6803, 5, 1131, 0, 0, 6801, 6804, 3, 578, 289, 0, 6802,
		6804, 3, 672, 336, 0, 6803, 6801, 1, 0, 0, 0, 6803, 6802, 1, 0, 0, 0, 6804,
		6805, 1, 0, 0, 0, 6805, 6808, 5, 80, 0, 0, 6806, 6809, 3, 578, 289, 0,
		6807, 6809, 3, 672, 336, 0, 6808, 6806, 1, 0, 0, 0, 6808, 6807, 1, 0, 0,
		0, 6809, 6810, 1, 0, 0, 0, 6810, 6811, 5, 1132, 0, 0, 6811, 6913, 1, 0,
		0, 0, 6812, 6813, 7, 114, 0, 0, 6813, 6816, 5, 1131, 0, 0, 6814, 6817,
		3, 578, 289, 0, 6815, 6817, 3, 672, 336, 0, 6816, 6814, 1, 0, 0, 0, 6816,
		6815, 1, 0, 0, 0, 6817, 6818, 1, 0, 0, 0, 6818, 6821, 5, 68, 0, 0, 6819,
		6822, 3, 574, 287, 0, 6820, 6822, 3, 672, 336, 0, 6821, 6819, 1, 0, 0,
		0, 6821, 6820, 1, 0, 0, 0, 6822, 6828, 1, 0, 0, 0, 6823, 6826, 5, 65, 0,
		0, 6824, 6827, 3, 574, 287, 0, 6825, 6827, 3, 672, 336, 0, 6826, 6824,
		1, 0, 0, 0, 6826, 6825, 1, 0, 0, 0, 6827, 6829, 1, 0, 0, 0, 6828, 6823,
		1, 0, 0, 0, 6828, 6829, 1, 0, 0, 0, 6829, 6830, 1, 0, 0, 0, 6830, 6831,
		5, 1132, 0, 0, 6831, 6913, 1, 0, 0, 0, 6832, 6833, 5, 328, 0, 0, 6833,
		6834, 5, 1131, 0, 0, 6834, 6837, 7, 115, 0, 0, 6835, 6838, 3, 578, 289,
		0, 6836, 6838, 3, 672, 336, 0, 6837, 6835, 1, 0, 0, 0, 6837, 6836, 1, 0,
		0, 0, 6837, 6838, 1, 0, 0, 0, 6838, 6839, 1, 0, 0, 0, 6839, 6842, 5, 68,
		0, 0, 6840, 6843, 3, 578, 289, 0, 6841, 6843, 3, 672, 336, 0, 6842, 6840,
		1, 0, 0, 0, 6842, 6841, 1, 0, 0, 0, 6843, 6844, 1, 0, 0, 0, 6844, 6845,
		5, 1132, 0, 0, 6845, 6913, 1, 0, 0, 0, 6846, 6847, 5, 328, 0, 0, 6847,
		6850, 5, 1131, 0, 0, 6848, 6851, 3, 578, 289, 0, 6849, 6851, 3, 672, 336,
		0, 6850, 6848, 1, 0, 0, 0, 6850, 6849, 1, 0, 0, 0, 6851, 6852, 1, 0, 0,
		0, 6852, 6855, 5, 68, 0, 0, 6853, 6856, 3, 578, 289, 0, 6854, 6856, 3,
		672, 336, 0, 6855, 6853, 1, 0, 0, 0, 6855, 6854, 1, 0, 0, 0, 6856, 6857,
		1, 0, 0, 0, 6857, 6858, 5, 1132, 0, 0, 6858, 6913, 1, 0, 0, 0, 6859, 6860,
		5, 1101, 0, 0, 6860, 6863, 5, 1131, 0, 0, 6861, 6864, 3, 578, 289, 0, 6862,
		6864, 3, 672, 336, 0, 6863, 6861, 1, 0, 0, 0, 6863, 6862, 1, 0, 0, 0, 6864,
		6871, 1, 0, 0, 0, 6865, 6866, 5, 12, 0, 0, 6866, 6867, 7, 116, 0, 0, 6867,
		6868, 5, 1131, 0, 0, 6868, 6869, 3, 574, 287, 0, 6869, 6870, 5, 1132, 0,
		0, 6870, 6872, 1, 0, 0, 0, 6871, 6865, 1, 0, 0, 0, 6871, 6872, 1, 0, 0,
		0, 6872, 6874, 1, 0, 0, 0, 6873, 6875, 3, 638, 319, 0, 6874, 6873, 1, 0,
		0, 0, 6874, 6875, 1, 0, 0, 0, 6875, 6876, 1, 0, 0, 0, 6876, 6877, 5, 1132,
		0, 0, 6877, 6913, 1, 0, 0, 0, 6878, 6879, 5, 321, 0, 0, 6879, 6880, 5,
		1131, 0, 0, 6880, 6881, 3, 70, 35, 0, 6881, 6884, 5, 68, 0, 0, 6882, 6885,
		3, 578, 289, 0, 6883, 6885, 3, 672, 336, 0, 6884, 6882, 1, 0, 0, 0, 6884,
		6883, 1, 0, 0, 0, 6885, 6886, 1, 0, 0, 0, 6886, 6887, 5, 1132, 0, 0, 6887,
		6913, 1, 0, 0, 0, 6888, 6889, 5, 899, 0, 0, 6889, 6890, 5, 1131, 0, 0,
		6890, 6891, 7, 117, 0, 0, 6891, 6892, 5, 1133, 0, 0, 6892, 6893, 3, 578,
		289, 0, 6893, 6894, 5, 1132, 0, 0, 6894, 6913, 1, 0, 0, 0, 6895, 6896,
		5, 282, 0, 0, 6896, 6897, 5, 1131, 0, 0, 6897, 6898, 3, 672, 336, 0, 6898,
		6899, 5, 1133, 0, 0, 6899, 6902, 3, 672, 336, 0, 6900, 6901, 5, 593, 0,
		0, 6901, 6903, 3, 592, 296, 0, 6902, 6900, 1, 0, 0, 0, 6902, 6903, 1, 0,
		0, 0, 6903, 6905, 1, 0, 0, 0, 6904, 6906, 3, 262, 131, 0, 6905, 6904, 1,
		0, 0, 0, 6905, 6906, 1, 0, 0, 0, 6906, 6908, 1, 0, 0, 0, 6907, 6909, 3,
		264, 132, 0, 6908, 6907, 1, 0, 0, 0, 6908, 6909, 1, 0, 0, 0, 6909, 6910,
		1, 0, 0, 0, 6910, 6911, 5, 1132, 0, 0, 6911, 6913, 1, 0, 0, 0, 6912, 6734,
		1, 0, 0, 0, 6912, 6739, 1, 0, 0, 0, 6912, 6746, 1, 0, 0, 0, 6912, 6753,
		1, 0, 0, 0, 6912, 6760, 1, 0, 0, 0, 6912, 6765, 1, 0, 0, 0, 6912, 6778,
		1, 0, 0, 0, 6912, 6790, 1, 0, 0, 0, 6912, 6799, 1, 0, 0, 0, 6912, 6812,
		1, 0, 0, 0, 6912, 6832, 1, 0, 0, 0, 6912, 6846, 1, 0, 0, 0, 6912, 6859,
		1, 0, 0, 0, 6912, 6878, 1, 0, 0, 0, 6912, 6888, 1, 0, 0, 0, 6912, 6895,
		1, 0, 0, 0, 6913, 635, 1, 0, 0, 0, 6914, 6915, 5, 189, 0, 0, 6915, 6916,
		3, 670, 335, 0, 6916, 6917, 5, 174, 0, 0, 6917, 6918, 3, 670, 335, 0, 6918,
		637, 1, 0, 0, 0, 6919, 6920, 5, 472, 0, 0, 6920, 6925, 3, 640, 320, 0,
		6921, 6922, 5, 1133, 0, 0, 6922, 6924, 3, 640, 320, 0, 6923, 6921, 1, 0,
		0, 0, 6924, 6927, 1, 0, 0, 0, 6925, 6923, 1, 0, 0, 0, 6925, 6926, 1, 0,
		0, 0, 6926, 6934, 1, 0, 0, 0, 6927, 6925, 1, 0, 0, 0, 6928, 6929, 5, 472,
		0, 0, 6929, 6930, 3, 574, 287, 0, 6930, 6931, 5, 1119, 0, 0, 6931, 6932,
		3, 574, 287, 0, 6932, 6934, 1, 0, 0, 0, 6933, 6919, 1, 0, 0, 0, 6933, 6928,
		1, 0, 0, 0, 6934, 639, 1, 0, 0, 0, 6935, 6937, 3, 574, 287, 0, 6936, 6938,
		7, 118, 0, 0, 6937, 6936, 1, 0, 0, 0, 6937, 6938, 1, 0, 0, 0, 6938, 641,
		1, 0, 0, 0, 6939, 6940, 7, 119, 0, 0, 6940, 6942, 5, 1131, 0, 0, 6941,
		6943, 7, 44, 0, 0, 6942, 6941, 1, 0, 0, 0, 6942, 6943, 1, 0, 0, 0, 6943,
		6944, 1, 0, 0, 0, 6944, 6945, 3, 670, 335, 0, 6945, 6947, 5, 1132, 0, 0,
		6946, 6948, 3, 646, 323, 0, 6947, 6946, 1, 0, 0, 0, 6947, 6948, 1, 0, 0,
		0, 6948, 6999, 1, 0, 0, 0, 6949, 6950, 5, 290, 0, 0, 6950, 6958, 5, 1131,
		0, 0, 6951, 6959, 5, 1115, 0, 0, 6952, 6954, 5, 6, 0, 0, 6953, 6952, 1,
		0, 0, 0, 6953, 6954, 1, 0, 0, 0, 6954, 6955, 1, 0, 0, 0, 6955, 6959, 3,
		670, 335, 0, 6956, 6957, 5, 49, 0, 0, 6957, 6959, 3, 668, 334, 0, 6958,
		6951, 1, 0, 0, 0, 6958, 6953, 1, 0, 0, 0, 6958, 6956, 1, 0, 0, 0, 6959,
		6960, 1, 0, 0, 0, 6960, 6962, 5, 1132, 0, 0, 6961, 6963, 3, 646, 323, 0,
		6962, 6961, 1, 0, 0, 0, 6962, 6963, 1, 0, 0, 0, 6963, 6999, 1, 0, 0, 0,
		6964, 6965, 7, 120, 0, 0, 6965, 6967, 5, 1131, 0, 0, 6966, 6968, 5, 6,
		0, 0, 6967, 6966, 1, 0, 0, 0, 6967, 6968, 1, 0, 0, 0, 6968, 6969, 1, 0,
		0, 0, 6969, 6970, 3, 670, 335, 0, 6970, 6972, 5, 1132, 0, 0, 6971, 6973,
		3, 646, 323, 0, 6972, 6971, 1, 0, 0, 0, 6972, 6973, 1, 0, 0, 0, 6973, 6999,
		1, 0, 0, 0, 6974, 6975, 5, 294, 0, 0, 6975, 6977, 5, 1131, 0, 0, 6976,
		6978, 5, 49, 0, 0, 6977, 6976, 1, 0, 0, 0, 6977, 6978, 1, 0, 0, 0, 6978,
		6979, 1, 0, 0, 0, 6979, 6990, 3, 668, 334, 0, 6980, 6981, 5, 124, 0, 0,
		6981, 6982, 5, 19, 0, 0, 6982, 6987, 3, 228, 114, 0, 6983, 6984, 5, 1133,
		0, 0, 6984, 6986, 3, 228, 114, 0, 6985, 6983, 1, 0, 0, 0, 6986, 6989, 1,
		0, 0, 0, 6987, 6985, 1, 0, 0, 0, 6987, 6988, 1, 0, 0, 0, 6988, 6991, 1,
		0, 0, 0, 6989, 6987, 1, 0, 0, 0, 6990, 6980, 1, 0, 0, 0, 6990, 6991, 1,
		0, 0, 0, 6991, 6994, 1, 0, 0, 0, 6992, 6993, 5, 154, 0, 0, 6993, 6995,
		5, 1146, 0, 0, 6994, 6992, 1, 0, 0, 0, 6994, 6995, 1, 0, 0, 0, 6995, 6996,
		1, 0, 0, 0, 6996, 6997, 5, 1132, 0, 0, 6997, 6999, 1, 0, 0, 0, 6998, 6939,
		1, 0, 0, 0, 6998, 6949, 1, 0, 0, 0, 6998, 6964, 1, 0, 0, 0, 6998, 6974,
		1, 0, 0, 0, 6999, 643, 1, 0, 0, 0, 7000, 7001, 7, 121, 0, 0, 7001, 7002,
		5, 1131, 0, 0, 7002, 7005, 3, 672, 336, 0, 7003, 7004, 5, 1133, 0, 0, 7004,
		7006, 3, 574, 287, 0, 7005, 7003, 1, 0, 0, 0, 7005, 7006, 1, 0, 0, 0, 7006,
		7009, 1, 0, 0, 0, 7007, 7008, 5, 1133, 0, 0, 7008, 7010, 3, 672, 336, 0,
		7009, 7007, 1, 0, 0, 0, 7009, 7010, 1, 0, 0, 0, 7010, 7011, 1, 0, 0, 0,
		7011, 7012, 5, 1132, 0, 0, 7012, 7013, 3, 646, 323, 0, 7013, 7039, 1, 0,
		0, 0, 7014, 7015, 7, 122, 0, 0, 7015, 7016, 5, 1131, 0, 0, 7016, 7017,
		3, 672, 336, 0, 7017, 7018, 5, 1132, 0, 0, 7018, 7019, 3, 646, 323, 0,
		7019, 7039, 1, 0, 0, 0, 7020, 7021, 7, 123, 0, 0, 7021, 7022, 5, 1131,
		0, 0, 7022, 7023, 5, 1132, 0, 0, 7023, 7039, 3, 646, 323, 0, 7024, 7025,
		5, 301, 0, 0, 7025, 7026, 5, 1131, 0, 0, 7026, 7027, 3, 672, 336, 0, 7027,
		7028, 5, 1133, 0, 0, 7028, 7029, 3, 574, 287, 0, 7029, 7030, 5, 1132, 0,
		0, 7030, 7031, 3, 646, 323, 0, 7031, 7039, 1, 0, 0, 0, 7032, 7033, 5, 300,
		0, 0, 7033, 7034, 5, 1131, 0, 0, 7034, 7035, 3, 574, 287, 0, 7035, 7036,
		5, 1132, 0, 0, 7036, 7037, 3, 646, 323, 0, 7037, 7039, 1, 0, 0, 0, 7038,
		7000, 1, 0, 0, 0, 7038, 7014, 1, 0, 0, 0, 7038, 7020, 1, 0, 0, 0, 7038,
		7024, 1, 0, 0, 0, 7038, 7032, 1, 0, 0, 0, 7039, 645, 1, 0, 0, 0, 7040,
		7046, 5, 128, 0, 0, 7041, 7042, 5, 1131, 0, 0, 7042, 7043, 3, 648, 324,
		0, 7043, 7044, 5, 1132, 0, 0, 7044, 7047, 1, 0, 0, 0, 7045, 7047, 3, 650,
		325, 0, 7046, 7041, 1, 0, 0, 0, 7046, 7045, 1, 0, 0, 0, 7047, 647, 1, 0,
		0, 0, 7048, 7050, 3, 650, 325, 0, 7049, 7048, 1, 0, 0, 0, 7049, 7050, 1,
		0, 0, 0, 7050, 7052, 1, 0, 0, 0, 7051, 7053, 3, 662, 331, 0, 7052, 7051,
		1, 0, 0, 0, 7052, 7053, 1, 0, 0, 0, 7053, 7055, 1, 0, 0, 0, 7054, 7056,
		3, 226, 113, 0, 7055, 7054, 1, 0, 0, 0, 7055, 7056, 1, 0, 0, 0, 7056, 7058,
		1, 0, 0, 0, 7057, 7059, 3, 652, 326, 0, 7058, 7057, 1, 0, 0, 0, 7058, 7059,
		1, 0, 0, 0, 7059, 649, 1, 0, 0, 0, 7060, 7061, 3, 568, 284, 0, 7061, 651,
		1, 0, 0, 0, 7062, 7063, 3, 654, 327, 0, 7063, 7064, 3, 656, 328, 0, 7064,
		653, 1, 0, 0, 0, 7065, 7066, 7, 124, 0, 0, 7066, 655, 1, 0, 0, 0, 7067,
		7070, 3, 660, 330, 0, 7068, 7070, 3, 658, 329, 0, 7069, 7067, 1, 0, 0,
		0, 7069, 7068, 1, 0, 0, 0, 7070, 657, 1, 0, 0, 0, 7071, 7072, 5, 16, 0,
		0, 7072, 7073, 3, 660, 330, 0, 7073, 7074, 5, 10, 0, 0, 7074, 7075, 3,
		660, 330, 0, 7075, 659, 1, 0, 0, 0, 7076, 7077, 5, 35, 0, 0, 7077, 7084,
		5, 600, 0, 0, 7078, 7079, 5, 657, 0, 0, 7079, 7084, 7, 125, 0, 0, 7080,
		7081, 3, 672, 336, 0, 7081, 7082, 7, 125, 0, 0, 7082, 7084, 1, 0, 0, 0,
		7083, 7076, 1, 0, 0, 0, 7083, 7078, 1, 0, 0, 0, 7083, 7080, 1, 0, 0, 0,
		7084, 661, 1, 0, 0, 0, 7085, 7086, 5, 129, 0, 0, 7086, 7087, 5, 19, 0,
		0, 7087, 7092, 3, 672, 336, 0, 7088, 7089, 5, 1133, 0, 0, 7089, 7091, 3,
		672, 336, 0, 7090, 7088, 1, 0, 0, 0, 7091, 7094, 1, 0, 0, 0, 7092, 7090,
		1, 0, 0, 0, 7092, 7093, 1, 0, 0, 0, 7093, 663, 1, 0, 0, 0, 7094, 7092,
		1, 0, 0, 0, 7095, 7119, 3, 702, 351, 0, 7096, 7119, 5, 746, 0, 0, 7097,
		7119, 5, 317, 0, 0, 7098, 7119, 5, 313, 0, 0, 7099, 7119, 5, 314, 0, 0,
		7100, 7119, 5, 315, 0, 0, 7101, 7119, 5, 318, 0, 0, 7102, 7119, 5, 319,
		0, 0, 7103, 7119, 5, 320, 0, 0, 7104, 7119, 5, 77, 0, 0, 7105, 7119, 5,
		85, 0, 0, 7106, 7119, 5, 316, 0, 0, 7107, 7119, 5, 322, 0, 0, 7108, 7119,
		5, 508, 0, 0, 7109, 7119, 5, 323, 0, 0, 7110, 7119, 5, 141, 0, 0, 7111,
		7119, 5, 325, 0, 0, 7112, 7119, 5, 326, 0, 0, 7113, 7119, 5, 327, 0, 0,
		7114, 7119, 5, 328, 0, 0, 7115, 7119, 5, 329, 0, 0, 7116, 7119, 5, 330,
		0, 0, 7117, 7119, 5, 331, 0, 0, 7118, 7095, 1, 0, 0, 0, 7118, 7096, 1,
		0, 0, 0, 7118, 7097, 1, 0, 0, 0, 7118, 7098, 1, 0, 0, 0, 7118, 7099, 1,
		0, 0, 0, 7118, 7100, 1, 0, 0, 0, 7118, 7101, 1, 0, 0, 0, 7118, 7102, 1,
		0, 0, 0, 7118, 7103, 1, 0, 0, 0, 7118, 7104, 1, 0, 0, 0, 7118, 7105, 1,
		0, 0, 0, 7118, 7106, 1, 0, 0, 0, 7118, 7107, 1, 0, 0, 0, 7118, 7108, 1,
		0, 0, 0, 7118, 7109, 1, 0, 0, 0, 7118, 7110, 1, 0, 0, 0, 7118, 7111, 1,
		0, 0, 0, 7118, 7112, 1, 0, 0, 0, 7118, 7113, 1, 0, 0, 0, 7118, 7114, 1,
		0, 0, 0, 7118, 7115, 1, 0, 0, 0, 7118, 7116, 1, 0, 0, 0, 7118, 7117, 1,
		0, 0, 0, 7119, 665, 1, 0, 0, 0, 7120, 7121, 7, 126, 0, 0, 7121, 7122, 5,
		1131, 0, 0, 7122, 7123, 3, 670, 335, 0, 7123, 7124, 5, 1132, 0, 0, 7124,
		667, 1, 0, 0, 0, 7125, 7130, 3, 586, 293, 0, 7126, 7130, 3, 546, 273, 0,
		7127, 7130, 3, 632, 316, 0, 7128, 7130, 3, 672, 336, 0, 7129, 7125, 1,
		0, 0, 0, 7129, 7126, 1, 0, 0, 0, 7129, 7127, 1, 0, 0, 0, 7129, 7128, 1,
		0, 0, 0, 7130, 7140, 1, 0, 0, 0, 7131, 7136, 5, 1133, 0, 0, 7132, 7137,
		3, 586, 293, 0, 7133, 7137, 3, 546, 273, 0, 7134, 7137, 3, 632, 316, 0,
		7135, 7137, 3, 672, 336, 0, 7136, 7132, 1, 0, 0, 0, 7136, 7133, 1, 0, 0,
		0, 7136, 7134, 1, 0, 0, 0, 7136, 7135, 1, 0, 0, 0, 7137, 7139, 1, 0, 0,
		0, 7138, 7131, 1, 0, 0, 0, 7139, 7142, 1, 0, 0, 0, 7140, 7138, 1, 0, 0,
		0, 7140, 7141, 1, 0, 0, 0, 7141, 669, 1, 0, 0, 0, 7142, 7140, 1, 0, 0,
		0, 7143, 7148, 3, 586, 293, 0, 7144, 7148, 3, 546, 273, 0, 7145, 7148,
		3, 632, 316, 0, 7146, 7148, 3, 672, 336, 0, 7147, 7143, 1, 0, 0, 0, 7147,
		7144, 1, 0, 0, 0, 7147, 7145, 1, 0, 0, 0, 7147, 7146, 1, 0, 0, 0, 7148,
		671, 1, 0, 0, 0, 7149, 7150, 6, 336, -1, 0, 7150, 7151, 7, 127, 0, 0, 7151,
		7161, 3, 672, 336, 4, 7152, 7153, 3, 674, 337, 0, 7153, 7155, 5, 88, 0,
		0, 7154, 7156, 5, 114, 0, 0, 7155, 7154, 1, 0, 0, 0, 7155, 7156, 1, 0,
		0, 0, 7156, 7157, 1, 0, 0, 0, 7157, 7158, 7, 128, 0, 0, 7158, 7161, 1,
		0, 0, 0, 7159, 7161, 3, 674, 337, 0, 7160, 7149, 1, 0, 0, 0, 7160, 7152,
		1, 0, 0, 0, 7160, 7159, 1, 0, 0, 0, 7161, 7168, 1, 0, 0, 0, 7162, 7163,
		10, 3, 0, 0, 7163, 7164, 3, 682, 341, 0, 7164, 7165, 3, 672, 336, 4, 7165,
		7167, 1, 0, 0, 0, 7166, 7162, 1, 0, 0, 0, 7167, 7170, 1, 0, 0, 0, 7168,
		7166, 1, 0, 0, 0, 7168, 7169, 1, 0, 0, 0, 7169, 673, 1, 0, 0, 0, 7170,
		7168, 1, 0, 0, 0, 7171, 7174, 6, 337, -1, 0, 7172, 7173, 5, 1158, 0, 0,
		7173, 7175, 5, 1106, 0, 0, 7174, 7172, 1, 0, 0, 0, 7174, 7175, 1, 0, 0,
		0, 7175, 7176, 1, 0, 0, 0, 7176, 7177, 3, 676, 338, 0, 7177, 7242, 1, 0,
		0, 0, 7178, 7179, 10, 8, 0, 0, 7179, 7180, 3, 680, 340, 0, 7180, 7181,
		3, 674, 337, 9, 7181, 7241, 1, 0, 0, 0, 7182, 7184, 10, 6, 0, 0, 7183,
		7185, 5, 114, 0, 0, 7184, 7183, 1, 0, 0, 0, 7184, 7185, 1, 0, 0, 0, 7185,
		7186, 1, 0, 0, 0, 7186, 7187, 5, 16, 0, 0, 7187, 7188, 3, 674, 337, 0,
		7188, 7189, 5, 10, 0, 0, 7189, 7190, 3, 674, 337, 7, 7190, 7241, 1, 0,
		0, 0, 7191, 7192, 10, 5, 0, 0, 7192, 7193, 5, 620, 0, 0, 7193, 7194, 5,
		98, 0, 0, 7194, 7241, 3, 674, 337, 6, 7195, 7197, 10, 3, 0, 0, 7196, 7198,
		5, 114, 0, 0, 7197, 7196, 1, 0, 0, 0, 7197, 7198, 1, 0, 0, 0, 7198, 7199,
		1, 0, 0, 0, 7199, 7200, 7, 129, 0, 0, 7200, 7241, 3, 674, 337, 4, 7201,
		7203, 10, 10, 0, 0, 7202, 7204, 5, 114, 0, 0, 7203, 7202, 1, 0, 0, 0, 7203,
		7204, 1, 0, 0, 0, 7204, 7205, 1, 0, 0, 0, 7205, 7206, 5, 80, 0, 0, 7206,
		7209, 5, 1131, 0, 0, 7207, 7210, 3, 196, 98, 0, 7208, 7210, 3, 608, 304,
		0, 7209, 7207, 1, 0, 0, 0, 7209, 7208, 1, 0, 0, 0, 7210, 7211, 1, 0, 0,
		0, 7211, 7212, 5, 1132, 0, 0, 7212, 7241, 1, 0, 0, 0, 7213, 7214, 10, 9,
		0, 0, 7214, 7215, 5, 88, 0, 0, 7215, 7241, 3, 584, 292, 0, 7216, 7217,
		10, 7, 0, 0, 7217, 7218, 3, 680, 340, 0, 7218, 7219, 7, 130, 0, 0, 7219,
		7220, 5, 1131, 0, 0, 7220, 7221, 3, 196, 98, 0, 7221, 7222, 5, 1132, 0,
		0, 7222, 7241, 1, 0, 0, 0, 7223, 7225, 10, 4, 0, 0, 7224, 7226, 5, 114,
		0, 0, 7225, 7224, 1, 0, 0, 0, 7225, 7226, 1, 0, 0, 0, 7226, 7227, 1, 0,
		0, 0, 7227, 7228, 5, 98, 0, 0, 7228, 7231, 3, 674, 337, 0, 7229, 7230,
		5, 413, 0, 0, 7230, 7232, 5, 1146, 0, 0, 7231, 7229, 1, 0, 0, 0, 7231,
		7232, 1, 0, 0, 0, 7232, 7241, 1, 0, 0, 0, 7233, 7234, 10, 1, 0, 0, 7234,
		7235, 5, 505, 0, 0, 7235, 7236, 5, 533, 0, 0, 7236, 7237, 5, 1131, 0, 0,
		7237, 7238, 3, 674, 337, 0, 7238, 7239, 5, 1132, 0, 0, 7239, 7241, 1, 0,
		0, 0, 7240, 7178, 1, 0, 0, 0, 7240, 7182, 1, 0, 0, 0, 7240, 7191, 1, 0,
		0, 0, 7240, 7195, 1, 0, 0, 0, 7240, 7201, 1, 0, 0, 0, 7240, 7213, 1, 0,
		0, 0, 7240, 7216, 1, 0, 0, 0, 7240, 7223, 1, 0, 0, 0, 7240, 7233, 1, 0,
		0, 0, 7241, 7244, 1, 0, 0, 0, 7242, 7240, 1, 0, 0, 0, 7242, 7243, 1, 0,
		0, 0, 7243, 675, 1, 0, 0, 0, 7244, 7242, 1, 0, 0, 0, 7245, 7246, 6, 338,
		-1, 0, 7246, 7292, 3, 586, 293, 0, 7247, 7292, 5, 1160, 0, 0, 7248, 7292,
		3, 546, 273, 0, 7249, 7292, 3, 632, 316, 0, 7250, 7292, 3, 552, 276, 0,
		7251, 7252, 3, 678, 339, 0, 7252, 7253, 3, 676, 338, 10, 7253, 7292, 1,
		0, 0, 0, 7254, 7255, 5, 226, 0, 0, 7255, 7292, 3, 676, 338, 9, 7256, 7257,
		5, 1131, 0, 0, 7257, 7262, 3, 672, 336, 0, 7258, 7259, 5, 1133, 0, 0, 7259,
		7261, 3, 672, 336, 0, 7260, 7258, 1, 0, 0, 0, 7261, 7264, 1, 0, 0, 0, 7262,
		7260, 1, 0, 0, 0, 7262, 7263, 1, 0, 0, 0, 7263, 7265, 1, 0, 0, 0, 7264,
		7262, 1, 0, 0, 0, 7265, 7266, 5, 1132, 0, 0, 7266, 7292, 1, 0, 0, 0, 7267,
		7268, 5, 600, 0, 0, 7268, 7269, 5, 1131, 0, 0, 7269, 7272, 3, 672, 336,
		0, 7270, 7271, 5, 1133, 0, 0, 7271, 7273, 3, 672, 336, 0, 7272, 7270, 1,
		0, 0, 0, 7273, 7274, 1, 0, 0, 0, 7274, 7272, 1, 0, 0, 0, 7274, 7275, 1,
		0, 0, 0, 7275, 7276, 1, 0, 0, 0, 7276, 7277, 5, 1132, 0, 0, 7277, 7292,
		1, 0, 0, 0, 7278, 7279, 5, 60, 0, 0, 7279, 7280, 5, 1131, 0, 0, 7280, 7281,
		3, 196, 98, 0, 7281, 7282, 5, 1132, 0, 0, 7282, 7292, 1, 0, 0, 0, 7283,
		7284, 5, 1131, 0, 0, 7284, 7285, 3, 196, 98, 0, 7285, 7286, 5, 1132, 0,
		0, 7286, 7292, 1, 0, 0, 0, 7287, 7288, 5, 86, 0, 0, 7288, 7289, 3, 672,
		336, 0, 7289, 7290, 3, 70, 35, 0, 7290, 7292, 1, 0, 0, 0, 7291, 7245, 1,
		0, 0, 0, 7291, 7247, 1, 0, 0, 0, 7291, 7248, 1, 0, 0, 0, 7291, 7249, 1,
		0, 0, 0, 7291, 7250, 1, 0, 0, 0, 7291, 7251, 1, 0, 0, 0, 7291, 7254, 1,
		0, 0, 0, 7291, 7256, 1, 0, 0, 0, 7291, 7267, 1, 0, 0, 0, 7291, 7278, 1,
		0, 0, 0, 7291, 7283, 1, 0, 0, 0, 7291, 7287, 1, 0, 0, 0, 7292, 7310, 1,
		0, 0, 0, 7293, 7294, 10, 3, 0, 0, 7294, 7295, 3, 684, 342, 0, 7295, 7296,
		3, 676, 338, 4, 7296, 7309, 1, 0, 0, 0, 7297, 7298, 10, 2, 0, 0, 7298,
		7299, 3, 686, 343, 0, 7299, 7300, 3, 676, 338, 3, 7300, 7309, 1, 0, 0,
		0, 7301, 7302, 10, 1, 0, 0, 7302, 7303, 3, 688, 344, 0, 7303, 7304, 3,
		676, 338, 2, 7304, 7309, 1, 0, 0, 0, 7305, 7306, 10, 12, 0, 0, 7306, 7307,
		5, 27, 0, 0, 7307, 7309, 3, 556, 278, 0, 7308, 7293, 1, 0, 0, 0, 7308,
		7297, 1, 0, 0, 0, 7308, 7301, 1, 0, 0, 0, 7308, 7305, 1, 0, 0, 0, 7309,
		7312, 1, 0, 0, 0, 7310, 7308, 1, 0, 0, 0, 7310, 7311, 1, 0, 0, 0, 7311,
		677, 1, 0, 0, 0, 7312, 7310, 1, 0, 0, 0, 7313, 7314, 7, 131, 0, 0, 7314,
		679, 1, 0, 0, 0, 7315, 7330, 5, 1122, 0, 0, 7316, 7330, 5, 1123, 0, 0,
		7317, 7330, 5, 1124, 0, 0, 7318, 7319, 5, 1124, 0, 0, 7319, 7330, 5, 1122,
		0, 0, 7320, 7321, 5, 1123, 0, 0, 7321, 7330, 5, 1122, 0, 0, 7322, 7323,
		5, 1124, 0, 0, 7323, 7330, 5, 1123, 0, 0, 7324, 7325, 5, 1125, 0, 0, 7325,
		7330, 5, 1122, 0, 0, 7326, 7327, 5, 1124, 0, 0, 7327, 7328, 5, 1122, 0,
		0, 7328, 7330, 5, 1123, 0, 0, 7329, 7315, 1, 0, 0, 0, 7329, 7316, 1, 0,
		0, 0, 7329, 7317, 1, 0, 0, 0, 7329, 7318, 1, 0, 0, 0, 7329, 7320, 1, 0,
		0, 0, 7329, 7322, 1, 0, 0, 0, 7329, 7324, 1, 0, 0, 0, 7329, 7326, 1, 0,
		0, 0, 7330, 681, 1, 0, 0, 0, 7331, 7339, 5, 10, 0, 0, 7332, 7333, 5, 1128,
		0, 0, 7333, 7339, 5, 1128, 0, 0, 7334, 7339, 5, 194, 0, 0, 7335, 7339,
		5, 123, 0, 0, 7336, 7337, 5, 1127, 0, 0, 7337, 7339, 5, 1127, 0, 0, 7338,
		7331, 1, 0, 0, 0, 7338, 7332, 1, 0, 0, 0, 7338, 7334, 1, 0, 0, 0, 7338,
		7335, 1, 0, 0, 0, 7338, 7336, 1, 0, 0, 0, 7339, 683, 1, 0, 0, 0, 7340,
		7341, 5, 1124, 0, 0, 7341, 7348, 5, 1124, 0, 0, 7342, 7343, 5, 1123, 0,
		0, 7343, 7348, 5, 1123, 0, 0, 7344, 7348, 5, 1128, 0, 0, 7345, 7348, 5,
		1129, 0, 0, 7346, 7348, 5, 1127, 0, 0, 7347, 7340, 1, 0, 0, 0, 7347, 7342,
		1, 0, 0, 0, 7347, 7344, 1, 0, 0, 0, 7347, 7345, 1, 0, 0, 0, 7347, 7346,
		1, 0, 0, 0, 7348, 685, 1, 0, 0, 0, 7349, 7350, 7, 132, 0, 0, 7350, 687,
		1, 0, 0, 0, 7351, 7352, 5, 1119, 0, 0, 7352, 7357, 5, 1123, 0, 0, 7353,
		7354, 5, 1119, 0, 0, 7354, 7355, 5, 1123, 0, 0, 7355, 7357, 5, 1123, 0,
		0, 7356, 7351, 1, 0, 0, 0, 7356, 7353, 1, 0, 0, 0, 7357, 689, 1, 0, 0,
		0, 7358, 7359, 7, 133, 0, 0, 7359, 691, 1, 0, 0, 0, 7360, 7361, 7, 134,
		0, 0, 7361, 693, 1, 0, 0, 0, 7362, 7363, 7, 135, 0, 0, 7363, 695, 1, 0,
		0, 0, 7364, 7365, 7, 136, 0, 0, 7365, 697, 1, 0, 0, 0, 7366, 7367, 7, 137,
		0, 0, 7367, 699, 1, 0, 0, 0, 7368, 7369, 7, 138, 0, 0, 7369, 701, 1, 0,
		0, 0, 7370, 7371, 7, 139, 0, 0, 7371, 703, 1, 0, 0, 0, 1077, 705, 709,
		716, 719, 722, 724, 730, 733, 736, 745, 787, 801, 812, 829, 834, 846, 873,
		882, 887, 893, 898, 902, 911, 914, 917, 921, 928, 931, 936, 944, 949, 954,
		957, 959, 971, 974, 978, 981, 985, 988, 992, 995, 998, 1002, 1005, 1009,
		1015, 1021, 1027, 1034, 1041, 1044, 1048, 1053, 1059, 1068, 1073, 1078,
		1085, 1102, 1109, 1113, 1123, 1127, 1131, 1135, 1139, 1144, 1147, 1150,
		1153, 1156, 1162, 1166, 1172, 1177, 1180, 1183, 1185, 1196, 1200, 1203,
		1217, 1220, 1224, 1227, 1231, 1234, 1238, 1241, 1245, 1248, 1251, 1255,
		1258, 1262, 1268, 1281, 1287, 1298, 1303, 1311, 1319, 1324, 1327, 1332,
		1340, 1345, 1351, 1356, 1360, 1362, 1365, 1369, 1373, 1376, 1380, 1384,
		1388, 1394, 1397, 1404, 1412, 1414, 1421, 1427, 1435, 1438, 1445, 1448,
		1450, 1456, 1462, 1479, 1486, 1493, 1505, 1510, 1513, 1516, 1529, 1542,
		1547, 1563, 1571, 1581, 1584, 1587, 1593, 1597, 1600, 1611, 1614, 1619,
		1632, 1639, 1646, 1648, 1655, 1659, 1661, 1666, 1669, 1675, 1680, 1682,
		1686, 1689, 1692, 1698, 1703, 1705, 1710, 1717, 1719, 1726, 1731, 1735,
		1738, 1746, 1754, 1756, 1766, 1770, 1773, 1779, 1784, 1787, 1793, 1796,
		1800, 1803, 1807, 1812, 1817, 1822, 1826, 1830, 1834, 1838, 1842, 1846,
		1851, 1856, 1861, 1867, 1872, 1877, 1882, 1887, 1892, 1898, 1903, 1908,
		1913, 1918, 1923, 1928, 1933, 1940, 1945, 1950, 1955, 1959, 1964, 1972,
		1977, 1983, 1995, 2002, 2004, 2012, 2017, 2020, 2028, 2034, 2038, 2051,
		2063, 2065, 2068, 2076, 2082, 2088, 2101, 2108, 2117, 2122, 2133, 2142,
		2147, 2159, 2166, 2175, 2180, 2192, 2199, 2208, 2213, 2220, 2229, 2234,
		2236, 2241, 2249, 2258, 2262, 2265, 2269, 2274, 2280, 2286, 2291, 2296,
		2301, 2306, 2309, 2314, 2319, 2329, 2333, 2340, 2345, 2348, 2353, 2356,
		2360, 2364, 2372, 2391, 2394, 2397, 2401, 2411, 2424, 2431, 2434, 2439,
		2446, 2449, 2452, 2463, 2466, 2470, 2478, 2481, 2486, 2494, 2500, 2504,
		2508, 2513, 2518, 2525, 2529, 2540, 2548, 2551, 2557, 2563, 2565, 2570,
		2573, 2579, 2585, 2587, 2591, 2594, 2597, 2603, 2609, 2612, 2618, 2624,
		2626, 2631, 2639, 2641, 2650, 2653, 2656, 2661, 2663, 2672, 2675, 2678,
		2683, 2685, 2694, 2699, 2707, 2711, 2719, 2729, 2734, 2741, 2745, 2749,
		2768, 2778, 2784, 2801, 2805, 2815, 2820, 2823, 2832, 2849, 2861, 2868,
		2875, 2890, 2903, 2909, 2915, 2921, 2927, 2933, 2941, 2949, 2954, 2959,
		2966, 2973, 2980, 2985, 2988, 2990, 3004, 3011, 3018, 3024, 3028, 3032,
		3039, 3042, 3047, 3054, 3061, 3065, 3070, 3077, 3090, 3093, 3098, 3103,
		3107, 3113, 3122, 3131, 3140, 3143, 3147, 3156, 3160, 3163, 3166, 3172,
		3175, 3181, 3190, 3193, 3203, 3208, 3210, 3221, 3224, 3229, 3232, 3237,
		3247, 3252, 3258, 3260, 3266, 3268, 3274, 3282, 3287, 3295, 3298, 3303,
		3306, 3311, 3319, 3327, 3333, 3341, 3346, 3354, 3357, 3361, 3364, 3372,
		3378, 3387, 3390, 3394, 3398, 3404, 3408, 3412, 3414, 3417, 3420, 3423,
		3429, 3433, 3436, 3439, 3442, 3445, 3452, 3454, 3458, 3463, 3469, 3474,
		3481, 3487, 3492, 3495, 3501, 3505, 3513, 3517, 3520, 3523, 3528, 3531,
		3538, 3542, 3545, 3549, 3553, 3556, 3559, 3564, 3570, 3574, 3584, 3590,
		3594, 3600, 3604, 3610, 3613, 3625, 3629, 3633, 3641, 3645, 3653, 3656,
		3660, 3663, 3671, 3676, 3679, 3682, 3686, 3689, 3698, 3703, 3712, 3717,
		3724, 3731, 3739, 3745, 3753, 3756, 3759, 3766, 3769, 3776, 3779, 3787,
		3793, 3804, 3807, 3811, 3821, 3827, 3831, 3835, 3845, 3850, 3852, 3856,
		3866, 3876, 3882, 3887, 3891, 3894, 3897, 3900, 3903, 3909, 3915, 3918,
		3921, 3924, 3927, 3930, 3932, 3938, 3944, 3947, 3950, 3953, 3956, 3960,
		3966, 3970, 3978, 3982, 3985, 3987, 4000, 4003, 4010, 4020, 4023, 4028,
		4030, 4034, 4042, 4048, 4057, 4070, 4074, 4080, 4089, 4092, 4096, 4099,
		4103, 4107, 4110, 4112, 4120, 4132, 4138, 4140, 4146, 4148, 4150, 4156,
		4164, 4172, 4176, 4180, 4189, 4194, 4214, 4219, 4225, 4232, 4237, 4246,
		4249, 4253, 4257, 4261, 4264, 4267, 4270, 4274, 4278, 4281, 4284, 4287,
		4294, 4298, 4313, 4317, 4329, 4337, 4347, 4351, 4354, 4360, 4363, 4366,
		4375, 4384, 4394, 4398, 4408, 4418, 4426, 4429, 4438, 4441, 4445, 4450,
		4454, 4463, 4466, 4497, 4500, 4503, 4559, 4564, 4592, 4606, 4613, 4617,
		4623, 4631, 4633, 4644, 4654, 4661, 4667, 4675, 4680, 4688, 4696, 4704,
		4712, 4718, 4723, 4728, 4733, 4739, 4741, 4752, 4757, 4764, 4766, 4780,
		4786, 4791, 4796, 4802, 4809, 4817, 4825, 4830, 4836, 4839, 4847, 4854,
		4863, 4866, 4883, 4891, 4899, 4903, 4910, 4916, 4924, 4933, 4939, 4946,
		4953, 4958, 4961, 4963, 4969, 4971, 4975, 4977, 4984, 4989, 4993, 4999,
		5008, 5014, 5021, 5027, 5033, 5038, 5041, 5043, 5049, 5051, 5055, 5057,
		5064, 5066, 5071, 5078, 5087, 5092, 5101, 5108, 5113, 5116, 5118, 5124,
		5126, 5129, 5137, 5142, 5147, 5151, 5157, 5162, 5166, 5172, 5174, 5185,
		5188, 5195, 5198, 5210, 5216, 5225, 5234, 5239, 5248, 5254, 5265, 5271,
		5276, 5280, 5286, 5291, 5295, 5298, 5310, 5317, 5322, 5340, 5348, 5353,
		5359, 5369, 5379, 5389, 5395, 5404, 5410, 5417, 5419, 5429, 5433, 5437,
		5447, 5452, 5523, 5541, 5549, 5561, 5568, 5570, 5580, 5583, 5591, 5598,
		5602, 5609, 5614, 5617, 5620, 5629, 5633, 5637, 5660, 5667, 5671, 5678,
		5685, 5688, 5704, 5707, 5717, 5721, 5727, 5730, 5735, 5739, 5746, 5749,
		5755, 5779, 5782, 5794, 5797, 5807, 5815, 5819, 5826, 5829, 5838, 5844,
		5850, 5860, 5862, 5868, 5871, 5874, 5886, 5889, 5895, 5898, 5906, 5914,
		5920, 5924, 5938, 5950, 5957, 5960, 5967, 5974, 5979, 5992, 6003, 6009,
		6014, 6027, 6029, 6034, 6038, 6041, 6043, 6050, 6057, 6060, 6063, 6069,
		6073, 6079, 6085, 6098, 6103, 6111, 6114, 6119, 6124, 6132, 6135, 6143,
		6147, 6154, 6159, 6172, 6178, 6190, 6193, 6202, 6207, 6213, 6219, 6224,
		6226, 6229, 6233, 6235, 6239, 6245, 6248, 6251, 6258, 6266, 6270, 6290,
		6297, 6299, 6306, 6308, 6312, 6317, 6328, 6333, 6339, 6342, 6346, 6351,
		6354, 6358, 6362, 6364, 6369, 6374, 6387, 6390, 6394, 6397, 6400, 6405,
		6410, 6416, 6419, 6424, 6427, 6432, 6435, 6439, 6444, 6449, 6454, 6459,
		6462, 6467, 6472, 6477, 6483, 6488, 6493, 6498, 6502, 6505, 6510, 6514,
		6518, 6526, 6533, 6537, 6542, 6547, 6551, 6553, 6556, 6572, 6581, 6589,
		6597, 6606, 6616, 6624, 6632, 6640, 6648, 6660, 6667, 6677, 6682, 6685,
		6690, 6693, 6697, 6712, 6720, 6727, 6732, 6737, 6770, 6774, 6782, 6786,
		6795, 6803, 6808, 6816, 6821, 6826, 6828, 6837, 6842, 6850, 6855, 6863,
		6871, 6874, 6884, 6902, 6905, 6908, 6912, 6925, 6933, 6937, 6942, 6947,
		6953, 6958, 6962, 6967, 6972, 6977, 6987, 6990, 6994, 6998, 7005, 7009,
		7038, 7046, 7049, 7052, 7055, 7058, 7069, 7083, 7092, 7118, 7129, 7136,
		7140, 7147, 7155, 7160, 7168, 7174, 7184, 7197, 7203, 7209, 7225, 7231,
		7240, 7242, 7262, 7274, 7291, 7308, 7310, 7329, 7338, 7347, 7356,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// MySqlParserInit initializes any static state used to implement MySqlParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewMySqlParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func MySqlParserInit() {
	staticData := &mysqlparserParserStaticData
	staticData.once.Do(mysqlparserParserInit)
}

// NewMySqlParser produces a new parser instance for the optional input antlr.TokenStream.
func NewMySqlParser(input antlr.TokenStream) *MySqlParser {
	MySqlParserInit()
	this := new(MySqlParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &mysqlparserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.predictionContextCache)
	this.RuleNames = staticData.ruleNames
	this.LiteralNames = staticData.literalNames
	this.SymbolicNames = staticData.symbolicNames
	this.GrammarFileName = "MySqlParser.g4"

	return this
}

// MySqlParser tokens.
const (
	MySqlParserEOF                               = antlr.TokenEOF
	MySqlParserSPACE                             = 1
	MySqlParserSPEC_MYSQL_COMMENT                = 2
	MySqlParserCOMMENT_INPUT                     = 3
	MySqlParserLINE_COMMENT                      = 4
	MySqlParserADD                               = 5
	MySqlParserALL                               = 6
	MySqlParserALTER                             = 7
	MySqlParserALWAYS                            = 8
	MySqlParserANALYZE                           = 9
	MySqlParserAND                               = 10
	MySqlParserARRAY                             = 11
	MySqlParserAS                                = 12
	MySqlParserASC                               = 13
	MySqlParserATTRIBUTE                         = 14
	MySqlParserBEFORE                            = 15
	MySqlParserBETWEEN                           = 16
	MySqlParserBOTH                              = 17
	MySqlParserBUCKETS                           = 18
	MySqlParserBY                                = 19
	MySqlParserCALL                              = 20
	MySqlParserCASCADE                           = 21
	MySqlParserCASE                              = 22
	MySqlParserCAST                              = 23
	MySqlParserCHANGE                            = 24
	MySqlParserCHARACTER                         = 25
	MySqlParserCHECK                             = 26
	MySqlParserCOLLATE                           = 27
	MySqlParserCOLUMN                            = 28
	MySqlParserCONDITION                         = 29
	MySqlParserCONSTRAINT                        = 30
	MySqlParserCONTINUE                          = 31
	MySqlParserCONVERT                           = 32
	MySqlParserCREATE                            = 33
	MySqlParserCROSS                             = 34
	MySqlParserCURRENT                           = 35
	MySqlParserCURRENT_ROLE                      = 36
	MySqlParserCURRENT_USER                      = 37
	MySqlParserCURSOR                            = 38
	MySqlParserDATABASE                          = 39
	MySqlParserDATABASES                         = 40
	MySqlParserDECLARE                           = 41
	MySqlParserDEFAULT                           = 42
	MySqlParserDELAYED                           = 43
	MySqlParserDELETE                            = 44
	MySqlParserDESC                              = 45
	MySqlParserDESCRIBE                          = 46
	MySqlParserDETERMINISTIC                     = 47
	MySqlParserDIAGNOSTICS                       = 48
	MySqlParserDISTINCT                          = 49
	MySqlParserDISTINCTROW                       = 50
	MySqlParserDROP                              = 51
	MySqlParserEACH                              = 52
	MySqlParserELSE                              = 53
	MySqlParserELSEIF                            = 54
	MySqlParserEMPTY                             = 55
	MySqlParserENCLOSED                          = 56
	MySqlParserENFORCED                          = 57
	MySqlParserESCAPED                           = 58
	MySqlParserEXCEPT                            = 59
	MySqlParserEXISTS                            = 60
	MySqlParserEXIT                              = 61
	MySqlParserEXPLAIN                           = 62
	MySqlParserFALSE                             = 63
	MySqlParserFETCH                             = 64
	MySqlParserFOR                               = 65
	MySqlParserFORCE                             = 66
	MySqlParserFOREIGN                           = 67
	MySqlParserFROM                              = 68
	MySqlParserFULLTEXT                          = 69
	MySqlParserGENERATED                         = 70
	MySqlParserGET                               = 71
	MySqlParserGRANT                             = 72
	MySqlParserGROUP                             = 73
	MySqlParserHAVING                            = 74
	MySqlParserHIGH_PRIORITY                     = 75
	MySqlParserHISTOGRAM                         = 76
	MySqlParserIF                                = 77
	MySqlParserIGNORE                            = 78
	MySqlParserIGNORED                           = 79
	MySqlParserIN                                = 80
	MySqlParserINDEX                             = 81
	MySqlParserINFILE                            = 82
	MySqlParserINNER                             = 83
	MySqlParserINOUT                             = 84
	MySqlParserINSERT                            = 85
	MySqlParserINTERVAL                          = 86
	MySqlParserINTO                              = 87
	MySqlParserIS                                = 88
	MySqlParserITERATE                           = 89
	MySqlParserJOIN                              = 90
	MySqlParserKEY                               = 91
	MySqlParserKEYS                              = 92
	MySqlParserKILL                              = 93
	MySqlParserLATERAL                           = 94
	MySqlParserLEADING                           = 95
	MySqlParserLEAVE                             = 96
	MySqlParserLEFT                              = 97
	MySqlParserLIKE                              = 98
	MySqlParserLIMIT                             = 99
	MySqlParserLINEAR                            = 100
	MySqlParserLINES                             = 101
	MySqlParserLOAD                              = 102
	MySqlParserLOCK                              = 103
	MySqlParserLOCKED                            = 104
	MySqlParserLOOP                              = 105
	MySqlParserLOW_PRIORITY                      = 106
	MySqlParserMASTER_BIND                       = 107
	MySqlParserMASTER_SSL_VERIFY_SERVER_CERT     = 108
	MySqlParserMATCH                             = 109
	MySqlParserMAXVALUE                          = 110
	MySqlParserMINVALUE                          = 111
	MySqlParserMODIFIES                          = 112
	MySqlParserNATURAL                           = 113
	MySqlParserNOT                               = 114
	MySqlParserNO_WRITE_TO_BINLOG                = 115
	MySqlParserNULL_LITERAL                      = 116
	MySqlParserNUMBER                            = 117
	MySqlParserON                                = 118
	MySqlParserOPTIMIZE                          = 119
	MySqlParserOPTION                            = 120
	MySqlParserOPTIONAL                          = 121
	MySqlParserOPTIONALLY                        = 122
	MySqlParserOR                                = 123
	MySqlParserORDER                             = 124
	MySqlParserOUT                               = 125
	MySqlParserOUTER                             = 126
	MySqlParserOUTFILE                           = 127
	MySqlParserOVER                              = 128
	MySqlParserPARTITION                         = 129
	MySqlParserPRIMARY                           = 130
	MySqlParserPROCEDURE                         = 131
	MySqlParserPURGE                             = 132
	MySqlParserRANGE                             = 133
	MySqlParserREAD                              = 134
	MySqlParserREADS                             = 135
	MySqlParserREFERENCES                        = 136
	MySqlParserREGEXP                            = 137
	MySqlParserRELEASE                           = 138
	MySqlParserRENAME                            = 139
	MySqlParserREPEAT                            = 140
	MySqlParserREPLACE                           = 141
	MySqlParserREQUIRE                           = 142
	MySqlParserRESIGNAL                          = 143
	MySqlParserRESTRICT                          = 144
	MySqlParserRETAIN                            = 145
	MySqlParserRETURN                            = 146
	MySqlParserREVOKE                            = 147
	MySqlParserRIGHT                             = 148
	MySqlParserRLIKE                             = 149
	MySqlParserSCHEMA                            = 150
	MySqlParserSCHEMAS                           = 151
	MySqlParserSELECT                            = 152
	MySqlParserSET                               = 153
	MySqlParserSEPARATOR                         = 154
	MySqlParserSHOW                              = 155
	MySqlParserSIGNAL                            = 156
	MySqlParserSKIP_                             = 157
	MySqlParserSKIP_QUERY_REWRITE                = 158
	MySqlParserSPATIAL                           = 159
	MySqlParserSQL                               = 160
	MySqlParserSQLEXCEPTION                      = 161
	MySqlParserSQLSTATE                          = 162
	MySqlParserSQLWARNING                        = 163
	MySqlParserSQL_BIG_RESULT                    = 164
	MySqlParserSQL_CALC_FOUND_ROWS               = 165
	MySqlParserSQL_SMALL_RESULT                  = 166
	MySqlParserSSL                               = 167
	MySqlParserSTACKED                           = 168
	MySqlParserSTARTING                          = 169
	MySqlParserSTATEMENT                         = 170
	MySqlParserSTRAIGHT_JOIN                     = 171
	MySqlParserTABLE                             = 172
	MySqlParserTERMINATED                        = 173
	MySqlParserTHEN                              = 174
	MySqlParserTO                                = 175
	MySqlParserTRAILING                          = 176
	MySqlParserTRIGGER                           = 177
	MySqlParserTRUE                              = 178
	MySqlParserUNDO                              = 179
	MySqlParserUNION                             = 180
	MySqlParserUNIQUE                            = 181
	MySqlParserUNLOCK                            = 182
	MySqlParserUNSIGNED                          = 183
	MySqlParserUPDATE                            = 184
	MySqlParserUSAGE                             = 185
	MySqlParserUSE                               = 186
	MySqlParserUSING                             = 187
	MySqlParserVALUES                            = 188
	MySqlParserWHEN                              = 189
	MySqlParserWHERE                             = 190
	MySqlParserWHILE                             = 191
	MySqlParserWITH                              = 192
	MySqlParserWRITE                             = 193
	MySqlParserXOR                               = 194
	MySqlParserZEROFILL                          = 195
	MySqlParserTINYINT                           = 196
	MySqlParserSMALLINT                          = 197
	MySqlParserMEDIUMINT                         = 198
	MySqlParserMIDDLEINT                         = 199
	MySqlParserINT                               = 200
	MySqlParserINT1                              = 201
	MySqlParserINT2                              = 202
	MySqlParserINT3                              = 203
	MySqlParserINT4                              = 204
	MySqlParserINT8                              = 205
	MySqlParserINTEGER                           = 206
	MySqlParserBIGINT                            = 207
	MySqlParserREAL                              = 208
	MySqlParserDOUBLE                            = 209
	MySqlParserPRECISION                         = 210
	MySqlParserFLOAT                             = 211
	MySqlParserFLOAT4                            = 212
	MySqlParserFLOAT8                            = 213
	MySqlParserDECIMAL                           = 214
	MySqlParserDEC                               = 215
	MySqlParserNUMERIC                           = 216
	MySqlParserDATE                              = 217
	MySqlParserTIME                              = 218
	MySqlParserTIMESTAMP                         = 219
	MySqlParserDATETIME                          = 220
	MySqlParserYEAR                              = 221
	MySqlParserCHAR                              = 222
	MySqlParserVARCHAR                           = 223
	MySqlParserNVARCHAR                          = 224
	MySqlParserNATIONAL                          = 225
	MySqlParserBINARY                            = 226
	MySqlParserVARBINARY                         = 227
	MySqlParserTINYBLOB                          = 228
	MySqlParserBLOB                              = 229
	MySqlParserMEDIUMBLOB                        = 230
	MySqlParserLONG                              = 231
	MySqlParserLONGBLOB                          = 232
	MySqlParserTINYTEXT                          = 233
	MySqlParserTEXT                              = 234
	MySqlParserMEDIUMTEXT                        = 235
	MySqlParserLONGTEXT                          = 236
	MySqlParserENUM                              = 237
	MySqlParserVARYING                           = 238
	MySqlParserSERIAL                            = 239
	MySqlParserYEAR_MONTH                        = 240
	MySqlParserDAY_HOUR                          = 241
	MySqlParserDAY_MINUTE                        = 242
	MySqlParserDAY_SECOND                        = 243
	MySqlParserHOUR_MINUTE                       = 244
	MySqlParserHOUR_SECOND                       = 245
	MySqlParserMINUTE_SECOND                     = 246
	MySqlParserSECOND_MICROSECOND                = 247
	MySqlParserMINUTE_MICROSECOND                = 248
	MySqlParserHOUR_MICROSECOND                  = 249
	MySqlParserDAY_MICROSECOND                   = 250
	MySqlParserJSON_ARRAY                        = 251
	MySqlParserJSON_ARRAYAGG                     = 252
	MySqlParserJSON_ARRAY_APPEND                 = 253
	MySqlParserJSON_ARRAY_INSERT                 = 254
	MySqlParserJSON_CONTAINS                     = 255
	MySqlParserJSON_CONTAINS_PATH                = 256
	MySqlParserJSON_DEPTH                        = 257
	MySqlParserJSON_EXTRACT                      = 258
	MySqlParserJSON_INSERT                       = 259
	MySqlParserJSON_KEYS                         = 260
	MySqlParserJSON_LENGTH                       = 261
	MySqlParserJSON_MERGE                        = 262
	MySqlParserJSON_MERGE_PATCH                  = 263
	MySqlParserJSON_MERGE_PRESERVE               = 264
	MySqlParserJSON_OBJECT                       = 265
	MySqlParserJSON_OBJECTAGG                    = 266
	MySqlParserJSON_OVERLAPS                     = 267
	MySqlParserJSON_PRETTY                       = 268
	MySqlParserJSON_QUOTE                        = 269
	MySqlParserJSON_REMOVE                       = 270
	MySqlParserJSON_REPLACE                      = 271
	MySqlParserJSON_SCHEMA_VALID                 = 272
	MySqlParserJSON_SCHEMA_VALIDATION_REPORT     = 273
	MySqlParserJSON_SEARCH                       = 274
	MySqlParserJSON_SET                          = 275
	MySqlParserJSON_STORAGE_FREE                 = 276
	MySqlParserJSON_STORAGE_SIZE                 = 277
	MySqlParserJSON_TABLE                        = 278
	MySqlParserJSON_TYPE                         = 279
	MySqlParserJSON_UNQUOTE                      = 280
	MySqlParserJSON_VALID                        = 281
	MySqlParserJSON_VALUE                        = 282
	MySqlParserNESTED                            = 283
	MySqlParserORDINALITY                        = 284
	MySqlParserPATH                              = 285
	MySqlParserAVG                               = 286
	MySqlParserBIT_AND                           = 287
	MySqlParserBIT_OR                            = 288
	MySqlParserBIT_XOR                           = 289
	MySqlParserCOUNT                             = 290
	MySqlParserCUME_DIST                         = 291
	MySqlParserDENSE_RANK                        = 292
	MySqlParserFIRST_VALUE                       = 293
	MySqlParserGROUP_CONCAT                      = 294
	MySqlParserLAG                               = 295
	MySqlParserLAST_VALUE                        = 296
	MySqlParserLEAD                              = 297
	MySqlParserMAX                               = 298
	MySqlParserMIN                               = 299
	MySqlParserNTILE                             = 300
	MySqlParserNTH_VALUE                         = 301
	MySqlParserPERCENT_RANK                      = 302
	MySqlParserRANK                              = 303
	MySqlParserROW_NUMBER                        = 304
	MySqlParserSTD                               = 305
	MySqlParserSTDDEV                            = 306
	MySqlParserSTDDEV_POP                        = 307
	MySqlParserSTDDEV_SAMP                       = 308
	MySqlParserSUM                               = 309
	MySqlParserVAR_POP                           = 310
	MySqlParserVAR_SAMP                          = 311
	MySqlParserVARIANCE                          = 312
	MySqlParserCURRENT_DATE                      = 313
	MySqlParserCURRENT_TIME                      = 314
	MySqlParserCURRENT_TIMESTAMP                 = 315
	MySqlParserLOCALTIME                         = 316
	MySqlParserCURDATE                           = 317
	MySqlParserCURTIME                           = 318
	MySqlParserDATE_ADD                          = 319
	MySqlParserDATE_SUB                          = 320
	MySqlParserEXTRACT                           = 321
	MySqlParserLOCALTIMESTAMP                    = 322
	MySqlParserNOW                               = 323
	MySqlParserPOSITION                          = 324
	MySqlParserSUBSTR                            = 325
	MySqlParserSUBSTRING                         = 326
	MySqlParserSYSDATE                           = 327
	MySqlParserTRIM                              = 328
	MySqlParserUTC_DATE                          = 329
	MySqlParserUTC_TIME                          = 330
	MySqlParserUTC_TIMESTAMP                     = 331
	MySqlParserACCOUNT                           = 332
	MySqlParserACTION                            = 333
	MySqlParserAFTER                             = 334
	MySqlParserAGGREGATE                         = 335
	MySqlParserALGORITHM                         = 336
	MySqlParserANY                               = 337
	MySqlParserAT                                = 338
	MySqlParserAUTHORS                           = 339
	MySqlParserAUTOCOMMIT                        = 340
	MySqlParserAUTOEXTEND_SIZE                   = 341
	MySqlParserAUTO_INCREMENT                    = 342
	MySqlParserAVG_ROW_LENGTH                    = 343
	MySqlParserBEGIN                             = 344
	MySqlParserBINLOG                            = 345
	MySqlParserBIT                               = 346
	MySqlParserBLOCK                             = 347
	MySqlParserBOOL                              = 348
	MySqlParserBOOLEAN                           = 349
	MySqlParserBTREE                             = 350
	MySqlParserCACHE                             = 351
	MySqlParserCASCADED                          = 352
	MySqlParserCHAIN                             = 353
	MySqlParserCHANGED                           = 354
	MySqlParserCHANNEL                           = 355
	MySqlParserCHECKSUM                          = 356
	MySqlParserPAGE_CHECKSUM                     = 357
	MySqlParserCIPHER                            = 358
	MySqlParserCLASS_ORIGIN                      = 359
	MySqlParserCLIENT                            = 360
	MySqlParserCLOSE                             = 361
	MySqlParserCLUSTERING                        = 362
	MySqlParserCOALESCE                          = 363
	MySqlParserCODE                              = 364
	MySqlParserCOLUMNS                           = 365
	MySqlParserCOLUMN_FORMAT                     = 366
	MySqlParserCOLUMN_NAME                       = 367
	MySqlParserCOMMENT                           = 368
	MySqlParserCOMMIT                            = 369
	MySqlParserCOMPACT                           = 370
	MySqlParserCOMPLETION                        = 371
	MySqlParserCOMPRESSED                        = 372
	MySqlParserCOMPRESSION                       = 373
	MySqlParserCONCURRENT                        = 374
	MySqlParserCONNECT                           = 375
	MySqlParserCONNECTION                        = 376
	MySqlParserCONSISTENT                        = 377
	MySqlParserCONSTRAINT_CATALOG                = 378
	MySqlParserCONSTRAINT_SCHEMA                 = 379
	MySqlParserCONSTRAINT_NAME                   = 380
	MySqlParserCONTAINS                          = 381
	MySqlParserCONTEXT                           = 382
	MySqlParserCONTRIBUTORS                      = 383
	MySqlParserCOPY                              = 384
	MySqlParserCPU                               = 385
	MySqlParserCYCLE                             = 386
	MySqlParserCURSOR_NAME                       = 387
	MySqlParserDATA                              = 388
	MySqlParserDATAFILE                          = 389
	MySqlParserDEALLOCATE                        = 390
	MySqlParserDEFAULT_AUTH                      = 391
	MySqlParserDEFINER                           = 392
	MySqlParserDELAY_KEY_WRITE                   = 393
	MySqlParserDES_KEY_FILE                      = 394
	MySqlParserDIRECTORY                         = 395
	MySqlParserDISABLE                           = 396
	MySqlParserDISCARD                           = 397
	MySqlParserDISK                              = 398
	MySqlParserDO                                = 399
	MySqlParserDUMPFILE                          = 400
	MySqlParserDUPLICATE                         = 401
	MySqlParserDYNAMIC                           = 402
	MySqlParserENABLE                            = 403
	MySqlParserENCRYPTED                         = 404
	MySqlParserENCRYPTION                        = 405
	MySqlParserENCRYPTION_KEY_ID                 = 406
	MySqlParserEND                               = 407
	MySqlParserENDS                              = 408
	MySqlParserENGINE                            = 409
	MySqlParserENGINES                           = 410
	MySqlParserERROR                             = 411
	MySqlParserERRORS                            = 412
	MySqlParserESCAPE                            = 413
	MySqlParserEVEN                              = 414
	MySqlParserEVENT                             = 415
	MySqlParserEVENTS                            = 416
	MySqlParserEVERY                             = 417
	MySqlParserEXCHANGE                          = 418
	MySqlParserEXCLUSIVE                         = 419
	MySqlParserEXPIRE                            = 420
	MySqlParserEXPORT                            = 421
	MySqlParserEXTENDED                          = 422
	MySqlParserEXTENT_SIZE                       = 423
	MySqlParserFAILED_LOGIN_ATTEMPTS             = 424
	MySqlParserFAST                              = 425
	MySqlParserFAULTS                            = 426
	MySqlParserFIELDS                            = 427
	MySqlParserFILE_BLOCK_SIZE                   = 428
	MySqlParserFILTER                            = 429
	MySqlParserFIRST                             = 430
	MySqlParserFIXED                             = 431
	MySqlParserFLUSH                             = 432
	MySqlParserFOLLOWING                         = 433
	MySqlParserFOLLOWS                           = 434
	MySqlParserFOUND                             = 435
	MySqlParserFULL                              = 436
	MySqlParserFUNCTION                          = 437
	MySqlParserGENERAL                           = 438
	MySqlParserGLOBAL                            = 439
	MySqlParserGRANTS                            = 440
	MySqlParserGROUP_REPLICATION                 = 441
	MySqlParserHANDLER                           = 442
	MySqlParserHASH                              = 443
	MySqlParserHELP                              = 444
	MySqlParserHISTORY                           = 445
	MySqlParserHOST                              = 446
	MySqlParserHOSTS                             = 447
	MySqlParserIDENTIFIED                        = 448
	MySqlParserIGNORE_SERVER_IDS                 = 449
	MySqlParserIMPORT                            = 450
	MySqlParserINCREMENT                         = 451
	MySqlParserINDEXES                           = 452
	MySqlParserINITIAL_SIZE                      = 453
	MySqlParserINPLACE                           = 454
	MySqlParserINSERT_METHOD                     = 455
	MySqlParserINSTALL                           = 456
	MySqlParserINSTANCE                          = 457
	MySqlParserINSTANT                           = 458
	MySqlParserINVISIBLE                         = 459
	MySqlParserINVOKER                           = 460
	MySqlParserIO                                = 461
	MySqlParserIO_THREAD                         = 462
	MySqlParserIPC                               = 463
	MySqlParserISOLATION                         = 464
	MySqlParserISSUER                            = 465
	MySqlParserJSON                              = 466
	MySqlParserKEY_BLOCK_SIZE                    = 467
	MySqlParserLANGUAGE                          = 468
	MySqlParserLAST                              = 469
	MySqlParserLEAVES                            = 470
	MySqlParserLESS                              = 471
	MySqlParserLEVEL                             = 472
	MySqlParserLIST                              = 473
	MySqlParserLOCAL                             = 474
	MySqlParserLOGFILE                           = 475
	MySqlParserLOGS                              = 476
	MySqlParserMASTER                            = 477
	MySqlParserMASTER_AUTO_POSITION              = 478
	MySqlParserMASTER_CONNECT_RETRY              = 479
	MySqlParserMASTER_DELAY                      = 480
	MySqlParserMASTER_HEARTBEAT_PERIOD           = 481
	MySqlParserMASTER_HOST                       = 482
	MySqlParserMASTER_LOG_FILE                   = 483
	MySqlParserMASTER_LOG_POS                    = 484
	MySqlParserMASTER_PASSWORD                   = 485
	MySqlParserMASTER_PORT                       = 486
	MySqlParserMASTER_RETRY_COUNT                = 487
	MySqlParserMASTER_SSL                        = 488
	MySqlParserMASTER_SSL_CA                     = 489
	MySqlParserMASTER_SSL_CAPATH                 = 490
	MySqlParserMASTER_SSL_CERT                   = 491
	MySqlParserMASTER_SSL_CIPHER                 = 492
	MySqlParserMASTER_SSL_CRL                    = 493
	MySqlParserMASTER_SSL_CRLPATH                = 494
	MySqlParserMASTER_SSL_KEY                    = 495
	MySqlParserMASTER_TLS_VERSION                = 496
	MySqlParserMASTER_USER                       = 497
	MySqlParserMAX_CONNECTIONS_PER_HOUR          = 498
	MySqlParserMAX_QUERIES_PER_HOUR              = 499
	MySqlParserMAX_ROWS                          = 500
	MySqlParserMAX_SIZE                          = 501
	MySqlParserMAX_UPDATES_PER_HOUR              = 502
	MySqlParserMAX_USER_CONNECTIONS              = 503
	MySqlParserMEDIUM                            = 504
	MySqlParserMEMBER                            = 505
	MySqlParserMERGE                             = 506
	MySqlParserMESSAGE_TEXT                      = 507
	MySqlParserMID                               = 508
	MySqlParserMIGRATE                           = 509
	MySqlParserMIN_ROWS                          = 510
	MySqlParserMODE                              = 511
	MySqlParserMODIFY                            = 512
	MySqlParserMUTEX                             = 513
	MySqlParserMYSQL                             = 514
	MySqlParserMYSQL_ERRNO                       = 515
	MySqlParserNAME                              = 516
	MySqlParserNAMES                             = 517
	MySqlParserNCHAR                             = 518
	MySqlParserNEVER                             = 519
	MySqlParserNEXT                              = 520
	MySqlParserNO                                = 521
	MySqlParserNOCACHE                           = 522
	MySqlParserNOCOPY                            = 523
	MySqlParserNOCYCLE                           = 524
	MySqlParserNOMAXVALUE                        = 525
	MySqlParserNOMINVALUE                        = 526
	MySqlParserNOWAIT                            = 527
	MySqlParserNODEGROUP                         = 528
	MySqlParserNONE                              = 529
	MySqlParserODBC                              = 530
	MySqlParserOFFLINE                           = 531
	MySqlParserOFFSET                            = 532
	MySqlParserOF                                = 533
	MySqlParserOJ                                = 534
	MySqlParserOLD_PASSWORD                      = 535
	MySqlParserONE                               = 536
	MySqlParserONLINE                            = 537
	MySqlParserONLY                              = 538
	MySqlParserOPEN                              = 539
	MySqlParserOPTIMIZER_COSTS                   = 540
	MySqlParserOPTIONS                           = 541
	MySqlParserOWNER                             = 542
	MySqlParserPACK_KEYS                         = 543
	MySqlParserPAGE                              = 544
	MySqlParserPAGE_COMPRESSED                   = 545
	MySqlParserPAGE_COMPRESSION_LEVEL            = 546
	MySqlParserPARSER                            = 547
	MySqlParserPARTIAL                           = 548
	MySqlParserPARTITIONING                      = 549
	MySqlParserPARTITIONS                        = 550
	MySqlParserPASSWORD                          = 551
	MySqlParserPASSWORD_LOCK_TIME                = 552
	MySqlParserPHASE                             = 553
	MySqlParserPLUGIN                            = 554
	MySqlParserPLUGIN_DIR                        = 555
	MySqlParserPLUGINS                           = 556
	MySqlParserPORT                              = 557
	MySqlParserPRECEDES                          = 558
	MySqlParserPRECEDING                         = 559
	MySqlParserPREPARE                           = 560
	MySqlParserPRESERVE                          = 561
	MySqlParserPREV                              = 562
	MySqlParserPROCESSLIST                       = 563
	MySqlParserPROFILE                           = 564
	MySqlParserPROFILES                          = 565
	MySqlParserPROXY                             = 566
	MySqlParserQUERY                             = 567
	MySqlParserQUICK                             = 568
	MySqlParserREBUILD                           = 569
	MySqlParserRECOVER                           = 570
	MySqlParserRECURSIVE                         = 571
	MySqlParserREDO_BUFFER_SIZE                  = 572
	MySqlParserREDUNDANT                         = 573
	MySqlParserRELAY                             = 574
	MySqlParserRELAY_LOG_FILE                    = 575
	MySqlParserRELAY_LOG_POS                     = 576
	MySqlParserRELAYLOG                          = 577
	MySqlParserREMOVE                            = 578
	MySqlParserREORGANIZE                        = 579
	MySqlParserREPAIR                            = 580
	MySqlParserREPLICATE_DO_DB                   = 581
	MySqlParserREPLICATE_DO_TABLE                = 582
	MySqlParserREPLICATE_IGNORE_DB               = 583
	MySqlParserREPLICATE_IGNORE_TABLE            = 584
	MySqlParserREPLICATE_REWRITE_DB              = 585
	MySqlParserREPLICATE_WILD_DO_TABLE           = 586
	MySqlParserREPLICATE_WILD_IGNORE_TABLE       = 587
	MySqlParserREPLICATION                       = 588
	MySqlParserRESET                             = 589
	MySqlParserRESTART                           = 590
	MySqlParserRESUME                            = 591
	MySqlParserRETURNED_SQLSTATE                 = 592
	MySqlParserRETURNING                         = 593
	MySqlParserRETURNS                           = 594
	MySqlParserREUSE                             = 595
	MySqlParserROLE                              = 596
	MySqlParserROLLBACK                          = 597
	MySqlParserROLLUP                            = 598
	MySqlParserROTATE                            = 599
	MySqlParserROW                               = 600
	MySqlParserROWS                              = 601
	MySqlParserROW_FORMAT                        = 602
	MySqlParserRTREE                             = 603
	MySqlParserSAVEPOINT                         = 604
	MySqlParserSCHEDULE                          = 605
	MySqlParserSECURITY                          = 606
	MySqlParserSEQUENCE                          = 607
	MySqlParserSERVER                            = 608
	MySqlParserSESSION                           = 609
	MySqlParserSHARE                             = 610
	MySqlParserSHARED                            = 611
	MySqlParserSIGNED                            = 612
	MySqlParserSIMPLE                            = 613
	MySqlParserSLAVE                             = 614
	MySqlParserSLOW                              = 615
	MySqlParserSNAPSHOT                          = 616
	MySqlParserSOCKET                            = 617
	MySqlParserSOME                              = 618
	MySqlParserSONAME                            = 619
	MySqlParserSOUNDS                            = 620
	MySqlParserSOURCE                            = 621
	MySqlParserSQL_AFTER_GTIDS                   = 622
	MySqlParserSQL_AFTER_MTS_GAPS                = 623
	MySqlParserSQL_BEFORE_GTIDS                  = 624
	MySqlParserSQL_BUFFER_RESULT                 = 625
	MySqlParserSQL_CACHE                         = 626
	MySqlParserSQL_NO_CACHE                      = 627
	MySqlParserSQL_THREAD                        = 628
	MySqlParserSTART                             = 629
	MySqlParserSTARTS                            = 630
	MySqlParserSTATS_AUTO_RECALC                 = 631
	MySqlParserSTATS_PERSISTENT                  = 632
	MySqlParserSTATS_SAMPLE_PAGES                = 633
	MySqlParserSTATUS                            = 634
	MySqlParserSTOP                              = 635
	MySqlParserSTORAGE                           = 636
	MySqlParserSTORED                            = 637
	MySqlParserSTRING                            = 638
	MySqlParserSUBCLASS_ORIGIN                   = 639
	MySqlParserSUBJECT                           = 640
	MySqlParserSUBPARTITION                      = 641
	MySqlParserSUBPARTITIONS                     = 642
	MySqlParserSUSPEND                           = 643
	MySqlParserSWAPS                             = 644
	MySqlParserSWITCHES                          = 645
	MySqlParserTABLE_NAME                        = 646
	MySqlParserTABLESPACE                        = 647
	MySqlParserTABLE_TYPE                        = 648
	MySqlParserTEMPORARY                         = 649
	MySqlParserTEMPTABLE                         = 650
	MySqlParserTHAN                              = 651
	MySqlParserTRADITIONAL                       = 652
	MySqlParserTRANSACTION                       = 653
	MySqlParserTRANSACTIONAL                     = 654
	MySqlParserTRIGGERS                          = 655
	MySqlParserTRUNCATE                          = 656
	MySqlParserUNBOUNDED                         = 657
	MySqlParserUNDEFINED                         = 658
	MySqlParserUNDOFILE                          = 659
	MySqlParserUNDO_BUFFER_SIZE                  = 660
	MySqlParserUNINSTALL                         = 661
	MySqlParserUNKNOWN                           = 662
	MySqlParserUNTIL                             = 663
	MySqlParserUPGRADE                           = 664
	MySqlParserUSER                              = 665
	MySqlParserUSE_FRM                           = 666
	MySqlParserUSER_RESOURCES                    = 667
	MySqlParserVALIDATION                        = 668
	MySqlParserVALUE                             = 669
	MySqlParserVARIABLES                         = 670
	MySqlParserVIEW                              = 671
	MySqlParserVIRTUAL                           = 672
	MySqlParserVISIBLE                           = 673
	MySqlParserWAIT                              = 674
	MySqlParserWARNINGS                          = 675
	MySqlParserWINDOW                            = 676
	MySqlParserWITHOUT                           = 677
	MySqlParserWORK                              = 678
	MySqlParserWRAPPER                           = 679
	MySqlParserX509                              = 680
	MySqlParserXA                                = 681
	MySqlParserXML                               = 682
	MySqlParserYES                               = 683
	MySqlParserEUR                               = 684
	MySqlParserUSA                               = 685
	MySqlParserJIS                               = 686
	MySqlParserISO                               = 687
	MySqlParserINTERNAL                          = 688
	MySqlParserQUARTER                           = 689
	MySqlParserMONTH                             = 690
	MySqlParserDAY                               = 691
	MySqlParserHOUR                              = 692
	MySqlParserMINUTE                            = 693
	MySqlParserWEEK                              = 694
	MySqlParserSECOND                            = 695
	MySqlParserMICROSECOND                       = 696
	MySqlParserADMIN                             = 697
	MySqlParserAPPLICATION_PASSWORD_ADMIN        = 698
	MySqlParserAUDIT_ABORT_EXEMPT                = 699
	MySqlParserAUDIT_ADMIN                       = 700
	MySqlParserBACKUP_ADMIN                      = 701
	MySqlParserBINLOG_ADMIN                      = 702
	MySqlParserBINLOG_ENCRYPTION_ADMIN           = 703
	MySqlParserCLONE_ADMIN                       = 704
	MySqlParserCONNECTION_ADMIN                  = 705
	MySqlParserENCRYPTION_KEY_ADMIN              = 706
	MySqlParserEXECUTE                           = 707
	MySqlParserFILE                              = 708
	MySqlParserFIREWALL_ADMIN                    = 709
	MySqlParserFIREWALL_EXEMPT                   = 710
	MySqlParserFIREWALL_USER                     = 711
	MySqlParserFLUSH_OPTIMIZER_COSTS             = 712
	MySqlParserFLUSH_STATUS                      = 713
	MySqlParserFLUSH_TABLES                      = 714
	MySqlParserFLUSH_USER_RESOURCES              = 715
	MySqlParserGROUP_REPLICATION_ADMIN           = 716
	MySqlParserINNODB_REDO_LOG_ARCHIVE           = 717
	MySqlParserINNODB_REDO_LOG_ENABLE            = 718
	MySqlParserINVOKE                            = 719
	MySqlParserLAMBDA                            = 720
	MySqlParserNDB_STORED_USER                   = 721
	MySqlParserPASSWORDLESS_USER_ADMIN           = 722
	MySqlParserPERSIST_RO_VARIABLES_ADMIN        = 723
	MySqlParserPRIVILEGES                        = 724
	MySqlParserPROCESS                           = 725
	MySqlParserRELOAD                            = 726
	MySqlParserREPLICATION_APPLIER               = 727
	MySqlParserREPLICATION_SLAVE_ADMIN           = 728
	MySqlParserRESOURCE_GROUP_ADMIN              = 729
	MySqlParserRESOURCE_GROUP_USER               = 730
	MySqlParserROLE_ADMIN                        = 731
	MySqlParserROUTINE                           = 732
	MySqlParserS3                                = 733
	MySqlParserSERVICE_CONNECTION_ADMIN          = 734
	MySqlParserSESSION_VARIABLES_ADMIN           = 735
	MySqlParserSET_USER_ID                       = 736
	MySqlParserSHOW_ROUTINE                      = 737
	MySqlParserSHUTDOWN                          = 738
	MySqlParserSUPER                             = 739
	MySqlParserSYSTEM_VARIABLES_ADMIN            = 740
	MySqlParserTABLES                            = 741
	MySqlParserTABLE_ENCRYPTION_ADMIN            = 742
	MySqlParserVERSION_TOKEN_ADMIN               = 743
	MySqlParserXA_RECOVER_ADMIN                  = 744
	MySqlParserARMSCII8                          = 745
	MySqlParserASCII                             = 746
	MySqlParserBIG5                              = 747
	MySqlParserCP1250                            = 748
	MySqlParserCP1251                            = 749
	MySqlParserCP1256                            = 750
	MySqlParserCP1257                            = 751
	MySqlParserCP850                             = 752
	MySqlParserCP852                             = 753
	MySqlParserCP866                             = 754
	MySqlParserCP932                             = 755
	MySqlParserDEC8                              = 756
	MySqlParserEUCJPMS                           = 757
	MySqlParserEUCKR                             = 758
	MySqlParserGB18030                           = 759
	MySqlParserGB2312                            = 760
	MySqlParserGBK                               = 761
	MySqlParserGEOSTD8                           = 762
	MySqlParserGREEK                             = 763
	MySqlParserHEBREW                            = 764
	MySqlParserHP8                               = 765
	MySqlParserKEYBCS2                           = 766
	MySqlParserKOI8R                             = 767
	MySqlParserKOI8U                             = 768
	MySqlParserLATIN1                            = 769
	MySqlParserLATIN2                            = 770
	MySqlParserLATIN5                            = 771
	MySqlParserLATIN7                            = 772
	MySqlParserMACCE                             = 773
	MySqlParserMACROMAN                          = 774
	MySqlParserSJIS                              = 775
	MySqlParserSWE7                              = 776
	MySqlParserTIS620                            = 777
	MySqlParserUCS2                              = 778
	MySqlParserUJIS                              = 779
	MySqlParserUTF16                             = 780
	MySqlParserUTF16LE                           = 781
	MySqlParserUTF32                             = 782
	MySqlParserUTF8                              = 783
	MySqlParserUTF8MB3                           = 784
	MySqlParserUTF8MB4                           = 785
	MySqlParserARCHIVE                           = 786
	MySqlParserBLACKHOLE                         = 787
	MySqlParserCSV                               = 788
	MySqlParserFEDERATED                         = 789
	MySqlParserINNODB                            = 790
	MySqlParserMEMORY                            = 791
	MySqlParserMRG_MYISAM                        = 792
	MySqlParserMYISAM                            = 793
	MySqlParserNDB                               = 794
	MySqlParserNDBCLUSTER                        = 795
	MySqlParserPERFORMANCE_SCHEMA                = 796
	MySqlParserTOKUDB                            = 797
	MySqlParserREPEATABLE                        = 798
	MySqlParserCOMMITTED                         = 799
	MySqlParserUNCOMMITTED                       = 800
	MySqlParserSERIALIZABLE                      = 801
	MySqlParserGEOMETRYCOLLECTION                = 802
	MySqlParserGEOMCOLLECTION                    = 803
	MySqlParserGEOMETRY                          = 804
	MySqlParserLINESTRING                        = 805
	MySqlParserMULTILINESTRING                   = 806
	MySqlParserMULTIPOINT                        = 807
	MySqlParserMULTIPOLYGON                      = 808
	MySqlParserPOINT                             = 809
	MySqlParserPOLYGON                           = 810
	MySqlParserABS                               = 811
	MySqlParserACOS                              = 812
	MySqlParserADDDATE                           = 813
	MySqlParserADDTIME                           = 814
	MySqlParserAES_DECRYPT                       = 815
	MySqlParserAES_ENCRYPT                       = 816
	MySqlParserAREA                              = 817
	MySqlParserASBINARY                          = 818
	MySqlParserASIN                              = 819
	MySqlParserASTEXT                            = 820
	MySqlParserASWKB                             = 821
	MySqlParserASWKT                             = 822
	MySqlParserASYMMETRIC_DECRYPT                = 823
	MySqlParserASYMMETRIC_DERIVE                 = 824
	MySqlParserASYMMETRIC_ENCRYPT                = 825
	MySqlParserASYMMETRIC_SIGN                   = 826
	MySqlParserASYMMETRIC_VERIFY                 = 827
	MySqlParserATAN                              = 828
	MySqlParserATAN2                             = 829
	MySqlParserBENCHMARK                         = 830
	MySqlParserBIN                               = 831
	MySqlParserBIT_COUNT                         = 832
	MySqlParserBIT_LENGTH                        = 833
	MySqlParserBUFFER                            = 834
	MySqlParserCATALOG_NAME                      = 835
	MySqlParserCEIL                              = 836
	MySqlParserCEILING                           = 837
	MySqlParserCENTROID                          = 838
	MySqlParserCHARACTER_LENGTH                  = 839
	MySqlParserCHARSET                           = 840
	MySqlParserCHAR_LENGTH                       = 841
	MySqlParserCOERCIBILITY                      = 842
	MySqlParserCOLLATION                         = 843
	MySqlParserCOMPRESS                          = 844
	MySqlParserCONCAT                            = 845
	MySqlParserCONCAT_WS                         = 846
	MySqlParserCONNECTION_ID                     = 847
	MySqlParserCONV                              = 848
	MySqlParserCONVERT_TZ                        = 849
	MySqlParserCOS                               = 850
	MySqlParserCOT                               = 851
	MySqlParserCRC32                             = 852
	MySqlParserCREATE_ASYMMETRIC_PRIV_KEY        = 853
	MySqlParserCREATE_ASYMMETRIC_PUB_KEY         = 854
	MySqlParserCREATE_DH_PARAMETERS              = 855
	MySqlParserCREATE_DIGEST                     = 856
	MySqlParserCROSSES                           = 857
	MySqlParserDATEDIFF                          = 858
	MySqlParserDATE_FORMAT                       = 859
	MySqlParserDAYNAME                           = 860
	MySqlParserDAYOFMONTH                        = 861
	MySqlParserDAYOFWEEK                         = 862
	MySqlParserDAYOFYEAR                         = 863
	MySqlParserDECODE                            = 864
	MySqlParserDEGREES                           = 865
	MySqlParserDES_DECRYPT                       = 866
	MySqlParserDES_ENCRYPT                       = 867
	MySqlParserDIMENSION                         = 868
	MySqlParserDISJOINT                          = 869
	MySqlParserELT                               = 870
	MySqlParserENCODE                            = 871
	MySqlParserENCRYPT                           = 872
	MySqlParserENDPOINT                          = 873
	MySqlParserENGINE_ATTRIBUTE                  = 874
	MySqlParserENVELOPE                          = 875
	MySqlParserEQUALS                            = 876
	MySqlParserEXP                               = 877
	MySqlParserEXPORT_SET                        = 878
	MySqlParserEXTERIORRING                      = 879
	MySqlParserEXTRACTVALUE                      = 880
	MySqlParserFIELD                             = 881
	MySqlParserFIND_IN_SET                       = 882
	MySqlParserFLOOR                             = 883
	MySqlParserFORMAT                            = 884
	MySqlParserFOUND_ROWS                        = 885
	MySqlParserFROM_BASE64                       = 886
	MySqlParserFROM_DAYS                         = 887
	MySqlParserFROM_UNIXTIME                     = 888
	MySqlParserGEOMCOLLFROMTEXT                  = 889
	MySqlParserGEOMCOLLFROMWKB                   = 890
	MySqlParserGEOMETRYCOLLECTIONFROMTEXT        = 891
	MySqlParserGEOMETRYCOLLECTIONFROMWKB         = 892
	MySqlParserGEOMETRYFROMTEXT                  = 893
	MySqlParserGEOMETRYFROMWKB                   = 894
	MySqlParserGEOMETRYN                         = 895
	MySqlParserGEOMETRYTYPE                      = 896
	MySqlParserGEOMFROMTEXT                      = 897
	MySqlParserGEOMFROMWKB                       = 898
	MySqlParserGET_FORMAT                        = 899
	MySqlParserGET_LOCK                          = 900
	MySqlParserGLENGTH                           = 901
	MySqlParserGREATEST                          = 902
	MySqlParserGTID_SUBSET                       = 903
	MySqlParserGTID_SUBTRACT                     = 904
	MySqlParserHEX                               = 905
	MySqlParserIFNULL                            = 906
	MySqlParserINET6_ATON                        = 907
	MySqlParserINET6_NTOA                        = 908
	MySqlParserINET_ATON                         = 909
	MySqlParserINET_NTOA                         = 910
	MySqlParserINSTR                             = 911
	MySqlParserINTERIORRINGN                     = 912
	MySqlParserINTERSECTS                        = 913
	MySqlParserISCLOSED                          = 914
	MySqlParserISEMPTY                           = 915
	MySqlParserISNULL                            = 916
	MySqlParserISSIMPLE                          = 917
	MySqlParserIS_FREE_LOCK                      = 918
	MySqlParserIS_IPV4                           = 919
	MySqlParserIS_IPV4_COMPAT                    = 920
	MySqlParserIS_IPV4_MAPPED                    = 921
	MySqlParserIS_IPV6                           = 922
	MySqlParserIS_USED_LOCK                      = 923
	MySqlParserLAST_INSERT_ID                    = 924
	MySqlParserLCASE                             = 925
	MySqlParserLEAST                             = 926
	MySqlParserLENGTH                            = 927
	MySqlParserLINEFROMTEXT                      = 928
	MySqlParserLINEFROMWKB                       = 929
	MySqlParserLINESTRINGFROMTEXT                = 930
	MySqlParserLINESTRINGFROMWKB                 = 931
	MySqlParserLN                                = 932
	MySqlParserLOAD_FILE                         = 933
	MySqlParserLOCATE                            = 934
	MySqlParserLOG                               = 935
	MySqlParserLOG10                             = 936
	MySqlParserLOG2                              = 937
	MySqlParserLOWER                             = 938
	MySqlParserLPAD                              = 939
	MySqlParserLTRIM                             = 940
	MySqlParserMAKEDATE                          = 941
	MySqlParserMAKETIME                          = 942
	MySqlParserMAKE_SET                          = 943
	MySqlParserMASTER_POS_WAIT                   = 944
	MySqlParserMBRCONTAINS                       = 945
	MySqlParserMBRDISJOINT                       = 946
	MySqlParserMBREQUAL                          = 947
	MySqlParserMBRINTERSECTS                     = 948
	MySqlParserMBROVERLAPS                       = 949
	MySqlParserMBRTOUCHES                        = 950
	MySqlParserMBRWITHIN                         = 951
	MySqlParserMD5                               = 952
	MySqlParserMLINEFROMTEXT                     = 953
	MySqlParserMLINEFROMWKB                      = 954
	MySqlParserMONTHNAME                         = 955
	MySqlParserMPOINTFROMTEXT                    = 956
	MySqlParserMPOINTFROMWKB                     = 957
	MySqlParserMPOLYFROMTEXT                     = 958
	MySqlParserMPOLYFROMWKB                      = 959
	MySqlParserMULTILINESTRINGFROMTEXT           = 960
	MySqlParserMULTILINESTRINGFROMWKB            = 961
	MySqlParserMULTIPOINTFROMTEXT                = 962
	MySqlParserMULTIPOINTFROMWKB                 = 963
	MySqlParserMULTIPOLYGONFROMTEXT              = 964
	MySqlParserMULTIPOLYGONFROMWKB               = 965
	MySqlParserNAME_CONST                        = 966
	MySqlParserNULLIF                            = 967
	MySqlParserNUMGEOMETRIES                     = 968
	MySqlParserNUMINTERIORRINGS                  = 969
	MySqlParserNUMPOINTS                         = 970
	MySqlParserOCT                               = 971
	MySqlParserOCTET_LENGTH                      = 972
	MySqlParserORD                               = 973
	MySqlParserOVERLAPS                          = 974
	MySqlParserPERIOD_ADD                        = 975
	MySqlParserPERIOD_DIFF                       = 976
	MySqlParserPI                                = 977
	MySqlParserPOINTFROMTEXT                     = 978
	MySqlParserPOINTFROMWKB                      = 979
	MySqlParserPOINTN                            = 980
	MySqlParserPOLYFROMTEXT                      = 981
	MySqlParserPOLYFROMWKB                       = 982
	MySqlParserPOLYGONFROMTEXT                   = 983
	MySqlParserPOLYGONFROMWKB                    = 984
	MySqlParserPOW                               = 985
	MySqlParserPOWER                             = 986
	MySqlParserQUOTE                             = 987
	MySqlParserRADIANS                           = 988
	MySqlParserRAND                              = 989
	MySqlParserRANDOM_BYTES                      = 990
	MySqlParserRELEASE_LOCK                      = 991
	MySqlParserREVERSE                           = 992
	MySqlParserROUND                             = 993
	MySqlParserROW_COUNT                         = 994
	MySqlParserRPAD                              = 995
	MySqlParserRTRIM                             = 996
	MySqlParserSEC_TO_TIME                       = 997
	MySqlParserSECONDARY_ENGINE_ATTRIBUTE        = 998
	MySqlParserSESSION_USER                      = 999
	MySqlParserSHA                               = 1000
	MySqlParserSHA1                              = 1001
	MySqlParserSHA2                              = 1002
	MySqlParserSCHEMA_NAME                       = 1003
	MySqlParserSIGN                              = 1004
	MySqlParserSIN                               = 1005
	MySqlParserSLEEP                             = 1006
	MySqlParserSOUNDEX                           = 1007
	MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS       = 1008
	MySqlParserSQRT                              = 1009
	MySqlParserSRID                              = 1010
	MySqlParserSTARTPOINT                        = 1011
	MySqlParserSTRCMP                            = 1012
	MySqlParserSTR_TO_DATE                       = 1013
	MySqlParserST_AREA                           = 1014
	MySqlParserST_ASBINARY                       = 1015
	MySqlParserST_ASTEXT                         = 1016
	MySqlParserST_ASWKB                          = 1017
	MySqlParserST_ASWKT                          = 1018
	MySqlParserST_BUFFER                         = 1019
	MySqlParserST_CENTROID                       = 1020
	MySqlParserST_CONTAINS                       = 1021
	MySqlParserST_CROSSES                        = 1022
	MySqlParserST_DIFFERENCE                     = 1023
	MySqlParserST_DIMENSION                      = 1024
	MySqlParserST_DISJOINT                       = 1025
	MySqlParserST_DISTANCE                       = 1026
	MySqlParserST_ENDPOINT                       = 1027
	MySqlParserST_ENVELOPE                       = 1028
	MySqlParserST_EQUALS                         = 1029
	MySqlParserST_EXTERIORRING                   = 1030
	MySqlParserST_GEOMCOLLFROMTEXT               = 1031
	MySqlParserST_GEOMCOLLFROMTXT                = 1032
	MySqlParserST_GEOMCOLLFROMWKB                = 1033
	MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT     = 1034
	MySqlParserST_GEOMETRYCOLLECTIONFROMWKB      = 1035
	MySqlParserST_GEOMETRYFROMTEXT               = 1036
	MySqlParserST_GEOMETRYFROMWKB                = 1037
	MySqlParserST_GEOMETRYN                      = 1038
	MySqlParserST_GEOMETRYTYPE                   = 1039
	MySqlParserST_GEOMFROMTEXT                   = 1040
	MySqlParserST_GEOMFROMWKB                    = 1041
	MySqlParserST_INTERIORRINGN                  = 1042
	MySqlParserST_INTERSECTION                   = 1043
	MySqlParserST_INTERSECTS                     = 1044
	MySqlParserST_ISCLOSED                       = 1045
	MySqlParserST_ISEMPTY                        = 1046
	MySqlParserST_ISSIMPLE                       = 1047
	MySqlParserST_LINEFROMTEXT                   = 1048
	MySqlParserST_LINEFROMWKB                    = 1049
	MySqlParserST_LINESTRINGFROMTEXT             = 1050
	MySqlParserST_LINESTRINGFROMWKB              = 1051
	MySqlParserST_NUMGEOMETRIES                  = 1052
	MySqlParserST_NUMINTERIORRING                = 1053
	MySqlParserST_NUMINTERIORRINGS               = 1054
	MySqlParserST_NUMPOINTS                      = 1055
	MySqlParserST_OVERLAPS                       = 1056
	MySqlParserST_POINTFROMTEXT                  = 1057
	MySqlParserST_POINTFROMWKB                   = 1058
	MySqlParserST_POINTN                         = 1059
	MySqlParserST_POLYFROMTEXT                   = 1060
	MySqlParserST_POLYFROMWKB                    = 1061
	MySqlParserST_POLYGONFROMTEXT                = 1062
	MySqlParserST_POLYGONFROMWKB                 = 1063
	MySqlParserST_SRID                           = 1064
	MySqlParserST_STARTPOINT                     = 1065
	MySqlParserST_SYMDIFFERENCE                  = 1066
	MySqlParserST_TOUCHES                        = 1067
	MySqlParserST_UNION                          = 1068
	MySqlParserST_WITHIN                         = 1069
	MySqlParserST_X                              = 1070
	MySqlParserST_Y                              = 1071
	MySqlParserSUBDATE                           = 1072
	MySqlParserSUBSTRING_INDEX                   = 1073
	MySqlParserSUBTIME                           = 1074
	MySqlParserSYSTEM_USER                       = 1075
	MySqlParserTAN                               = 1076
	MySqlParserTIMEDIFF                          = 1077
	MySqlParserTIMESTAMPADD                      = 1078
	MySqlParserTIMESTAMPDIFF                     = 1079
	MySqlParserTIME_FORMAT                       = 1080
	MySqlParserTIME_TO_SEC                       = 1081
	MySqlParserTOUCHES                           = 1082
	MySqlParserTO_BASE64                         = 1083
	MySqlParserTO_DAYS                           = 1084
	MySqlParserTO_SECONDS                        = 1085
	MySqlParserTP_CONNECTION_ADMIN               = 1086
	MySqlParserUCASE                             = 1087
	MySqlParserUNCOMPRESS                        = 1088
	MySqlParserUNCOMPRESSED_LENGTH               = 1089
	MySqlParserUNHEX                             = 1090
	MySqlParserUNIX_TIMESTAMP                    = 1091
	MySqlParserUPDATEXML                         = 1092
	MySqlParserUPPER                             = 1093
	MySqlParserUUID                              = 1094
	MySqlParserUUID_SHORT                        = 1095
	MySqlParserVALIDATE_PASSWORD_STRENGTH        = 1096
	MySqlParserVERSION                           = 1097
	MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS = 1098
	MySqlParserWEEKDAY                           = 1099
	MySqlParserWEEKOFYEAR                        = 1100
	MySqlParserWEIGHT_STRING                     = 1101
	MySqlParserWITHIN                            = 1102
	MySqlParserYEARWEEK                          = 1103
	MySqlParserY_FUNCTION                        = 1104
	MySqlParserX_FUNCTION                        = 1105
	MySqlParserVAR_ASSIGN                        = 1106
	MySqlParserPLUS_ASSIGN                       = 1107
	MySqlParserMINUS_ASSIGN                      = 1108
	MySqlParserMULT_ASSIGN                       = 1109
	MySqlParserDIV_ASSIGN                        = 1110
	MySqlParserMOD_ASSIGN                        = 1111
	MySqlParserAND_ASSIGN                        = 1112
	MySqlParserXOR_ASSIGN                        = 1113
	MySqlParserOR_ASSIGN                         = 1114
	MySqlParserSTAR                              = 1115
	MySqlParserDIVIDE                            = 1116
	MySqlParserMODULE                            = 1117
	MySqlParserPLUS                              = 1118
	MySqlParserMINUS                             = 1119
	MySqlParserDIV                               = 1120
	MySqlParserMOD                               = 1121
	MySqlParserEQUAL_SYMBOL                      = 1122
	MySqlParserGREATER_SYMBOL                    = 1123
	MySqlParserLESS_SYMBOL                       = 1124
	MySqlParserEXCLAMATION_SYMBOL                = 1125
	MySqlParserBIT_NOT_OP                        = 1126
	MySqlParserBIT_OR_OP                         = 1127
	MySqlParserBIT_AND_OP                        = 1128
	MySqlParserBIT_XOR_OP                        = 1129
	MySqlParserDOT                               = 1130
	MySqlParserLR_BRACKET                        = 1131
	MySqlParserRR_BRACKET                        = 1132
	MySqlParserCOMMA                             = 1133
	MySqlParserSEMI                              = 1134
	MySqlParserAT_SIGN                           = 1135
	MySqlParserZERO_DECIMAL                      = 1136
	MySqlParserONE_DECIMAL                       = 1137
	MySqlParserTWO_DECIMAL                       = 1138
	MySqlParserSINGLE_QUOTE_SYMB                 = 1139
	MySqlParserDOUBLE_QUOTE_SYMB                 = 1140
	MySqlParserREVERSE_QUOTE_SYMB                = 1141
	MySqlParserCOLON_SYMB                        = 1142
	MySqlParserCHARSET_REVERSE_QOUTE_STRING      = 1143
	MySqlParserFILESIZE_LITERAL                  = 1144
	MySqlParserSTART_NATIONAL_STRING_LITERAL     = 1145
	MySqlParserSTRING_LITERAL                    = 1146
	MySqlParserDECIMAL_LITERAL                   = 1147
	MySqlParserHEXADECIMAL_LITERAL               = 1148
	MySqlParserREAL_LITERAL                      = 1149
	MySqlParserNULL_SPEC_LITERAL                 = 1150
	MySqlParserBIT_STRING                        = 1151
	MySqlParserSTRING_CHARSET_NAME               = 1152
	MySqlParserDOT_ID                            = 1153
	MySqlParserID                                = 1154
	MySqlParserREVERSE_QUOTE_ID                  = 1155
	MySqlParserSTRING_USER_NAME                  = 1156
	MySqlParserIP_ADDRESS                        = 1157
	MySqlParserLOCAL_ID                          = 1158
	MySqlParserGLOBAL_ID                         = 1159
	MySqlParserBIND_PARAMETER                    = 1160
	MySqlParserERROR_RECONGNIGION                = 1161
)

// MySqlParser rules.
const (
	MySqlParserRULE_root                                = 0
	MySqlParserRULE_sqlStatements                       = 1
	MySqlParserRULE_sqlStatement                        = 2
	MySqlParserRULE_emptyStatement_                     = 3
	MySqlParserRULE_ddlStatement                        = 4
	MySqlParserRULE_dmlStatement                        = 5
	MySqlParserRULE_transactionStatement                = 6
	MySqlParserRULE_replicationStatement                = 7
	MySqlParserRULE_preparedStatement                   = 8
	MySqlParserRULE_compoundStatement                   = 9
	MySqlParserRULE_administrationStatement             = 10
	MySqlParserRULE_utilityStatement                    = 11
	MySqlParserRULE_createDatabase                      = 12
	MySqlParserRULE_createEvent                         = 13
	MySqlParserRULE_createIndex                         = 14
	MySqlParserRULE_createLogfileGroup                  = 15
	MySqlParserRULE_createProcedure                     = 16
	MySqlParserRULE_createFunction                      = 17
	MySqlParserRULE_createRole                          = 18
	MySqlParserRULE_createServer                        = 19
	MySqlParserRULE_createTable                         = 20
	MySqlParserRULE_createTablespaceInnodb              = 21
	MySqlParserRULE_createTablespaceNdb                 = 22
	MySqlParserRULE_createTrigger                       = 23
	MySqlParserRULE_withClause                          = 24
	MySqlParserRULE_commonTableExpressions              = 25
	MySqlParserRULE_cteName                             = 26
	MySqlParserRULE_cteColumnName                       = 27
	MySqlParserRULE_createView                          = 28
	MySqlParserRULE_createDatabaseOption                = 29
	MySqlParserRULE_charSet                             = 30
	MySqlParserRULE_ownerStatement                      = 31
	MySqlParserRULE_scheduleExpression                  = 32
	MySqlParserRULE_timestampValue                      = 33
	MySqlParserRULE_intervalExpr                        = 34
	MySqlParserRULE_intervalType                        = 35
	MySqlParserRULE_enableType                          = 36
	MySqlParserRULE_indexType                           = 37
	MySqlParserRULE_indexOption                         = 38
	MySqlParserRULE_procedureParameter                  = 39
	MySqlParserRULE_functionParameter                   = 40
	MySqlParserRULE_routineOption                       = 41
	MySqlParserRULE_serverOption                        = 42
	MySqlParserRULE_createDefinitions                   = 43
	MySqlParserRULE_createDefinition                    = 44
	MySqlParserRULE_columnDefinition                    = 45
	MySqlParserRULE_columnConstraint                    = 46
	MySqlParserRULE_tableConstraint                     = 47
	MySqlParserRULE_referenceDefinition                 = 48
	MySqlParserRULE_referenceAction                     = 49
	MySqlParserRULE_referenceControlType                = 50
	MySqlParserRULE_indexColumnDefinition               = 51
	MySqlParserRULE_tableOption                         = 52
	MySqlParserRULE_tableType                           = 53
	MySqlParserRULE_tablespaceStorage                   = 54
	MySqlParserRULE_partitionDefinitions                = 55
	MySqlParserRULE_partitionFunctionDefinition         = 56
	MySqlParserRULE_subpartitionFunctionDefinition      = 57
	MySqlParserRULE_partitionDefinition                 = 58
	MySqlParserRULE_partitionDefinerAtom                = 59
	MySqlParserRULE_partitionDefinerVector              = 60
	MySqlParserRULE_subpartitionDefinition              = 61
	MySqlParserRULE_partitionOption                     = 62
	MySqlParserRULE_alterDatabase                       = 63
	MySqlParserRULE_alterEvent                          = 64
	MySqlParserRULE_alterFunction                       = 65
	MySqlParserRULE_alterInstance                       = 66
	MySqlParserRULE_alterLogfileGroup                   = 67
	MySqlParserRULE_alterProcedure                      = 68
	MySqlParserRULE_alterServer                         = 69
	MySqlParserRULE_alterTable                          = 70
	MySqlParserRULE_alterTablespace                     = 71
	MySqlParserRULE_alterView                           = 72
	MySqlParserRULE_alterSpecification                  = 73
	MySqlParserRULE_dropDatabase                        = 74
	MySqlParserRULE_dropEvent                           = 75
	MySqlParserRULE_dropIndex                           = 76
	MySqlParserRULE_dropLogfileGroup                    = 77
	MySqlParserRULE_dropProcedure                       = 78
	MySqlParserRULE_dropFunction                        = 79
	MySqlParserRULE_dropServer                          = 80
	MySqlParserRULE_dropTable                           = 81
	MySqlParserRULE_dropTablespace                      = 82
	MySqlParserRULE_dropTrigger                         = 83
	MySqlParserRULE_dropView                            = 84
	MySqlParserRULE_dropRole                            = 85
	MySqlParserRULE_setRole                             = 86
	MySqlParserRULE_renameTable                         = 87
	MySqlParserRULE_renameTableClause                   = 88
	MySqlParserRULE_truncateTable                       = 89
	MySqlParserRULE_callStatement                       = 90
	MySqlParserRULE_deleteStatement                     = 91
	MySqlParserRULE_doStatement                         = 92
	MySqlParserRULE_handlerStatement                    = 93
	MySqlParserRULE_insertStatement                     = 94
	MySqlParserRULE_loadDataStatement                   = 95
	MySqlParserRULE_loadXmlStatement                    = 96
	MySqlParserRULE_replaceStatement                    = 97
	MySqlParserRULE_selectStatement                     = 98
	MySqlParserRULE_updateStatement                     = 99
	MySqlParserRULE_valuesStatement                     = 100
	MySqlParserRULE_insertStatementValue                = 101
	MySqlParserRULE_updatedElement                      = 102
	MySqlParserRULE_assignmentField                     = 103
	MySqlParserRULE_lockClause                          = 104
	MySqlParserRULE_singleDeleteStatement               = 105
	MySqlParserRULE_multipleDeleteStatement             = 106
	MySqlParserRULE_handlerOpenStatement                = 107
	MySqlParserRULE_handlerReadIndexStatement           = 108
	MySqlParserRULE_handlerReadStatement                = 109
	MySqlParserRULE_handlerCloseStatement               = 110
	MySqlParserRULE_singleUpdateStatement               = 111
	MySqlParserRULE_multipleUpdateStatement             = 112
	MySqlParserRULE_orderByClause                       = 113
	MySqlParserRULE_orderByExpression                   = 114
	MySqlParserRULE_tableSources                        = 115
	MySqlParserRULE_tableSource                         = 116
	MySqlParserRULE_tableSourceItem                     = 117
	MySqlParserRULE_indexHint                           = 118
	MySqlParserRULE_indexHintType                       = 119
	MySqlParserRULE_joinPart                            = 120
	MySqlParserRULE_queryExpression                     = 121
	MySqlParserRULE_queryExpressionNointo               = 122
	MySqlParserRULE_querySpecification                  = 123
	MySqlParserRULE_querySpecificationNointo            = 124
	MySqlParserRULE_unionParenthesis                    = 125
	MySqlParserRULE_unionStatement                      = 126
	MySqlParserRULE_lateralStatement                    = 127
	MySqlParserRULE_jsonTable                           = 128
	MySqlParserRULE_jsonColumnList                      = 129
	MySqlParserRULE_jsonColumn                          = 130
	MySqlParserRULE_jsonOnEmpty                         = 131
	MySqlParserRULE_jsonOnError                         = 132
	MySqlParserRULE_selectSpec                          = 133
	MySqlParserRULE_selectElements                      = 134
	MySqlParserRULE_selectElement                       = 135
	MySqlParserRULE_selectIntoExpression                = 136
	MySqlParserRULE_selectFieldsInto                    = 137
	MySqlParserRULE_selectLinesInto                     = 138
	MySqlParserRULE_fromClause                          = 139
	MySqlParserRULE_groupByClause                       = 140
	MySqlParserRULE_havingClause                        = 141
	MySqlParserRULE_windowClause                        = 142
	MySqlParserRULE_groupByItem                         = 143
	MySqlParserRULE_limitClause                         = 144
	MySqlParserRULE_limitClauseAtom                     = 145
	MySqlParserRULE_startTransaction                    = 146
	MySqlParserRULE_beginWork                           = 147
	MySqlParserRULE_commitWork                          = 148
	MySqlParserRULE_rollbackWork                        = 149
	MySqlParserRULE_savepointStatement                  = 150
	MySqlParserRULE_rollbackStatement                   = 151
	MySqlParserRULE_releaseStatement                    = 152
	MySqlParserRULE_lockTables                          = 153
	MySqlParserRULE_unlockTables                        = 154
	MySqlParserRULE_setAutocommitStatement              = 155
	MySqlParserRULE_setTransactionStatement             = 156
	MySqlParserRULE_transactionMode                     = 157
	MySqlParserRULE_lockTableElement                    = 158
	MySqlParserRULE_lockAction                          = 159
	MySqlParserRULE_transactionOption                   = 160
	MySqlParserRULE_transactionLevel                    = 161
	MySqlParserRULE_changeMaster                        = 162
	MySqlParserRULE_changeReplicationFilter             = 163
	MySqlParserRULE_purgeBinaryLogs                     = 164
	MySqlParserRULE_resetMaster                         = 165
	MySqlParserRULE_resetSlave                          = 166
	MySqlParserRULE_startSlave                          = 167
	MySqlParserRULE_stopSlave                           = 168
	MySqlParserRULE_startGroupReplication               = 169
	MySqlParserRULE_stopGroupReplication                = 170
	MySqlParserRULE_masterOption                        = 171
	MySqlParserRULE_stringMasterOption                  = 172
	MySqlParserRULE_decimalMasterOption                 = 173
	MySqlParserRULE_boolMasterOption                    = 174
	MySqlParserRULE_channelOption                       = 175
	MySqlParserRULE_replicationFilter                   = 176
	MySqlParserRULE_tablePair                           = 177
	MySqlParserRULE_threadType                          = 178
	MySqlParserRULE_untilOption                         = 179
	MySqlParserRULE_connectionOption                    = 180
	MySqlParserRULE_gtuidSet                            = 181
	MySqlParserRULE_xaStartTransaction                  = 182
	MySqlParserRULE_xaEndTransaction                    = 183
	MySqlParserRULE_xaPrepareStatement                  = 184
	MySqlParserRULE_xaCommitWork                        = 185
	MySqlParserRULE_xaRollbackWork                      = 186
	MySqlParserRULE_xaRecoverWork                       = 187
	MySqlParserRULE_prepareStatement                    = 188
	MySqlParserRULE_executeStatement                    = 189
	MySqlParserRULE_deallocatePrepare                   = 190
	MySqlParserRULE_routineBody                         = 191
	MySqlParserRULE_blockStatement                      = 192
	MySqlParserRULE_caseStatement                       = 193
	MySqlParserRULE_ifStatement                         = 194
	MySqlParserRULE_iterateStatement                    = 195
	MySqlParserRULE_leaveStatement                      = 196
	MySqlParserRULE_loopStatement                       = 197
	MySqlParserRULE_repeatStatement                     = 198
	MySqlParserRULE_returnStatement                     = 199
	MySqlParserRULE_whileStatement                      = 200
	MySqlParserRULE_cursorStatement                     = 201
	MySqlParserRULE_declareVariable                     = 202
	MySqlParserRULE_declareCondition                    = 203
	MySqlParserRULE_declareCursor                       = 204
	MySqlParserRULE_declareHandler                      = 205
	MySqlParserRULE_handlerConditionValue               = 206
	MySqlParserRULE_procedureSqlStatement               = 207
	MySqlParserRULE_caseAlternative                     = 208
	MySqlParserRULE_elifAlternative                     = 209
	MySqlParserRULE_alterUser                           = 210
	MySqlParserRULE_createUser                          = 211
	MySqlParserRULE_dropUser                            = 212
	MySqlParserRULE_grantStatement                      = 213
	MySqlParserRULE_roleOption                          = 214
	MySqlParserRULE_grantProxy                          = 215
	MySqlParserRULE_renameUser                          = 216
	MySqlParserRULE_revokeStatement                     = 217
	MySqlParserRULE_revokeProxy                         = 218
	MySqlParserRULE_setPasswordStatement                = 219
	MySqlParserRULE_userSpecification                   = 220
	MySqlParserRULE_userAuthOption                      = 221
	MySqlParserRULE_authenticationRule                  = 222
	MySqlParserRULE_tlsOption                           = 223
	MySqlParserRULE_userResourceOption                  = 224
	MySqlParserRULE_userPasswordOption                  = 225
	MySqlParserRULE_userLockOption                      = 226
	MySqlParserRULE_privelegeClause                     = 227
	MySqlParserRULE_privilege                           = 228
	MySqlParserRULE_privilegeLevel                      = 229
	MySqlParserRULE_renameUserClause                    = 230
	MySqlParserRULE_analyzeTable                        = 231
	MySqlParserRULE_checkTable                          = 232
	MySqlParserRULE_checksumTable                       = 233
	MySqlParserRULE_optimizeTable                       = 234
	MySqlParserRULE_repairTable                         = 235
	MySqlParserRULE_checkTableOption                    = 236
	MySqlParserRULE_createUdfunction                    = 237
	MySqlParserRULE_installPlugin                       = 238
	MySqlParserRULE_uninstallPlugin                     = 239
	MySqlParserRULE_setStatement                        = 240
	MySqlParserRULE_showStatement                       = 241
	MySqlParserRULE_variableClause                      = 242
	MySqlParserRULE_showCommonEntity                    = 243
	MySqlParserRULE_showFilter                          = 244
	MySqlParserRULE_showGlobalInfoClause                = 245
	MySqlParserRULE_showSchemaEntity                    = 246
	MySqlParserRULE_showProfileType                     = 247
	MySqlParserRULE_binlogStatement                     = 248
	MySqlParserRULE_cacheIndexStatement                 = 249
	MySqlParserRULE_flushStatement                      = 250
	MySqlParserRULE_killStatement                       = 251
	MySqlParserRULE_loadIndexIntoCache                  = 252
	MySqlParserRULE_resetStatement                      = 253
	MySqlParserRULE_shutdownStatement                   = 254
	MySqlParserRULE_tableIndexes                        = 255
	MySqlParserRULE_flushOption                         = 256
	MySqlParserRULE_flushTableOption                    = 257
	MySqlParserRULE_loadedTableIndexes                  = 258
	MySqlParserRULE_simpleDescribeStatement             = 259
	MySqlParserRULE_fullDescribeStatement               = 260
	MySqlParserRULE_helpStatement                       = 261
	MySqlParserRULE_useStatement                        = 262
	MySqlParserRULE_signalStatement                     = 263
	MySqlParserRULE_resignalStatement                   = 264
	MySqlParserRULE_signalConditionInformation          = 265
	MySqlParserRULE_withStatement                       = 266
	MySqlParserRULE_diagnosticsStatement                = 267
	MySqlParserRULE_diagnosticsConditionInformationName = 268
	MySqlParserRULE_describeObjectClause                = 269
	MySqlParserRULE_fullId                              = 270
	MySqlParserRULE_tableName                           = 271
	MySqlParserRULE_roleName                            = 272
	MySqlParserRULE_fullColumnName                      = 273
	MySqlParserRULE_indexColumnName                     = 274
	MySqlParserRULE_userName                            = 275
	MySqlParserRULE_mysqlVariable                       = 276
	MySqlParserRULE_charsetName                         = 277
	MySqlParserRULE_collationName                       = 278
	MySqlParserRULE_engineName                          = 279
	MySqlParserRULE_uuidSet                             = 280
	MySqlParserRULE_xid                                 = 281
	MySqlParserRULE_xuidStringId                        = 282
	MySqlParserRULE_authPlugin                          = 283
	MySqlParserRULE_uid                                 = 284
	MySqlParserRULE_simpleId                            = 285
	MySqlParserRULE_dottedId                            = 286
	MySqlParserRULE_decimalLiteral                      = 287
	MySqlParserRULE_fileSizeLiteral                     = 288
	MySqlParserRULE_stringLiteral                       = 289
	MySqlParserRULE_booleanLiteral                      = 290
	MySqlParserRULE_hexadecimalLiteral                  = 291
	MySqlParserRULE_nullNotnull                         = 292
	MySqlParserRULE_constant                            = 293
	MySqlParserRULE_dataType                            = 294
	MySqlParserRULE_collectionOptions                   = 295
	MySqlParserRULE_convertedDataType                   = 296
	MySqlParserRULE_lengthOneDimension                  = 297
	MySqlParserRULE_lengthTwoDimension                  = 298
	MySqlParserRULE_lengthTwoOptionalDimension          = 299
	MySqlParserRULE_uidList                             = 300
	MySqlParserRULE_fullColumnNameList                  = 301
	MySqlParserRULE_tables                              = 302
	MySqlParserRULE_indexColumnNames                    = 303
	MySqlParserRULE_expressions                         = 304
	MySqlParserRULE_expressionsWithDefaults             = 305
	MySqlParserRULE_constants                           = 306
	MySqlParserRULE_simpleStrings                       = 307
	MySqlParserRULE_userVariables                       = 308
	MySqlParserRULE_defaultValue                        = 309
	MySqlParserRULE_currentTimestamp                    = 310
	MySqlParserRULE_expressionOrDefault                 = 311
	MySqlParserRULE_ifExists                            = 312
	MySqlParserRULE_ifNotExists                         = 313
	MySqlParserRULE_orReplace                           = 314
	MySqlParserRULE_waitNowaitClause                    = 315
	MySqlParserRULE_functionCall                        = 316
	MySqlParserRULE_specificFunction                    = 317
	MySqlParserRULE_caseFuncAlternative                 = 318
	MySqlParserRULE_levelsInWeightString                = 319
	MySqlParserRULE_levelInWeightListElement            = 320
	MySqlParserRULE_aggregateWindowedFunction           = 321
	MySqlParserRULE_nonAggregateWindowedFunction        = 322
	MySqlParserRULE_overClause                          = 323
	MySqlParserRULE_windowSpec                          = 324
	MySqlParserRULE_windowName                          = 325
	MySqlParserRULE_frameClause                         = 326
	MySqlParserRULE_frameUnits                          = 327
	MySqlParserRULE_frameExtent                         = 328
	MySqlParserRULE_frameBetween                        = 329
	MySqlParserRULE_frameRange                          = 330
	MySqlParserRULE_partitionClause                     = 331
	MySqlParserRULE_scalarFunctionName                  = 332
	MySqlParserRULE_passwordFunctionClause              = 333
	MySqlParserRULE_functionArgs                        = 334
	MySqlParserRULE_functionArg                         = 335
	MySqlParserRULE_expression                          = 336
	MySqlParserRULE_predicate                           = 337
	MySqlParserRULE_expressionAtom                      = 338
	MySqlParserRULE_unaryOperator                       = 339
	MySqlParserRULE_comparisonOperator                  = 340
	MySqlParserRULE_logicalOperator                     = 341
	MySqlParserRULE_bitOperator                         = 342
	MySqlParserRULE_mathOperator                        = 343
	MySqlParserRULE_jsonOperator                        = 344
	MySqlParserRULE_charsetNameBase                     = 345
	MySqlParserRULE_transactionLevelBase                = 346
	MySqlParserRULE_privilegesBase                      = 347
	MySqlParserRULE_intervalTypeBase                    = 348
	MySqlParserRULE_dataTypeBase                        = 349
	MySqlParserRULE_keywordsCanBeId                     = 350
	MySqlParserRULE_functionNameBase                    = 351
)

// IRootContext is an interface to support dynamic dispatch.
type IRootContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	SqlStatements() ISqlStatementsContext
	AllMINUS() []antlr.TerminalNode
	MINUS(i int) antlr.TerminalNode

	// IsRootContext differentiates from other interfaces.
	IsRootContext()
}

type RootContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRootContext() *RootContext {
	var p = new(RootContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_root
	return p
}

func (*RootContext) IsRootContext() {}

func NewRootContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RootContext {
	var p = new(RootContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_root

	return p
}

func (s *RootContext) GetParser() antlr.Parser { return s.parser }

func (s *RootContext) EOF() antlr.TerminalNode {
	return s.GetToken(MySqlParserEOF, 0)
}

func (s *RootContext) SqlStatements() ISqlStatementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlStatementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlStatementsContext)
}

func (s *RootContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserMINUS)
}

func (s *RootContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUS, i)
}

func (s *RootContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RootContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RootContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRoot(s)
	}
}

func (s *RootContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRoot(s)
	}
}

func (p *MySqlParser) Root() (localctx IRootContext) {
	this := p
	_ = this

	localctx = NewRootContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, MySqlParserRULE_root)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(705)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4614060972218253952) != 0) || ((int64((_la-71)) & ^0x3f) == 0 && ((int64(1)<<(_la-71))&2306124490637066243) != 0) || ((int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&19509734323700267) != 0) || ((int64((_la-344)) & ^0x3f) == 0 && ((int64(1)<<(_la-344))&36099165796700291) != 0) || ((int64((_la-432)) & ^0x3f) == 0 && ((int64(1)<<(_la-432))&16782337) != 0) || ((int64((_la-560)) & ^0x3f) == 0 && ((int64(1)<<(_la-560))&17730162917377) != 0) || ((int64((_la-629)) & ^0x3f) == 0 && ((int64(1)<<(_la-629))&4503604056555585) != 0) || _la == MySqlParserEXECUTE || _la == MySqlParserSHUTDOWN || _la == MySqlParserLR_BRACKET || _la == MySqlParserSEMI {
		{
			p.SetState(704)
			p.SqlStatements()
		}

	}
	p.SetState(709)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserMINUS {
		{
			p.SetState(707)
			p.Match(MySqlParserMINUS)
		}
		{
			p.SetState(708)
			p.Match(MySqlParserMINUS)
		}

	}
	{
		p.SetState(711)
		p.Match(MySqlParserEOF)
	}

	return localctx
}

// ISqlStatementsContext is an interface to support dynamic dispatch.
type ISqlStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSqlStatement() []ISqlStatementContext
	SqlStatement(i int) ISqlStatementContext
	AllEmptyStatement_() []IEmptyStatement_Context
	EmptyStatement_(i int) IEmptyStatement_Context
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	AllMINUS() []antlr.TerminalNode
	MINUS(i int) antlr.TerminalNode

	// IsSqlStatementsContext differentiates from other interfaces.
	IsSqlStatementsContext()
}

type SqlStatementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySqlStatementsContext() *SqlStatementsContext {
	var p = new(SqlStatementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_sqlStatements
	return p
}

func (*SqlStatementsContext) IsSqlStatementsContext() {}

func NewSqlStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SqlStatementsContext {
	var p = new(SqlStatementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_sqlStatements

	return p
}

func (s *SqlStatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *SqlStatementsContext) AllSqlStatement() []ISqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISqlStatementContext); ok {
			len++
		}
	}

	tst := make([]ISqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISqlStatementContext); ok {
			tst[i] = t.(ISqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *SqlStatementsContext) SqlStatement(i int) ISqlStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlStatementContext)
}

func (s *SqlStatementsContext) AllEmptyStatement_() []IEmptyStatement_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEmptyStatement_Context); ok {
			len++
		}
	}

	tst := make([]IEmptyStatement_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEmptyStatement_Context); ok {
			tst[i] = t.(IEmptyStatement_Context)
			i++
		}
	}

	return tst
}

func (s *SqlStatementsContext) EmptyStatement_(i int) IEmptyStatement_Context {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyStatement_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyStatement_Context)
}

func (s *SqlStatementsContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSEMI)
}

func (s *SqlStatementsContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSEMI, i)
}

func (s *SqlStatementsContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserMINUS)
}

func (s *SqlStatementsContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUS, i)
}

func (s *SqlStatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqlStatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SqlStatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSqlStatements(s)
	}
}

func (s *SqlStatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSqlStatements(s)
	}
}

func (p *MySqlParser) SqlStatements() (localctx ISqlStatementsContext) {
	this := p
	_ = this

	localctx = NewSqlStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, MySqlParserRULE_sqlStatements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(724)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(722)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case MySqlParserALTER, MySqlParserANALYZE, MySqlParserCALL, MySqlParserCHANGE, MySqlParserCHECK, MySqlParserCREATE, MySqlParserDELETE, MySqlParserDESC, MySqlParserDESCRIBE, MySqlParserDROP, MySqlParserEXPLAIN, MySqlParserGET, MySqlParserGRANT, MySqlParserINSERT, MySqlParserKILL, MySqlParserLOAD, MySqlParserLOCK, MySqlParserOPTIMIZE, MySqlParserPURGE, MySqlParserRELEASE, MySqlParserRENAME, MySqlParserREPLACE, MySqlParserRESIGNAL, MySqlParserREVOKE, MySqlParserSELECT, MySqlParserSET, MySqlParserSHOW, MySqlParserSIGNAL, MySqlParserUNLOCK, MySqlParserUPDATE, MySqlParserUSE, MySqlParserVALUES, MySqlParserWITH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserCACHE, MySqlParserCHECKSUM, MySqlParserCOMMIT, MySqlParserDEALLOCATE, MySqlParserDO, MySqlParserFLUSH, MySqlParserHANDLER, MySqlParserHELP, MySqlParserINSTALL, MySqlParserPREPARE, MySqlParserREPAIR, MySqlParserRESET, MySqlParserROLLBACK, MySqlParserSAVEPOINT, MySqlParserSTART, MySqlParserSTOP, MySqlParserTRUNCATE, MySqlParserUNINSTALL, MySqlParserXA, MySqlParserEXECUTE, MySqlParserSHUTDOWN, MySqlParserLR_BRACKET:
				{
					p.SetState(713)
					p.SqlStatement()
				}
				p.SetState(716)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == MySqlParserMINUS {
					{
						p.SetState(714)
						p.Match(MySqlParserMINUS)
					}
					{
						p.SetState(715)
						p.Match(MySqlParserMINUS)
					}

				}
				p.SetState(719)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(718)
						p.Match(MySqlParserSEMI)
					}

				}

			case MySqlParserSEMI:
				{
					p.SetState(721)
					p.EmptyStatement_()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(726)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext())
	}
	p.SetState(736)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserALTER, MySqlParserANALYZE, MySqlParserCALL, MySqlParserCHANGE, MySqlParserCHECK, MySqlParserCREATE, MySqlParserDELETE, MySqlParserDESC, MySqlParserDESCRIBE, MySqlParserDROP, MySqlParserEXPLAIN, MySqlParserGET, MySqlParserGRANT, MySqlParserINSERT, MySqlParserKILL, MySqlParserLOAD, MySqlParserLOCK, MySqlParserOPTIMIZE, MySqlParserPURGE, MySqlParserRELEASE, MySqlParserRENAME, MySqlParserREPLACE, MySqlParserRESIGNAL, MySqlParserREVOKE, MySqlParserSELECT, MySqlParserSET, MySqlParserSHOW, MySqlParserSIGNAL, MySqlParserUNLOCK, MySqlParserUPDATE, MySqlParserUSE, MySqlParserVALUES, MySqlParserWITH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserCACHE, MySqlParserCHECKSUM, MySqlParserCOMMIT, MySqlParserDEALLOCATE, MySqlParserDO, MySqlParserFLUSH, MySqlParserHANDLER, MySqlParserHELP, MySqlParserINSTALL, MySqlParserPREPARE, MySqlParserREPAIR, MySqlParserRESET, MySqlParserROLLBACK, MySqlParserSAVEPOINT, MySqlParserSTART, MySqlParserSTOP, MySqlParserTRUNCATE, MySqlParserUNINSTALL, MySqlParserXA, MySqlParserEXECUTE, MySqlParserSHUTDOWN, MySqlParserLR_BRACKET:
		{
			p.SetState(727)
			p.SqlStatement()
		}
		p.SetState(733)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext()) == 1 {
			p.SetState(730)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserMINUS {
				{
					p.SetState(728)
					p.Match(MySqlParserMINUS)
				}
				{
					p.SetState(729)
					p.Match(MySqlParserMINUS)
				}

			}
			{
				p.SetState(732)
				p.Match(MySqlParserSEMI)
			}

		}

	case MySqlParserSEMI:
		{
			p.SetState(735)
			p.EmptyStatement_()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISqlStatementContext is an interface to support dynamic dispatch.
type ISqlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DdlStatement() IDdlStatementContext
	DmlStatement() IDmlStatementContext
	TransactionStatement() ITransactionStatementContext
	ReplicationStatement() IReplicationStatementContext
	PreparedStatement() IPreparedStatementContext
	AdministrationStatement() IAdministrationStatementContext
	UtilityStatement() IUtilityStatementContext

	// IsSqlStatementContext differentiates from other interfaces.
	IsSqlStatementContext()
}

type SqlStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySqlStatementContext() *SqlStatementContext {
	var p = new(SqlStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_sqlStatement
	return p
}

func (*SqlStatementContext) IsSqlStatementContext() {}

func NewSqlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SqlStatementContext {
	var p = new(SqlStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_sqlStatement

	return p
}

func (s *SqlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SqlStatementContext) DdlStatement() IDdlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDdlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDdlStatementContext)
}

func (s *SqlStatementContext) DmlStatement() IDmlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDmlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDmlStatementContext)
}

func (s *SqlStatementContext) TransactionStatement() ITransactionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionStatementContext)
}

func (s *SqlStatementContext) ReplicationStatement() IReplicationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplicationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplicationStatementContext)
}

func (s *SqlStatementContext) PreparedStatement() IPreparedStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreparedStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreparedStatementContext)
}

func (s *SqlStatementContext) AdministrationStatement() IAdministrationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdministrationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdministrationStatementContext)
}

func (s *SqlStatementContext) UtilityStatement() IUtilityStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUtilityStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUtilityStatementContext)
}

func (s *SqlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SqlStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSqlStatement(s)
	}
}

func (s *SqlStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSqlStatement(s)
	}
}

func (p *MySqlParser) SqlStatement() (localctx ISqlStatementContext) {
	this := p
	_ = this

	localctx = NewSqlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, MySqlParserRULE_sqlStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(745)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(738)
			p.DdlStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(739)
			p.DmlStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(740)
			p.TransactionStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(741)
			p.ReplicationStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(742)
			p.PreparedStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(743)
			p.AdministrationStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(744)
			p.UtilityStatement()
		}

	}

	return localctx
}

// IEmptyStatement_Context is an interface to support dynamic dispatch.
type IEmptyStatement_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEMI() antlr.TerminalNode

	// IsEmptyStatement_Context differentiates from other interfaces.
	IsEmptyStatement_Context()
}

type EmptyStatement_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmptyStatement_Context() *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_emptyStatement_
	return p
}

func (*EmptyStatement_Context) IsEmptyStatement_Context() {}

func NewEmptyStatement_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmptyStatement_Context {
	var p = new(EmptyStatement_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_emptyStatement_

	return p
}

func (s *EmptyStatement_Context) GetParser() antlr.Parser { return s.parser }

func (s *EmptyStatement_Context) SEMI() antlr.TerminalNode {
	return s.GetToken(MySqlParserSEMI, 0)
}

func (s *EmptyStatement_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyStatement_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmptyStatement_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterEmptyStatement_(s)
	}
}

func (s *EmptyStatement_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitEmptyStatement_(s)
	}
}

func (p *MySqlParser) EmptyStatement_() (localctx IEmptyStatement_Context) {
	this := p
	_ = this

	localctx = NewEmptyStatement_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, MySqlParserRULE_emptyStatement_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(747)
		p.Match(MySqlParserSEMI)
	}

	return localctx
}

// IDdlStatementContext is an interface to support dynamic dispatch.
type IDdlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CreateDatabase() ICreateDatabaseContext
	CreateEvent() ICreateEventContext
	CreateIndex() ICreateIndexContext
	CreateLogfileGroup() ICreateLogfileGroupContext
	CreateProcedure() ICreateProcedureContext
	CreateFunction() ICreateFunctionContext
	CreateServer() ICreateServerContext
	CreateTable() ICreateTableContext
	CreateTablespaceInnodb() ICreateTablespaceInnodbContext
	CreateTablespaceNdb() ICreateTablespaceNdbContext
	CreateTrigger() ICreateTriggerContext
	CreateView() ICreateViewContext
	CreateRole() ICreateRoleContext
	AlterDatabase() IAlterDatabaseContext
	AlterEvent() IAlterEventContext
	AlterFunction() IAlterFunctionContext
	AlterInstance() IAlterInstanceContext
	AlterLogfileGroup() IAlterLogfileGroupContext
	AlterProcedure() IAlterProcedureContext
	AlterServer() IAlterServerContext
	AlterTable() IAlterTableContext
	AlterTablespace() IAlterTablespaceContext
	AlterView() IAlterViewContext
	DropDatabase() IDropDatabaseContext
	DropEvent() IDropEventContext
	DropIndex() IDropIndexContext
	DropLogfileGroup() IDropLogfileGroupContext
	DropProcedure() IDropProcedureContext
	DropFunction() IDropFunctionContext
	DropServer() IDropServerContext
	DropTable() IDropTableContext
	DropTablespace() IDropTablespaceContext
	DropTrigger() IDropTriggerContext
	DropView() IDropViewContext
	DropRole() IDropRoleContext
	SetRole() ISetRoleContext
	RenameTable() IRenameTableContext
	TruncateTable() ITruncateTableContext

	// IsDdlStatementContext differentiates from other interfaces.
	IsDdlStatementContext()
}

type DdlStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDdlStatementContext() *DdlStatementContext {
	var p = new(DdlStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_ddlStatement
	return p
}

func (*DdlStatementContext) IsDdlStatementContext() {}

func NewDdlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DdlStatementContext {
	var p = new(DdlStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_ddlStatement

	return p
}

func (s *DdlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DdlStatementContext) CreateDatabase() ICreateDatabaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDatabaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDatabaseContext)
}

func (s *DdlStatementContext) CreateEvent() ICreateEventContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateEventContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateEventContext)
}

func (s *DdlStatementContext) CreateIndex() ICreateIndexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateIndexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateIndexContext)
}

func (s *DdlStatementContext) CreateLogfileGroup() ICreateLogfileGroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateLogfileGroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateLogfileGroupContext)
}

func (s *DdlStatementContext) CreateProcedure() ICreateProcedureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateProcedureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateProcedureContext)
}

func (s *DdlStatementContext) CreateFunction() ICreateFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateFunctionContext)
}

func (s *DdlStatementContext) CreateServer() ICreateServerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateServerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateServerContext)
}

func (s *DdlStatementContext) CreateTable() ICreateTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableContext)
}

func (s *DdlStatementContext) CreateTablespaceInnodb() ICreateTablespaceInnodbContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTablespaceInnodbContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTablespaceInnodbContext)
}

func (s *DdlStatementContext) CreateTablespaceNdb() ICreateTablespaceNdbContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTablespaceNdbContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTablespaceNdbContext)
}

func (s *DdlStatementContext) CreateTrigger() ICreateTriggerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTriggerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTriggerContext)
}

func (s *DdlStatementContext) CreateView() ICreateViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateViewContext)
}

func (s *DdlStatementContext) CreateRole() ICreateRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateRoleContext)
}

func (s *DdlStatementContext) AlterDatabase() IAlterDatabaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterDatabaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterDatabaseContext)
}

func (s *DdlStatementContext) AlterEvent() IAlterEventContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterEventContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterEventContext)
}

func (s *DdlStatementContext) AlterFunction() IAlterFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterFunctionContext)
}

func (s *DdlStatementContext) AlterInstance() IAlterInstanceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterInstanceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterInstanceContext)
}

func (s *DdlStatementContext) AlterLogfileGroup() IAlterLogfileGroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterLogfileGroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterLogfileGroupContext)
}

func (s *DdlStatementContext) AlterProcedure() IAlterProcedureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterProcedureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterProcedureContext)
}

func (s *DdlStatementContext) AlterServer() IAlterServerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterServerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterServerContext)
}

func (s *DdlStatementContext) AlterTable() IAlterTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTableContext)
}

func (s *DdlStatementContext) AlterTablespace() IAlterTablespaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTablespaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTablespaceContext)
}

func (s *DdlStatementContext) AlterView() IAlterViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterViewContext)
}

func (s *DdlStatementContext) DropDatabase() IDropDatabaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropDatabaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropDatabaseContext)
}

func (s *DdlStatementContext) DropEvent() IDropEventContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropEventContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropEventContext)
}

func (s *DdlStatementContext) DropIndex() IDropIndexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropIndexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropIndexContext)
}

func (s *DdlStatementContext) DropLogfileGroup() IDropLogfileGroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropLogfileGroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropLogfileGroupContext)
}

func (s *DdlStatementContext) DropProcedure() IDropProcedureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropProcedureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropProcedureContext)
}

func (s *DdlStatementContext) DropFunction() IDropFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropFunctionContext)
}

func (s *DdlStatementContext) DropServer() IDropServerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropServerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropServerContext)
}

func (s *DdlStatementContext) DropTable() IDropTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTableContext)
}

func (s *DdlStatementContext) DropTablespace() IDropTablespaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTablespaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTablespaceContext)
}

func (s *DdlStatementContext) DropTrigger() IDropTriggerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTriggerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTriggerContext)
}

func (s *DdlStatementContext) DropView() IDropViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropViewContext)
}

func (s *DdlStatementContext) DropRole() IDropRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropRoleContext)
}

func (s *DdlStatementContext) SetRole() ISetRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetRoleContext)
}

func (s *DdlStatementContext) RenameTable() IRenameTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRenameTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRenameTableContext)
}

func (s *DdlStatementContext) TruncateTable() ITruncateTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITruncateTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITruncateTableContext)
}

func (s *DdlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DdlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DdlStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDdlStatement(s)
	}
}

func (s *DdlStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDdlStatement(s)
	}
}

func (p *MySqlParser) DdlStatement() (localctx IDdlStatementContext) {
	this := p
	_ = this

	localctx = NewDdlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, MySqlParserRULE_ddlStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(787)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 10, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(749)
			p.CreateDatabase()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(750)
			p.CreateEvent()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(751)
			p.CreateIndex()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(752)
			p.CreateLogfileGroup()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(753)
			p.CreateProcedure()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(754)
			p.CreateFunction()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(755)
			p.CreateServer()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(756)
			p.CreateTable()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(757)
			p.CreateTablespaceInnodb()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(758)
			p.CreateTablespaceNdb()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(759)
			p.CreateTrigger()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(760)
			p.CreateView()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(761)
			p.CreateRole()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(762)
			p.AlterDatabase()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(763)
			p.AlterEvent()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(764)
			p.AlterFunction()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(765)
			p.AlterInstance()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(766)
			p.AlterLogfileGroup()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(767)
			p.AlterProcedure()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(768)
			p.AlterServer()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(769)
			p.AlterTable()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(770)
			p.AlterTablespace()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(771)
			p.AlterView()
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(772)
			p.DropDatabase()
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(773)
			p.DropEvent()
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(774)
			p.DropIndex()
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(775)
			p.DropLogfileGroup()
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(776)
			p.DropProcedure()
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(777)
			p.DropFunction()
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(778)
			p.DropServer()
		}

	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(779)
			p.DropTable()
		}

	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(780)
			p.DropTablespace()
		}

	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(781)
			p.DropTrigger()
		}

	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(782)
			p.DropView()
		}

	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(783)
			p.DropRole()
		}

	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(784)
			p.SetRole()
		}

	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(785)
			p.RenameTable()
		}

	case 38:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(786)
			p.TruncateTable()
		}

	}

	return localctx
}

// IDmlStatementContext is an interface to support dynamic dispatch.
type IDmlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SelectStatement() ISelectStatementContext
	InsertStatement() IInsertStatementContext
	UpdateStatement() IUpdateStatementContext
	DeleteStatement() IDeleteStatementContext
	ReplaceStatement() IReplaceStatementContext
	CallStatement() ICallStatementContext
	LoadDataStatement() ILoadDataStatementContext
	LoadXmlStatement() ILoadXmlStatementContext
	DoStatement() IDoStatementContext
	HandlerStatement() IHandlerStatementContext
	ValuesStatement() IValuesStatementContext
	WithStatement() IWithStatementContext

	// IsDmlStatementContext differentiates from other interfaces.
	IsDmlStatementContext()
}

type DmlStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDmlStatementContext() *DmlStatementContext {
	var p = new(DmlStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_dmlStatement
	return p
}

func (*DmlStatementContext) IsDmlStatementContext() {}

func NewDmlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DmlStatementContext {
	var p = new(DmlStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dmlStatement

	return p
}

func (s *DmlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DmlStatementContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *DmlStatementContext) InsertStatement() IInsertStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertStatementContext)
}

func (s *DmlStatementContext) UpdateStatement() IUpdateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateStatementContext)
}

func (s *DmlStatementContext) DeleteStatement() IDeleteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeleteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeleteStatementContext)
}

func (s *DmlStatementContext) ReplaceStatement() IReplaceStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplaceStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplaceStatementContext)
}

func (s *DmlStatementContext) CallStatement() ICallStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallStatementContext)
}

func (s *DmlStatementContext) LoadDataStatement() ILoadDataStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadDataStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadDataStatementContext)
}

func (s *DmlStatementContext) LoadXmlStatement() ILoadXmlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadXmlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadXmlStatementContext)
}

func (s *DmlStatementContext) DoStatement() IDoStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDoStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDoStatementContext)
}

func (s *DmlStatementContext) HandlerStatement() IHandlerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHandlerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHandlerStatementContext)
}

func (s *DmlStatementContext) ValuesStatement() IValuesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValuesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValuesStatementContext)
}

func (s *DmlStatementContext) WithStatement() IWithStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithStatementContext)
}

func (s *DmlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DmlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DmlStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDmlStatement(s)
	}
}

func (s *DmlStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDmlStatement(s)
	}
}

func (p *MySqlParser) DmlStatement() (localctx IDmlStatementContext) {
	this := p
	_ = this

	localctx = NewDmlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, MySqlParserRULE_dmlStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(801)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 11, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(789)
			p.SelectStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(790)
			p.InsertStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(791)
			p.UpdateStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(792)
			p.DeleteStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(793)
			p.ReplaceStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(794)
			p.CallStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(795)
			p.LoadDataStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(796)
			p.LoadXmlStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(797)
			p.DoStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(798)
			p.HandlerStatement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(799)
			p.ValuesStatement()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(800)
			p.WithStatement()
		}

	}

	return localctx
}

// ITransactionStatementContext is an interface to support dynamic dispatch.
type ITransactionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StartTransaction() IStartTransactionContext
	BeginWork() IBeginWorkContext
	CommitWork() ICommitWorkContext
	RollbackWork() IRollbackWorkContext
	SavepointStatement() ISavepointStatementContext
	RollbackStatement() IRollbackStatementContext
	ReleaseStatement() IReleaseStatementContext
	LockTables() ILockTablesContext
	UnlockTables() IUnlockTablesContext

	// IsTransactionStatementContext differentiates from other interfaces.
	IsTransactionStatementContext()
}

type TransactionStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionStatementContext() *TransactionStatementContext {
	var p = new(TransactionStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_transactionStatement
	return p
}

func (*TransactionStatementContext) IsTransactionStatementContext() {}

func NewTransactionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionStatementContext {
	var p = new(TransactionStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_transactionStatement

	return p
}

func (s *TransactionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionStatementContext) StartTransaction() IStartTransactionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStartTransactionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStartTransactionContext)
}

func (s *TransactionStatementContext) BeginWork() IBeginWorkContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBeginWorkContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBeginWorkContext)
}

func (s *TransactionStatementContext) CommitWork() ICommitWorkContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommitWorkContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommitWorkContext)
}

func (s *TransactionStatementContext) RollbackWork() IRollbackWorkContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollbackWorkContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollbackWorkContext)
}

func (s *TransactionStatementContext) SavepointStatement() ISavepointStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISavepointStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISavepointStatementContext)
}

func (s *TransactionStatementContext) RollbackStatement() IRollbackStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollbackStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollbackStatementContext)
}

func (s *TransactionStatementContext) ReleaseStatement() IReleaseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReleaseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReleaseStatementContext)
}

func (s *TransactionStatementContext) LockTables() ILockTablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockTablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockTablesContext)
}

func (s *TransactionStatementContext) UnlockTables() IUnlockTablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnlockTablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnlockTablesContext)
}

func (s *TransactionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTransactionStatement(s)
	}
}

func (s *TransactionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTransactionStatement(s)
	}
}

func (p *MySqlParser) TransactionStatement() (localctx ITransactionStatementContext) {
	this := p
	_ = this

	localctx = NewTransactionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, MySqlParserRULE_transactionStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(812)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(803)
			p.StartTransaction()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(804)
			p.BeginWork()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(805)
			p.CommitWork()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(806)
			p.RollbackWork()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(807)
			p.SavepointStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(808)
			p.RollbackStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(809)
			p.ReleaseStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(810)
			p.LockTables()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(811)
			p.UnlockTables()
		}

	}

	return localctx
}

// IReplicationStatementContext is an interface to support dynamic dispatch.
type IReplicationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ChangeMaster() IChangeMasterContext
	ChangeReplicationFilter() IChangeReplicationFilterContext
	PurgeBinaryLogs() IPurgeBinaryLogsContext
	ResetMaster() IResetMasterContext
	ResetSlave() IResetSlaveContext
	StartSlave() IStartSlaveContext
	StopSlave() IStopSlaveContext
	StartGroupReplication() IStartGroupReplicationContext
	StopGroupReplication() IStopGroupReplicationContext
	XaStartTransaction() IXaStartTransactionContext
	XaEndTransaction() IXaEndTransactionContext
	XaPrepareStatement() IXaPrepareStatementContext
	XaCommitWork() IXaCommitWorkContext
	XaRollbackWork() IXaRollbackWorkContext
	XaRecoverWork() IXaRecoverWorkContext

	// IsReplicationStatementContext differentiates from other interfaces.
	IsReplicationStatementContext()
}

type ReplicationStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplicationStatementContext() *ReplicationStatementContext {
	var p = new(ReplicationStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_replicationStatement
	return p
}

func (*ReplicationStatementContext) IsReplicationStatementContext() {}

func NewReplicationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplicationStatementContext {
	var p = new(ReplicationStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_replicationStatement

	return p
}

func (s *ReplicationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplicationStatementContext) ChangeMaster() IChangeMasterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChangeMasterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChangeMasterContext)
}

func (s *ReplicationStatementContext) ChangeReplicationFilter() IChangeReplicationFilterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChangeReplicationFilterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChangeReplicationFilterContext)
}

func (s *ReplicationStatementContext) PurgeBinaryLogs() IPurgeBinaryLogsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPurgeBinaryLogsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPurgeBinaryLogsContext)
}

func (s *ReplicationStatementContext) ResetMaster() IResetMasterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResetMasterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResetMasterContext)
}

func (s *ReplicationStatementContext) ResetSlave() IResetSlaveContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResetSlaveContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResetSlaveContext)
}

func (s *ReplicationStatementContext) StartSlave() IStartSlaveContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStartSlaveContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStartSlaveContext)
}

func (s *ReplicationStatementContext) StopSlave() IStopSlaveContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStopSlaveContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStopSlaveContext)
}

func (s *ReplicationStatementContext) StartGroupReplication() IStartGroupReplicationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStartGroupReplicationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStartGroupReplicationContext)
}

func (s *ReplicationStatementContext) StopGroupReplication() IStopGroupReplicationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStopGroupReplicationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStopGroupReplicationContext)
}

func (s *ReplicationStatementContext) XaStartTransaction() IXaStartTransactionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXaStartTransactionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXaStartTransactionContext)
}

func (s *ReplicationStatementContext) XaEndTransaction() IXaEndTransactionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXaEndTransactionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXaEndTransactionContext)
}

func (s *ReplicationStatementContext) XaPrepareStatement() IXaPrepareStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXaPrepareStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXaPrepareStatementContext)
}

func (s *ReplicationStatementContext) XaCommitWork() IXaCommitWorkContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXaCommitWorkContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXaCommitWorkContext)
}

func (s *ReplicationStatementContext) XaRollbackWork() IXaRollbackWorkContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXaRollbackWorkContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXaRollbackWorkContext)
}

func (s *ReplicationStatementContext) XaRecoverWork() IXaRecoverWorkContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXaRecoverWorkContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXaRecoverWorkContext)
}

func (s *ReplicationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplicationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplicationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterReplicationStatement(s)
	}
}

func (s *ReplicationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitReplicationStatement(s)
	}
}

func (p *MySqlParser) ReplicationStatement() (localctx IReplicationStatementContext) {
	this := p
	_ = this

	localctx = NewReplicationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, MySqlParserRULE_replicationStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(829)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 13, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(814)
			p.ChangeMaster()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(815)
			p.ChangeReplicationFilter()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(816)
			p.PurgeBinaryLogs()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(817)
			p.ResetMaster()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(818)
			p.ResetSlave()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(819)
			p.StartSlave()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(820)
			p.StopSlave()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(821)
			p.StartGroupReplication()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(822)
			p.StopGroupReplication()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(823)
			p.XaStartTransaction()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(824)
			p.XaEndTransaction()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(825)
			p.XaPrepareStatement()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(826)
			p.XaCommitWork()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(827)
			p.XaRollbackWork()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(828)
			p.XaRecoverWork()
		}

	}

	return localctx
}

// IPreparedStatementContext is an interface to support dynamic dispatch.
type IPreparedStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrepareStatement() IPrepareStatementContext
	ExecuteStatement() IExecuteStatementContext
	DeallocatePrepare() IDeallocatePrepareContext

	// IsPreparedStatementContext differentiates from other interfaces.
	IsPreparedStatementContext()
}

type PreparedStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPreparedStatementContext() *PreparedStatementContext {
	var p = new(PreparedStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_preparedStatement
	return p
}

func (*PreparedStatementContext) IsPreparedStatementContext() {}

func NewPreparedStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PreparedStatementContext {
	var p = new(PreparedStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_preparedStatement

	return p
}

func (s *PreparedStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PreparedStatementContext) PrepareStatement() IPrepareStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrepareStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrepareStatementContext)
}

func (s *PreparedStatementContext) ExecuteStatement() IExecuteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExecuteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExecuteStatementContext)
}

func (s *PreparedStatementContext) DeallocatePrepare() IDeallocatePrepareContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeallocatePrepareContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeallocatePrepareContext)
}

func (s *PreparedStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreparedStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PreparedStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPreparedStatement(s)
	}
}

func (s *PreparedStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPreparedStatement(s)
	}
}

func (p *MySqlParser) PreparedStatement() (localctx IPreparedStatementContext) {
	this := p
	_ = this

	localctx = NewPreparedStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, MySqlParserRULE_preparedStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(834)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserPREPARE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(831)
			p.PrepareStatement()
		}

	case MySqlParserEXECUTE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(832)
			p.ExecuteStatement()
		}

	case MySqlParserDROP, MySqlParserDEALLOCATE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(833)
			p.DeallocatePrepare()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICompoundStatementContext is an interface to support dynamic dispatch.
type ICompoundStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BlockStatement() IBlockStatementContext
	CaseStatement() ICaseStatementContext
	IfStatement() IIfStatementContext
	LeaveStatement() ILeaveStatementContext
	LoopStatement() ILoopStatementContext
	RepeatStatement() IRepeatStatementContext
	WhileStatement() IWhileStatementContext
	IterateStatement() IIterateStatementContext
	ReturnStatement() IReturnStatementContext
	CursorStatement() ICursorStatementContext

	// IsCompoundStatementContext differentiates from other interfaces.
	IsCompoundStatementContext()
}

type CompoundStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompoundStatementContext() *CompoundStatementContext {
	var p = new(CompoundStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_compoundStatement
	return p
}

func (*CompoundStatementContext) IsCompoundStatementContext() {}

func NewCompoundStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompoundStatementContext {
	var p = new(CompoundStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_compoundStatement

	return p
}

func (s *CompoundStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CompoundStatementContext) BlockStatement() IBlockStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *CompoundStatementContext) CaseStatement() ICaseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseStatementContext)
}

func (s *CompoundStatementContext) IfStatement() IIfStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *CompoundStatementContext) LeaveStatement() ILeaveStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILeaveStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILeaveStatementContext)
}

func (s *CompoundStatementContext) LoopStatement() ILoopStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoopStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoopStatementContext)
}

func (s *CompoundStatementContext) RepeatStatement() IRepeatStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRepeatStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRepeatStatementContext)
}

func (s *CompoundStatementContext) WhileStatement() IWhileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileStatementContext)
}

func (s *CompoundStatementContext) IterateStatement() IIterateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIterateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIterateStatementContext)
}

func (s *CompoundStatementContext) ReturnStatement() IReturnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *CompoundStatementContext) CursorStatement() ICursorStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICursorStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICursorStatementContext)
}

func (s *CompoundStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompoundStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompoundStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCompoundStatement(s)
	}
}

func (s *CompoundStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCompoundStatement(s)
	}
}

func (p *MySqlParser) CompoundStatement() (localctx ICompoundStatementContext) {
	this := p
	_ = this

	localctx = NewCompoundStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, MySqlParserRULE_compoundStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(846)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(836)
			p.BlockStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(837)
			p.CaseStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(838)
			p.IfStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(839)
			p.LeaveStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(840)
			p.LoopStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(841)
			p.RepeatStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(842)
			p.WhileStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(843)
			p.IterateStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(844)
			p.ReturnStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(845)
			p.CursorStatement()
		}

	}

	return localctx
}

// IAdministrationStatementContext is an interface to support dynamic dispatch.
type IAdministrationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AlterUser() IAlterUserContext
	CreateUser() ICreateUserContext
	DropUser() IDropUserContext
	GrantStatement() IGrantStatementContext
	GrantProxy() IGrantProxyContext
	RenameUser() IRenameUserContext
	RevokeStatement() IRevokeStatementContext
	RevokeProxy() IRevokeProxyContext
	AnalyzeTable() IAnalyzeTableContext
	CheckTable() ICheckTableContext
	ChecksumTable() IChecksumTableContext
	OptimizeTable() IOptimizeTableContext
	RepairTable() IRepairTableContext
	CreateUdfunction() ICreateUdfunctionContext
	InstallPlugin() IInstallPluginContext
	UninstallPlugin() IUninstallPluginContext
	SetStatement() ISetStatementContext
	ShowStatement() IShowStatementContext
	BinlogStatement() IBinlogStatementContext
	CacheIndexStatement() ICacheIndexStatementContext
	FlushStatement() IFlushStatementContext
	KillStatement() IKillStatementContext
	LoadIndexIntoCache() ILoadIndexIntoCacheContext
	ResetStatement() IResetStatementContext
	ShutdownStatement() IShutdownStatementContext

	// IsAdministrationStatementContext differentiates from other interfaces.
	IsAdministrationStatementContext()
}

type AdministrationStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdministrationStatementContext() *AdministrationStatementContext {
	var p = new(AdministrationStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_administrationStatement
	return p
}

func (*AdministrationStatementContext) IsAdministrationStatementContext() {}

func NewAdministrationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdministrationStatementContext {
	var p = new(AdministrationStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_administrationStatement

	return p
}

func (s *AdministrationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdministrationStatementContext) AlterUser() IAlterUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterUserContext)
}

func (s *AdministrationStatementContext) CreateUser() ICreateUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateUserContext)
}

func (s *AdministrationStatementContext) DropUser() IDropUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropUserContext)
}

func (s *AdministrationStatementContext) GrantStatement() IGrantStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantStatementContext)
}

func (s *AdministrationStatementContext) GrantProxy() IGrantProxyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantProxyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantProxyContext)
}

func (s *AdministrationStatementContext) RenameUser() IRenameUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRenameUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRenameUserContext)
}

func (s *AdministrationStatementContext) RevokeStatement() IRevokeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRevokeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRevokeStatementContext)
}

func (s *AdministrationStatementContext) RevokeProxy() IRevokeProxyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRevokeProxyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRevokeProxyContext)
}

func (s *AdministrationStatementContext) AnalyzeTable() IAnalyzeTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyzeTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyzeTableContext)
}

func (s *AdministrationStatementContext) CheckTable() ICheckTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICheckTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICheckTableContext)
}

func (s *AdministrationStatementContext) ChecksumTable() IChecksumTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChecksumTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChecksumTableContext)
}

func (s *AdministrationStatementContext) OptimizeTable() IOptimizeTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptimizeTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptimizeTableContext)
}

func (s *AdministrationStatementContext) RepairTable() IRepairTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRepairTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRepairTableContext)
}

func (s *AdministrationStatementContext) CreateUdfunction() ICreateUdfunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateUdfunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateUdfunctionContext)
}

func (s *AdministrationStatementContext) InstallPlugin() IInstallPluginContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstallPluginContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstallPluginContext)
}

func (s *AdministrationStatementContext) UninstallPlugin() IUninstallPluginContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUninstallPluginContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUninstallPluginContext)
}

func (s *AdministrationStatementContext) SetStatement() ISetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetStatementContext)
}

func (s *AdministrationStatementContext) ShowStatement() IShowStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowStatementContext)
}

func (s *AdministrationStatementContext) BinlogStatement() IBinlogStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBinlogStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBinlogStatementContext)
}

func (s *AdministrationStatementContext) CacheIndexStatement() ICacheIndexStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICacheIndexStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICacheIndexStatementContext)
}

func (s *AdministrationStatementContext) FlushStatement() IFlushStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFlushStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFlushStatementContext)
}

func (s *AdministrationStatementContext) KillStatement() IKillStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKillStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKillStatementContext)
}

func (s *AdministrationStatementContext) LoadIndexIntoCache() ILoadIndexIntoCacheContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadIndexIntoCacheContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadIndexIntoCacheContext)
}

func (s *AdministrationStatementContext) ResetStatement() IResetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResetStatementContext)
}

func (s *AdministrationStatementContext) ShutdownStatement() IShutdownStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShutdownStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShutdownStatementContext)
}

func (s *AdministrationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdministrationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdministrationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAdministrationStatement(s)
	}
}

func (s *AdministrationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAdministrationStatement(s)
	}
}

func (p *MySqlParser) AdministrationStatement() (localctx IAdministrationStatementContext) {
	this := p
	_ = this

	localctx = NewAdministrationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, MySqlParserRULE_administrationStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(873)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(848)
			p.AlterUser()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(849)
			p.CreateUser()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(850)
			p.DropUser()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(851)
			p.GrantStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(852)
			p.GrantProxy()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(853)
			p.RenameUser()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(854)
			p.RevokeStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(855)
			p.RevokeProxy()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(856)
			p.AnalyzeTable()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(857)
			p.CheckTable()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(858)
			p.ChecksumTable()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(859)
			p.OptimizeTable()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(860)
			p.RepairTable()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(861)
			p.CreateUdfunction()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(862)
			p.InstallPlugin()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(863)
			p.UninstallPlugin()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(864)
			p.SetStatement()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(865)
			p.ShowStatement()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(866)
			p.BinlogStatement()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(867)
			p.CacheIndexStatement()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(868)
			p.FlushStatement()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(869)
			p.KillStatement()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(870)
			p.LoadIndexIntoCache()
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(871)
			p.ResetStatement()
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(872)
			p.ShutdownStatement()
		}

	}

	return localctx
}

// IUtilityStatementContext is an interface to support dynamic dispatch.
type IUtilityStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleDescribeStatement() ISimpleDescribeStatementContext
	FullDescribeStatement() IFullDescribeStatementContext
	HelpStatement() IHelpStatementContext
	UseStatement() IUseStatementContext
	SignalStatement() ISignalStatementContext
	ResignalStatement() IResignalStatementContext
	DiagnosticsStatement() IDiagnosticsStatementContext

	// IsUtilityStatementContext differentiates from other interfaces.
	IsUtilityStatementContext()
}

type UtilityStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUtilityStatementContext() *UtilityStatementContext {
	var p = new(UtilityStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_utilityStatement
	return p
}

func (*UtilityStatementContext) IsUtilityStatementContext() {}

func NewUtilityStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UtilityStatementContext {
	var p = new(UtilityStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_utilityStatement

	return p
}

func (s *UtilityStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UtilityStatementContext) SimpleDescribeStatement() ISimpleDescribeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleDescribeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleDescribeStatementContext)
}

func (s *UtilityStatementContext) FullDescribeStatement() IFullDescribeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullDescribeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullDescribeStatementContext)
}

func (s *UtilityStatementContext) HelpStatement() IHelpStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHelpStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHelpStatementContext)
}

func (s *UtilityStatementContext) UseStatement() IUseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseStatementContext)
}

func (s *UtilityStatementContext) SignalStatement() ISignalStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignalStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignalStatementContext)
}

func (s *UtilityStatementContext) ResignalStatement() IResignalStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResignalStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResignalStatementContext)
}

func (s *UtilityStatementContext) DiagnosticsStatement() IDiagnosticsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDiagnosticsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDiagnosticsStatementContext)
}

func (s *UtilityStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UtilityStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UtilityStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUtilityStatement(s)
	}
}

func (s *UtilityStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUtilityStatement(s)
	}
}

func (p *MySqlParser) UtilityStatement() (localctx IUtilityStatementContext) {
	this := p
	_ = this

	localctx = NewUtilityStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, MySqlParserRULE_utilityStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(882)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(875)
			p.SimpleDescribeStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(876)
			p.FullDescribeStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(877)
			p.HelpStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(878)
			p.UseStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(879)
			p.SignalStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(880)
			p.ResignalStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(881)
			p.DiagnosticsStatement()
		}

	}

	return localctx
}

// ICreateDatabaseContext is an interface to support dynamic dispatch.
type ICreateDatabaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDbFormat returns the dbFormat token.
	GetDbFormat() antlr.Token

	// SetDbFormat sets the dbFormat token.
	SetDbFormat(antlr.Token)

	// Getter signatures
	CREATE() antlr.TerminalNode
	Uid() IUidContext
	DATABASE() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	IfNotExists() IIfNotExistsContext
	AllCreateDatabaseOption() []ICreateDatabaseOptionContext
	CreateDatabaseOption(i int) ICreateDatabaseOptionContext

	// IsCreateDatabaseContext differentiates from other interfaces.
	IsCreateDatabaseContext()
}

type CreateDatabaseContext struct {
	*antlr.BaseParserRuleContext
	parser   antlr.Parser
	dbFormat antlr.Token
}

func NewEmptyCreateDatabaseContext() *CreateDatabaseContext {
	var p = new(CreateDatabaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_createDatabase
	return p
}

func (*CreateDatabaseContext) IsCreateDatabaseContext() {}

func NewCreateDatabaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDatabaseContext {
	var p = new(CreateDatabaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createDatabase

	return p
}

func (s *CreateDatabaseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDatabaseContext) GetDbFormat() antlr.Token { return s.dbFormat }

func (s *CreateDatabaseContext) SetDbFormat(v antlr.Token) { s.dbFormat = v }

func (s *CreateDatabaseContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateDatabaseContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CreateDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATABASE, 0)
}

func (s *CreateDatabaseContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEMA, 0)
}

func (s *CreateDatabaseContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateDatabaseContext) AllCreateDatabaseOption() []ICreateDatabaseOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreateDatabaseOptionContext); ok {
			len++
		}
	}

	tst := make([]ICreateDatabaseOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreateDatabaseOptionContext); ok {
			tst[i] = t.(ICreateDatabaseOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateDatabaseContext) CreateDatabaseOption(i int) ICreateDatabaseOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDatabaseOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDatabaseOptionContext)
}

func (s *CreateDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDatabaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateDatabase(s)
	}
}

func (s *CreateDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateDatabase(s)
	}
}

func (p *MySqlParser) CreateDatabase() (localctx ICreateDatabaseContext) {
	this := p
	_ = this

	localctx = NewCreateDatabaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, MySqlParserRULE_createDatabase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(884)
		p.Match(MySqlParserCREATE)
	}
	{
		p.SetState(885)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*CreateDatabaseContext).dbFormat = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserDATABASE || _la == MySqlParserSCHEMA) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*CreateDatabaseContext).dbFormat = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(887)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(886)
			p.IfNotExists()
		}

	}
	{
		p.SetState(889)
		p.Uid()
	}
	p.SetState(893)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4398214283264) != 0) || _la == MySqlParserREAD || _la == MySqlParserCHAR || _la == MySqlParserENCRYPTION || _la == MySqlParserCHARSET {
		{
			p.SetState(890)
			p.CreateDatabaseOption()
		}

		p.SetState(895)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICreateEventContext is an interface to support dynamic dispatch.
type ICreateEventContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	EVENT() antlr.TerminalNode
	FullId() IFullIdContext
	AllON() []antlr.TerminalNode
	ON(i int) antlr.TerminalNode
	SCHEDULE() antlr.TerminalNode
	ScheduleExpression() IScheduleExpressionContext
	DO() antlr.TerminalNode
	RoutineBody() IRoutineBodyContext
	OwnerStatement() IOwnerStatementContext
	IfNotExists() IIfNotExistsContext
	COMPLETION() antlr.TerminalNode
	PRESERVE() antlr.TerminalNode
	EnableType() IEnableTypeContext
	COMMENT() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsCreateEventContext differentiates from other interfaces.
	IsCreateEventContext()
}

type CreateEventContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateEventContext() *CreateEventContext {
	var p = new(CreateEventContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_createEvent
	return p
}

func (*CreateEventContext) IsCreateEventContext() {}

func NewCreateEventContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateEventContext {
	var p = new(CreateEventContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createEvent

	return p
}

func (s *CreateEventContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateEventContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateEventContext) EVENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVENT, 0)
}

func (s *CreateEventContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *CreateEventContext) AllON() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserON)
}

func (s *CreateEventContext) ON(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserON, i)
}

func (s *CreateEventContext) SCHEDULE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEDULE, 0)
}

func (s *CreateEventContext) ScheduleExpression() IScheduleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScheduleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScheduleExpressionContext)
}

func (s *CreateEventContext) DO() antlr.TerminalNode {
	return s.GetToken(MySqlParserDO, 0)
}

func (s *CreateEventContext) RoutineBody() IRoutineBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineBodyContext)
}

func (s *CreateEventContext) OwnerStatement() IOwnerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOwnerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOwnerStatementContext)
}

func (s *CreateEventContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateEventContext) COMPLETION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMPLETION, 0)
}

func (s *CreateEventContext) PRESERVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRESERVE, 0)
}

func (s *CreateEventContext) EnableType() IEnableTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnableTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnableTypeContext)
}

func (s *CreateEventContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT, 0)
}

func (s *CreateEventContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *CreateEventContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *CreateEventContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateEventContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateEventContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateEvent(s)
	}
}

func (s *CreateEventContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateEvent(s)
	}
}

func (p *MySqlParser) CreateEvent() (localctx ICreateEventContext) {
	this := p
	_ = this

	localctx = NewCreateEventContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, MySqlParserRULE_createEvent)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(896)
		p.Match(MySqlParserCREATE)
	}
	p.SetState(898)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserDEFINER {
		{
			p.SetState(897)
			p.OwnerStatement()
		}

	}
	{
		p.SetState(900)
		p.Match(MySqlParserEVENT)
	}
	p.SetState(902)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(901)
			p.IfNotExists()
		}

	}
	{
		p.SetState(904)
		p.FullId()
	}
	{
		p.SetState(905)
		p.Match(MySqlParserON)
	}
	{
		p.SetState(906)
		p.Match(MySqlParserSCHEDULE)
	}
	{
		p.SetState(907)
		p.ScheduleExpression()
	}
	p.SetState(914)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserON {
		{
			p.SetState(908)
			p.Match(MySqlParserON)
		}
		{
			p.SetState(909)
			p.Match(MySqlParserCOMPLETION)
		}
		p.SetState(911)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserNOT {
			{
				p.SetState(910)
				p.Match(MySqlParserNOT)
			}

		}
		{
			p.SetState(913)
			p.Match(MySqlParserPRESERVE)
		}

	}
	p.SetState(917)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserDISABLE || _la == MySqlParserENABLE {
		{
			p.SetState(916)
			p.EnableType()
		}

	}
	p.SetState(921)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserCOMMENT {
		{
			p.SetState(919)
			p.Match(MySqlParserCOMMENT)
		}
		{
			p.SetState(920)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	}
	{
		p.SetState(923)
		p.Match(MySqlParserDO)
	}
	{
		p.SetState(924)
		p.RoutineBody()
	}

	return localctx
}

// ICreateIndexContext is an interface to support dynamic dispatch.
type ICreateIndexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIntimeAction returns the intimeAction token.
	GetIntimeAction() antlr.Token

	// GetIndexCategory returns the indexCategory token.
	GetIndexCategory() antlr.Token

	// GetAlgType returns the algType token.
	GetAlgType() antlr.Token

	// GetLockType returns the lockType token.
	GetLockType() antlr.Token

	// SetIntimeAction sets the intimeAction token.
	SetIntimeAction(antlr.Token)

	// SetIndexCategory sets the indexCategory token.
	SetIndexCategory(antlr.Token)

	// SetAlgType sets the algType token.
	SetAlgType(antlr.Token)

	// SetLockType sets the lockType token.
	SetLockType(antlr.Token)

	// Getter signatures
	CREATE() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	Uid() IUidContext
	ON() antlr.TerminalNode
	TableName() ITableNameContext
	IndexColumnNames() IIndexColumnNamesContext
	IndexType() IIndexTypeContext
	AllIndexOption() []IIndexOptionContext
	IndexOption(i int) IIndexOptionContext
	AllALGORITHM() []antlr.TerminalNode
	ALGORITHM(i int) antlr.TerminalNode
	AllLOCK() []antlr.TerminalNode
	LOCK(i int) antlr.TerminalNode
	ONLINE() antlr.TerminalNode
	OFFLINE() antlr.TerminalNode
	UNIQUE() antlr.TerminalNode
	FULLTEXT() antlr.TerminalNode
	SPATIAL() antlr.TerminalNode
	AllDEFAULT() []antlr.TerminalNode
	DEFAULT(i int) antlr.TerminalNode
	AllINPLACE() []antlr.TerminalNode
	INPLACE(i int) antlr.TerminalNode
	AllCOPY() []antlr.TerminalNode
	COPY(i int) antlr.TerminalNode
	AllNONE() []antlr.TerminalNode
	NONE(i int) antlr.TerminalNode
	AllSHARED() []antlr.TerminalNode
	SHARED(i int) antlr.TerminalNode
	AllEXCLUSIVE() []antlr.TerminalNode
	EXCLUSIVE(i int) antlr.TerminalNode
	AllEQUAL_SYMBOL() []antlr.TerminalNode
	EQUAL_SYMBOL(i int) antlr.TerminalNode

	// IsCreateIndexContext differentiates from other interfaces.
	IsCreateIndexContext()
}

type CreateIndexContext struct {
	*antlr.BaseParserRuleContext
	parser        antlr.Parser
	intimeAction  antlr.Token
	indexCategory antlr.Token
	algType       antlr.Token
	lockType      antlr.Token
}

func NewEmptyCreateIndexContext() *CreateIndexContext {
	var p = new(CreateIndexContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_createIndex
	return p
}

func (*CreateIndexContext) IsCreateIndexContext() {}

func NewCreateIndexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateIndexContext {
	var p = new(CreateIndexContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createIndex

	return p
}

func (s *CreateIndexContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateIndexContext) GetIntimeAction() antlr.Token { return s.intimeAction }

func (s *CreateIndexContext) GetIndexCategory() antlr.Token { return s.indexCategory }

func (s *CreateIndexContext) GetAlgType() antlr.Token { return s.algType }

func (s *CreateIndexContext) GetLockType() antlr.Token { return s.lockType }

func (s *CreateIndexContext) SetIntimeAction(v antlr.Token) { s.intimeAction = v }

func (s *CreateIndexContext) SetIndexCategory(v antlr.Token) { s.indexCategory = v }

func (s *CreateIndexContext) SetAlgType(v antlr.Token) { s.algType = v }

func (s *CreateIndexContext) SetLockType(v antlr.Token) { s.lockType = v }

func (s *CreateIndexContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *CreateIndexContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CreateIndexContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *CreateIndexContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *CreateIndexContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *CreateIndexContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *CreateIndexContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateIndexContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *CreateIndexContext) AllALGORITHM() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserALGORITHM)
}

func (s *CreateIndexContext) ALGORITHM(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserALGORITHM, i)
}

func (s *CreateIndexContext) AllLOCK() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLOCK)
}

func (s *CreateIndexContext) LOCK(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCK, i)
}

func (s *CreateIndexContext) ONLINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserONLINE, 0)
}

func (s *CreateIndexContext) OFFLINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserOFFLINE, 0)
}

func (s *CreateIndexContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNIQUE, 0)
}

func (s *CreateIndexContext) FULLTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserFULLTEXT, 0)
}

func (s *CreateIndexContext) SPATIAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSPATIAL, 0)
}

func (s *CreateIndexContext) AllDEFAULT() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserDEFAULT)
}

func (s *CreateIndexContext) DEFAULT(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, i)
}

func (s *CreateIndexContext) AllINPLACE() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserINPLACE)
}

func (s *CreateIndexContext) INPLACE(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserINPLACE, i)
}

func (s *CreateIndexContext) AllCOPY() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOPY)
}

func (s *CreateIndexContext) COPY(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOPY, i)
}

func (s *CreateIndexContext) AllNONE() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserNONE)
}

func (s *CreateIndexContext) NONE(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserNONE, i)
}

func (s *CreateIndexContext) AllSHARED() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSHARED)
}

func (s *CreateIndexContext) SHARED(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSHARED, i)
}

func (s *CreateIndexContext) AllEXCLUSIVE() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEXCLUSIVE)
}

func (s *CreateIndexContext) EXCLUSIVE(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCLUSIVE, i)
}

func (s *CreateIndexContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *CreateIndexContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *CreateIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateIndexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateIndex(s)
	}
}

func (s *CreateIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateIndex(s)
	}
}

func (p *MySqlParser) CreateIndex() (localctx ICreateIndexContext) {
	this := p
	_ = this

	localctx = NewCreateIndexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, MySqlParserRULE_createIndex)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(926)
		p.Match(MySqlParserCREATE)
	}
	p.SetState(928)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserOFFLINE || _la == MySqlParserONLINE {
		{
			p.SetState(927)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CreateIndexContext).intimeAction = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserOFFLINE || _la == MySqlParserONLINE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CreateIndexContext).intimeAction = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(931)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserFULLTEXT || _la == MySqlParserSPATIAL || _la == MySqlParserUNIQUE {
		{
			p.SetState(930)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CreateIndexContext).indexCategory = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFULLTEXT || _la == MySqlParserSPATIAL || _la == MySqlParserUNIQUE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CreateIndexContext).indexCategory = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(933)
		p.Match(MySqlParserINDEX)
	}
	{
		p.SetState(934)
		p.Uid()
	}
	p.SetState(936)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserUSING {
		{
			p.SetState(935)
			p.IndexType()
		}

	}
	{
		p.SetState(938)
		p.Match(MySqlParserON)
	}
	{
		p.SetState(939)
		p.TableName()
	}
	{
		p.SetState(940)
		p.IndexColumnNames()
	}
	p.SetState(944)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(941)
				p.IndexOption()
			}

		}
		p.SetState(946)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext())
	}
	p.SetState(959)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(957)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case MySqlParserALGORITHM:
				{
					p.SetState(947)
					p.Match(MySqlParserALGORITHM)
				}
				p.SetState(949)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == MySqlParserEQUAL_SYMBOL {
					{
						p.SetState(948)
						p.Match(MySqlParserEQUAL_SYMBOL)
					}

				}
				{
					p.SetState(951)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*CreateIndexContext).algType = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserDEFAULT || _la == MySqlParserCOPY || _la == MySqlParserINPLACE) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*CreateIndexContext).algType = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			case MySqlParserLOCK:
				{
					p.SetState(952)
					p.Match(MySqlParserLOCK)
				}
				p.SetState(954)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == MySqlParserEQUAL_SYMBOL {
					{
						p.SetState(953)
						p.Match(MySqlParserEQUAL_SYMBOL)
					}

				}
				{
					p.SetState(956)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*CreateIndexContext).lockType = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserDEFAULT || _la == MySqlParserEXCLUSIVE || _la == MySqlParserNONE || _la == MySqlParserSHARED) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*CreateIndexContext).lockType = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(961)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext())
	}

	return localctx
}

// ICreateLogfileGroupContext is an interface to support dynamic dispatch.
type ICreateLogfileGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUndoFile returns the undoFile token.
	GetUndoFile() antlr.Token

	// GetComment returns the comment token.
	GetComment() antlr.Token

	// SetUndoFile sets the undoFile token.
	SetUndoFile(antlr.Token)

	// SetComment sets the comment token.
	SetComment(antlr.Token)

	// GetInitSize returns the initSize rule contexts.
	GetInitSize() IFileSizeLiteralContext

	// GetUndoSize returns the undoSize rule contexts.
	GetUndoSize() IFileSizeLiteralContext

	// GetRedoSize returns the redoSize rule contexts.
	GetRedoSize() IFileSizeLiteralContext

	// SetInitSize sets the initSize rule contexts.
	SetInitSize(IFileSizeLiteralContext)

	// SetUndoSize sets the undoSize rule contexts.
	SetUndoSize(IFileSizeLiteralContext)

	// SetRedoSize sets the redoSize rule contexts.
	SetRedoSize(IFileSizeLiteralContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	LOGFILE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	AllUid() []IUidContext
	Uid(i int) IUidContext
	ADD() antlr.TerminalNode
	UNDOFILE() antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	EngineName() IEngineNameContext
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	INITIAL_SIZE() antlr.TerminalNode
	UNDO_BUFFER_SIZE() antlr.TerminalNode
	REDO_BUFFER_SIZE() antlr.TerminalNode
	NODEGROUP() antlr.TerminalNode
	WAIT() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	AllEQUAL_SYMBOL() []antlr.TerminalNode
	EQUAL_SYMBOL(i int) antlr.TerminalNode
	AllFileSizeLiteral() []IFileSizeLiteralContext
	FileSizeLiteral(i int) IFileSizeLiteralContext

	// IsCreateLogfileGroupContext differentiates from other interfaces.
	IsCreateLogfileGroupContext()
}

type CreateLogfileGroupContext struct {
	*antlr.BaseParserRuleContext
	parser   antlr.Parser
	undoFile antlr.Token
	initSize IFileSizeLiteralContext
	undoSize IFileSizeLiteralContext
	redoSize IFileSizeLiteralContext
	comment  antlr.Token
}

func NewEmptyCreateLogfileGroupContext() *CreateLogfileGroupContext {
	var p = new(CreateLogfileGroupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_createLogfileGroup
	return p
}

func (*CreateLogfileGroupContext) IsCreateLogfileGroupContext() {}

func NewCreateLogfileGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateLogfileGroupContext {
	var p = new(CreateLogfileGroupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createLogfileGroup

	return p
}

func (s *CreateLogfileGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateLogfileGroupContext) GetUndoFile() antlr.Token { return s.undoFile }

func (s *CreateLogfileGroupContext) GetComment() antlr.Token { return s.comment }

func (s *CreateLogfileGroupContext) SetUndoFile(v antlr.Token) { s.undoFile = v }

func (s *CreateLogfileGroupContext) SetComment(v antlr.Token) { s.comment = v }

func (s *CreateLogfileGroupContext) GetInitSize() IFileSizeLiteralContext { return s.initSize }

func (s *CreateLogfileGroupContext) GetUndoSize() IFileSizeLiteralContext { return s.undoSize }

func (s *CreateLogfileGroupContext) GetRedoSize() IFileSizeLiteralContext { return s.redoSize }

func (s *CreateLogfileGroupContext) SetInitSize(v IFileSizeLiteralContext) { s.initSize = v }

func (s *CreateLogfileGroupContext) SetUndoSize(v IFileSizeLiteralContext) { s.undoSize = v }

func (s *CreateLogfileGroupContext) SetRedoSize(v IFileSizeLiteralContext) { s.redoSize = v }

func (s *CreateLogfileGroupContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateLogfileGroupContext) LOGFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOGFILE, 0)
}

func (s *CreateLogfileGroupContext) GROUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP, 0)
}

func (s *CreateLogfileGroupContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *CreateLogfileGroupContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CreateLogfileGroupContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *CreateLogfileGroupContext) UNDOFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNDOFILE, 0)
}

func (s *CreateLogfileGroupContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE, 0)
}

func (s *CreateLogfileGroupContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *CreateLogfileGroupContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSTRING_LITERAL)
}

func (s *CreateLogfileGroupContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, i)
}

func (s *CreateLogfileGroupContext) INITIAL_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINITIAL_SIZE, 0)
}

func (s *CreateLogfileGroupContext) UNDO_BUFFER_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNDO_BUFFER_SIZE, 0)
}

func (s *CreateLogfileGroupContext) REDO_BUFFER_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREDO_BUFFER_SIZE, 0)
}

func (s *CreateLogfileGroupContext) NODEGROUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserNODEGROUP, 0)
}

func (s *CreateLogfileGroupContext) WAIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserWAIT, 0)
}

func (s *CreateLogfileGroupContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT, 0)
}

func (s *CreateLogfileGroupContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *CreateLogfileGroupContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *CreateLogfileGroupContext) AllFileSizeLiteral() []IFileSizeLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			len++
		}
	}

	tst := make([]IFileSizeLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFileSizeLiteralContext); ok {
			tst[i] = t.(IFileSizeLiteralContext)
			i++
		}
	}

	return tst
}

func (s *CreateLogfileGroupContext) FileSizeLiteral(i int) IFileSizeLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileSizeLiteralContext)
}

func (s *CreateLogfileGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateLogfileGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateLogfileGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateLogfileGroup(s)
	}
}

func (s *CreateLogfileGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateLogfileGroup(s)
	}
}

func (p *MySqlParser) CreateLogfileGroup() (localctx ICreateLogfileGroupContext) {
	this := p
	_ = this

	localctx = NewCreateLogfileGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, MySqlParserRULE_createLogfileGroup)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(962)
		p.Match(MySqlParserCREATE)
	}
	{
		p.SetState(963)
		p.Match(MySqlParserLOGFILE)
	}
	{
		p.SetState(964)
		p.Match(MySqlParserGROUP)
	}
	{
		p.SetState(965)
		p.Uid()
	}
	{
		p.SetState(966)
		p.Match(MySqlParserADD)
	}
	{
		p.SetState(967)
		p.Match(MySqlParserUNDOFILE)
	}
	{
		p.SetState(968)

		var _m = p.Match(MySqlParserSTRING_LITERAL)

		localctx.(*CreateLogfileGroupContext).undoFile = _m
	}
	p.SetState(974)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserINITIAL_SIZE {
		{
			p.SetState(969)
			p.Match(MySqlParserINITIAL_SIZE)
		}
		p.SetState(971)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(970)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(973)

			var _x = p.FileSizeLiteral()

			localctx.(*CreateLogfileGroupContext).initSize = _x
		}

	}
	p.SetState(981)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserUNDO_BUFFER_SIZE {
		{
			p.SetState(976)
			p.Match(MySqlParserUNDO_BUFFER_SIZE)
		}
		p.SetState(978)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(977)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(980)

			var _x = p.FileSizeLiteral()

			localctx.(*CreateLogfileGroupContext).undoSize = _x
		}

	}
	p.SetState(988)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserREDO_BUFFER_SIZE {
		{
			p.SetState(983)
			p.Match(MySqlParserREDO_BUFFER_SIZE)
		}
		p.SetState(985)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(984)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(987)

			var _x = p.FileSizeLiteral()

			localctx.(*CreateLogfileGroupContext).redoSize = _x
		}

	}
	p.SetState(995)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserNODEGROUP {
		{
			p.SetState(990)
			p.Match(MySqlParserNODEGROUP)
		}
		p.SetState(992)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(991)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(994)
			p.Uid()
		}

	}
	p.SetState(998)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserWAIT {
		{
			p.SetState(997)
			p.Match(MySqlParserWAIT)
		}

	}
	p.SetState(1005)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserCOMMENT {
		{
			p.SetState(1000)
			p.Match(MySqlParserCOMMENT)
		}
		p.SetState(1002)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1001)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1004)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*CreateLogfileGroupContext).comment = _m
		}

	}
	{
		p.SetState(1007)
		p.Match(MySqlParserENGINE)
	}
	p.SetState(1009)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserEQUAL_SYMBOL {
		{
			p.SetState(1008)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}

	}
	{
		p.SetState(1011)
		p.EngineName()
	}

	return localctx
}

// ICreateProcedureContext is an interface to support dynamic dispatch.
type ICreateProcedureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	PROCEDURE() antlr.TerminalNode
	FullId() IFullIdContext
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	RoutineBody() IRoutineBodyContext
	OwnerStatement() IOwnerStatementContext
	AllProcedureParameter() []IProcedureParameterContext
	ProcedureParameter(i int) IProcedureParameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllRoutineOption() []IRoutineOptionContext
	RoutineOption(i int) IRoutineOptionContext

	// IsCreateProcedureContext differentiates from other interfaces.
	IsCreateProcedureContext()
}

type CreateProcedureContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateProcedureContext() *CreateProcedureContext {
	var p = new(CreateProcedureContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_createProcedure
	return p
}

func (*CreateProcedureContext) IsCreateProcedureContext() {}

func NewCreateProcedureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateProcedureContext {
	var p = new(CreateProcedureContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createProcedure

	return p
}

func (s *CreateProcedureContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateProcedureContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateProcedureContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROCEDURE, 0)
}

func (s *CreateProcedureContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *CreateProcedureContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CreateProcedureContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CreateProcedureContext) RoutineBody() IRoutineBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineBodyContext)
}

func (s *CreateProcedureContext) OwnerStatement() IOwnerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOwnerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOwnerStatementContext)
}

func (s *CreateProcedureContext) AllProcedureParameter() []IProcedureParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureParameterContext); ok {
			len++
		}
	}

	tst := make([]IProcedureParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureParameterContext); ok {
			tst[i] = t.(IProcedureParameterContext)
			i++
		}
	}

	return tst
}

func (s *CreateProcedureContext) ProcedureParameter(i int) IProcedureParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureParameterContext)
}

func (s *CreateProcedureContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *CreateProcedureContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *CreateProcedureContext) AllRoutineOption() []IRoutineOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoutineOptionContext); ok {
			len++
		}
	}

	tst := make([]IRoutineOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoutineOptionContext); ok {
			tst[i] = t.(IRoutineOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateProcedureContext) RoutineOption(i int) IRoutineOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineOptionContext)
}

func (s *CreateProcedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateProcedureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateProcedureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateProcedure(s)
	}
}

func (s *CreateProcedureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateProcedure(s)
	}
}

func (p *MySqlParser) CreateProcedure() (localctx ICreateProcedureContext) {
	this := p
	_ = this

	localctx = NewCreateProcedureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, MySqlParserRULE_createProcedure)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1013)
		p.Match(MySqlParserCREATE)
	}
	p.SetState(1015)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserDEFINER {
		{
			p.SetState(1014)
			p.OwnerStatement()
		}

	}
	{
		p.SetState(1017)
		p.Match(MySqlParserPROCEDURE)
	}
	{
		p.SetState(1018)
		p.FullId()
	}
	{
		p.SetState(1019)
		p.Match(MySqlParserLR_BRACKET)
	}
	p.SetState(1021)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&756891332513120256) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&151169654698547409) != 0) || ((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&134349441) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-2882305960540372993) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-4398063288321) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-16325548649218049) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-81064793296864001) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-68719476801) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-11118270170269697) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-33) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-3073) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&144115188075855871) != 0) || ((int64((_la-1121)) & ^0x3f) == 0 && ((int64(1)<<(_la-1121))&25807552513) != 0) {
		{
			p.SetState(1020)
			p.ProcedureParameter()
		}

	}
	p.SetState(1027)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(1023)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(1024)
			p.ProcedureParameter()
		}

		p.SetState(1029)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1030)
		p.Match(MySqlParserRR_BRACKET)
	}
	p.SetState(1034)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1031)
				p.RoutineOption()
			}

		}
		p.SetState(1036)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext())
	}
	{
		p.SetState(1037)
		p.RoutineBody()
	}

	return localctx
}

// ICreateFunctionContext is an interface to support dynamic dispatch.
type ICreateFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	FullId() IFullIdContext
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	RETURNS() antlr.TerminalNode
	DataType() IDataTypeContext
	RoutineBody() IRoutineBodyContext
	ReturnStatement() IReturnStatementContext
	OwnerStatement() IOwnerStatementContext
	AGGREGATE() antlr.TerminalNode
	IfNotExists() IIfNotExistsContext
	AllFunctionParameter() []IFunctionParameterContext
	FunctionParameter(i int) IFunctionParameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllRoutineOption() []IRoutineOptionContext
	RoutineOption(i int) IRoutineOptionContext

	// IsCreateFunctionContext differentiates from other interfaces.
	IsCreateFunctionContext()
}

type CreateFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateFunctionContext() *CreateFunctionContext {
	var p = new(CreateFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_createFunction
	return p
}

func (*CreateFunctionContext) IsCreateFunctionContext() {}

func NewCreateFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateFunctionContext {
	var p = new(CreateFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createFunction

	return p
}

func (s *CreateFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateFunctionContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserFUNCTION, 0)
}

func (s *CreateFunctionContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *CreateFunctionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CreateFunctionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CreateFunctionContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(MySqlParserRETURNS, 0)
}

func (s *CreateFunctionContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *CreateFunctionContext) RoutineBody() IRoutineBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineBodyContext)
}

func (s *CreateFunctionContext) ReturnStatement() IReturnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *CreateFunctionContext) OwnerStatement() IOwnerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOwnerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOwnerStatementContext)
}

func (s *CreateFunctionContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserAGGREGATE, 0)
}

func (s *CreateFunctionContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateFunctionContext) AllFunctionParameter() []IFunctionParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionParameterContext); ok {
			len++
		}
	}

	tst := make([]IFunctionParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionParameterContext); ok {
			tst[i] = t.(IFunctionParameterContext)
			i++
		}
	}

	return tst
}

func (s *CreateFunctionContext) FunctionParameter(i int) IFunctionParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionParameterContext)
}

func (s *CreateFunctionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *CreateFunctionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *CreateFunctionContext) AllRoutineOption() []IRoutineOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoutineOptionContext); ok {
			len++
		}
	}

	tst := make([]IRoutineOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoutineOptionContext); ok {
			tst[i] = t.(IRoutineOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateFunctionContext) RoutineOption(i int) IRoutineOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineOptionContext)
}

func (s *CreateFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateFunction(s)
	}
}

func (s *CreateFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateFunction(s)
	}
}

func (p *MySqlParser) CreateFunction() (localctx ICreateFunctionContext) {
	this := p
	_ = this

	localctx = NewCreateFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, MySqlParserRULE_createFunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1039)
		p.Match(MySqlParserCREATE)
	}
	p.SetState(1041)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserDEFINER {
		{
			p.SetState(1040)
			p.OwnerStatement()
		}

	}
	p.SetState(1044)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserAGGREGATE {
		{
			p.SetState(1043)
			p.Match(MySqlParserAGGREGATE)
		}

	}
	{
		p.SetState(1046)
		p.Match(MySqlParserFUNCTION)
	}
	p.SetState(1048)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1047)
			p.IfNotExists()
		}

	}
	{
		p.SetState(1050)
		p.FullId()
	}
	{
		p.SetState(1051)
		p.Match(MySqlParserLR_BRACKET)
	}
	p.SetState(1053)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&756891332513120256) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&146666055071174737) != 0) || ((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&134349441) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-2882305960540372993) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-4398063288321) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-16325548649218049) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-81064793296864001) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-68719476801) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-11118270170269697) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-33) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-3073) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&144115188075855871) != 0) || ((int64((_la-1121)) & ^0x3f) == 0 && ((int64(1)<<(_la-1121))&25807552513) != 0) {
		{
			p.SetState(1052)
			p.FunctionParameter()
		}

	}
	p.SetState(1059)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(1055)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(1056)
			p.FunctionParameter()
		}

		p.SetState(1061)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1062)
		p.Match(MySqlParserRR_BRACKET)
	}
	{
		p.SetState(1063)
		p.Match(MySqlParserRETURNS)
	}
	{
		p.SetState(1064)
		p.DataType()
	}
	p.SetState(1068)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1065)
				p.RoutineOption()
			}

		}
		p.SetState(1070)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext())
	}
	p.SetState(1073)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserALTER, MySqlParserANALYZE, MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCALL, MySqlParserCHANGE, MySqlParserCHECK, MySqlParserCONDITION, MySqlParserCREATE, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDELETE, MySqlParserDESC, MySqlParserDESCRIBE, MySqlParserDIAGNOSTICS, MySqlParserDROP, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserEXPLAIN, MySqlParserGET, MySqlParserGRANT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserKILL, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserLOAD, MySqlParserLOCK, MySqlParserNUMBER, MySqlParserOPTIMIZE, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserPURGE, MySqlParserRELEASE, MySqlParserRENAME, MySqlParserREPLACE, MySqlParserRESIGNAL, MySqlParserREVOKE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSELECT, MySqlParserSET, MySqlParserSHOW, MySqlParserSIGNAL, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserUNLOCK, MySqlParserUPDATE, MySqlParserUSE, MySqlParserVALUES, MySqlParserWITH, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserLR_BRACKET, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID, MySqlParserREVERSE_QUOTE_ID:
		{
			p.SetState(1071)
			p.RoutineBody()
		}

	case MySqlParserRETURN:
		{
			p.SetState(1072)
			p.ReturnStatement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICreateRoleContext is an interface to support dynamic dispatch.
type ICreateRoleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	AllRoleName() []IRoleNameContext
	RoleName(i int) IRoleNameContext
	IfNotExists() IIfNotExistsContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCreateRoleContext differentiates from other interfaces.
	IsCreateRoleContext()
}

type CreateRoleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateRoleContext() *CreateRoleContext {
	var p = new(CreateRoleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_createRole
	return p
}

func (*CreateRoleContext) IsCreateRoleContext() {}

func NewCreateRoleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateRoleContext {
	var p = new(CreateRoleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createRole

	return p
}

func (s *CreateRoleContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateRoleContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLE, 0)
}

func (s *CreateRoleContext) AllRoleName() []IRoleNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoleNameContext); ok {
			len++
		}
	}

	tst := make([]IRoleNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoleNameContext); ok {
			tst[i] = t.(IRoleNameContext)
			i++
		}
	}

	return tst
}

func (s *CreateRoleContext) RoleName(i int) IRoleNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleNameContext)
}

func (s *CreateRoleContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateRoleContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *CreateRoleContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *CreateRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRoleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateRole(s)
	}
}

func (s *CreateRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateRole(s)
	}
}

func (p *MySqlParser) CreateRole() (localctx ICreateRoleContext) {
	this := p
	_ = this

	localctx = NewCreateRoleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, MySqlParserRULE_createRole)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1075)
		p.Match(MySqlParserCREATE)
	}
	{
		p.SetState(1076)
		p.Match(MySqlParserROLE)
	}
	p.SetState(1078)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1077)
			p.IfNotExists()
		}

	}
	{
		p.SetState(1080)
		p.RoleName()
	}
	p.SetState(1085)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(1081)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(1082)
			p.RoleName()
		}

		p.SetState(1087)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICreateServerContext is an interface to support dynamic dispatch.
type ICreateServerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWrapperName returns the wrapperName token.
	GetWrapperName() antlr.Token

	// SetWrapperName sets the wrapperName token.
	SetWrapperName(antlr.Token)

	// Getter signatures
	CREATE() antlr.TerminalNode
	SERVER() antlr.TerminalNode
	Uid() IUidContext
	FOREIGN() antlr.TerminalNode
	DATA() antlr.TerminalNode
	WRAPPER() antlr.TerminalNode
	OPTIONS() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	AllServerOption() []IServerOptionContext
	ServerOption(i int) IServerOptionContext
	RR_BRACKET() antlr.TerminalNode
	MYSQL() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCreateServerContext differentiates from other interfaces.
	IsCreateServerContext()
}

type CreateServerContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	wrapperName antlr.Token
}

func NewEmptyCreateServerContext() *CreateServerContext {
	var p = new(CreateServerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_createServer
	return p
}

func (*CreateServerContext) IsCreateServerContext() {}

func NewCreateServerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateServerContext {
	var p = new(CreateServerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createServer

	return p
}

func (s *CreateServerContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateServerContext) GetWrapperName() antlr.Token { return s.wrapperName }

func (s *CreateServerContext) SetWrapperName(v antlr.Token) { s.wrapperName = v }

func (s *CreateServerContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateServerContext) SERVER() antlr.TerminalNode {
	return s.GetToken(MySqlParserSERVER, 0)
}

func (s *CreateServerContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CreateServerContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOREIGN, 0)
}

func (s *CreateServerContext) DATA() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATA, 0)
}

func (s *CreateServerContext) WRAPPER() antlr.TerminalNode {
	return s.GetToken(MySqlParserWRAPPER, 0)
}

func (s *CreateServerContext) OPTIONS() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTIONS, 0)
}

func (s *CreateServerContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CreateServerContext) AllServerOption() []IServerOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IServerOptionContext); ok {
			len++
		}
	}

	tst := make([]IServerOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IServerOptionContext); ok {
			tst[i] = t.(IServerOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateServerContext) ServerOption(i int) IServerOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IServerOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IServerOptionContext)
}

func (s *CreateServerContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CreateServerContext) MYSQL() antlr.TerminalNode {
	return s.GetToken(MySqlParserMYSQL, 0)
}

func (s *CreateServerContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *CreateServerContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *CreateServerContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *CreateServerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateServerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateServerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateServer(s)
	}
}

func (s *CreateServerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateServer(s)
	}
}

func (p *MySqlParser) CreateServer() (localctx ICreateServerContext) {
	this := p
	_ = this

	localctx = NewCreateServerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, MySqlParserRULE_createServer)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1088)
		p.Match(MySqlParserCREATE)
	}
	{
		p.SetState(1089)
		p.Match(MySqlParserSERVER)
	}
	{
		p.SetState(1090)
		p.Uid()
	}
	{
		p.SetState(1091)
		p.Match(MySqlParserFOREIGN)
	}
	{
		p.SetState(1092)
		p.Match(MySqlParserDATA)
	}
	{
		p.SetState(1093)
		p.Match(MySqlParserWRAPPER)
	}
	{
		p.SetState(1094)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*CreateServerContext).wrapperName = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserMYSQL || _la == MySqlParserSTRING_LITERAL) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*CreateServerContext).wrapperName = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1095)
		p.Match(MySqlParserOPTIONS)
	}
	{
		p.SetState(1096)
		p.Match(MySqlParserLR_BRACKET)
	}
	{
		p.SetState(1097)
		p.ServerOption()
	}
	p.SetState(1102)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(1098)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(1099)
			p.ServerOption()
		}

		p.SetState(1104)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1105)
		p.Match(MySqlParserRR_BRACKET)
	}

	return localctx
}

// ICreateTableContext is an interface to support dynamic dispatch.
type ICreateTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsCreateTableContext differentiates from other interfaces.
	IsCreateTableContext()
}

type CreateTableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTableContext() *CreateTableContext {
	var p = new(CreateTableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_createTable
	return p
}

func (*CreateTableContext) IsCreateTableContext() {}

func NewCreateTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableContext {
	var p = new(CreateTableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createTable

	return p
}

func (s *CreateTableContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableContext) CopyFrom(ctx *CreateTableContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *CreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CopyCreateTableContext struct {
	*CreateTableContext
	parenthesisTable ITableNameContext
}

func NewCopyCreateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CopyCreateTableContext {
	var p = new(CopyCreateTableContext)

	p.CreateTableContext = NewEmptyCreateTableContext()
	p.parser = parser
	p.CopyFrom(ctx.(*CreateTableContext))

	return p
}

func (s *CopyCreateTableContext) GetParenthesisTable() ITableNameContext { return s.parenthesisTable }

func (s *CopyCreateTableContext) SetParenthesisTable(v ITableNameContext) { s.parenthesisTable = v }

func (s *CopyCreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CopyCreateTableContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CopyCreateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *CopyCreateTableContext) AllTableName() []ITableNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableNameContext); ok {
			len++
		}
	}

	tst := make([]ITableNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableNameContext); ok {
			tst[i] = t.(ITableNameContext)
			i++
		}
	}

	return tst
}

func (s *CopyCreateTableContext) TableName(i int) ITableNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *CopyCreateTableContext) LIKE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIKE, 0)
}

func (s *CopyCreateTableContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CopyCreateTableContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CopyCreateTableContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserTEMPORARY, 0)
}

func (s *CopyCreateTableContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CopyCreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCopyCreateTable(s)
	}
}

func (s *CopyCreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCopyCreateTable(s)
	}
}

type ColumnCreateTableContext struct {
	*CreateTableContext
}

func NewColumnCreateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnCreateTableContext {
	var p = new(ColumnCreateTableContext)

	p.CreateTableContext = NewEmptyCreateTableContext()
	p.parser = parser
	p.CopyFrom(ctx.(*CreateTableContext))

	return p
}

func (s *ColumnCreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnCreateTableContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *ColumnCreateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *ColumnCreateTableContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *ColumnCreateTableContext) CreateDefinitions() ICreateDefinitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDefinitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDefinitionsContext)
}

func (s *ColumnCreateTableContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserTEMPORARY, 0)
}

func (s *ColumnCreateTableContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *ColumnCreateTableContext) AllTableOption() []ITableOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableOptionContext); ok {
			len++
		}
	}

	tst := make([]ITableOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableOptionContext); ok {
			tst[i] = t.(ITableOptionContext)
			i++
		}
	}

	return tst
}

func (s *ColumnCreateTableContext) TableOption(i int) ITableOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOptionContext)
}

func (s *ColumnCreateTableContext) PartitionDefinitions() IPartitionDefinitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinitionsContext)
}

func (s *ColumnCreateTableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *ColumnCreateTableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *ColumnCreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterColumnCreateTable(s)
	}
}

func (s *ColumnCreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitColumnCreateTable(s)
	}
}

type QueryCreateTableContext struct {
	*CreateTableContext
	keyViolate antlr.Token
}

func NewQueryCreateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryCreateTableContext {
	var p = new(QueryCreateTableContext)

	p.CreateTableContext = NewEmptyCreateTableContext()
	p.parser = parser
	p.CopyFrom(ctx.(*CreateTableContext))

	return p
}

func (s *QueryCreateTableContext) GetKeyViolate() antlr.Token { return s.keyViolate }

func (s *QueryCreateTableContext) SetKeyViolate(v antlr.Token) { s.keyViolate = v }

func (s *QueryCreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryCreateTableContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *QueryCreateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *QueryCreateTableContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *QueryCreateTableContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *QueryCreateTableContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserTEMPORARY, 0)
}

func (s *QueryCreateTableContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *QueryCreateTableContext) CreateDefinitions() ICreateDefinitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDefinitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDefinitionsContext)
}

func (s *QueryCreateTableContext) AllTableOption() []ITableOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableOptionContext); ok {
			len++
		}
	}

	tst := make([]ITableOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableOptionContext); ok {
			tst[i] = t.(ITableOptionContext)
			i++
		}
	}

	return tst
}

func (s *QueryCreateTableContext) TableOption(i int) ITableOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOptionContext)
}

func (s *QueryCreateTableContext) PartitionDefinitions() IPartitionDefinitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinitionsContext)
}

func (s *QueryCreateTableContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *QueryCreateTableContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE, 0)
}

func (s *QueryCreateTableContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLACE, 0)
}

func (s *QueryCreateTableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *QueryCreateTableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *QueryCreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterQueryCreateTable(s)
	}
}

func (s *QueryCreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitQueryCreateTable(s)
	}
}

func (p *MySqlParser) CreateTable() (localctx ICreateTableContext) {
	this := p
	_ = this

	localctx = NewCreateTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, MySqlParserRULE_createTable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1185)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCopyCreateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1107)
			p.Match(MySqlParserCREATE)
		}
		p.SetState(1109)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserTEMPORARY {
			{
				p.SetState(1108)
				p.Match(MySqlParserTEMPORARY)
			}

		}
		{
			p.SetState(1111)
			p.Match(MySqlParserTABLE)
		}
		p.SetState(1113)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 61, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1112)
				p.IfNotExists()
			}

		}
		{
			p.SetState(1115)
			p.TableName()
		}
		p.SetState(1123)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserLIKE:
			{
				p.SetState(1116)
				p.Match(MySqlParserLIKE)
			}
			{
				p.SetState(1117)
				p.TableName()
			}

		case MySqlParserLR_BRACKET:
			{
				p.SetState(1118)
				p.Match(MySqlParserLR_BRACKET)
			}
			{
				p.SetState(1119)
				p.Match(MySqlParserLIKE)
			}
			{
				p.SetState(1120)

				var _x = p.TableName()

				localctx.(*CopyCreateTableContext).parenthesisTable = _x
			}
			{
				p.SetState(1121)
				p.Match(MySqlParserRR_BRACKET)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 2:
		localctx = NewQueryCreateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1125)
			p.Match(MySqlParserCREATE)
		}
		p.SetState(1127)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserTEMPORARY {
			{
				p.SetState(1126)
				p.Match(MySqlParserTEMPORARY)
			}

		}
		{
			p.SetState(1129)
			p.Match(MySqlParserTABLE)
		}
		p.SetState(1131)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1130)
				p.IfNotExists()
			}

		}
		{
			p.SetState(1133)
			p.TableName()
		}
		p.SetState(1135)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1134)
				p.CreateDefinitions()
			}

		}
		p.SetState(1147)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-25)) & ^0x3f) == 0 && ((int64(1)<<(_la-25))&72057594038059013) != 0) || _la == MySqlParserUNION || _la == MySqlParserCHAR || ((int64((_la-341)) & ^0x3f) == 0 && ((int64(1)<<(_la-341))&4644375904747527) != 0) || ((int64((_la-405)) & ^0x3f) == 0 && ((int64(1)<<(_la-405))&4612811918334230547) != 0) || ((int64((_la-500)) & ^0x3f) == 0 && ((int64(1)<<(_la-500))&2366149022974977) != 0) || ((int64((_la-602)) & ^0x3f) == 0 && ((int64(1)<<(_la-602))&4609173815820289) != 0) || _la == MySqlParserCHARSET || _la == MySqlParserENGINE_ATTRIBUTE || _la == MySqlParserSECONDARY_ENGINE_ATTRIBUTE || _la == MySqlParserSTRING_LITERAL {
			{
				p.SetState(1137)
				p.TableOption()
			}
			p.SetState(1144)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for ((int64((_la-25)) & ^0x3f) == 0 && ((int64(1)<<(_la-25))&72057594038059013) != 0) || _la == MySqlParserUNION || _la == MySqlParserCHAR || ((int64((_la-341)) & ^0x3f) == 0 && ((int64(1)<<(_la-341))&4644375904747527) != 0) || ((int64((_la-405)) & ^0x3f) == 0 && ((int64(1)<<(_la-405))&4612811918334230547) != 0) || ((int64((_la-500)) & ^0x3f) == 0 && ((int64(1)<<(_la-500))&2366149022974977) != 0) || ((int64((_la-602)) & ^0x3f) == 0 && ((int64(1)<<(_la-602))&4609173815820289) != 0) || _la == MySqlParserCHARSET || _la == MySqlParserENGINE_ATTRIBUTE || _la == MySqlParserSECONDARY_ENGINE_ATTRIBUTE || _la == MySqlParserCOMMA || _la == MySqlParserSTRING_LITERAL {
				p.SetState(1139)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == MySqlParserCOMMA {
					{
						p.SetState(1138)
						p.Match(MySqlParserCOMMA)
					}

				}
				{
					p.SetState(1141)
					p.TableOption()
				}

				p.SetState(1146)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(1150)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserPARTITION {
			{
				p.SetState(1149)
				p.PartitionDefinitions()
			}

		}
		p.SetState(1153)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserIGNORE || _la == MySqlParserREPLACE {
			{
				p.SetState(1152)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*QueryCreateTableContext).keyViolate = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserIGNORE || _la == MySqlParserREPLACE) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*QueryCreateTableContext).keyViolate = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1156)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserAS {
			{
				p.SetState(1155)
				p.Match(MySqlParserAS)
			}

		}
		{
			p.SetState(1158)
			p.SelectStatement()
		}

	case 3:
		localctx = NewColumnCreateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1160)
			p.Match(MySqlParserCREATE)
		}
		p.SetState(1162)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserTEMPORARY {
			{
				p.SetState(1161)
				p.Match(MySqlParserTEMPORARY)
			}

		}
		{
			p.SetState(1164)
			p.Match(MySqlParserTABLE)
		}
		p.SetState(1166)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1165)
				p.IfNotExists()
			}

		}
		{
			p.SetState(1168)
			p.TableName()
		}
		{
			p.SetState(1169)
			p.CreateDefinitions()
		}
		p.SetState(1180)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1170)
				p.TableOption()
			}
			p.SetState(1177)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					p.SetState(1172)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)

					if _la == MySqlParserCOMMA {
						{
							p.SetState(1171)
							p.Match(MySqlParserCOMMA)
						}

					}
					{
						p.SetState(1174)
						p.TableOption()
					}

				}
				p.SetState(1179)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext())
			}

		}
		p.SetState(1183)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserPARTITION {
			{
				p.SetState(1182)
				p.PartitionDefinitions()
			}

		}

	}

	return localctx
}

// ICreateTablespaceInnodbContext is an interface to support dynamic dispatch.
type ICreateTablespaceInnodbContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDatafile returns the datafile token.
	GetDatafile() antlr.Token

	// SetDatafile sets the datafile token.
	SetDatafile(antlr.Token)

	// GetFileBlockSize returns the fileBlockSize rule contexts.
	GetFileBlockSize() IFileSizeLiteralContext

	// SetFileBlockSize sets the fileBlockSize rule contexts.
	SetFileBlockSize(IFileSizeLiteralContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	TABLESPACE() antlr.TerminalNode
	Uid() IUidContext
	ADD() antlr.TerminalNode
	DATAFILE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	FILE_BLOCK_SIZE() antlr.TerminalNode
	AllEQUAL_SYMBOL() []antlr.TerminalNode
	EQUAL_SYMBOL(i int) antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	EngineName() IEngineNameContext
	FileSizeLiteral() IFileSizeLiteralContext

	// IsCreateTablespaceInnodbContext differentiates from other interfaces.
	IsCreateTablespaceInnodbContext()
}

type CreateTablespaceInnodbContext struct {
	*antlr.BaseParserRuleContext
	parser        antlr.Parser
	datafile      antlr.Token
	fileBlockSize IFileSizeLiteralContext
}

func NewEmptyCreateTablespaceInnodbContext() *CreateTablespaceInnodbContext {
	var p = new(CreateTablespaceInnodbContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_createTablespaceInnodb
	return p
}

func (*CreateTablespaceInnodbContext) IsCreateTablespaceInnodbContext() {}

func NewCreateTablespaceInnodbContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTablespaceInnodbContext {
	var p = new(CreateTablespaceInnodbContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createTablespaceInnodb

	return p
}

func (s *CreateTablespaceInnodbContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTablespaceInnodbContext) GetDatafile() antlr.Token { return s.datafile }

func (s *CreateTablespaceInnodbContext) SetDatafile(v antlr.Token) { s.datafile = v }

func (s *CreateTablespaceInnodbContext) GetFileBlockSize() IFileSizeLiteralContext {
	return s.fileBlockSize
}

func (s *CreateTablespaceInnodbContext) SetFileBlockSize(v IFileSizeLiteralContext) {
	s.fileBlockSize = v
}

func (s *CreateTablespaceInnodbContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateTablespaceInnodbContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLESPACE, 0)
}

func (s *CreateTablespaceInnodbContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CreateTablespaceInnodbContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *CreateTablespaceInnodbContext) DATAFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATAFILE, 0)
}

func (s *CreateTablespaceInnodbContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *CreateTablespaceInnodbContext) FILE_BLOCK_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFILE_BLOCK_SIZE, 0)
}

func (s *CreateTablespaceInnodbContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *CreateTablespaceInnodbContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *CreateTablespaceInnodbContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE, 0)
}

func (s *CreateTablespaceInnodbContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *CreateTablespaceInnodbContext) FileSizeLiteral() IFileSizeLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileSizeLiteralContext)
}

func (s *CreateTablespaceInnodbContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTablespaceInnodbContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTablespaceInnodbContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateTablespaceInnodb(s)
	}
}

func (s *CreateTablespaceInnodbContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateTablespaceInnodb(s)
	}
}

func (p *MySqlParser) CreateTablespaceInnodb() (localctx ICreateTablespaceInnodbContext) {
	this := p
	_ = this

	localctx = NewCreateTablespaceInnodbContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, MySqlParserRULE_createTablespaceInnodb)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1187)
		p.Match(MySqlParserCREATE)
	}
	{
		p.SetState(1188)
		p.Match(MySqlParserTABLESPACE)
	}
	{
		p.SetState(1189)
		p.Uid()
	}
	{
		p.SetState(1190)
		p.Match(MySqlParserADD)
	}
	{
		p.SetState(1191)
		p.Match(MySqlParserDATAFILE)
	}
	{
		p.SetState(1192)

		var _m = p.Match(MySqlParserSTRING_LITERAL)

		localctx.(*CreateTablespaceInnodbContext).datafile = _m
	}
	p.SetState(1196)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserFILE_BLOCK_SIZE {
		{
			p.SetState(1193)
			p.Match(MySqlParserFILE_BLOCK_SIZE)
		}
		{
			p.SetState(1194)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}
		{
			p.SetState(1195)

			var _x = p.FileSizeLiteral()

			localctx.(*CreateTablespaceInnodbContext).fileBlockSize = _x
		}

	}
	p.SetState(1203)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserENGINE {
		{
			p.SetState(1198)
			p.Match(MySqlParserENGINE)
		}
		p.SetState(1200)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1199)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1202)
			p.EngineName()
		}

	}

	return localctx
}

// ICreateTablespaceNdbContext is an interface to support dynamic dispatch.
type ICreateTablespaceNdbContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDatafile returns the datafile token.
	GetDatafile() antlr.Token

	// GetComment returns the comment token.
	GetComment() antlr.Token

	// SetDatafile sets the datafile token.
	SetDatafile(antlr.Token)

	// SetComment sets the comment token.
	SetComment(antlr.Token)

	// GetExtentSize returns the extentSize rule contexts.
	GetExtentSize() IFileSizeLiteralContext

	// GetInitialSize returns the initialSize rule contexts.
	GetInitialSize() IFileSizeLiteralContext

	// GetAutoextendSize returns the autoextendSize rule contexts.
	GetAutoextendSize() IFileSizeLiteralContext

	// GetMaxSize returns the maxSize rule contexts.
	GetMaxSize() IFileSizeLiteralContext

	// SetExtentSize sets the extentSize rule contexts.
	SetExtentSize(IFileSizeLiteralContext)

	// SetInitialSize sets the initialSize rule contexts.
	SetInitialSize(IFileSizeLiteralContext)

	// SetAutoextendSize sets the autoextendSize rule contexts.
	SetAutoextendSize(IFileSizeLiteralContext)

	// SetMaxSize sets the maxSize rule contexts.
	SetMaxSize(IFileSizeLiteralContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	TABLESPACE() antlr.TerminalNode
	AllUid() []IUidContext
	Uid(i int) IUidContext
	ADD() antlr.TerminalNode
	DATAFILE() antlr.TerminalNode
	USE() antlr.TerminalNode
	LOGFILE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	EngineName() IEngineNameContext
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	EXTENT_SIZE() antlr.TerminalNode
	INITIAL_SIZE() antlr.TerminalNode
	AUTOEXTEND_SIZE() antlr.TerminalNode
	MAX_SIZE() antlr.TerminalNode
	NODEGROUP() antlr.TerminalNode
	WAIT() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	AllEQUAL_SYMBOL() []antlr.TerminalNode
	EQUAL_SYMBOL(i int) antlr.TerminalNode
	AllFileSizeLiteral() []IFileSizeLiteralContext
	FileSizeLiteral(i int) IFileSizeLiteralContext

	// IsCreateTablespaceNdbContext differentiates from other interfaces.
	IsCreateTablespaceNdbContext()
}

type CreateTablespaceNdbContext struct {
	*antlr.BaseParserRuleContext
	parser         antlr.Parser
	datafile       antlr.Token
	extentSize     IFileSizeLiteralContext
	initialSize    IFileSizeLiteralContext
	autoextendSize IFileSizeLiteralContext
	maxSize        IFileSizeLiteralContext
	comment        antlr.Token
}

func NewEmptyCreateTablespaceNdbContext() *CreateTablespaceNdbContext {
	var p = new(CreateTablespaceNdbContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_createTablespaceNdb
	return p
}

func (*CreateTablespaceNdbContext) IsCreateTablespaceNdbContext() {}

func NewCreateTablespaceNdbContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTablespaceNdbContext {
	var p = new(CreateTablespaceNdbContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createTablespaceNdb

	return p
}

func (s *CreateTablespaceNdbContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTablespaceNdbContext) GetDatafile() antlr.Token { return s.datafile }

func (s *CreateTablespaceNdbContext) GetComment() antlr.Token { return s.comment }

func (s *CreateTablespaceNdbContext) SetDatafile(v antlr.Token) { s.datafile = v }

func (s *CreateTablespaceNdbContext) SetComment(v antlr.Token) { s.comment = v }

func (s *CreateTablespaceNdbContext) GetExtentSize() IFileSizeLiteralContext { return s.extentSize }

func (s *CreateTablespaceNdbContext) GetInitialSize() IFileSizeLiteralContext { return s.initialSize }

func (s *CreateTablespaceNdbContext) GetAutoextendSize() IFileSizeLiteralContext {
	return s.autoextendSize
}

func (s *CreateTablespaceNdbContext) GetMaxSize() IFileSizeLiteralContext { return s.maxSize }

func (s *CreateTablespaceNdbContext) SetExtentSize(v IFileSizeLiteralContext) { s.extentSize = v }

func (s *CreateTablespaceNdbContext) SetInitialSize(v IFileSizeLiteralContext) { s.initialSize = v }

func (s *CreateTablespaceNdbContext) SetAutoextendSize(v IFileSizeLiteralContext) {
	s.autoextendSize = v
}

func (s *CreateTablespaceNdbContext) SetMaxSize(v IFileSizeLiteralContext) { s.maxSize = v }

func (s *CreateTablespaceNdbContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateTablespaceNdbContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLESPACE, 0)
}

func (s *CreateTablespaceNdbContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *CreateTablespaceNdbContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CreateTablespaceNdbContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *CreateTablespaceNdbContext) DATAFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATAFILE, 0)
}

func (s *CreateTablespaceNdbContext) USE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSE, 0)
}

func (s *CreateTablespaceNdbContext) LOGFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOGFILE, 0)
}

func (s *CreateTablespaceNdbContext) GROUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP, 0)
}

func (s *CreateTablespaceNdbContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE, 0)
}

func (s *CreateTablespaceNdbContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *CreateTablespaceNdbContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSTRING_LITERAL)
}

func (s *CreateTablespaceNdbContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, i)
}

func (s *CreateTablespaceNdbContext) EXTENT_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXTENT_SIZE, 0)
}

func (s *CreateTablespaceNdbContext) INITIAL_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINITIAL_SIZE, 0)
}

func (s *CreateTablespaceNdbContext) AUTOEXTEND_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUTOEXTEND_SIZE, 0)
}

func (s *CreateTablespaceNdbContext) MAX_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_SIZE, 0)
}

func (s *CreateTablespaceNdbContext) NODEGROUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserNODEGROUP, 0)
}

func (s *CreateTablespaceNdbContext) WAIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserWAIT, 0)
}

func (s *CreateTablespaceNdbContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT, 0)
}

func (s *CreateTablespaceNdbContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *CreateTablespaceNdbContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *CreateTablespaceNdbContext) AllFileSizeLiteral() []IFileSizeLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			len++
		}
	}

	tst := make([]IFileSizeLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFileSizeLiteralContext); ok {
			tst[i] = t.(IFileSizeLiteralContext)
			i++
		}
	}

	return tst
}

func (s *CreateTablespaceNdbContext) FileSizeLiteral(i int) IFileSizeLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileSizeLiteralContext)
}

func (s *CreateTablespaceNdbContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTablespaceNdbContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTablespaceNdbContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateTablespaceNdb(s)
	}
}

func (s *CreateTablespaceNdbContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateTablespaceNdb(s)
	}
}

func (p *MySqlParser) CreateTablespaceNdb() (localctx ICreateTablespaceNdbContext) {
	this := p
	_ = this

	localctx = NewCreateTablespaceNdbContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, MySqlParserRULE_createTablespaceNdb)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1205)
		p.Match(MySqlParserCREATE)
	}
	{
		p.SetState(1206)
		p.Match(MySqlParserTABLESPACE)
	}
	{
		p.SetState(1207)
		p.Uid()
	}
	{
		p.SetState(1208)
		p.Match(MySqlParserADD)
	}
	{
		p.SetState(1209)
		p.Match(MySqlParserDATAFILE)
	}
	{
		p.SetState(1210)

		var _m = p.Match(MySqlParserSTRING_LITERAL)

		localctx.(*CreateTablespaceNdbContext).datafile = _m
	}
	{
		p.SetState(1211)
		p.Match(MySqlParserUSE)
	}
	{
		p.SetState(1212)
		p.Match(MySqlParserLOGFILE)
	}
	{
		p.SetState(1213)
		p.Match(MySqlParserGROUP)
	}
	{
		p.SetState(1214)
		p.Uid()
	}
	p.SetState(1220)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserEXTENT_SIZE {
		{
			p.SetState(1215)
			p.Match(MySqlParserEXTENT_SIZE)
		}
		p.SetState(1217)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1216)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1219)

			var _x = p.FileSizeLiteral()

			localctx.(*CreateTablespaceNdbContext).extentSize = _x
		}

	}
	p.SetState(1227)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserINITIAL_SIZE {
		{
			p.SetState(1222)
			p.Match(MySqlParserINITIAL_SIZE)
		}
		p.SetState(1224)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1223)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1226)

			var _x = p.FileSizeLiteral()

			localctx.(*CreateTablespaceNdbContext).initialSize = _x
		}

	}
	p.SetState(1234)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserAUTOEXTEND_SIZE {
		{
			p.SetState(1229)
			p.Match(MySqlParserAUTOEXTEND_SIZE)
		}
		p.SetState(1231)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1230)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1233)

			var _x = p.FileSizeLiteral()

			localctx.(*CreateTablespaceNdbContext).autoextendSize = _x
		}

	}
	p.SetState(1241)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserMAX_SIZE {
		{
			p.SetState(1236)
			p.Match(MySqlParserMAX_SIZE)
		}
		p.SetState(1238)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1237)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1240)

			var _x = p.FileSizeLiteral()

			localctx.(*CreateTablespaceNdbContext).maxSize = _x
		}

	}
	p.SetState(1248)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserNODEGROUP {
		{
			p.SetState(1243)
			p.Match(MySqlParserNODEGROUP)
		}
		p.SetState(1245)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1244)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1247)
			p.Uid()
		}

	}
	p.SetState(1251)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserWAIT {
		{
			p.SetState(1250)
			p.Match(MySqlParserWAIT)
		}

	}
	p.SetState(1258)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserCOMMENT {
		{
			p.SetState(1253)
			p.Match(MySqlParserCOMMENT)
		}
		p.SetState(1255)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1254)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1257)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*CreateTablespaceNdbContext).comment = _m
		}

	}
	{
		p.SetState(1260)
		p.Match(MySqlParserENGINE)
	}
	p.SetState(1262)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserEQUAL_SYMBOL {
		{
			p.SetState(1261)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}

	}
	{
		p.SetState(1264)
		p.EngineName()
	}

	return localctx
}

// ICreateTriggerContext is an interface to support dynamic dispatch.
type ICreateTriggerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTriggerTime returns the triggerTime token.
	GetTriggerTime() antlr.Token

	// GetTriggerEvent returns the triggerEvent token.
	GetTriggerEvent() antlr.Token

	// GetTriggerPlace returns the triggerPlace token.
	GetTriggerPlace() antlr.Token

	// SetTriggerTime sets the triggerTime token.
	SetTriggerTime(antlr.Token)

	// SetTriggerEvent sets the triggerEvent token.
	SetTriggerEvent(antlr.Token)

	// SetTriggerPlace sets the triggerPlace token.
	SetTriggerPlace(antlr.Token)

	// GetThisTrigger returns the thisTrigger rule contexts.
	GetThisTrigger() IFullIdContext

	// GetOtherTrigger returns the otherTrigger rule contexts.
	GetOtherTrigger() IFullIdContext

	// SetThisTrigger sets the thisTrigger rule contexts.
	SetThisTrigger(IFullIdContext)

	// SetOtherTrigger sets the otherTrigger rule contexts.
	SetOtherTrigger(IFullIdContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	TRIGGER() antlr.TerminalNode
	ON() antlr.TerminalNode
	TableName() ITableNameContext
	FOR() antlr.TerminalNode
	EACH() antlr.TerminalNode
	ROW() antlr.TerminalNode
	RoutineBody() IRoutineBodyContext
	AllFullId() []IFullIdContext
	FullId(i int) IFullIdContext
	BEFORE() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	INSERT() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	OwnerStatement() IOwnerStatementContext
	FOLLOWS() antlr.TerminalNode
	PRECEDES() antlr.TerminalNode

	// IsCreateTriggerContext differentiates from other interfaces.
	IsCreateTriggerContext()
}

type CreateTriggerContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	thisTrigger  IFullIdContext
	triggerTime  antlr.Token
	triggerEvent antlr.Token
	triggerPlace antlr.Token
	otherTrigger IFullIdContext
}

func NewEmptyCreateTriggerContext() *CreateTriggerContext {
	var p = new(CreateTriggerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_createTrigger
	return p
}

func (*CreateTriggerContext) IsCreateTriggerContext() {}

func NewCreateTriggerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTriggerContext {
	var p = new(CreateTriggerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createTrigger

	return p
}

func (s *CreateTriggerContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTriggerContext) GetTriggerTime() antlr.Token { return s.triggerTime }

func (s *CreateTriggerContext) GetTriggerEvent() antlr.Token { return s.triggerEvent }

func (s *CreateTriggerContext) GetTriggerPlace() antlr.Token { return s.triggerPlace }

func (s *CreateTriggerContext) SetTriggerTime(v antlr.Token) { s.triggerTime = v }

func (s *CreateTriggerContext) SetTriggerEvent(v antlr.Token) { s.triggerEvent = v }

func (s *CreateTriggerContext) SetTriggerPlace(v antlr.Token) { s.triggerPlace = v }

func (s *CreateTriggerContext) GetThisTrigger() IFullIdContext { return s.thisTrigger }

func (s *CreateTriggerContext) GetOtherTrigger() IFullIdContext { return s.otherTrigger }

func (s *CreateTriggerContext) SetThisTrigger(v IFullIdContext) { s.thisTrigger = v }

func (s *CreateTriggerContext) SetOtherTrigger(v IFullIdContext) { s.otherTrigger = v }

func (s *CreateTriggerContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateTriggerContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRIGGER, 0)
}

func (s *CreateTriggerContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *CreateTriggerContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *CreateTriggerContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *CreateTriggerContext) EACH() antlr.TerminalNode {
	return s.GetToken(MySqlParserEACH, 0)
}

func (s *CreateTriggerContext) ROW() antlr.TerminalNode {
	return s.GetToken(MySqlParserROW, 0)
}

func (s *CreateTriggerContext) RoutineBody() IRoutineBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineBodyContext)
}

func (s *CreateTriggerContext) AllFullId() []IFullIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFullIdContext); ok {
			len++
		}
	}

	tst := make([]IFullIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFullIdContext); ok {
			tst[i] = t.(IFullIdContext)
			i++
		}
	}

	return tst
}

func (s *CreateTriggerContext) FullId(i int) IFullIdContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *CreateTriggerContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(MySqlParserBEFORE, 0)
}

func (s *CreateTriggerContext) AFTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserAFTER, 0)
}

func (s *CreateTriggerContext) INSERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSERT, 0)
}

func (s *CreateTriggerContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPDATE, 0)
}

func (s *CreateTriggerContext) DELETE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDELETE, 0)
}

func (s *CreateTriggerContext) OwnerStatement() IOwnerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOwnerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOwnerStatementContext)
}

func (s *CreateTriggerContext) FOLLOWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOLLOWS, 0)
}

func (s *CreateTriggerContext) PRECEDES() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRECEDES, 0)
}

func (s *CreateTriggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTriggerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTriggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateTrigger(s)
	}
}

func (s *CreateTriggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateTrigger(s)
	}
}

func (p *MySqlParser) CreateTrigger() (localctx ICreateTriggerContext) {
	this := p
	_ = this

	localctx = NewCreateTriggerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, MySqlParserRULE_createTrigger)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1266)
		p.Match(MySqlParserCREATE)
	}
	p.SetState(1268)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserDEFINER {
		{
			p.SetState(1267)
			p.OwnerStatement()
		}

	}
	{
		p.SetState(1270)
		p.Match(MySqlParserTRIGGER)
	}
	{
		p.SetState(1271)

		var _x = p.FullId()

		localctx.(*CreateTriggerContext).thisTrigger = _x
	}
	{
		p.SetState(1272)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*CreateTriggerContext).triggerTime = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserBEFORE || _la == MySqlParserAFTER) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*CreateTriggerContext).triggerTime = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1273)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*CreateTriggerContext).triggerEvent = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserDELETE || _la == MySqlParserINSERT || _la == MySqlParserUPDATE) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*CreateTriggerContext).triggerEvent = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1274)
		p.Match(MySqlParserON)
	}
	{
		p.SetState(1275)
		p.TableName()
	}
	{
		p.SetState(1276)
		p.Match(MySqlParserFOR)
	}
	{
		p.SetState(1277)
		p.Match(MySqlParserEACH)
	}
	{
		p.SetState(1278)
		p.Match(MySqlParserROW)
	}
	p.SetState(1281)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1279)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CreateTriggerContext).triggerPlace = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFOLLOWS || _la == MySqlParserPRECEDES) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CreateTriggerContext).triggerPlace = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1280)

			var _x = p.FullId()

			localctx.(*CreateTriggerContext).otherTrigger = _x
		}

	}
	{
		p.SetState(1283)
		p.RoutineBody()
	}

	return localctx
}

// IWithClauseContext is an interface to support dynamic dispatch.
type IWithClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	CommonTableExpressions() ICommonTableExpressionsContext
	RECURSIVE() antlr.TerminalNode

	// IsWithClauseContext differentiates from other interfaces.
	IsWithClauseContext()
}

type WithClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithClauseContext() *WithClauseContext {
	var p = new(WithClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_withClause
	return p
}

func (*WithClauseContext) IsWithClauseContext() {}

func NewWithClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithClauseContext {
	var p = new(WithClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_withClause

	return p
}

func (s *WithClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WithClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *WithClauseContext) CommonTableExpressions() ICommonTableExpressionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommonTableExpressionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommonTableExpressionsContext)
}

func (s *WithClauseContext) RECURSIVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRECURSIVE, 0)
}

func (s *WithClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterWithClause(s)
	}
}

func (s *WithClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitWithClause(s)
	}
}

func (p *MySqlParser) WithClause() (localctx IWithClauseContext) {
	this := p
	_ = this

	localctx = NewWithClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, MySqlParserRULE_withClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1285)
		p.Match(MySqlParserWITH)
	}
	p.SetState(1287)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1286)
			p.Match(MySqlParserRECURSIVE)
		}

	}
	{
		p.SetState(1289)
		p.CommonTableExpressions()
	}

	return localctx
}

// ICommonTableExpressionsContext is an interface to support dynamic dispatch.
type ICommonTableExpressionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CteName() ICteNameContext
	AS() antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	DmlStatement() IDmlStatementContext
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	AllCteColumnName() []ICteColumnNameContext
	CteColumnName(i int) ICteColumnNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	CommonTableExpressions() ICommonTableExpressionsContext

	// IsCommonTableExpressionsContext differentiates from other interfaces.
	IsCommonTableExpressionsContext()
}

type CommonTableExpressionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommonTableExpressionsContext() *CommonTableExpressionsContext {
	var p = new(CommonTableExpressionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_commonTableExpressions
	return p
}

func (*CommonTableExpressionsContext) IsCommonTableExpressionsContext() {}

func NewCommonTableExpressionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommonTableExpressionsContext {
	var p = new(CommonTableExpressionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_commonTableExpressions

	return p
}

func (s *CommonTableExpressionsContext) GetParser() antlr.Parser { return s.parser }

func (s *CommonTableExpressionsContext) CteName() ICteNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICteNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICteNameContext)
}

func (s *CommonTableExpressionsContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *CommonTableExpressionsContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *CommonTableExpressionsContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *CommonTableExpressionsContext) DmlStatement() IDmlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDmlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDmlStatementContext)
}

func (s *CommonTableExpressionsContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *CommonTableExpressionsContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *CommonTableExpressionsContext) AllCteColumnName() []ICteColumnNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICteColumnNameContext); ok {
			len++
		}
	}

	tst := make([]ICteColumnNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICteColumnNameContext); ok {
			tst[i] = t.(ICteColumnNameContext)
			i++
		}
	}

	return tst
}

func (s *CommonTableExpressionsContext) CteColumnName(i int) ICteColumnNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICteColumnNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICteColumnNameContext)
}

func (s *CommonTableExpressionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *CommonTableExpressionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *CommonTableExpressionsContext) CommonTableExpressions() ICommonTableExpressionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommonTableExpressionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommonTableExpressionsContext)
}

func (s *CommonTableExpressionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommonTableExpressionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommonTableExpressionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCommonTableExpressions(s)
	}
}

func (s *CommonTableExpressionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCommonTableExpressions(s)
	}
}

func (p *MySqlParser) CommonTableExpressions() (localctx ICommonTableExpressionsContext) {
	this := p
	_ = this

	localctx = NewCommonTableExpressionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, MySqlParserRULE_commonTableExpressions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1291)
		p.CteName()
	}
	p.SetState(1303)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserLR_BRACKET {
		{
			p.SetState(1292)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(1293)
			p.CteColumnName()
		}
		p.SetState(1298)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(1294)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(1295)
				p.CteColumnName()
			}

			p.SetState(1300)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1301)
			p.Match(MySqlParserRR_BRACKET)
		}

	}
	{
		p.SetState(1305)
		p.Match(MySqlParserAS)
	}
	{
		p.SetState(1306)
		p.Match(MySqlParserLR_BRACKET)
	}
	{
		p.SetState(1307)
		p.DmlStatement()
	}
	{
		p.SetState(1308)
		p.Match(MySqlParserRR_BRACKET)
	}
	p.SetState(1311)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1309)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(1310)
			p.CommonTableExpressions()
		}

	}

	return localctx
}

// ICteNameContext is an interface to support dynamic dispatch.
type ICteNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext

	// IsCteNameContext differentiates from other interfaces.
	IsCteNameContext()
}

type CteNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCteNameContext() *CteNameContext {
	var p = new(CteNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_cteName
	return p
}

func (*CteNameContext) IsCteNameContext() {}

func NewCteNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CteNameContext {
	var p = new(CteNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_cteName

	return p
}

func (s *CteNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CteNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CteNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CteNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CteNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCteName(s)
	}
}

func (s *CteNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCteName(s)
	}
}

func (p *MySqlParser) CteName() (localctx ICteNameContext) {
	this := p
	_ = this

	localctx = NewCteNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, MySqlParserRULE_cteName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1313)
		p.Uid()
	}

	return localctx
}

// ICteColumnNameContext is an interface to support dynamic dispatch.
type ICteColumnNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext

	// IsCteColumnNameContext differentiates from other interfaces.
	IsCteColumnNameContext()
}

type CteColumnNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCteColumnNameContext() *CteColumnNameContext {
	var p = new(CteColumnNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_cteColumnName
	return p
}

func (*CteColumnNameContext) IsCteColumnNameContext() {}

func NewCteColumnNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CteColumnNameContext {
	var p = new(CteColumnNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_cteColumnName

	return p
}

func (s *CteColumnNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CteColumnNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CteColumnNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CteColumnNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CteColumnNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCteColumnName(s)
	}
}

func (s *CteColumnNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCteColumnName(s)
	}
}

func (p *MySqlParser) CteColumnName() (localctx ICteColumnNameContext) {
	this := p
	_ = this

	localctx = NewCteColumnNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, MySqlParserRULE_cteColumnName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1315)
		p.Uid()
	}

	return localctx
}

// ICreateViewContext is an interface to support dynamic dispatch.
type ICreateViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAlgType returns the algType token.
	GetAlgType() antlr.Token

	// GetSecContext returns the secContext token.
	GetSecContext() antlr.Token

	// GetCheckOption returns the checkOption token.
	GetCheckOption() antlr.Token

	// SetAlgType sets the algType token.
	SetAlgType(antlr.Token)

	// SetSecContext sets the secContext token.
	SetSecContext(antlr.Token)

	// SetCheckOption sets the checkOption token.
	SetCheckOption(antlr.Token)

	// Getter signatures
	CREATE() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	FullId() IFullIdContext
	AS() antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	SelectStatement() ISelectStatementContext
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	OrReplace() IOrReplaceContext
	ALGORITHM() antlr.TerminalNode
	EQUAL_SYMBOL() antlr.TerminalNode
	OwnerStatement() IOwnerStatementContext
	SQL() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	UidList() IUidListContext
	UNDEFINED() antlr.TerminalNode
	MERGE() antlr.TerminalNode
	TEMPTABLE() antlr.TerminalNode
	DEFINER() antlr.TerminalNode
	INVOKER() antlr.TerminalNode
	WithClause() IWithClauseContext
	WITH() antlr.TerminalNode
	CHECK() antlr.TerminalNode
	OPTION() antlr.TerminalNode
	CASCADED() antlr.TerminalNode
	LOCAL() antlr.TerminalNode

	// IsCreateViewContext differentiates from other interfaces.
	IsCreateViewContext()
}

type CreateViewContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	algType     antlr.Token
	secContext  antlr.Token
	checkOption antlr.Token
}

func NewEmptyCreateViewContext() *CreateViewContext {
	var p = new(CreateViewContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_createView
	return p
}

func (*CreateViewContext) IsCreateViewContext() {}

func NewCreateViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateViewContext {
	var p = new(CreateViewContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createView

	return p
}

func (s *CreateViewContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateViewContext) GetAlgType() antlr.Token { return s.algType }

func (s *CreateViewContext) GetSecContext() antlr.Token { return s.secContext }

func (s *CreateViewContext) GetCheckOption() antlr.Token { return s.checkOption }

func (s *CreateViewContext) SetAlgType(v antlr.Token) { s.algType = v }

func (s *CreateViewContext) SetSecContext(v antlr.Token) { s.secContext = v }

func (s *CreateViewContext) SetCheckOption(v antlr.Token) { s.checkOption = v }

func (s *CreateViewContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(MySqlParserVIEW, 0)
}

func (s *CreateViewContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *CreateViewContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *CreateViewContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *CreateViewContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *CreateViewContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *CreateViewContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *CreateViewContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *CreateViewContext) OrReplace() IOrReplaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrReplaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrReplaceContext)
}

func (s *CreateViewContext) ALGORITHM() antlr.TerminalNode {
	return s.GetToken(MySqlParserALGORITHM, 0)
}

func (s *CreateViewContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *CreateViewContext) OwnerStatement() IOwnerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOwnerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOwnerStatementContext)
}

func (s *CreateViewContext) SQL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL, 0)
}

func (s *CreateViewContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserSECURITY, 0)
}

func (s *CreateViewContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *CreateViewContext) UNDEFINED() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNDEFINED, 0)
}

func (s *CreateViewContext) MERGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMERGE, 0)
}

func (s *CreateViewContext) TEMPTABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTEMPTABLE, 0)
}

func (s *CreateViewContext) DEFINER() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFINER, 0)
}

func (s *CreateViewContext) INVOKER() antlr.TerminalNode {
	return s.GetToken(MySqlParserINVOKER, 0)
}

func (s *CreateViewContext) WithClause() IWithClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *CreateViewContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *CreateViewContext) CHECK() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHECK, 0)
}

func (s *CreateViewContext) OPTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTION, 0)
}

func (s *CreateViewContext) CASCADED() antlr.TerminalNode {
	return s.GetToken(MySqlParserCASCADED, 0)
}

func (s *CreateViewContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL, 0)
}

func (s *CreateViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateView(s)
	}
}

func (s *CreateViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateView(s)
	}
}

func (p *MySqlParser) CreateView() (localctx ICreateViewContext) {
	this := p
	_ = this

	localctx = NewCreateViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, MySqlParserRULE_createView)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1317)
		p.Match(MySqlParserCREATE)
	}
	p.SetState(1319)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserOR {
		{
			p.SetState(1318)
			p.OrReplace()
		}

	}
	p.SetState(1324)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserALGORITHM {
		{
			p.SetState(1321)
			p.Match(MySqlParserALGORITHM)
		}
		{
			p.SetState(1322)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}
		{
			p.SetState(1323)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CreateViewContext).algType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserMERGE || _la == MySqlParserTEMPTABLE || _la == MySqlParserUNDEFINED) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CreateViewContext).algType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1327)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserDEFINER {
		{
			p.SetState(1326)
			p.OwnerStatement()
		}

	}
	p.SetState(1332)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserSQL {
		{
			p.SetState(1329)
			p.Match(MySqlParserSQL)
		}
		{
			p.SetState(1330)
			p.Match(MySqlParserSECURITY)
		}
		{
			p.SetState(1331)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CreateViewContext).secContext = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDEFINER || _la == MySqlParserINVOKER) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CreateViewContext).secContext = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1334)
		p.Match(MySqlParserVIEW)
	}
	{
		p.SetState(1335)
		p.FullId()
	}
	p.SetState(1340)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserLR_BRACKET {
		{
			p.SetState(1336)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(1337)
			p.UidList()
		}
		{
			p.SetState(1338)
			p.Match(MySqlParserRR_BRACKET)
		}

	}
	{
		p.SetState(1342)
		p.Match(MySqlParserAS)
	}
	p.SetState(1362)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 111, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1343)
			p.Match(MySqlParserLR_BRACKET)
		}
		p.SetState(1345)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserWITH {
			{
				p.SetState(1344)
				p.WithClause()
			}

		}
		{
			p.SetState(1347)
			p.SelectStatement()
		}
		{
			p.SetState(1348)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 2:
		p.SetState(1351)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserWITH {
			{
				p.SetState(1350)
				p.WithClause()
			}

		}
		{
			p.SetState(1353)
			p.SelectStatement()
		}
		p.SetState(1360)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 110, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1354)
				p.Match(MySqlParserWITH)
			}
			p.SetState(1356)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserCASCADED || _la == MySqlParserLOCAL {
				{
					p.SetState(1355)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*CreateViewContext).checkOption = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserCASCADED || _la == MySqlParserLOCAL) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*CreateViewContext).checkOption = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(1358)
				p.Match(MySqlParserCHECK)
			}
			{
				p.SetState(1359)
				p.Match(MySqlParserOPTION)
			}

		}

	}

	return localctx
}

// ICreateDatabaseOptionContext is an interface to support dynamic dispatch.
type ICreateDatabaseOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CharSet() ICharSetContext
	CharsetName() ICharsetNameContext
	AllDEFAULT() []antlr.TerminalNode
	DEFAULT(i int) antlr.TerminalNode
	EQUAL_SYMBOL() antlr.TerminalNode
	COLLATE() antlr.TerminalNode
	CollationName() ICollationNameContext
	ENCRYPTION() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	READ() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	ZERO_DECIMAL() antlr.TerminalNode
	ONE_DECIMAL() antlr.TerminalNode

	// IsCreateDatabaseOptionContext differentiates from other interfaces.
	IsCreateDatabaseOptionContext()
}

type CreateDatabaseOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateDatabaseOptionContext() *CreateDatabaseOptionContext {
	var p = new(CreateDatabaseOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_createDatabaseOption
	return p
}

func (*CreateDatabaseOptionContext) IsCreateDatabaseOptionContext() {}

func NewCreateDatabaseOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDatabaseOptionContext {
	var p = new(CreateDatabaseOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createDatabaseOption

	return p
}

func (s *CreateDatabaseOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDatabaseOptionContext) CharSet() ICharSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharSetContext)
}

func (s *CreateDatabaseOptionContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *CreateDatabaseOptionContext) AllDEFAULT() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserDEFAULT)
}

func (s *CreateDatabaseOptionContext) DEFAULT(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, i)
}

func (s *CreateDatabaseOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *CreateDatabaseOptionContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATE, 0)
}

func (s *CreateDatabaseOptionContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *CreateDatabaseOptionContext) ENCRYPTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserENCRYPTION, 0)
}

func (s *CreateDatabaseOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *CreateDatabaseOptionContext) READ() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAD, 0)
}

func (s *CreateDatabaseOptionContext) ONLY() antlr.TerminalNode {
	return s.GetToken(MySqlParserONLY, 0)
}

func (s *CreateDatabaseOptionContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserZERO_DECIMAL, 0)
}

func (s *CreateDatabaseOptionContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *CreateDatabaseOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDatabaseOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateDatabaseOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateDatabaseOption(s)
	}
}

func (s *CreateDatabaseOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateDatabaseOption(s)
	}
}

func (p *MySqlParser) CreateDatabaseOption() (localctx ICreateDatabaseOptionContext) {
	this := p
	_ = this

	localctx = NewCreateDatabaseOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, MySqlParserRULE_createDatabaseOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1397)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 120, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1365)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserDEFAULT {
			{
				p.SetState(1364)
				p.Match(MySqlParserDEFAULT)
			}

		}
		{
			p.SetState(1367)
			p.CharSet()
		}
		p.SetState(1369)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1368)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		p.SetState(1373)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserBINARY, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL:
			{
				p.SetState(1371)
				p.CharsetName()
			}

		case MySqlParserDEFAULT:
			{
				p.SetState(1372)
				p.Match(MySqlParserDEFAULT)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1376)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserDEFAULT {
			{
				p.SetState(1375)
				p.Match(MySqlParserDEFAULT)
			}

		}
		{
			p.SetState(1378)
			p.Match(MySqlParserCOLLATE)
		}
		p.SetState(1380)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1379)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1382)
			p.CollationName()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1384)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserDEFAULT {
			{
				p.SetState(1383)
				p.Match(MySqlParserDEFAULT)
			}

		}
		{
			p.SetState(1386)
			p.Match(MySqlParserENCRYPTION)
		}
		p.SetState(1388)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1387)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1390)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1391)
			p.Match(MySqlParserREAD)
		}
		{
			p.SetState(1392)
			p.Match(MySqlParserONLY)
		}
		p.SetState(1394)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1393)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1396)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDEFAULT || _la == MySqlParserZERO_DECIMAL || _la == MySqlParserONE_DECIMAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// ICharSetContext is an interface to support dynamic dispatch.
type ICharSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHARACTER() antlr.TerminalNode
	SET() antlr.TerminalNode
	CHARSET() antlr.TerminalNode
	CHAR() antlr.TerminalNode

	// IsCharSetContext differentiates from other interfaces.
	IsCharSetContext()
}

type CharSetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharSetContext() *CharSetContext {
	var p = new(CharSetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_charSet
	return p
}

func (*CharSetContext) IsCharSetContext() {}

func NewCharSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharSetContext {
	var p = new(CharSetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_charSet

	return p
}

func (s *CharSetContext) GetParser() antlr.Parser { return s.parser }

func (s *CharSetContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER, 0)
}

func (s *CharSetContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *CharSetContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARSET, 0)
}

func (s *CharSetContext) CHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAR, 0)
}

func (s *CharSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCharSet(s)
	}
}

func (s *CharSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCharSet(s)
	}
}

func (p *MySqlParser) CharSet() (localctx ICharSetContext) {
	this := p
	_ = this

	localctx = NewCharSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, MySqlParserRULE_charSet)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1404)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserCHARACTER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1399)
			p.Match(MySqlParserCHARACTER)
		}
		{
			p.SetState(1400)
			p.Match(MySqlParserSET)
		}

	case MySqlParserCHARSET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1401)
			p.Match(MySqlParserCHARSET)
		}

	case MySqlParserCHAR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1402)
			p.Match(MySqlParserCHAR)
		}
		{
			p.SetState(1403)
			p.Match(MySqlParserSET)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOwnerStatementContext is an interface to support dynamic dispatch.
type IOwnerStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFINER() antlr.TerminalNode
	EQUAL_SYMBOL() antlr.TerminalNode
	UserName() IUserNameContext
	CURRENT_USER() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode

	// IsOwnerStatementContext differentiates from other interfaces.
	IsOwnerStatementContext()
}

type OwnerStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOwnerStatementContext() *OwnerStatementContext {
	var p = new(OwnerStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_ownerStatement
	return p
}

func (*OwnerStatementContext) IsOwnerStatementContext() {}

func NewOwnerStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OwnerStatementContext {
	var p = new(OwnerStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_ownerStatement

	return p
}

func (s *OwnerStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *OwnerStatementContext) DEFINER() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFINER, 0)
}

func (s *OwnerStatementContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *OwnerStatementContext) UserName() IUserNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *OwnerStatementContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT_USER, 0)
}

func (s *OwnerStatementContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *OwnerStatementContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *OwnerStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OwnerStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OwnerStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterOwnerStatement(s)
	}
}

func (s *OwnerStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitOwnerStatement(s)
	}
}

func (p *MySqlParser) OwnerStatement() (localctx IOwnerStatementContext) {
	this := p
	_ = this

	localctx = NewOwnerStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, MySqlParserRULE_ownerStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1406)
		p.Match(MySqlParserDEFINER)
	}
	{
		p.SetState(1407)
		p.Match(MySqlParserEQUAL_SYMBOL)
	}
	p.SetState(1414)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 123, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1408)
			p.UserName()
		}

	case 2:
		{
			p.SetState(1409)
			p.Match(MySqlParserCURRENT_USER)
		}
		p.SetState(1412)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(1410)
				p.Match(MySqlParserLR_BRACKET)
			}
			{
				p.SetState(1411)
				p.Match(MySqlParserRR_BRACKET)
			}

		}

	}

	return localctx
}

// IScheduleExpressionContext is an interface to support dynamic dispatch.
type IScheduleExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsScheduleExpressionContext differentiates from other interfaces.
	IsScheduleExpressionContext()
}

type ScheduleExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScheduleExpressionContext() *ScheduleExpressionContext {
	var p = new(ScheduleExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_scheduleExpression
	return p
}

func (*ScheduleExpressionContext) IsScheduleExpressionContext() {}

func NewScheduleExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScheduleExpressionContext {
	var p = new(ScheduleExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_scheduleExpression

	return p
}

func (s *ScheduleExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ScheduleExpressionContext) CopyFrom(ctx *ScheduleExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ScheduleExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScheduleExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PreciseScheduleContext struct {
	*ScheduleExpressionContext
}

func NewPreciseScheduleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PreciseScheduleContext {
	var p = new(PreciseScheduleContext)

	p.ScheduleExpressionContext = NewEmptyScheduleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ScheduleExpressionContext))

	return p
}

func (s *PreciseScheduleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreciseScheduleContext) AT() antlr.TerminalNode {
	return s.GetToken(MySqlParserAT, 0)
}

func (s *PreciseScheduleContext) TimestampValue() ITimestampValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimestampValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimestampValueContext)
}

func (s *PreciseScheduleContext) AllIntervalExpr() []IIntervalExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIntervalExprContext); ok {
			len++
		}
	}

	tst := make([]IIntervalExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIntervalExprContext); ok {
			tst[i] = t.(IIntervalExprContext)
			i++
		}
	}

	return tst
}

func (s *PreciseScheduleContext) IntervalExpr(i int) IIntervalExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalExprContext)
}

func (s *PreciseScheduleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPreciseSchedule(s)
	}
}

func (s *PreciseScheduleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPreciseSchedule(s)
	}
}

type IntervalScheduleContext struct {
	*ScheduleExpressionContext
	startTimestamp ITimestampValueContext
	_intervalExpr  IIntervalExprContext
	startIntervals []IIntervalExprContext
	endTimestamp   ITimestampValueContext
	endIntervals   []IIntervalExprContext
}

func NewIntervalScheduleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntervalScheduleContext {
	var p = new(IntervalScheduleContext)

	p.ScheduleExpressionContext = NewEmptyScheduleExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ScheduleExpressionContext))

	return p
}

func (s *IntervalScheduleContext) GetStartTimestamp() ITimestampValueContext { return s.startTimestamp }

func (s *IntervalScheduleContext) Get_intervalExpr() IIntervalExprContext { return s._intervalExpr }

func (s *IntervalScheduleContext) GetEndTimestamp() ITimestampValueContext { return s.endTimestamp }

func (s *IntervalScheduleContext) SetStartTimestamp(v ITimestampValueContext) { s.startTimestamp = v }

func (s *IntervalScheduleContext) Set_intervalExpr(v IIntervalExprContext) { s._intervalExpr = v }

func (s *IntervalScheduleContext) SetEndTimestamp(v ITimestampValueContext) { s.endTimestamp = v }

func (s *IntervalScheduleContext) GetStartIntervals() []IIntervalExprContext { return s.startIntervals }

func (s *IntervalScheduleContext) GetEndIntervals() []IIntervalExprContext { return s.endIntervals }

func (s *IntervalScheduleContext) SetStartIntervals(v []IIntervalExprContext) { s.startIntervals = v }

func (s *IntervalScheduleContext) SetEndIntervals(v []IIntervalExprContext) { s.endIntervals = v }

func (s *IntervalScheduleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalScheduleContext) EVERY() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVERY, 0)
}

func (s *IntervalScheduleContext) IntervalType() IIntervalTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalTypeContext)
}

func (s *IntervalScheduleContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *IntervalScheduleContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IntervalScheduleContext) STARTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTARTS, 0)
}

func (s *IntervalScheduleContext) ENDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserENDS, 0)
}

func (s *IntervalScheduleContext) AllTimestampValue() []ITimestampValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITimestampValueContext); ok {
			len++
		}
	}

	tst := make([]ITimestampValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITimestampValueContext); ok {
			tst[i] = t.(ITimestampValueContext)
			i++
		}
	}

	return tst
}

func (s *IntervalScheduleContext) TimestampValue(i int) ITimestampValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimestampValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimestampValueContext)
}

func (s *IntervalScheduleContext) AllIntervalExpr() []IIntervalExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIntervalExprContext); ok {
			len++
		}
	}

	tst := make([]IIntervalExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIntervalExprContext); ok {
			tst[i] = t.(IIntervalExprContext)
			i++
		}
	}

	return tst
}

func (s *IntervalScheduleContext) IntervalExpr(i int) IIntervalExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalExprContext)
}

func (s *IntervalScheduleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIntervalSchedule(s)
	}
}

func (s *IntervalScheduleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIntervalSchedule(s)
	}
}

func (p *MySqlParser) ScheduleExpression() (localctx IScheduleExpressionContext) {
	this := p
	_ = this

	localctx = NewScheduleExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, MySqlParserRULE_scheduleExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1450)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserAT:
		localctx = NewPreciseScheduleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1416)
			p.Match(MySqlParserAT)
		}
		{
			p.SetState(1417)
			p.TimestampValue()
		}
		p.SetState(1421)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserPLUS {
			{
				p.SetState(1418)
				p.IntervalExpr()
			}

			p.SetState(1423)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case MySqlParserEVERY:
		localctx = NewIntervalScheduleContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1424)
			p.Match(MySqlParserEVERY)
		}
		p.SetState(1427)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1425)
				p.DecimalLiteral()
			}

		case 2:
			{
				p.SetState(1426)
				p.expression(0)
			}

		}
		{
			p.SetState(1429)
			p.IntervalType()
		}
		p.SetState(1438)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserSTARTS {
			{
				p.SetState(1430)
				p.Match(MySqlParserSTARTS)
			}
			{
				p.SetState(1431)

				var _x = p.TimestampValue()

				localctx.(*IntervalScheduleContext).startTimestamp = _x
			}
			p.SetState(1435)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == MySqlParserPLUS {
				{
					p.SetState(1432)

					var _x = p.IntervalExpr()

					localctx.(*IntervalScheduleContext)._intervalExpr = _x
				}
				localctx.(*IntervalScheduleContext).startIntervals = append(localctx.(*IntervalScheduleContext).startIntervals, localctx.(*IntervalScheduleContext)._intervalExpr)

				p.SetState(1437)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(1448)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserENDS {
			{
				p.SetState(1440)
				p.Match(MySqlParserENDS)
			}
			{
				p.SetState(1441)

				var _x = p.TimestampValue()

				localctx.(*IntervalScheduleContext).endTimestamp = _x
			}
			p.SetState(1445)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == MySqlParserPLUS {
				{
					p.SetState(1442)

					var _x = p.IntervalExpr()

					localctx.(*IntervalScheduleContext)._intervalExpr = _x
				}
				localctx.(*IntervalScheduleContext).endIntervals = append(localctx.(*IntervalScheduleContext).endIntervals, localctx.(*IntervalScheduleContext)._intervalExpr)

				p.SetState(1447)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITimestampValueContext is an interface to support dynamic dispatch.
type ITimestampValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CURRENT_TIMESTAMP() antlr.TerminalNode
	StringLiteral() IStringLiteralContext
	DecimalLiteral() IDecimalLiteralContext
	Expression() IExpressionContext

	// IsTimestampValueContext differentiates from other interfaces.
	IsTimestampValueContext()
}

type TimestampValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimestampValueContext() *TimestampValueContext {
	var p = new(TimestampValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_timestampValue
	return p
}

func (*TimestampValueContext) IsTimestampValueContext() {}

func NewTimestampValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimestampValueContext {
	var p = new(TimestampValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_timestampValue

	return p
}

func (s *TimestampValueContext) GetParser() antlr.Parser { return s.parser }

func (s *TimestampValueContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT_TIMESTAMP, 0)
}

func (s *TimestampValueContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *TimestampValueContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TimestampValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TimestampValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimestampValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TimestampValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTimestampValue(s)
	}
}

func (s *TimestampValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTimestampValue(s)
	}
}

func (p *MySqlParser) TimestampValue() (localctx ITimestampValueContext) {
	this := p
	_ = this

	localctx = NewTimestampValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, MySqlParserRULE_timestampValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1456)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 131, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1452)
			p.Match(MySqlParserCURRENT_TIMESTAMP)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1453)
			p.StringLiteral()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1454)
			p.DecimalLiteral()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1455)
			p.expression(0)
		}

	}

	return localctx
}

// IIntervalExprContext is an interface to support dynamic dispatch.
type IIntervalExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PLUS() antlr.TerminalNode
	INTERVAL() antlr.TerminalNode
	IntervalType() IIntervalTypeContext
	DecimalLiteral() IDecimalLiteralContext
	Expression() IExpressionContext

	// IsIntervalExprContext differentiates from other interfaces.
	IsIntervalExprContext()
}

type IntervalExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalExprContext() *IntervalExprContext {
	var p = new(IntervalExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_intervalExpr
	return p
}

func (*IntervalExprContext) IsIntervalExprContext() {}

func NewIntervalExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalExprContext {
	var p = new(IntervalExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_intervalExpr

	return p
}

func (s *IntervalExprContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalExprContext) PLUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPLUS, 0)
}

func (s *IntervalExprContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTERVAL, 0)
}

func (s *IntervalExprContext) IntervalType() IIntervalTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalTypeContext)
}

func (s *IntervalExprContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *IntervalExprContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IntervalExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIntervalExpr(s)
	}
}

func (s *IntervalExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIntervalExpr(s)
	}
}

func (p *MySqlParser) IntervalExpr() (localctx IIntervalExprContext) {
	this := p
	_ = this

	localctx = NewIntervalExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, MySqlParserRULE_intervalExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1458)
		p.Match(MySqlParserPLUS)
	}
	{
		p.SetState(1459)
		p.Match(MySqlParserINTERVAL)
	}
	p.SetState(1462)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 132, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1460)
			p.DecimalLiteral()
		}

	case 2:
		{
			p.SetState(1461)
			p.expression(0)
		}

	}
	{
		p.SetState(1464)
		p.IntervalType()
	}

	return localctx
}

// IIntervalTypeContext is an interface to support dynamic dispatch.
type IIntervalTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IntervalTypeBase() IIntervalTypeBaseContext
	YEAR() antlr.TerminalNode
	YEAR_MONTH() antlr.TerminalNode
	DAY_HOUR() antlr.TerminalNode
	DAY_MINUTE() antlr.TerminalNode
	DAY_SECOND() antlr.TerminalNode
	HOUR_MINUTE() antlr.TerminalNode
	HOUR_SECOND() antlr.TerminalNode
	MINUTE_SECOND() antlr.TerminalNode
	SECOND_MICROSECOND() antlr.TerminalNode
	MINUTE_MICROSECOND() antlr.TerminalNode
	HOUR_MICROSECOND() antlr.TerminalNode
	DAY_MICROSECOND() antlr.TerminalNode

	// IsIntervalTypeContext differentiates from other interfaces.
	IsIntervalTypeContext()
}

type IntervalTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalTypeContext() *IntervalTypeContext {
	var p = new(IntervalTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_intervalType
	return p
}

func (*IntervalTypeContext) IsIntervalTypeContext() {}

func NewIntervalTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalTypeContext {
	var p = new(IntervalTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_intervalType

	return p
}

func (s *IntervalTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalTypeContext) IntervalTypeBase() IIntervalTypeBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalTypeBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalTypeBaseContext)
}

func (s *IntervalTypeContext) YEAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserYEAR, 0)
}

func (s *IntervalTypeContext) YEAR_MONTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserYEAR_MONTH, 0)
}

func (s *IntervalTypeContext) DAY_HOUR() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAY_HOUR, 0)
}

func (s *IntervalTypeContext) DAY_MINUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAY_MINUTE, 0)
}

func (s *IntervalTypeContext) DAY_SECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAY_SECOND, 0)
}

func (s *IntervalTypeContext) HOUR_MINUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOUR_MINUTE, 0)
}

func (s *IntervalTypeContext) HOUR_SECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOUR_SECOND, 0)
}

func (s *IntervalTypeContext) MINUTE_SECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUTE_SECOND, 0)
}

func (s *IntervalTypeContext) SECOND_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserSECOND_MICROSECOND, 0)
}

func (s *IntervalTypeContext) MINUTE_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUTE_MICROSECOND, 0)
}

func (s *IntervalTypeContext) HOUR_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOUR_MICROSECOND, 0)
}

func (s *IntervalTypeContext) DAY_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAY_MICROSECOND, 0)
}

func (s *IntervalTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIntervalType(s)
	}
}

func (s *IntervalTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIntervalType(s)
	}
}

func (p *MySqlParser) IntervalType() (localctx IIntervalTypeContext) {
	this := p
	_ = this

	localctx = NewIntervalTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, MySqlParserRULE_intervalType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1479)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1466)
			p.IntervalTypeBase()
		}

	case MySqlParserYEAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1467)
			p.Match(MySqlParserYEAR)
		}

	case MySqlParserYEAR_MONTH:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1468)
			p.Match(MySqlParserYEAR_MONTH)
		}

	case MySqlParserDAY_HOUR:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1469)
			p.Match(MySqlParserDAY_HOUR)
		}

	case MySqlParserDAY_MINUTE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1470)
			p.Match(MySqlParserDAY_MINUTE)
		}

	case MySqlParserDAY_SECOND:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1471)
			p.Match(MySqlParserDAY_SECOND)
		}

	case MySqlParserHOUR_MINUTE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1472)
			p.Match(MySqlParserHOUR_MINUTE)
		}

	case MySqlParserHOUR_SECOND:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1473)
			p.Match(MySqlParserHOUR_SECOND)
		}

	case MySqlParserMINUTE_SECOND:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1474)
			p.Match(MySqlParserMINUTE_SECOND)
		}

	case MySqlParserSECOND_MICROSECOND:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1475)
			p.Match(MySqlParserSECOND_MICROSECOND)
		}

	case MySqlParserMINUTE_MICROSECOND:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1476)
			p.Match(MySqlParserMINUTE_MICROSECOND)
		}

	case MySqlParserHOUR_MICROSECOND:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1477)
			p.Match(MySqlParserHOUR_MICROSECOND)
		}

	case MySqlParserDAY_MICROSECOND:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1478)
			p.Match(MySqlParserDAY_MICROSECOND)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEnableTypeContext is an interface to support dynamic dispatch.
type IEnableTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ENABLE() antlr.TerminalNode
	DISABLE() antlr.TerminalNode
	ON() antlr.TerminalNode
	SLAVE() antlr.TerminalNode

	// IsEnableTypeContext differentiates from other interfaces.
	IsEnableTypeContext()
}

type EnableTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnableTypeContext() *EnableTypeContext {
	var p = new(EnableTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_enableType
	return p
}

func (*EnableTypeContext) IsEnableTypeContext() {}

func NewEnableTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnableTypeContext {
	var p = new(EnableTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_enableType

	return p
}

func (s *EnableTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *EnableTypeContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENABLE, 0)
}

func (s *EnableTypeContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISABLE, 0)
}

func (s *EnableTypeContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *EnableTypeContext) SLAVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSLAVE, 0)
}

func (s *EnableTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnableTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnableTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterEnableType(s)
	}
}

func (s *EnableTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitEnableType(s)
	}
}

func (p *MySqlParser) EnableType() (localctx IEnableTypeContext) {
	this := p
	_ = this

	localctx = NewEnableTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, MySqlParserRULE_enableType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1486)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 134, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1481)
			p.Match(MySqlParserENABLE)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1482)
			p.Match(MySqlParserDISABLE)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1483)
			p.Match(MySqlParserDISABLE)
		}
		{
			p.SetState(1484)
			p.Match(MySqlParserON)
		}
		{
			p.SetState(1485)
			p.Match(MySqlParserSLAVE)
		}

	}

	return localctx
}

// IIndexTypeContext is an interface to support dynamic dispatch.
type IIndexTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USING() antlr.TerminalNode
	BTREE() antlr.TerminalNode
	HASH() antlr.TerminalNode

	// IsIndexTypeContext differentiates from other interfaces.
	IsIndexTypeContext()
}

type IndexTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexTypeContext() *IndexTypeContext {
	var p = new(IndexTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_indexType
	return p
}

func (*IndexTypeContext) IsIndexTypeContext() {}

func NewIndexTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexTypeContext {
	var p = new(IndexTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_indexType

	return p
}

func (s *IndexTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexTypeContext) USING() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSING, 0)
}

func (s *IndexTypeContext) BTREE() antlr.TerminalNode {
	return s.GetToken(MySqlParserBTREE, 0)
}

func (s *IndexTypeContext) HASH() antlr.TerminalNode {
	return s.GetToken(MySqlParserHASH, 0)
}

func (s *IndexTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIndexType(s)
	}
}

func (s *IndexTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIndexType(s)
	}
}

func (p *MySqlParser) IndexType() (localctx IIndexTypeContext) {
	this := p
	_ = this

	localctx = NewIndexTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, MySqlParserRULE_indexType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1488)
		p.Match(MySqlParserUSING)
	}
	{
		p.SetState(1489)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserBTREE || _la == MySqlParserHASH) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IIndexOptionContext is an interface to support dynamic dispatch.
type IIndexOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEY_BLOCK_SIZE() antlr.TerminalNode
	FileSizeLiteral() IFileSizeLiteralContext
	EQUAL_SYMBOL() antlr.TerminalNode
	IndexType() IIndexTypeContext
	WITH() antlr.TerminalNode
	PARSER() antlr.TerminalNode
	Uid() IUidContext
	COMMENT() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	VISIBLE() antlr.TerminalNode
	INVISIBLE() antlr.TerminalNode
	ENGINE_ATTRIBUTE() antlr.TerminalNode
	SECONDARY_ENGINE_ATTRIBUTE() antlr.TerminalNode

	// IsIndexOptionContext differentiates from other interfaces.
	IsIndexOptionContext()
}

type IndexOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexOptionContext() *IndexOptionContext {
	var p = new(IndexOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_indexOption
	return p
}

func (*IndexOptionContext) IsIndexOptionContext() {}

func NewIndexOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexOptionContext {
	var p = new(IndexOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_indexOption

	return p
}

func (s *IndexOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexOptionContext) KEY_BLOCK_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY_BLOCK_SIZE, 0)
}

func (s *IndexOptionContext) FileSizeLiteral() IFileSizeLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileSizeLiteralContext)
}

func (s *IndexOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *IndexOptionContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *IndexOptionContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *IndexOptionContext) PARSER() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARSER, 0)
}

func (s *IndexOptionContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *IndexOptionContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT, 0)
}

func (s *IndexOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *IndexOptionContext) VISIBLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVISIBLE, 0)
}

func (s *IndexOptionContext) INVISIBLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINVISIBLE, 0)
}

func (s *IndexOptionContext) ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE_ATTRIBUTE, 0)
}

func (s *IndexOptionContext) SECONDARY_ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSECONDARY_ENGINE_ATTRIBUTE, 0)
}

func (s *IndexOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIndexOption(s)
	}
}

func (s *IndexOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIndexOption(s)
	}
}

func (p *MySqlParser) IndexOption() (localctx IIndexOptionContext) {
	this := p
	_ = this

	localctx = NewIndexOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, MySqlParserRULE_indexOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1513)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserKEY_BLOCK_SIZE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1491)
			p.Match(MySqlParserKEY_BLOCK_SIZE)
		}
		p.SetState(1493)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1492)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1495)
			p.FileSizeLiteral()
		}

	case MySqlParserUSING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1496)
			p.IndexType()
		}

	case MySqlParserWITH:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1497)
			p.Match(MySqlParserWITH)
		}
		{
			p.SetState(1498)
			p.Match(MySqlParserPARSER)
		}
		{
			p.SetState(1499)
			p.Uid()
		}

	case MySqlParserCOMMENT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1500)
			p.Match(MySqlParserCOMMENT)
		}
		{
			p.SetState(1501)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	case MySqlParserINVISIBLE, MySqlParserVISIBLE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1502)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserINVISIBLE || _la == MySqlParserVISIBLE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case MySqlParserENGINE_ATTRIBUTE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1503)
			p.Match(MySqlParserENGINE_ATTRIBUTE)
		}
		p.SetState(1505)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1504)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1507)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	case MySqlParserSECONDARY_ENGINE_ATTRIBUTE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1508)
			p.Match(MySqlParserSECONDARY_ENGINE_ATTRIBUTE)
		}
		p.SetState(1510)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1509)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1512)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IProcedureParameterContext is an interface to support dynamic dispatch.
type IProcedureParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDirection returns the direction token.
	GetDirection() antlr.Token

	// SetDirection sets the direction token.
	SetDirection(antlr.Token)

	// Getter signatures
	Uid() IUidContext
	DataType() IDataTypeContext
	IN() antlr.TerminalNode
	OUT() antlr.TerminalNode
	INOUT() antlr.TerminalNode

	// IsProcedureParameterContext differentiates from other interfaces.
	IsProcedureParameterContext()
}

type ProcedureParameterContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	direction antlr.Token
}

func NewEmptyProcedureParameterContext() *ProcedureParameterContext {
	var p = new(ProcedureParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_procedureParameter
	return p
}

func (*ProcedureParameterContext) IsProcedureParameterContext() {}

func NewProcedureParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureParameterContext {
	var p = new(ProcedureParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_procedureParameter

	return p
}

func (s *ProcedureParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureParameterContext) GetDirection() antlr.Token { return s.direction }

func (s *ProcedureParameterContext) SetDirection(v antlr.Token) { s.direction = v }

func (s *ProcedureParameterContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ProcedureParameterContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ProcedureParameterContext) IN() antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, 0)
}

func (s *ProcedureParameterContext) OUT() antlr.TerminalNode {
	return s.GetToken(MySqlParserOUT, 0)
}

func (s *ProcedureParameterContext) INOUT() antlr.TerminalNode {
	return s.GetToken(MySqlParserINOUT, 0)
}

func (s *ProcedureParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterProcedureParameter(s)
	}
}

func (s *ProcedureParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitProcedureParameter(s)
	}
}

func (p *MySqlParser) ProcedureParameter() (localctx IProcedureParameterContext) {
	this := p
	_ = this

	localctx = NewProcedureParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, MySqlParserRULE_procedureParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1516)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-80)) & ^0x3f) == 0 && ((int64(1)<<(_la-80))&35184372088849) != 0 {
		{
			p.SetState(1515)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ProcedureParameterContext).direction = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-80)) & ^0x3f) == 0 && ((int64(1)<<(_la-80))&35184372088849) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ProcedureParameterContext).direction = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1518)
		p.Uid()
	}
	{
		p.SetState(1519)
		p.DataType()
	}

	return localctx
}

// IFunctionParameterContext is an interface to support dynamic dispatch.
type IFunctionParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext
	DataType() IDataTypeContext

	// IsFunctionParameterContext differentiates from other interfaces.
	IsFunctionParameterContext()
}

type FunctionParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionParameterContext() *FunctionParameterContext {
	var p = new(FunctionParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_functionParameter
	return p
}

func (*FunctionParameterContext) IsFunctionParameterContext() {}

func NewFunctionParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionParameterContext {
	var p = new(FunctionParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_functionParameter

	return p
}

func (s *FunctionParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionParameterContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *FunctionParameterContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *FunctionParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFunctionParameter(s)
	}
}

func (s *FunctionParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFunctionParameter(s)
	}
}

func (p *MySqlParser) FunctionParameter() (localctx IFunctionParameterContext) {
	this := p
	_ = this

	localctx = NewFunctionParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, MySqlParserRULE_functionParameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1521)
		p.Uid()
	}
	{
		p.SetState(1522)
		p.DataType()
	}

	return localctx
}

// IRoutineOptionContext is an interface to support dynamic dispatch.
type IRoutineOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRoutineOptionContext differentiates from other interfaces.
	IsRoutineOptionContext()
}

type RoutineOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoutineOptionContext() *RoutineOptionContext {
	var p = new(RoutineOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_routineOption
	return p
}

func (*RoutineOptionContext) IsRoutineOptionContext() {}

func NewRoutineOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoutineOptionContext {
	var p = new(RoutineOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_routineOption

	return p
}

func (s *RoutineOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *RoutineOptionContext) CopyFrom(ctx *RoutineOptionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *RoutineOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RoutineBehaviorContext struct {
	*RoutineOptionContext
}

func NewRoutineBehaviorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RoutineBehaviorContext {
	var p = new(RoutineBehaviorContext)

	p.RoutineOptionContext = NewEmptyRoutineOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RoutineOptionContext))

	return p
}

func (s *RoutineBehaviorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineBehaviorContext) DETERMINISTIC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDETERMINISTIC, 0)
}

func (s *RoutineBehaviorContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *RoutineBehaviorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRoutineBehavior(s)
	}
}

func (s *RoutineBehaviorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRoutineBehavior(s)
	}
}

type RoutineLanguageContext struct {
	*RoutineOptionContext
}

func NewRoutineLanguageContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RoutineLanguageContext {
	var p = new(RoutineLanguageContext)

	p.RoutineOptionContext = NewEmptyRoutineOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RoutineOptionContext))

	return p
}

func (s *RoutineLanguageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineLanguageContext) LANGUAGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLANGUAGE, 0)
}

func (s *RoutineLanguageContext) SQL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL, 0)
}

func (s *RoutineLanguageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRoutineLanguage(s)
	}
}

func (s *RoutineLanguageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRoutineLanguage(s)
	}
}

type RoutineCommentContext struct {
	*RoutineOptionContext
}

func NewRoutineCommentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RoutineCommentContext {
	var p = new(RoutineCommentContext)

	p.RoutineOptionContext = NewEmptyRoutineOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RoutineOptionContext))

	return p
}

func (s *RoutineCommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineCommentContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT, 0)
}

func (s *RoutineCommentContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *RoutineCommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRoutineComment(s)
	}
}

func (s *RoutineCommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRoutineComment(s)
	}
}

type RoutineSecurityContext struct {
	*RoutineOptionContext
	context antlr.Token
}

func NewRoutineSecurityContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RoutineSecurityContext {
	var p = new(RoutineSecurityContext)

	p.RoutineOptionContext = NewEmptyRoutineOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RoutineOptionContext))

	return p
}

func (s *RoutineSecurityContext) GetContext() antlr.Token { return s.context }

func (s *RoutineSecurityContext) SetContext(v antlr.Token) { s.context = v }

func (s *RoutineSecurityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineSecurityContext) SQL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL, 0)
}

func (s *RoutineSecurityContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserSECURITY, 0)
}

func (s *RoutineSecurityContext) DEFINER() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFINER, 0)
}

func (s *RoutineSecurityContext) INVOKER() antlr.TerminalNode {
	return s.GetToken(MySqlParserINVOKER, 0)
}

func (s *RoutineSecurityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRoutineSecurity(s)
	}
}

func (s *RoutineSecurityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRoutineSecurity(s)
	}
}

type RoutineDataContext struct {
	*RoutineOptionContext
}

func NewRoutineDataContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RoutineDataContext {
	var p = new(RoutineDataContext)

	p.RoutineOptionContext = NewEmptyRoutineOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RoutineOptionContext))

	return p
}

func (s *RoutineDataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineDataContext) CONTAINS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONTAINS, 0)
}

func (s *RoutineDataContext) SQL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL, 0)
}

func (s *RoutineDataContext) NO() antlr.TerminalNode {
	return s.GetToken(MySqlParserNO, 0)
}

func (s *RoutineDataContext) READS() antlr.TerminalNode {
	return s.GetToken(MySqlParserREADS, 0)
}

func (s *RoutineDataContext) DATA() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATA, 0)
}

func (s *RoutineDataContext) MODIFIES() antlr.TerminalNode {
	return s.GetToken(MySqlParserMODIFIES, 0)
}

func (s *RoutineDataContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRoutineData(s)
	}
}

func (s *RoutineDataContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRoutineData(s)
	}
}

func (p *MySqlParser) RoutineOption() (localctx IRoutineOptionContext) {
	this := p
	_ = this

	localctx = NewRoutineOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, MySqlParserRULE_routineOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1547)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserCOMMENT:
		localctx = NewRoutineCommentContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1524)
			p.Match(MySqlParserCOMMENT)
		}
		{
			p.SetState(1525)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	case MySqlParserLANGUAGE:
		localctx = NewRoutineLanguageContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1526)
			p.Match(MySqlParserLANGUAGE)
		}
		{
			p.SetState(1527)
			p.Match(MySqlParserSQL)
		}

	case MySqlParserDETERMINISTIC, MySqlParserNOT:
		localctx = NewRoutineBehaviorContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1529)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserNOT {
			{
				p.SetState(1528)
				p.Match(MySqlParserNOT)
			}

		}
		{
			p.SetState(1531)
			p.Match(MySqlParserDETERMINISTIC)
		}

	case MySqlParserMODIFIES, MySqlParserREADS, MySqlParserCONTAINS, MySqlParserNO:
		localctx = NewRoutineDataContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1542)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserCONTAINS:
			{
				p.SetState(1532)
				p.Match(MySqlParserCONTAINS)
			}
			{
				p.SetState(1533)
				p.Match(MySqlParserSQL)
			}

		case MySqlParserNO:
			{
				p.SetState(1534)
				p.Match(MySqlParserNO)
			}
			{
				p.SetState(1535)
				p.Match(MySqlParserSQL)
			}

		case MySqlParserREADS:
			{
				p.SetState(1536)
				p.Match(MySqlParserREADS)
			}
			{
				p.SetState(1537)
				p.Match(MySqlParserSQL)
			}
			{
				p.SetState(1538)
				p.Match(MySqlParserDATA)
			}

		case MySqlParserMODIFIES:
			{
				p.SetState(1539)
				p.Match(MySqlParserMODIFIES)
			}
			{
				p.SetState(1540)
				p.Match(MySqlParserSQL)
			}
			{
				p.SetState(1541)
				p.Match(MySqlParserDATA)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case MySqlParserSQL:
		localctx = NewRoutineSecurityContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1544)
			p.Match(MySqlParserSQL)
		}
		{
			p.SetState(1545)
			p.Match(MySqlParserSECURITY)
		}
		{
			p.SetState(1546)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*RoutineSecurityContext).context = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDEFINER || _la == MySqlParserINVOKER) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*RoutineSecurityContext).context = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IServerOptionContext is an interface to support dynamic dispatch.
type IServerOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HOST() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	USER() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	SOCKET() antlr.TerminalNode
	OWNER() antlr.TerminalNode
	PORT() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext

	// IsServerOptionContext differentiates from other interfaces.
	IsServerOptionContext()
}

type ServerOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyServerOptionContext() *ServerOptionContext {
	var p = new(ServerOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_serverOption
	return p
}

func (*ServerOptionContext) IsServerOptionContext() {}

func NewServerOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ServerOptionContext {
	var p = new(ServerOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_serverOption

	return p
}

func (s *ServerOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ServerOptionContext) HOST() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOST, 0)
}

func (s *ServerOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *ServerOptionContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATABASE, 0)
}

func (s *ServerOptionContext) USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER, 0)
}

func (s *ServerOptionContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD, 0)
}

func (s *ServerOptionContext) SOCKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSOCKET, 0)
}

func (s *ServerOptionContext) OWNER() antlr.TerminalNode {
	return s.GetToken(MySqlParserOWNER, 0)
}

func (s *ServerOptionContext) PORT() antlr.TerminalNode {
	return s.GetToken(MySqlParserPORT, 0)
}

func (s *ServerOptionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *ServerOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ServerOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ServerOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterServerOption(s)
	}
}

func (s *ServerOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitServerOption(s)
	}
}

func (p *MySqlParser) ServerOption() (localctx IServerOptionContext) {
	this := p
	_ = this

	localctx = NewServerOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, MySqlParserRULE_serverOption)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1563)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserHOST:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1549)
			p.Match(MySqlParserHOST)
		}
		{
			p.SetState(1550)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	case MySqlParserDATABASE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1551)
			p.Match(MySqlParserDATABASE)
		}
		{
			p.SetState(1552)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	case MySqlParserUSER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1553)
			p.Match(MySqlParserUSER)
		}
		{
			p.SetState(1554)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	case MySqlParserPASSWORD:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1555)
			p.Match(MySqlParserPASSWORD)
		}
		{
			p.SetState(1556)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	case MySqlParserSOCKET:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1557)
			p.Match(MySqlParserSOCKET)
		}
		{
			p.SetState(1558)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	case MySqlParserOWNER:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1559)
			p.Match(MySqlParserOWNER)
		}
		{
			p.SetState(1560)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	case MySqlParserPORT:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1561)
			p.Match(MySqlParserPORT)
		}
		{
			p.SetState(1562)
			p.DecimalLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICreateDefinitionsContext is an interface to support dynamic dispatch.
type ICreateDefinitionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	AllCreateDefinition() []ICreateDefinitionContext
	CreateDefinition(i int) ICreateDefinitionContext
	RR_BRACKET() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCreateDefinitionsContext differentiates from other interfaces.
	IsCreateDefinitionsContext()
}

type CreateDefinitionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateDefinitionsContext() *CreateDefinitionsContext {
	var p = new(CreateDefinitionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_createDefinitions
	return p
}

func (*CreateDefinitionsContext) IsCreateDefinitionsContext() {}

func NewCreateDefinitionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDefinitionsContext {
	var p = new(CreateDefinitionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createDefinitions

	return p
}

func (s *CreateDefinitionsContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDefinitionsContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CreateDefinitionsContext) AllCreateDefinition() []ICreateDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreateDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ICreateDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreateDefinitionContext); ok {
			tst[i] = t.(ICreateDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *CreateDefinitionsContext) CreateDefinition(i int) ICreateDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDefinitionContext)
}

func (s *CreateDefinitionsContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CreateDefinitionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *CreateDefinitionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *CreateDefinitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDefinitionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateDefinitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateDefinitions(s)
	}
}

func (s *CreateDefinitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateDefinitions(s)
	}
}

func (p *MySqlParser) CreateDefinitions() (localctx ICreateDefinitionsContext) {
	this := p
	_ = this

	localctx = NewCreateDefinitionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, MySqlParserRULE_createDefinitions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1565)
		p.Match(MySqlParserLR_BRACKET)
	}
	{
		p.SetState(1566)
		p.CreateDefinition()
	}
	p.SetState(1571)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(1567)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(1568)
			p.CreateDefinition()
		}

		p.SetState(1573)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1574)
		p.Match(MySqlParserRR_BRACKET)
	}

	return localctx
}

// ICreateDefinitionContext is an interface to support dynamic dispatch.
type ICreateDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsCreateDefinitionContext differentiates from other interfaces.
	IsCreateDefinitionContext()
}

type CreateDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateDefinitionContext() *CreateDefinitionContext {
	var p = new(CreateDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_createDefinition
	return p
}

func (*CreateDefinitionContext) IsCreateDefinitionContext() {}

func NewCreateDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDefinitionContext {
	var p = new(CreateDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createDefinition

	return p
}

func (s *CreateDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDefinitionContext) CopyFrom(ctx *CreateDefinitionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *CreateDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ColumnDeclarationContext struct {
	*CreateDefinitionContext
}

func NewColumnDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnDeclarationContext {
	var p = new(ColumnDeclarationContext)

	p.CreateDefinitionContext = NewEmptyCreateDefinitionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*CreateDefinitionContext))

	return p
}

func (s *ColumnDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDeclarationContext) FullColumnName() IFullColumnNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *ColumnDeclarationContext) ColumnDefinition() IColumnDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *ColumnDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterColumnDeclaration(s)
	}
}

func (s *ColumnDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitColumnDeclaration(s)
	}
}

type ConstraintDeclarationContext struct {
	*CreateDefinitionContext
}

func NewConstraintDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConstraintDeclarationContext {
	var p = new(ConstraintDeclarationContext)

	p.CreateDefinitionContext = NewEmptyCreateDefinitionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*CreateDefinitionContext))

	return p
}

func (s *ConstraintDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintDeclarationContext) TableConstraint() ITableConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableConstraintContext)
}

func (s *ConstraintDeclarationContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *ConstraintDeclarationContext) ENFORCED() antlr.TerminalNode {
	return s.GetToken(MySqlParserENFORCED, 0)
}

func (s *ConstraintDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterConstraintDeclaration(s)
	}
}

func (s *ConstraintDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitConstraintDeclaration(s)
	}
}

type IndexDeclarationContext struct {
	*CreateDefinitionContext
}

func NewIndexDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IndexDeclarationContext {
	var p = new(IndexDeclarationContext)

	p.CreateDefinitionContext = NewEmptyCreateDefinitionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*CreateDefinitionContext))

	return p
}

func (s *IndexDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexDeclarationContext) IndexColumnDefinition() IIndexColumnDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnDefinitionContext)
}

func (s *IndexDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIndexDeclaration(s)
	}
}

func (s *IndexDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIndexDeclaration(s)
	}
}

func (p *MySqlParser) CreateDefinition() (localctx ICreateDefinitionContext) {
	this := p
	_ = this

	localctx = NewCreateDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, MySqlParserRULE_createDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1587)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 147, p.GetParserRuleContext()) {
	case 1:
		localctx = NewColumnDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1576)
			p.FullColumnName()
		}
		{
			p.SetState(1577)
			p.ColumnDefinition()
		}

	case 2:
		localctx = NewConstraintDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1579)
			p.TableConstraint()
		}
		p.SetState(1581)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserNOT {
			{
				p.SetState(1580)
				p.Match(MySqlParserNOT)
			}

		}
		p.SetState(1584)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserENFORCED {
			{
				p.SetState(1583)
				p.Match(MySqlParserENFORCED)
			}

		}

	case 3:
		localctx = NewIndexDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1586)
			p.IndexColumnDefinition()
		}

	}

	return localctx
}

// IColumnDefinitionContext is an interface to support dynamic dispatch.
type IColumnDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DataType() IDataTypeContext
	AllColumnConstraint() []IColumnConstraintContext
	ColumnConstraint(i int) IColumnConstraintContext
	NOT() antlr.TerminalNode
	ENFORCED() antlr.TerminalNode

	// IsColumnDefinitionContext differentiates from other interfaces.
	IsColumnDefinitionContext()
}

type ColumnDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnDefinitionContext() *ColumnDefinitionContext {
	var p = new(ColumnDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_columnDefinition
	return p
}

func (*ColumnDefinitionContext) IsColumnDefinitionContext() {}

func NewColumnDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnDefinitionContext {
	var p = new(ColumnDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_columnDefinition

	return p
}

func (s *ColumnDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnDefinitionContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ColumnDefinitionContext) AllColumnConstraint() []IColumnConstraintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnConstraintContext); ok {
			len++
		}
	}

	tst := make([]IColumnConstraintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnConstraintContext); ok {
			tst[i] = t.(IColumnConstraintContext)
			i++
		}
	}

	return tst
}

func (s *ColumnDefinitionContext) ColumnConstraint(i int) IColumnConstraintContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnConstraintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnConstraintContext)
}

func (s *ColumnDefinitionContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *ColumnDefinitionContext) ENFORCED() antlr.TerminalNode {
	return s.GetToken(MySqlParserENFORCED, 0)
}

func (s *ColumnDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterColumnDefinition(s)
	}
}

func (s *ColumnDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitColumnDefinition(s)
	}
}

func (p *MySqlParser) ColumnDefinition() (localctx IColumnDefinitionContext) {
	this := p
	_ = this

	localctx = NewColumnDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, MySqlParserRULE_columnDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1589)
		p.DataType()
	}
	p.SetState(1593)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 148, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1590)
				p.ColumnConstraint()
			}

		}
		p.SetState(1595)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 148, p.GetParserRuleContext())
	}
	p.SetState(1597)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserNOT {
		{
			p.SetState(1596)
			p.Match(MySqlParserNOT)
		}

	}
	p.SetState(1600)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserENFORCED {
		{
			p.SetState(1599)
			p.Match(MySqlParserENFORCED)
		}

	}

	return localctx
}

// IColumnConstraintContext is an interface to support dynamic dispatch.
type IColumnConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsColumnConstraintContext differentiates from other interfaces.
	IsColumnConstraintContext()
}

type ColumnConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnConstraintContext() *ColumnConstraintContext {
	var p = new(ColumnConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_columnConstraint
	return p
}

func (*ColumnConstraintContext) IsColumnConstraintContext() {}

func NewColumnConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnConstraintContext {
	var p = new(ColumnConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_columnConstraint

	return p
}

func (s *ColumnConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnConstraintContext) CopyFrom(ctx *ColumnConstraintContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type StorageColumnConstraintContext struct {
	*ColumnConstraintContext
	storageval antlr.Token
}

func NewStorageColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StorageColumnConstraintContext {
	var p = new(StorageColumnConstraintContext)

	p.ColumnConstraintContext = NewEmptyColumnConstraintContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnConstraintContext))

	return p
}

func (s *StorageColumnConstraintContext) GetStorageval() antlr.Token { return s.storageval }

func (s *StorageColumnConstraintContext) SetStorageval(v antlr.Token) { s.storageval = v }

func (s *StorageColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StorageColumnConstraintContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTORAGE, 0)
}

func (s *StorageColumnConstraintContext) DISK() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISK, 0)
}

func (s *StorageColumnConstraintContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEMORY, 0)
}

func (s *StorageColumnConstraintContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *StorageColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterStorageColumnConstraint(s)
	}
}

func (s *StorageColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitStorageColumnConstraint(s)
	}
}

type VisibilityColumnConstraintContext struct {
	*ColumnConstraintContext
}

func NewVisibilityColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VisibilityColumnConstraintContext {
	var p = new(VisibilityColumnConstraintContext)

	p.ColumnConstraintContext = NewEmptyColumnConstraintContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnConstraintContext))

	return p
}

func (s *VisibilityColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VisibilityColumnConstraintContext) VISIBLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVISIBLE, 0)
}

func (s *VisibilityColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterVisibilityColumnConstraint(s)
	}
}

func (s *VisibilityColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitVisibilityColumnConstraint(s)
	}
}

type AutoIncrementColumnConstraintContext struct {
	*ColumnConstraintContext
}

func NewAutoIncrementColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AutoIncrementColumnConstraintContext {
	var p = new(AutoIncrementColumnConstraintContext)

	p.ColumnConstraintContext = NewEmptyColumnConstraintContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnConstraintContext))

	return p
}

func (s *AutoIncrementColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AutoIncrementColumnConstraintContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUTO_INCREMENT, 0)
}

func (s *AutoIncrementColumnConstraintContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *AutoIncrementColumnConstraintContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPDATE, 0)
}

func (s *AutoIncrementColumnConstraintContext) CurrentTimestamp() ICurrentTimestampContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICurrentTimestampContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICurrentTimestampContext)
}

func (s *AutoIncrementColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAutoIncrementColumnConstraint(s)
	}
}

func (s *AutoIncrementColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAutoIncrementColumnConstraint(s)
	}
}

type CommentColumnConstraintContext struct {
	*ColumnConstraintContext
}

func NewCommentColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CommentColumnConstraintContext {
	var p = new(CommentColumnConstraintContext)

	p.ColumnConstraintContext = NewEmptyColumnConstraintContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnConstraintContext))

	return p
}

func (s *CommentColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentColumnConstraintContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT, 0)
}

func (s *CommentColumnConstraintContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *CommentColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCommentColumnConstraint(s)
	}
}

func (s *CommentColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCommentColumnConstraint(s)
	}
}

type UniqueKeyColumnConstraintContext struct {
	*ColumnConstraintContext
}

func NewUniqueKeyColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UniqueKeyColumnConstraintContext {
	var p = new(UniqueKeyColumnConstraintContext)

	p.ColumnConstraintContext = NewEmptyColumnConstraintContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnConstraintContext))

	return p
}

func (s *UniqueKeyColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UniqueKeyColumnConstraintContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNIQUE, 0)
}

func (s *UniqueKeyColumnConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *UniqueKeyColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUniqueKeyColumnConstraint(s)
	}
}

func (s *UniqueKeyColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUniqueKeyColumnConstraint(s)
	}
}

type SerialDefaultColumnConstraintContext struct {
	*ColumnConstraintContext
}

func NewSerialDefaultColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SerialDefaultColumnConstraintContext {
	var p = new(SerialDefaultColumnConstraintContext)

	p.ColumnConstraintContext = NewEmptyColumnConstraintContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnConstraintContext))

	return p
}

func (s *SerialDefaultColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SerialDefaultColumnConstraintContext) SERIAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSERIAL, 0)
}

func (s *SerialDefaultColumnConstraintContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *SerialDefaultColumnConstraintContext) VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUE, 0)
}

func (s *SerialDefaultColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSerialDefaultColumnConstraint(s)
	}
}

func (s *SerialDefaultColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSerialDefaultColumnConstraint(s)
	}
}

type GeneratedColumnConstraintContext struct {
	*ColumnConstraintContext
}

func NewGeneratedColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GeneratedColumnConstraintContext {
	var p = new(GeneratedColumnConstraintContext)

	p.ColumnConstraintContext = NewEmptyColumnConstraintContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnConstraintContext))

	return p
}

func (s *GeneratedColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneratedColumnConstraintContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *GeneratedColumnConstraintContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *GeneratedColumnConstraintContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GeneratedColumnConstraintContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *GeneratedColumnConstraintContext) GENERATED() antlr.TerminalNode {
	return s.GetToken(MySqlParserGENERATED, 0)
}

func (s *GeneratedColumnConstraintContext) ALWAYS() antlr.TerminalNode {
	return s.GetToken(MySqlParserALWAYS, 0)
}

func (s *GeneratedColumnConstraintContext) VIRTUAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserVIRTUAL, 0)
}

func (s *GeneratedColumnConstraintContext) STORED() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTORED, 0)
}

func (s *GeneratedColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterGeneratedColumnConstraint(s)
	}
}

func (s *GeneratedColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitGeneratedColumnConstraint(s)
	}
}

type FormatColumnConstraintContext struct {
	*ColumnConstraintContext
	colformat antlr.Token
}

func NewFormatColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FormatColumnConstraintContext {
	var p = new(FormatColumnConstraintContext)

	p.ColumnConstraintContext = NewEmptyColumnConstraintContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnConstraintContext))

	return p
}

func (s *FormatColumnConstraintContext) GetColformat() antlr.Token { return s.colformat }

func (s *FormatColumnConstraintContext) SetColformat(v antlr.Token) { s.colformat = v }

func (s *FormatColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormatColumnConstraintContext) COLUMN_FORMAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN_FORMAT, 0)
}

func (s *FormatColumnConstraintContext) FIXED() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIXED, 0)
}

func (s *FormatColumnConstraintContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDYNAMIC, 0)
}

func (s *FormatColumnConstraintContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *FormatColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFormatColumnConstraint(s)
	}
}

func (s *FormatColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFormatColumnConstraint(s)
	}
}

type CollateColumnConstraintContext struct {
	*ColumnConstraintContext
}

func NewCollateColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CollateColumnConstraintContext {
	var p = new(CollateColumnConstraintContext)

	p.ColumnConstraintContext = NewEmptyColumnConstraintContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnConstraintContext))

	return p
}

func (s *CollateColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollateColumnConstraintContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATE, 0)
}

func (s *CollateColumnConstraintContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *CollateColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCollateColumnConstraint(s)
	}
}

func (s *CollateColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCollateColumnConstraint(s)
	}
}

type PrimaryKeyColumnConstraintContext struct {
	*ColumnConstraintContext
}

func NewPrimaryKeyColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryKeyColumnConstraintContext {
	var p = new(PrimaryKeyColumnConstraintContext)

	p.ColumnConstraintContext = NewEmptyColumnConstraintContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnConstraintContext))

	return p
}

func (s *PrimaryKeyColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryKeyColumnConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *PrimaryKeyColumnConstraintContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRIMARY, 0)
}

func (s *PrimaryKeyColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPrimaryKeyColumnConstraint(s)
	}
}

func (s *PrimaryKeyColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPrimaryKeyColumnConstraint(s)
	}
}

type CheckColumnConstraintContext struct {
	*ColumnConstraintContext
	name IUidContext
}

func NewCheckColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CheckColumnConstraintContext {
	var p = new(CheckColumnConstraintContext)

	p.ColumnConstraintContext = NewEmptyColumnConstraintContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnConstraintContext))

	return p
}

func (s *CheckColumnConstraintContext) GetName() IUidContext { return s.name }

func (s *CheckColumnConstraintContext) SetName(v IUidContext) { s.name = v }

func (s *CheckColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckColumnConstraintContext) CHECK() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHECK, 0)
}

func (s *CheckColumnConstraintContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CheckColumnConstraintContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CheckColumnConstraintContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CheckColumnConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT, 0)
}

func (s *CheckColumnConstraintContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CheckColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCheckColumnConstraint(s)
	}
}

func (s *CheckColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCheckColumnConstraint(s)
	}
}

type NullColumnConstraintContext struct {
	*ColumnConstraintContext
}

func NewNullColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullColumnConstraintContext {
	var p = new(NullColumnConstraintContext)

	p.ColumnConstraintContext = NewEmptyColumnConstraintContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnConstraintContext))

	return p
}

func (s *NullColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullColumnConstraintContext) NullNotnull() INullNotnullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullNotnullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullNotnullContext)
}

func (s *NullColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterNullColumnConstraint(s)
	}
}

func (s *NullColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitNullColumnConstraint(s)
	}
}

type DefaultColumnConstraintContext struct {
	*ColumnConstraintContext
}

func NewDefaultColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DefaultColumnConstraintContext {
	var p = new(DefaultColumnConstraintContext)

	p.ColumnConstraintContext = NewEmptyColumnConstraintContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnConstraintContext))

	return p
}

func (s *DefaultColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultColumnConstraintContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *DefaultColumnConstraintContext) DefaultValue() IDefaultValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultValueContext)
}

func (s *DefaultColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDefaultColumnConstraint(s)
	}
}

func (s *DefaultColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDefaultColumnConstraint(s)
	}
}

type ReferenceColumnConstraintContext struct {
	*ColumnConstraintContext
}

func NewReferenceColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReferenceColumnConstraintContext {
	var p = new(ReferenceColumnConstraintContext)

	p.ColumnConstraintContext = NewEmptyColumnConstraintContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnConstraintContext))

	return p
}

func (s *ReferenceColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceColumnConstraintContext) ReferenceDefinition() IReferenceDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceDefinitionContext)
}

func (s *ReferenceColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterReferenceColumnConstraint(s)
	}
}

func (s *ReferenceColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitReferenceColumnConstraint(s)
	}
}

type InvisibilityColumnConstraintContext struct {
	*ColumnConstraintContext
}

func NewInvisibilityColumnConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InvisibilityColumnConstraintContext {
	var p = new(InvisibilityColumnConstraintContext)

	p.ColumnConstraintContext = NewEmptyColumnConstraintContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ColumnConstraintContext))

	return p
}

func (s *InvisibilityColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InvisibilityColumnConstraintContext) INVISIBLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINVISIBLE, 0)
}

func (s *InvisibilityColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterInvisibilityColumnConstraint(s)
	}
}

func (s *InvisibilityColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitInvisibilityColumnConstraint(s)
	}
}

func (p *MySqlParser) ColumnConstraint() (localctx IColumnConstraintContext) {
	this := p
	_ = this

	localctx = NewColumnConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, MySqlParserRULE_columnConstraint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1655)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserNOT, MySqlParserNULL_LITERAL, MySqlParserNULL_SPEC_LITERAL:
		localctx = NewNullColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1602)
			p.NullNotnull()
		}

	case MySqlParserDEFAULT:
		localctx = NewDefaultColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1603)
			p.Match(MySqlParserDEFAULT)
		}
		{
			p.SetState(1604)
			p.DefaultValue()
		}

	case MySqlParserVISIBLE:
		localctx = NewVisibilityColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1605)
			p.Match(MySqlParserVISIBLE)
		}

	case MySqlParserINVISIBLE:
		localctx = NewInvisibilityColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1606)
			p.Match(MySqlParserINVISIBLE)
		}

	case MySqlParserON, MySqlParserAUTO_INCREMENT:
		localctx = NewAutoIncrementColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		p.SetState(1611)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserAUTO_INCREMENT:
			{
				p.SetState(1607)
				p.Match(MySqlParserAUTO_INCREMENT)
			}

		case MySqlParserON:
			{
				p.SetState(1608)
				p.Match(MySqlParserON)
			}
			{
				p.SetState(1609)
				p.Match(MySqlParserUPDATE)
			}
			{
				p.SetState(1610)
				p.CurrentTimestamp()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case MySqlParserKEY, MySqlParserPRIMARY:
		localctx = NewPrimaryKeyColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		p.SetState(1614)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserPRIMARY {
			{
				p.SetState(1613)
				p.Match(MySqlParserPRIMARY)
			}

		}
		{
			p.SetState(1616)
			p.Match(MySqlParserKEY)
		}

	case MySqlParserUNIQUE:
		localctx = NewUniqueKeyColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1617)
			p.Match(MySqlParserUNIQUE)
		}
		p.SetState(1619)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 153, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1618)
				p.Match(MySqlParserKEY)
			}

		}

	case MySqlParserCOMMENT:
		localctx = NewCommentColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1621)
			p.Match(MySqlParserCOMMENT)
		}
		{
			p.SetState(1622)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	case MySqlParserCOLUMN_FORMAT:
		localctx = NewFormatColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1623)
			p.Match(MySqlParserCOLUMN_FORMAT)
		}
		{
			p.SetState(1624)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*FormatColumnConstraintContext).colformat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDEFAULT || _la == MySqlParserDYNAMIC || _la == MySqlParserFIXED) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*FormatColumnConstraintContext).colformat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case MySqlParserSTORAGE:
		localctx = NewStorageColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1625)
			p.Match(MySqlParserSTORAGE)
		}
		{
			p.SetState(1626)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*StorageColumnConstraintContext).storageval = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDEFAULT || _la == MySqlParserDISK || _la == MySqlParserMEMORY) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*StorageColumnConstraintContext).storageval = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case MySqlParserREFERENCES:
		localctx = NewReferenceColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1627)
			p.ReferenceDefinition()
		}

	case MySqlParserCOLLATE:
		localctx = NewCollateColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1628)
			p.Match(MySqlParserCOLLATE)
		}
		{
			p.SetState(1629)
			p.CollationName()
		}

	case MySqlParserAS, MySqlParserGENERATED:
		localctx = NewGeneratedColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		p.SetState(1632)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserGENERATED {
			{
				p.SetState(1630)
				p.Match(MySqlParserGENERATED)
			}
			{
				p.SetState(1631)
				p.Match(MySqlParserALWAYS)
			}

		}
		{
			p.SetState(1634)
			p.Match(MySqlParserAS)
		}
		{
			p.SetState(1635)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(1636)
			p.expression(0)
		}
		{
			p.SetState(1637)
			p.Match(MySqlParserRR_BRACKET)
		}
		p.SetState(1639)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserSTORED || _la == MySqlParserVIRTUAL {
			{
				p.SetState(1638)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserSTORED || _la == MySqlParserVIRTUAL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	case MySqlParserSERIAL:
		localctx = NewSerialDefaultColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1641)
			p.Match(MySqlParserSERIAL)
		}
		{
			p.SetState(1642)
			p.Match(MySqlParserDEFAULT)
		}
		{
			p.SetState(1643)
			p.Match(MySqlParserVALUE)
		}

	case MySqlParserCHECK, MySqlParserCONSTRAINT:
		localctx = NewCheckColumnConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		p.SetState(1648)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCONSTRAINT {
			{
				p.SetState(1644)
				p.Match(MySqlParserCONSTRAINT)
			}
			p.SetState(1646)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&756891332513120256) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&146666055071174737) != 0) || ((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&134349441) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-2882305960540372993) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-4398063288321) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-16325548649218049) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-81064793296864001) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-68719476801) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-11118270170269697) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-33) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-3073) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&144115188075855871) != 0) || ((int64((_la-1121)) & ^0x3f) == 0 && ((int64(1)<<(_la-1121))&25807552513) != 0) {
				{
					p.SetState(1645)

					var _x = p.Uid()

					localctx.(*CheckColumnConstraintContext).name = _x
				}

			}

		}
		{
			p.SetState(1650)
			p.Match(MySqlParserCHECK)
		}
		{
			p.SetState(1651)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(1652)
			p.expression(0)
		}
		{
			p.SetState(1653)
			p.Match(MySqlParserRR_BRACKET)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITableConstraintContext is an interface to support dynamic dispatch.
type ITableConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTableConstraintContext differentiates from other interfaces.
	IsTableConstraintContext()
}

type TableConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableConstraintContext() *TableConstraintContext {
	var p = new(TableConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_tableConstraint
	return p
}

func (*TableConstraintContext) IsTableConstraintContext() {}

func NewTableConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableConstraintContext {
	var p = new(TableConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tableConstraint

	return p
}

func (s *TableConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *TableConstraintContext) CopyFrom(ctx *TableConstraintContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *TableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UniqueKeyTableConstraintContext struct {
	*TableConstraintContext
	name        IUidContext
	indexFormat antlr.Token
	index       IUidContext
}

func NewUniqueKeyTableConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UniqueKeyTableConstraintContext {
	var p = new(UniqueKeyTableConstraintContext)

	p.TableConstraintContext = NewEmptyTableConstraintContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableConstraintContext))

	return p
}

func (s *UniqueKeyTableConstraintContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *UniqueKeyTableConstraintContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *UniqueKeyTableConstraintContext) GetName() IUidContext { return s.name }

func (s *UniqueKeyTableConstraintContext) GetIndex() IUidContext { return s.index }

func (s *UniqueKeyTableConstraintContext) SetName(v IUidContext) { s.name = v }

func (s *UniqueKeyTableConstraintContext) SetIndex(v IUidContext) { s.index = v }

func (s *UniqueKeyTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UniqueKeyTableConstraintContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNIQUE, 0)
}

func (s *UniqueKeyTableConstraintContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *UniqueKeyTableConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT, 0)
}

func (s *UniqueKeyTableConstraintContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *UniqueKeyTableConstraintContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *UniqueKeyTableConstraintContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *UniqueKeyTableConstraintContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *UniqueKeyTableConstraintContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *UniqueKeyTableConstraintContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *UniqueKeyTableConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *UniqueKeyTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUniqueKeyTableConstraint(s)
	}
}

func (s *UniqueKeyTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUniqueKeyTableConstraint(s)
	}
}

type CheckTableConstraintContext struct {
	*TableConstraintContext
	name IUidContext
}

func NewCheckTableConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CheckTableConstraintContext {
	var p = new(CheckTableConstraintContext)

	p.TableConstraintContext = NewEmptyTableConstraintContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableConstraintContext))

	return p
}

func (s *CheckTableConstraintContext) GetName() IUidContext { return s.name }

func (s *CheckTableConstraintContext) SetName(v IUidContext) { s.name = v }

func (s *CheckTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckTableConstraintContext) CHECK() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHECK, 0)
}

func (s *CheckTableConstraintContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CheckTableConstraintContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CheckTableConstraintContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CheckTableConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT, 0)
}

func (s *CheckTableConstraintContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CheckTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCheckTableConstraint(s)
	}
}

func (s *CheckTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCheckTableConstraint(s)
	}
}

type PrimaryKeyTableConstraintContext struct {
	*TableConstraintContext
	name  IUidContext
	index IUidContext
}

func NewPrimaryKeyTableConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryKeyTableConstraintContext {
	var p = new(PrimaryKeyTableConstraintContext)

	p.TableConstraintContext = NewEmptyTableConstraintContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableConstraintContext))

	return p
}

func (s *PrimaryKeyTableConstraintContext) GetName() IUidContext { return s.name }

func (s *PrimaryKeyTableConstraintContext) GetIndex() IUidContext { return s.index }

func (s *PrimaryKeyTableConstraintContext) SetName(v IUidContext) { s.name = v }

func (s *PrimaryKeyTableConstraintContext) SetIndex(v IUidContext) { s.index = v }

func (s *PrimaryKeyTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryKeyTableConstraintContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRIMARY, 0)
}

func (s *PrimaryKeyTableConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *PrimaryKeyTableConstraintContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *PrimaryKeyTableConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT, 0)
}

func (s *PrimaryKeyTableConstraintContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *PrimaryKeyTableConstraintContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *PrimaryKeyTableConstraintContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *PrimaryKeyTableConstraintContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *PrimaryKeyTableConstraintContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PrimaryKeyTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPrimaryKeyTableConstraint(s)
	}
}

func (s *PrimaryKeyTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPrimaryKeyTableConstraint(s)
	}
}

type ForeignKeyTableConstraintContext struct {
	*TableConstraintContext
	name  IUidContext
	index IUidContext
}

func NewForeignKeyTableConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForeignKeyTableConstraintContext {
	var p = new(ForeignKeyTableConstraintContext)

	p.TableConstraintContext = NewEmptyTableConstraintContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableConstraintContext))

	return p
}

func (s *ForeignKeyTableConstraintContext) GetName() IUidContext { return s.name }

func (s *ForeignKeyTableConstraintContext) GetIndex() IUidContext { return s.index }

func (s *ForeignKeyTableConstraintContext) SetName(v IUidContext) { s.name = v }

func (s *ForeignKeyTableConstraintContext) SetIndex(v IUidContext) { s.index = v }

func (s *ForeignKeyTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForeignKeyTableConstraintContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOREIGN, 0)
}

func (s *ForeignKeyTableConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *ForeignKeyTableConstraintContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *ForeignKeyTableConstraintContext) ReferenceDefinition() IReferenceDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceDefinitionContext)
}

func (s *ForeignKeyTableConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT, 0)
}

func (s *ForeignKeyTableConstraintContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *ForeignKeyTableConstraintContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ForeignKeyTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterForeignKeyTableConstraint(s)
	}
}

func (s *ForeignKeyTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitForeignKeyTableConstraint(s)
	}
}

func (p *MySqlParser) TableConstraint() (localctx ITableConstraintContext) {
	this := p
	_ = this

	localctx = NewTableConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, MySqlParserRULE_tableConstraint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1726)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 175, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPrimaryKeyTableConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1661)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCONSTRAINT {
			{
				p.SetState(1657)
				p.Match(MySqlParserCONSTRAINT)
			}
			p.SetState(1659)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 159, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1658)

					var _x = p.Uid()

					localctx.(*PrimaryKeyTableConstraintContext).name = _x
				}

			}

		}
		{
			p.SetState(1663)
			p.Match(MySqlParserPRIMARY)
		}
		{
			p.SetState(1664)
			p.Match(MySqlParserKEY)
		}
		p.SetState(1666)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&756891332513120256) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&146666055071174737) != 0) || ((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&134349441) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-2882305960540372993) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-4398063288321) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-16325548649218049) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-81064793296864001) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-68719476801) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-11118270170269697) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-33) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-3073) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&144115188075855871) != 0) || ((int64((_la-1121)) & ^0x3f) == 0 && ((int64(1)<<(_la-1121))&25807552513) != 0) {
			{
				p.SetState(1665)

				var _x = p.Uid()

				localctx.(*PrimaryKeyTableConstraintContext).index = _x
			}

		}
		p.SetState(1669)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserUSING {
			{
				p.SetState(1668)
				p.IndexType()
			}

		}
		{
			p.SetState(1671)
			p.IndexColumnNames()
		}
		p.SetState(1675)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserUSING || _la == MySqlParserWITH || _la == MySqlParserCOMMENT || _la == MySqlParserINVISIBLE || _la == MySqlParserKEY_BLOCK_SIZE || _la == MySqlParserVISIBLE || _la == MySqlParserENGINE_ATTRIBUTE || _la == MySqlParserSECONDARY_ENGINE_ATTRIBUTE {
			{
				p.SetState(1672)
				p.IndexOption()
			}

			p.SetState(1677)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewUniqueKeyTableConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1682)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCONSTRAINT {
			{
				p.SetState(1678)
				p.Match(MySqlParserCONSTRAINT)
			}
			p.SetState(1680)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&756891332513120256) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&146666055071174737) != 0) || ((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&134349441) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-2882305960540372993) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-4398063288321) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-16325548649218049) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-81064793296864001) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-68719476801) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-11118270170269697) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-33) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-3073) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&144115188075855871) != 0) || ((int64((_la-1121)) & ^0x3f) == 0 && ((int64(1)<<(_la-1121))&25807552513) != 0) {
				{
					p.SetState(1679)

					var _x = p.Uid()

					localctx.(*UniqueKeyTableConstraintContext).name = _x
				}

			}

		}
		{
			p.SetState(1684)
			p.Match(MySqlParserUNIQUE)
		}
		p.SetState(1686)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserINDEX || _la == MySqlParserKEY {
			{
				p.SetState(1685)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*UniqueKeyTableConstraintContext).indexFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserINDEX || _la == MySqlParserKEY) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*UniqueKeyTableConstraintContext).indexFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1689)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&756891332513120256) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&146666055071174737) != 0) || ((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&134349441) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-2882305960540372993) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-4398063288321) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-16325548649218049) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-81064793296864001) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-68719476801) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-11118270170269697) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-33) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-3073) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&144115188075855871) != 0) || ((int64((_la-1121)) & ^0x3f) == 0 && ((int64(1)<<(_la-1121))&25807552513) != 0) {
			{
				p.SetState(1688)

				var _x = p.Uid()

				localctx.(*UniqueKeyTableConstraintContext).index = _x
			}

		}
		p.SetState(1692)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserUSING {
			{
				p.SetState(1691)
				p.IndexType()
			}

		}
		{
			p.SetState(1694)
			p.IndexColumnNames()
		}
		p.SetState(1698)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserUSING || _la == MySqlParserWITH || _la == MySqlParserCOMMENT || _la == MySqlParserINVISIBLE || _la == MySqlParserKEY_BLOCK_SIZE || _la == MySqlParserVISIBLE || _la == MySqlParserENGINE_ATTRIBUTE || _la == MySqlParserSECONDARY_ENGINE_ATTRIBUTE {
			{
				p.SetState(1695)
				p.IndexOption()
			}

			p.SetState(1700)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		localctx = NewForeignKeyTableConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1705)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCONSTRAINT {
			{
				p.SetState(1701)
				p.Match(MySqlParserCONSTRAINT)
			}
			p.SetState(1703)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&756891332513120256) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&146666055071174737) != 0) || ((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&134349441) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-2882305960540372993) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-4398063288321) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-16325548649218049) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-81064793296864001) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-68719476801) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-11118270170269697) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-33) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-3073) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&144115188075855871) != 0) || ((int64((_la-1121)) & ^0x3f) == 0 && ((int64(1)<<(_la-1121))&25807552513) != 0) {
				{
					p.SetState(1702)

					var _x = p.Uid()

					localctx.(*ForeignKeyTableConstraintContext).name = _x
				}

			}

		}
		{
			p.SetState(1707)
			p.Match(MySqlParserFOREIGN)
		}
		{
			p.SetState(1708)
			p.Match(MySqlParserKEY)
		}
		p.SetState(1710)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&756891332513120256) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&146666055071174737) != 0) || ((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&134349441) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-2882305960540372993) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-4398063288321) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-16325548649218049) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-81064793296864001) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-68719476801) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-11118270170269697) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-33) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-3073) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&144115188075855871) != 0) || ((int64((_la-1121)) & ^0x3f) == 0 && ((int64(1)<<(_la-1121))&25807552513) != 0) {
			{
				p.SetState(1709)

				var _x = p.Uid()

				localctx.(*ForeignKeyTableConstraintContext).index = _x
			}

		}
		{
			p.SetState(1712)
			p.IndexColumnNames()
		}
		{
			p.SetState(1713)
			p.ReferenceDefinition()
		}

	case 4:
		localctx = NewCheckTableConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1719)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCONSTRAINT {
			{
				p.SetState(1715)
				p.Match(MySqlParserCONSTRAINT)
			}
			p.SetState(1717)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&756891332513120256) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&146666055071174737) != 0) || ((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&134349441) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-2882305960540372993) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-4398063288321) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-16325548649218049) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-81064793296864001) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-68719476801) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-11118270170269697) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-33) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-3073) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&144115188075855871) != 0) || ((int64((_la-1121)) & ^0x3f) == 0 && ((int64(1)<<(_la-1121))&25807552513) != 0) {
				{
					p.SetState(1716)

					var _x = p.Uid()

					localctx.(*CheckTableConstraintContext).name = _x
				}

			}

		}
		{
			p.SetState(1721)
			p.Match(MySqlParserCHECK)
		}
		{
			p.SetState(1722)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(1723)
			p.expression(0)
		}
		{
			p.SetState(1724)
			p.Match(MySqlParserRR_BRACKET)
		}

	}

	return localctx
}

// IReferenceDefinitionContext is an interface to support dynamic dispatch.
type IReferenceDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMatchType returns the matchType token.
	GetMatchType() antlr.Token

	// SetMatchType sets the matchType token.
	SetMatchType(antlr.Token)

	// Getter signatures
	REFERENCES() antlr.TerminalNode
	TableName() ITableNameContext
	IndexColumnNames() IIndexColumnNamesContext
	MATCH() antlr.TerminalNode
	ReferenceAction() IReferenceActionContext
	FULL() antlr.TerminalNode
	PARTIAL() antlr.TerminalNode
	SIMPLE() antlr.TerminalNode

	// IsReferenceDefinitionContext differentiates from other interfaces.
	IsReferenceDefinitionContext()
}

type ReferenceDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	matchType antlr.Token
}

func NewEmptyReferenceDefinitionContext() *ReferenceDefinitionContext {
	var p = new(ReferenceDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_referenceDefinition
	return p
}

func (*ReferenceDefinitionContext) IsReferenceDefinitionContext() {}

func NewReferenceDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceDefinitionContext {
	var p = new(ReferenceDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_referenceDefinition

	return p
}

func (s *ReferenceDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceDefinitionContext) GetMatchType() antlr.Token { return s.matchType }

func (s *ReferenceDefinitionContext) SetMatchType(v antlr.Token) { s.matchType = v }

func (s *ReferenceDefinitionContext) REFERENCES() antlr.TerminalNode {
	return s.GetToken(MySqlParserREFERENCES, 0)
}

func (s *ReferenceDefinitionContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *ReferenceDefinitionContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *ReferenceDefinitionContext) MATCH() antlr.TerminalNode {
	return s.GetToken(MySqlParserMATCH, 0)
}

func (s *ReferenceDefinitionContext) ReferenceAction() IReferenceActionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceActionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceActionContext)
}

func (s *ReferenceDefinitionContext) FULL() antlr.TerminalNode {
	return s.GetToken(MySqlParserFULL, 0)
}

func (s *ReferenceDefinitionContext) PARTIAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTIAL, 0)
}

func (s *ReferenceDefinitionContext) SIMPLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSIMPLE, 0)
}

func (s *ReferenceDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferenceDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterReferenceDefinition(s)
	}
}

func (s *ReferenceDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitReferenceDefinition(s)
	}
}

func (p *MySqlParser) ReferenceDefinition() (localctx IReferenceDefinitionContext) {
	this := p
	_ = this

	localctx = NewReferenceDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, MySqlParserRULE_referenceDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1728)
		p.Match(MySqlParserREFERENCES)
	}
	{
		p.SetState(1729)
		p.TableName()
	}
	p.SetState(1731)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 176, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1730)
			p.IndexColumnNames()
		}

	}
	p.SetState(1735)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserMATCH {
		{
			p.SetState(1733)
			p.Match(MySqlParserMATCH)
		}
		{
			p.SetState(1734)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ReferenceDefinitionContext).matchType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFULL || _la == MySqlParserPARTIAL || _la == MySqlParserSIMPLE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ReferenceDefinitionContext).matchType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1738)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 178, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1737)
			p.ReferenceAction()
		}

	}

	return localctx
}

// IReferenceActionContext is an interface to support dynamic dispatch.
type IReferenceActionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOnDelete returns the onDelete rule contexts.
	GetOnDelete() IReferenceControlTypeContext

	// GetOnUpdate returns the onUpdate rule contexts.
	GetOnUpdate() IReferenceControlTypeContext

	// SetOnDelete sets the onDelete rule contexts.
	SetOnDelete(IReferenceControlTypeContext)

	// SetOnUpdate sets the onUpdate rule contexts.
	SetOnUpdate(IReferenceControlTypeContext)

	// Getter signatures
	AllON() []antlr.TerminalNode
	ON(i int) antlr.TerminalNode
	DELETE() antlr.TerminalNode
	AllReferenceControlType() []IReferenceControlTypeContext
	ReferenceControlType(i int) IReferenceControlTypeContext
	UPDATE() antlr.TerminalNode

	// IsReferenceActionContext differentiates from other interfaces.
	IsReferenceActionContext()
}

type ReferenceActionContext struct {
	*antlr.BaseParserRuleContext
	parser   antlr.Parser
	onDelete IReferenceControlTypeContext
	onUpdate IReferenceControlTypeContext
}

func NewEmptyReferenceActionContext() *ReferenceActionContext {
	var p = new(ReferenceActionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_referenceAction
	return p
}

func (*ReferenceActionContext) IsReferenceActionContext() {}

func NewReferenceActionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceActionContext {
	var p = new(ReferenceActionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_referenceAction

	return p
}

func (s *ReferenceActionContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceActionContext) GetOnDelete() IReferenceControlTypeContext { return s.onDelete }

func (s *ReferenceActionContext) GetOnUpdate() IReferenceControlTypeContext { return s.onUpdate }

func (s *ReferenceActionContext) SetOnDelete(v IReferenceControlTypeContext) { s.onDelete = v }

func (s *ReferenceActionContext) SetOnUpdate(v IReferenceControlTypeContext) { s.onUpdate = v }

func (s *ReferenceActionContext) AllON() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserON)
}

func (s *ReferenceActionContext) ON(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserON, i)
}

func (s *ReferenceActionContext) DELETE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDELETE, 0)
}

func (s *ReferenceActionContext) AllReferenceControlType() []IReferenceControlTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReferenceControlTypeContext); ok {
			len++
		}
	}

	tst := make([]IReferenceControlTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReferenceControlTypeContext); ok {
			tst[i] = t.(IReferenceControlTypeContext)
			i++
		}
	}

	return tst
}

func (s *ReferenceActionContext) ReferenceControlType(i int) IReferenceControlTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceControlTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceControlTypeContext)
}

func (s *ReferenceActionContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPDATE, 0)
}

func (s *ReferenceActionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceActionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferenceActionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterReferenceAction(s)
	}
}

func (s *ReferenceActionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitReferenceAction(s)
	}
}

func (p *MySqlParser) ReferenceAction() (localctx IReferenceActionContext) {
	this := p
	_ = this

	localctx = NewReferenceActionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, MySqlParserRULE_referenceAction)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1756)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 181, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1740)
			p.Match(MySqlParserON)
		}
		{
			p.SetState(1741)
			p.Match(MySqlParserDELETE)
		}
		{
			p.SetState(1742)

			var _x = p.ReferenceControlType()

			localctx.(*ReferenceActionContext).onDelete = _x
		}
		p.SetState(1746)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 179, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1743)
				p.Match(MySqlParserON)
			}
			{
				p.SetState(1744)
				p.Match(MySqlParserUPDATE)
			}
			{
				p.SetState(1745)

				var _x = p.ReferenceControlType()

				localctx.(*ReferenceActionContext).onUpdate = _x
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1748)
			p.Match(MySqlParserON)
		}
		{
			p.SetState(1749)
			p.Match(MySqlParserUPDATE)
		}
		{
			p.SetState(1750)

			var _x = p.ReferenceControlType()

			localctx.(*ReferenceActionContext).onUpdate = _x
		}
		p.SetState(1754)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 180, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1751)
				p.Match(MySqlParserON)
			}
			{
				p.SetState(1752)
				p.Match(MySqlParserDELETE)
			}
			{
				p.SetState(1753)

				var _x = p.ReferenceControlType()

				localctx.(*ReferenceActionContext).onDelete = _x
			}

		}

	}

	return localctx
}

// IReferenceControlTypeContext is an interface to support dynamic dispatch.
type IReferenceControlTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESTRICT() antlr.TerminalNode
	CASCADE() antlr.TerminalNode
	SET() antlr.TerminalNode
	NULL_LITERAL() antlr.TerminalNode
	NO() antlr.TerminalNode
	ACTION() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode

	// IsReferenceControlTypeContext differentiates from other interfaces.
	IsReferenceControlTypeContext()
}

type ReferenceControlTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferenceControlTypeContext() *ReferenceControlTypeContext {
	var p = new(ReferenceControlTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_referenceControlType
	return p
}

func (*ReferenceControlTypeContext) IsReferenceControlTypeContext() {}

func NewReferenceControlTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceControlTypeContext {
	var p = new(ReferenceControlTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_referenceControlType

	return p
}

func (s *ReferenceControlTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceControlTypeContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESTRICT, 0)
}

func (s *ReferenceControlTypeContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCASCADE, 0)
}

func (s *ReferenceControlTypeContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *ReferenceControlTypeContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserNULL_LITERAL, 0)
}

func (s *ReferenceControlTypeContext) NO() antlr.TerminalNode {
	return s.GetToken(MySqlParserNO, 0)
}

func (s *ReferenceControlTypeContext) ACTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserACTION, 0)
}

func (s *ReferenceControlTypeContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *ReferenceControlTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceControlTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferenceControlTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterReferenceControlType(s)
	}
}

func (s *ReferenceControlTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitReferenceControlType(s)
	}
}

func (p *MySqlParser) ReferenceControlType() (localctx IReferenceControlTypeContext) {
	this := p
	_ = this

	localctx = NewReferenceControlTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, MySqlParserRULE_referenceControlType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1766)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 182, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1758)
			p.Match(MySqlParserRESTRICT)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1759)
			p.Match(MySqlParserCASCADE)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1760)
			p.Match(MySqlParserSET)
		}
		{
			p.SetState(1761)
			p.Match(MySqlParserNULL_LITERAL)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1762)
			p.Match(MySqlParserNO)
		}
		{
			p.SetState(1763)
			p.Match(MySqlParserACTION)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1764)
			p.Match(MySqlParserSET)
		}
		{
			p.SetState(1765)
			p.Match(MySqlParserDEFAULT)
		}

	}

	return localctx
}

// IIndexColumnDefinitionContext is an interface to support dynamic dispatch.
type IIndexColumnDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsIndexColumnDefinitionContext differentiates from other interfaces.
	IsIndexColumnDefinitionContext()
}

type IndexColumnDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexColumnDefinitionContext() *IndexColumnDefinitionContext {
	var p = new(IndexColumnDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_indexColumnDefinition
	return p
}

func (*IndexColumnDefinitionContext) IsIndexColumnDefinitionContext() {}

func NewIndexColumnDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexColumnDefinitionContext {
	var p = new(IndexColumnDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_indexColumnDefinition

	return p
}

func (s *IndexColumnDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexColumnDefinitionContext) CopyFrom(ctx *IndexColumnDefinitionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *IndexColumnDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexColumnDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SpecialIndexDeclarationContext struct {
	*IndexColumnDefinitionContext
	indexFormat antlr.Token
}

func NewSpecialIndexDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpecialIndexDeclarationContext {
	var p = new(SpecialIndexDeclarationContext)

	p.IndexColumnDefinitionContext = NewEmptyIndexColumnDefinitionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IndexColumnDefinitionContext))

	return p
}

func (s *SpecialIndexDeclarationContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *SpecialIndexDeclarationContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *SpecialIndexDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialIndexDeclarationContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *SpecialIndexDeclarationContext) FULLTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserFULLTEXT, 0)
}

func (s *SpecialIndexDeclarationContext) SPATIAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSPATIAL, 0)
}

func (s *SpecialIndexDeclarationContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SpecialIndexDeclarationContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *SpecialIndexDeclarationContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *SpecialIndexDeclarationContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *SpecialIndexDeclarationContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *SpecialIndexDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSpecialIndexDeclaration(s)
	}
}

func (s *SpecialIndexDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSpecialIndexDeclaration(s)
	}
}

type SimpleIndexDeclarationContext struct {
	*IndexColumnDefinitionContext
	indexFormat antlr.Token
}

func NewSimpleIndexDeclarationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleIndexDeclarationContext {
	var p = new(SimpleIndexDeclarationContext)

	p.IndexColumnDefinitionContext = NewEmptyIndexColumnDefinitionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IndexColumnDefinitionContext))

	return p
}

func (s *SimpleIndexDeclarationContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *SimpleIndexDeclarationContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *SimpleIndexDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleIndexDeclarationContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *SimpleIndexDeclarationContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *SimpleIndexDeclarationContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *SimpleIndexDeclarationContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SimpleIndexDeclarationContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *SimpleIndexDeclarationContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *SimpleIndexDeclarationContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *SimpleIndexDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSimpleIndexDeclaration(s)
	}
}

func (s *SimpleIndexDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSimpleIndexDeclaration(s)
	}
}

func (p *MySqlParser) IndexColumnDefinition() (localctx IIndexColumnDefinitionContext) {
	this := p
	_ = this

	localctx = NewIndexColumnDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, MySqlParserRULE_indexColumnDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1796)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserINDEX, MySqlParserKEY:
		localctx = NewSimpleIndexDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1768)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SimpleIndexDeclarationContext).indexFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserINDEX || _la == MySqlParserKEY) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SimpleIndexDeclarationContext).indexFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1770)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&756891332513120256) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&146666055071174737) != 0) || ((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&134349441) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-2882305960540372993) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-4398063288321) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-16325548649218049) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-81064793296864001) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-68719476801) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-11118270170269697) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-33) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-3073) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&144115188075855871) != 0) || ((int64((_la-1121)) & ^0x3f) == 0 && ((int64(1)<<(_la-1121))&25807552513) != 0) {
			{
				p.SetState(1769)
				p.Uid()
			}

		}
		p.SetState(1773)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserUSING {
			{
				p.SetState(1772)
				p.IndexType()
			}

		}
		{
			p.SetState(1775)
			p.IndexColumnNames()
		}
		p.SetState(1779)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserUSING || _la == MySqlParserWITH || _la == MySqlParserCOMMENT || _la == MySqlParserINVISIBLE || _la == MySqlParserKEY_BLOCK_SIZE || _la == MySqlParserVISIBLE || _la == MySqlParserENGINE_ATTRIBUTE || _la == MySqlParserSECONDARY_ENGINE_ATTRIBUTE {
			{
				p.SetState(1776)
				p.IndexOption()
			}

			p.SetState(1781)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case MySqlParserFULLTEXT, MySqlParserSPATIAL:
		localctx = NewSpecialIndexDeclarationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1782)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFULLTEXT || _la == MySqlParserSPATIAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1784)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserINDEX || _la == MySqlParserKEY {
			{
				p.SetState(1783)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*SpecialIndexDeclarationContext).indexFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserINDEX || _la == MySqlParserKEY) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*SpecialIndexDeclarationContext).indexFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1787)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&756891332513120256) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&146666055071174737) != 0) || ((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&134349441) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-2882305960540372993) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-4398063288321) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-16325548649218049) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-81064793296864001) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-68719476801) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-11118270170269697) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-33) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-3073) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&144115188075855871) != 0) || ((int64((_la-1121)) & ^0x3f) == 0 && ((int64(1)<<(_la-1121))&25807552513) != 0) {
			{
				p.SetState(1786)
				p.Uid()
			}

		}
		{
			p.SetState(1789)
			p.IndexColumnNames()
		}
		p.SetState(1793)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserUSING || _la == MySqlParserWITH || _la == MySqlParserCOMMENT || _la == MySqlParserINVISIBLE || _la == MySqlParserKEY_BLOCK_SIZE || _la == MySqlParserVISIBLE || _la == MySqlParserENGINE_ATTRIBUTE || _la == MySqlParserSECONDARY_ENGINE_ATTRIBUTE {
			{
				p.SetState(1790)
				p.IndexOption()
			}

			p.SetState(1795)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITableOptionContext is an interface to support dynamic dispatch.
type ITableOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTableOptionContext differentiates from other interfaces.
	IsTableOptionContext()
}

type TableOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableOptionContext() *TableOptionContext {
	var p = new(TableOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_tableOption
	return p
}

func (*TableOptionContext) IsTableOptionContext() {}

func NewTableOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableOptionContext {
	var p = new(TableOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tableOption

	return p
}

func (s *TableOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *TableOptionContext) CopyFrom(ctx *TableOptionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *TableOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TableOptionEngineContext struct {
	*TableOptionContext
}

func NewTableOptionEngineContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionEngineContext {
	var p = new(TableOptionEngineContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionEngineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionEngineContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE, 0)
}

func (s *TableOptionEngineContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionEngineContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *TableOptionEngineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionEngine(s)
	}
}

func (s *TableOptionEngineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionEngine(s)
	}
}

type TableOptionMaxRowsContext struct {
	*TableOptionContext
}

func NewTableOptionMaxRowsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionMaxRowsContext {
	var p = new(TableOptionMaxRowsContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionMaxRowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionMaxRowsContext) MAX_ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_ROWS, 0)
}

func (s *TableOptionMaxRowsContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionMaxRowsContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionMaxRowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionMaxRows(s)
	}
}

func (s *TableOptionMaxRowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionMaxRows(s)
	}
}

type TableOptionCollateContext struct {
	*TableOptionContext
}

func NewTableOptionCollateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionCollateContext {
	var p = new(TableOptionCollateContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionCollateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionCollateContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATE, 0)
}

func (s *TableOptionCollateContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *TableOptionCollateContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *TableOptionCollateContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionCollateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionCollate(s)
	}
}

func (s *TableOptionCollateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionCollate(s)
	}
}

type TableOptionPersistentContext struct {
	*TableOptionContext
	extBoolValue antlr.Token
}

func NewTableOptionPersistentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionPersistentContext {
	var p = new(TableOptionPersistentContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionPersistentContext) GetExtBoolValue() antlr.Token { return s.extBoolValue }

func (s *TableOptionPersistentContext) SetExtBoolValue(v antlr.Token) { s.extBoolValue = v }

func (s *TableOptionPersistentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionPersistentContext) STATS_PERSISTENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATS_PERSISTENT, 0)
}

func (s *TableOptionPersistentContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *TableOptionPersistentContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserZERO_DECIMAL, 0)
}

func (s *TableOptionPersistentContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *TableOptionPersistentContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionPersistentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionPersistent(s)
	}
}

func (s *TableOptionPersistentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionPersistent(s)
	}
}

type TableOptionTablespaceContext struct {
	*TableOptionContext
}

func NewTableOptionTablespaceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionTablespaceContext {
	var p = new(TableOptionTablespaceContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionTablespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionTablespaceContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLESPACE, 0)
}

func (s *TableOptionTablespaceContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *TableOptionTablespaceContext) TablespaceStorage() ITablespaceStorageContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablespaceStorageContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablespaceStorageContext)
}

func (s *TableOptionTablespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionTablespace(s)
	}
}

func (s *TableOptionTablespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionTablespace(s)
	}
}

type TableOptionAutoextendSizeContext struct {
	*TableOptionContext
}

func NewTableOptionAutoextendSizeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionAutoextendSizeContext {
	var p = new(TableOptionAutoextendSizeContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionAutoextendSizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionAutoextendSizeContext) AUTOEXTEND_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUTOEXTEND_SIZE, 0)
}

func (s *TableOptionAutoextendSizeContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionAutoextendSizeContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionAutoextendSizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionAutoextendSize(s)
	}
}

func (s *TableOptionAutoextendSizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionAutoextendSize(s)
	}
}

type TableOptionPageCompressedContext struct {
	*TableOptionContext
}

func NewTableOptionPageCompressedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionPageCompressedContext {
	var p = new(TableOptionPageCompressedContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionPageCompressedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionPageCompressedContext) PAGE_COMPRESSED() antlr.TerminalNode {
	return s.GetToken(MySqlParserPAGE_COMPRESSED, 0)
}

func (s *TableOptionPageCompressedContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *TableOptionPageCompressedContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserZERO_DECIMAL, 0)
}

func (s *TableOptionPageCompressedContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *TableOptionPageCompressedContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionPageCompressedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionPageCompressed(s)
	}
}

func (s *TableOptionPageCompressedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionPageCompressed(s)
	}
}

type TableOptionStartTransactionContext struct {
	*TableOptionContext
}

func NewTableOptionStartTransactionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionStartTransactionContext {
	var p = new(TableOptionStartTransactionContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionStartTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionStartTransactionContext) START() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTART, 0)
}

func (s *TableOptionStartTransactionContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRANSACTION, 0)
}

func (s *TableOptionStartTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionStartTransaction(s)
	}
}

func (s *TableOptionStartTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionStartTransaction(s)
	}
}

type TableOptionPackKeysContext struct {
	*TableOptionContext
	extBoolValue antlr.Token
}

func NewTableOptionPackKeysContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionPackKeysContext {
	var p = new(TableOptionPackKeysContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionPackKeysContext) GetExtBoolValue() antlr.Token { return s.extBoolValue }

func (s *TableOptionPackKeysContext) SetExtBoolValue(v antlr.Token) { s.extBoolValue = v }

func (s *TableOptionPackKeysContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionPackKeysContext) PACK_KEYS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPACK_KEYS, 0)
}

func (s *TableOptionPackKeysContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserZERO_DECIMAL, 0)
}

func (s *TableOptionPackKeysContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *TableOptionPackKeysContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *TableOptionPackKeysContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionPackKeysContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionPackKeys(s)
	}
}

func (s *TableOptionPackKeysContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionPackKeys(s)
	}
}

type TableOptionPasswordContext struct {
	*TableOptionContext
}

func NewTableOptionPasswordContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionPasswordContext {
	var p = new(TableOptionPasswordContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionPasswordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionPasswordContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD, 0)
}

func (s *TableOptionPasswordContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *TableOptionPasswordContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionPasswordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionPassword(s)
	}
}

func (s *TableOptionPasswordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionPassword(s)
	}
}

type TableOptionUnionContext struct {
	*TableOptionContext
}

func NewTableOptionUnionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionUnionContext {
	var p = new(TableOptionUnionContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionUnionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionUnionContext) UNION() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNION, 0)
}

func (s *TableOptionUnionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *TableOptionUnionContext) Tables() ITablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *TableOptionUnionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *TableOptionUnionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionUnionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionUnion(s)
	}
}

func (s *TableOptionUnionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionUnion(s)
	}
}

type TableOptionSamplePageContext struct {
	*TableOptionContext
}

func NewTableOptionSamplePageContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionSamplePageContext {
	var p = new(TableOptionSamplePageContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionSamplePageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionSamplePageContext) STATS_SAMPLE_PAGES() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATS_SAMPLE_PAGES, 0)
}

func (s *TableOptionSamplePageContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *TableOptionSamplePageContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionSamplePageContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionSamplePageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionSamplePage(s)
	}
}

func (s *TableOptionSamplePageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionSamplePage(s)
	}
}

type TableOptionCharsetContext struct {
	*TableOptionContext
}

func NewTableOptionCharsetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionCharsetContext {
	var p = new(TableOptionCharsetContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionCharsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionCharsetContext) CharSet() ICharSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharSetContext)
}

func (s *TableOptionCharsetContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *TableOptionCharsetContext) AllDEFAULT() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserDEFAULT)
}

func (s *TableOptionCharsetContext) DEFAULT(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, i)
}

func (s *TableOptionCharsetContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionCharsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionCharset(s)
	}
}

func (s *TableOptionCharsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionCharset(s)
	}
}

type TableOptionIndexDirectoryContext struct {
	*TableOptionContext
}

func NewTableOptionIndexDirectoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionIndexDirectoryContext {
	var p = new(TableOptionIndexDirectoryContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionIndexDirectoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionIndexDirectoryContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *TableOptionIndexDirectoryContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserDIRECTORY, 0)
}

func (s *TableOptionIndexDirectoryContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *TableOptionIndexDirectoryContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionIndexDirectoryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionIndexDirectory(s)
	}
}

func (s *TableOptionIndexDirectoryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionIndexDirectory(s)
	}
}

type TableOptionTableTypeContext struct {
	*TableOptionContext
}

func NewTableOptionTableTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionTableTypeContext {
	var p = new(TableOptionTableTypeContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionTableTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionTableTypeContext) TABLE_TYPE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE_TYPE, 0)
}

func (s *TableOptionTableTypeContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionTableTypeContext) TableType() ITableTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableTypeContext)
}

func (s *TableOptionTableTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionTableType(s)
	}
}

func (s *TableOptionTableTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionTableType(s)
	}
}

type TableOptionKeyBlockSizeContext struct {
	*TableOptionContext
}

func NewTableOptionKeyBlockSizeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionKeyBlockSizeContext {
	var p = new(TableOptionKeyBlockSizeContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionKeyBlockSizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionKeyBlockSizeContext) KEY_BLOCK_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY_BLOCK_SIZE, 0)
}

func (s *TableOptionKeyBlockSizeContext) FileSizeLiteral() IFileSizeLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileSizeLiteralContext)
}

func (s *TableOptionKeyBlockSizeContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionKeyBlockSizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionKeyBlockSize(s)
	}
}

func (s *TableOptionKeyBlockSizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionKeyBlockSize(s)
	}
}

type TableOptionEncryptionContext struct {
	*TableOptionContext
}

func NewTableOptionEncryptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionEncryptionContext {
	var p = new(TableOptionEncryptionContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionEncryptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionEncryptionContext) ENCRYPTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserENCRYPTION, 0)
}

func (s *TableOptionEncryptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *TableOptionEncryptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionEncryptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionEncryption(s)
	}
}

func (s *TableOptionEncryptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionEncryption(s)
	}
}

type TableOptionDataDirectoryContext struct {
	*TableOptionContext
}

func NewTableOptionDataDirectoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionDataDirectoryContext {
	var p = new(TableOptionDataDirectoryContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionDataDirectoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionDataDirectoryContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserDIRECTORY, 0)
}

func (s *TableOptionDataDirectoryContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *TableOptionDataDirectoryContext) DATA() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATA, 0)
}

func (s *TableOptionDataDirectoryContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *TableOptionDataDirectoryContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionDataDirectoryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionDataDirectory(s)
	}
}

func (s *TableOptionDataDirectoryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionDataDirectory(s)
	}
}

type TableOptionRecalculationContext struct {
	*TableOptionContext
	extBoolValue antlr.Token
}

func NewTableOptionRecalculationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionRecalculationContext {
	var p = new(TableOptionRecalculationContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionRecalculationContext) GetExtBoolValue() antlr.Token { return s.extBoolValue }

func (s *TableOptionRecalculationContext) SetExtBoolValue(v antlr.Token) { s.extBoolValue = v }

func (s *TableOptionRecalculationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionRecalculationContext) STATS_AUTO_RECALC() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATS_AUTO_RECALC, 0)
}

func (s *TableOptionRecalculationContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *TableOptionRecalculationContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserZERO_DECIMAL, 0)
}

func (s *TableOptionRecalculationContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *TableOptionRecalculationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionRecalculationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionRecalculation(s)
	}
}

func (s *TableOptionRecalculationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionRecalculation(s)
	}
}

type TableOptionAutoIncrementContext struct {
	*TableOptionContext
}

func NewTableOptionAutoIncrementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionAutoIncrementContext {
	var p = new(TableOptionAutoIncrementContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionAutoIncrementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionAutoIncrementContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUTO_INCREMENT, 0)
}

func (s *TableOptionAutoIncrementContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionAutoIncrementContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionAutoIncrementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionAutoIncrement(s)
	}
}

func (s *TableOptionAutoIncrementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionAutoIncrement(s)
	}
}

type TableOptionEncryptionKeyIdContext struct {
	*TableOptionContext
}

func NewTableOptionEncryptionKeyIdContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionEncryptionKeyIdContext {
	var p = new(TableOptionEncryptionKeyIdContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionEncryptionKeyIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionEncryptionKeyIdContext) ENCRYPTION_KEY_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserENCRYPTION_KEY_ID, 0)
}

func (s *TableOptionEncryptionKeyIdContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionEncryptionKeyIdContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionEncryptionKeyIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionEncryptionKeyId(s)
	}
}

func (s *TableOptionEncryptionKeyIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionEncryptionKeyId(s)
	}
}

type TableOptionChecksumContext struct {
	*TableOptionContext
	boolValue antlr.Token
}

func NewTableOptionChecksumContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionChecksumContext {
	var p = new(TableOptionChecksumContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionChecksumContext) GetBoolValue() antlr.Token { return s.boolValue }

func (s *TableOptionChecksumContext) SetBoolValue(v antlr.Token) { s.boolValue = v }

func (s *TableOptionChecksumContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionChecksumContext) CHECKSUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHECKSUM, 0)
}

func (s *TableOptionChecksumContext) PAGE_CHECKSUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserPAGE_CHECKSUM, 0)
}

func (s *TableOptionChecksumContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserZERO_DECIMAL, 0)
}

func (s *TableOptionChecksumContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *TableOptionChecksumContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionChecksumContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionChecksum(s)
	}
}

func (s *TableOptionChecksumContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionChecksum(s)
	}
}

type TableOptionDelayContext struct {
	*TableOptionContext
	boolValue antlr.Token
}

func NewTableOptionDelayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionDelayContext {
	var p = new(TableOptionDelayContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionDelayContext) GetBoolValue() antlr.Token { return s.boolValue }

func (s *TableOptionDelayContext) SetBoolValue(v antlr.Token) { s.boolValue = v }

func (s *TableOptionDelayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionDelayContext) DELAY_KEY_WRITE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDELAY_KEY_WRITE, 0)
}

func (s *TableOptionDelayContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserZERO_DECIMAL, 0)
}

func (s *TableOptionDelayContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *TableOptionDelayContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionDelayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionDelay(s)
	}
}

func (s *TableOptionDelayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionDelay(s)
	}
}

type TableOptionConnectionContext struct {
	*TableOptionContext
}

func NewTableOptionConnectionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionConnectionContext {
	var p = new(TableOptionConnectionContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionConnectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionConnectionContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONNECTION, 0)
}

func (s *TableOptionConnectionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *TableOptionConnectionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionConnectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionConnection(s)
	}
}

func (s *TableOptionConnectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionConnection(s)
	}
}

type TableOptionTransactionalContext struct {
	*TableOptionContext
}

func NewTableOptionTransactionalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionTransactionalContext {
	var p = new(TableOptionTransactionalContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionTransactionalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionTransactionalContext) TRANSACTIONAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRANSACTIONAL, 0)
}

func (s *TableOptionTransactionalContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserZERO_DECIMAL, 0)
}

func (s *TableOptionTransactionalContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *TableOptionTransactionalContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionTransactionalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionTransactional(s)
	}
}

func (s *TableOptionTransactionalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionTransactional(s)
	}
}

type TableOptionPageCompressionLevelContext struct {
	*TableOptionContext
}

func NewTableOptionPageCompressionLevelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionPageCompressionLevelContext {
	var p = new(TableOptionPageCompressionLevelContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionPageCompressionLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionPageCompressionLevelContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionPageCompressionLevelContext) PAGE_COMPRESSION_LEVEL() antlr.TerminalNode {
	return s.GetToken(MySqlParserPAGE_COMPRESSION_LEVEL, 0)
}

func (s *TableOptionPageCompressionLevelContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *TableOptionPageCompressionLevelContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionPageCompressionLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionPageCompressionLevel(s)
	}
}

func (s *TableOptionPageCompressionLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionPageCompressionLevel(s)
	}
}

type TableOptionSecondaryEngineAttributeContext struct {
	*TableOptionContext
}

func NewTableOptionSecondaryEngineAttributeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionSecondaryEngineAttributeContext {
	var p = new(TableOptionSecondaryEngineAttributeContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionSecondaryEngineAttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionSecondaryEngineAttributeContext) SECONDARY_ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSECONDARY_ENGINE_ATTRIBUTE, 0)
}

func (s *TableOptionSecondaryEngineAttributeContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *TableOptionSecondaryEngineAttributeContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionSecondaryEngineAttributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionSecondaryEngineAttribute(s)
	}
}

func (s *TableOptionSecondaryEngineAttributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionSecondaryEngineAttribute(s)
	}
}

type TableOptionCommentContext struct {
	*TableOptionContext
}

func NewTableOptionCommentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionCommentContext {
	var p = new(TableOptionCommentContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionCommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionCommentContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT, 0)
}

func (s *TableOptionCommentContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *TableOptionCommentContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionCommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionComment(s)
	}
}

func (s *TableOptionCommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionComment(s)
	}
}

type TableOptionAverageContext struct {
	*TableOptionContext
}

func NewTableOptionAverageContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionAverageContext {
	var p = new(TableOptionAverageContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionAverageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionAverageContext) AVG_ROW_LENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserAVG_ROW_LENGTH, 0)
}

func (s *TableOptionAverageContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionAverageContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionAverageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionAverage(s)
	}
}

func (s *TableOptionAverageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionAverage(s)
	}
}

type TableOptionRowFormatContext struct {
	*TableOptionContext
	rowFormat antlr.Token
}

func NewTableOptionRowFormatContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionRowFormatContext {
	var p = new(TableOptionRowFormatContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionRowFormatContext) GetRowFormat() antlr.Token { return s.rowFormat }

func (s *TableOptionRowFormatContext) SetRowFormat(v antlr.Token) { s.rowFormat = v }

func (s *TableOptionRowFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionRowFormatContext) ROW_FORMAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserROW_FORMAT, 0)
}

func (s *TableOptionRowFormatContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *TableOptionRowFormatContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDYNAMIC, 0)
}

func (s *TableOptionRowFormatContext) FIXED() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIXED, 0)
}

func (s *TableOptionRowFormatContext) COMPRESSED() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMPRESSED, 0)
}

func (s *TableOptionRowFormatContext) REDUNDANT() antlr.TerminalNode {
	return s.GetToken(MySqlParserREDUNDANT, 0)
}

func (s *TableOptionRowFormatContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMPACT, 0)
}

func (s *TableOptionRowFormatContext) ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserID, 0)
}

func (s *TableOptionRowFormatContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionRowFormatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionRowFormat(s)
	}
}

func (s *TableOptionRowFormatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionRowFormat(s)
	}
}

type TableOptionCompressionContext struct {
	*TableOptionContext
}

func NewTableOptionCompressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionCompressionContext {
	var p = new(TableOptionCompressionContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionCompressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionCompressionContext) COMPRESSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMPRESSION, 0)
}

func (s *TableOptionCompressionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *TableOptionCompressionContext) ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserID, 0)
}

func (s *TableOptionCompressionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionCompressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionCompression(s)
	}
}

func (s *TableOptionCompressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionCompression(s)
	}
}

type TableOptionInsertMethodContext struct {
	*TableOptionContext
	insertMethod antlr.Token
}

func NewTableOptionInsertMethodContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionInsertMethodContext {
	var p = new(TableOptionInsertMethodContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionInsertMethodContext) GetInsertMethod() antlr.Token { return s.insertMethod }

func (s *TableOptionInsertMethodContext) SetInsertMethod(v antlr.Token) { s.insertMethod = v }

func (s *TableOptionInsertMethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionInsertMethodContext) INSERT_METHOD() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSERT_METHOD, 0)
}

func (s *TableOptionInsertMethodContext) NO() antlr.TerminalNode {
	return s.GetToken(MySqlParserNO, 0)
}

func (s *TableOptionInsertMethodContext) FIRST() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIRST, 0)
}

func (s *TableOptionInsertMethodContext) LAST() antlr.TerminalNode {
	return s.GetToken(MySqlParserLAST, 0)
}

func (s *TableOptionInsertMethodContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionInsertMethodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionInsertMethod(s)
	}
}

func (s *TableOptionInsertMethodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionInsertMethod(s)
	}
}

type TableOptionEngineAttributeContext struct {
	*TableOptionContext
}

func NewTableOptionEngineAttributeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionEngineAttributeContext {
	var p = new(TableOptionEngineAttributeContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionEngineAttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionEngineAttributeContext) ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE_ATTRIBUTE, 0)
}

func (s *TableOptionEngineAttributeContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *TableOptionEngineAttributeContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionEngineAttributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionEngineAttribute(s)
	}
}

func (s *TableOptionEngineAttributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionEngineAttribute(s)
	}
}

type TableOptionMinRowsContext struct {
	*TableOptionContext
}

func NewTableOptionMinRowsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableOptionMinRowsContext {
	var p = new(TableOptionMinRowsContext)

	p.TableOptionContext = NewEmptyTableOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableOptionContext))

	return p
}

func (s *TableOptionMinRowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionMinRowsContext) MIN_ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMIN_ROWS, 0)
}

func (s *TableOptionMinRowsContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TableOptionMinRowsContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *TableOptionMinRowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableOptionMinRows(s)
	}
}

func (s *TableOptionMinRowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableOptionMinRows(s)
	}
}

func (p *MySqlParser) TableOption() (localctx ITableOptionContext) {
	this := p
	_ = this

	localctx = NewTableOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, MySqlParserRULE_tableOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1983)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 227, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTableOptionEngineContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1798)
			p.Match(MySqlParserENGINE)
		}
		p.SetState(1800)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1799)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		p.SetState(1803)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 191, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1802)
				p.EngineName()
			}

		}

	case 2:
		localctx = NewTableOptionEngineAttributeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1805)
			p.Match(MySqlParserENGINE_ATTRIBUTE)
		}
		p.SetState(1807)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1806)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1809)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	case 3:
		localctx = NewTableOptionAutoextendSizeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1810)
			p.Match(MySqlParserAUTOEXTEND_SIZE)
		}
		p.SetState(1812)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1811)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1814)
			p.DecimalLiteral()
		}

	case 4:
		localctx = NewTableOptionAutoIncrementContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1815)
			p.Match(MySqlParserAUTO_INCREMENT)
		}
		p.SetState(1817)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1816)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1819)
			p.DecimalLiteral()
		}

	case 5:
		localctx = NewTableOptionAverageContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1820)
			p.Match(MySqlParserAVG_ROW_LENGTH)
		}
		p.SetState(1822)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1821)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1824)
			p.DecimalLiteral()
		}

	case 6:
		localctx = NewTableOptionCharsetContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		p.SetState(1826)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserDEFAULT {
			{
				p.SetState(1825)
				p.Match(MySqlParserDEFAULT)
			}

		}
		{
			p.SetState(1828)
			p.CharSet()
		}
		p.SetState(1830)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1829)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		p.SetState(1834)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserBINARY, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL:
			{
				p.SetState(1832)
				p.CharsetName()
			}

		case MySqlParserDEFAULT:
			{
				p.SetState(1833)
				p.Match(MySqlParserDEFAULT)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 7:
		localctx = NewTableOptionChecksumContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1836)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCHECKSUM || _la == MySqlParserPAGE_CHECKSUM) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1838)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1837)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1840)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionChecksumContext).boolValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserZERO_DECIMAL || _la == MySqlParserONE_DECIMAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionChecksumContext).boolValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 8:
		localctx = NewTableOptionCollateContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		p.SetState(1842)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserDEFAULT {
			{
				p.SetState(1841)
				p.Match(MySqlParserDEFAULT)
			}

		}
		{
			p.SetState(1844)
			p.Match(MySqlParserCOLLATE)
		}
		p.SetState(1846)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1845)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1848)
			p.CollationName()
		}

	case 9:
		localctx = NewTableOptionCommentContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1849)
			p.Match(MySqlParserCOMMENT)
		}
		p.SetState(1851)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1850)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1853)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	case 10:
		localctx = NewTableOptionCompressionContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1854)
			p.Match(MySqlParserCOMPRESSION)
		}
		p.SetState(1856)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1855)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1858)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserSTRING_LITERAL || _la == MySqlParserID) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 11:
		localctx = NewTableOptionConnectionContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1859)
			p.Match(MySqlParserCONNECTION)
		}
		p.SetState(1861)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1860)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1863)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	case 12:
		localctx = NewTableOptionDataDirectoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1864)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserINDEX || _la == MySqlParserDATA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1865)
			p.Match(MySqlParserDIRECTORY)
		}
		p.SetState(1867)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1866)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1869)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	case 13:
		localctx = NewTableOptionDelayContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1870)
			p.Match(MySqlParserDELAY_KEY_WRITE)
		}
		p.SetState(1872)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1871)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1874)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionDelayContext).boolValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserZERO_DECIMAL || _la == MySqlParserONE_DECIMAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionDelayContext).boolValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 14:
		localctx = NewTableOptionEncryptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1875)
			p.Match(MySqlParserENCRYPTION)
		}
		p.SetState(1877)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1876)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1879)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	case 15:
		localctx = NewTableOptionPageCompressedContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1880)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserPAGE_COMPRESSED || _la == MySqlParserSTRING_LITERAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1882)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1881)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1884)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserZERO_DECIMAL || _la == MySqlParserONE_DECIMAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 16:
		localctx = NewTableOptionPageCompressionLevelContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1885)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserPAGE_COMPRESSION_LEVEL || _la == MySqlParserSTRING_LITERAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1887)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1886)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1889)
			p.DecimalLiteral()
		}

	case 17:
		localctx = NewTableOptionEncryptionKeyIdContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1890)
			p.Match(MySqlParserENCRYPTION_KEY_ID)
		}
		p.SetState(1892)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1891)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1894)
			p.DecimalLiteral()
		}

	case 18:
		localctx = NewTableOptionIndexDirectoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1895)
			p.Match(MySqlParserINDEX)
		}
		{
			p.SetState(1896)
			p.Match(MySqlParserDIRECTORY)
		}
		p.SetState(1898)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1897)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1900)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	case 19:
		localctx = NewTableOptionInsertMethodContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1901)
			p.Match(MySqlParserINSERT_METHOD)
		}
		p.SetState(1903)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1902)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1905)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionInsertMethodContext).insertMethod = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFIRST || _la == MySqlParserLAST || _la == MySqlParserNO) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionInsertMethodContext).insertMethod = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 20:
		localctx = NewTableOptionKeyBlockSizeContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1906)
			p.Match(MySqlParserKEY_BLOCK_SIZE)
		}
		p.SetState(1908)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1907)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1910)
			p.FileSizeLiteral()
		}

	case 21:
		localctx = NewTableOptionMaxRowsContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1911)
			p.Match(MySqlParserMAX_ROWS)
		}
		p.SetState(1913)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1912)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1915)
			p.DecimalLiteral()
		}

	case 22:
		localctx = NewTableOptionMinRowsContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1916)
			p.Match(MySqlParserMIN_ROWS)
		}
		p.SetState(1918)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1917)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1920)
			p.DecimalLiteral()
		}

	case 23:
		localctx = NewTableOptionPackKeysContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1921)
			p.Match(MySqlParserPACK_KEYS)
		}
		p.SetState(1923)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1922)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1925)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionPackKeysContext).extBoolValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDEFAULT || _la == MySqlParserZERO_DECIMAL || _la == MySqlParserONE_DECIMAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionPackKeysContext).extBoolValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 24:
		localctx = NewTableOptionPasswordContext(p, localctx)
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(1926)
			p.Match(MySqlParserPASSWORD)
		}
		p.SetState(1928)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1927)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1930)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	case 25:
		localctx = NewTableOptionRowFormatContext(p, localctx)
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(1931)
			p.Match(MySqlParserROW_FORMAT)
		}
		p.SetState(1933)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1932)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1935)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionRowFormatContext).rowFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDEFAULT || ((int64((_la-370)) & ^0x3f) == 0 && ((int64(1)<<(_la-370))&2305843013508661253) != 0) || _la == MySqlParserREDUNDANT || _la == MySqlParserID) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionRowFormatContext).rowFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 26:
		localctx = NewTableOptionStartTransactionContext(p, localctx)
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(1936)
			p.Match(MySqlParserSTART)
		}
		{
			p.SetState(1937)
			p.Match(MySqlParserTRANSACTION)
		}

	case 27:
		localctx = NewTableOptionSecondaryEngineAttributeContext(p, localctx)
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(1938)
			p.Match(MySqlParserSECONDARY_ENGINE_ATTRIBUTE)
		}
		p.SetState(1940)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1939)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1942)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	case 28:
		localctx = NewTableOptionRecalculationContext(p, localctx)
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(1943)
			p.Match(MySqlParserSTATS_AUTO_RECALC)
		}
		p.SetState(1945)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1944)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1947)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionRecalculationContext).extBoolValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDEFAULT || _la == MySqlParserZERO_DECIMAL || _la == MySqlParserONE_DECIMAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionRecalculationContext).extBoolValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 29:
		localctx = NewTableOptionPersistentContext(p, localctx)
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(1948)
			p.Match(MySqlParserSTATS_PERSISTENT)
		}
		p.SetState(1950)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1949)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1952)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableOptionPersistentContext).extBoolValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDEFAULT || _la == MySqlParserZERO_DECIMAL || _la == MySqlParserONE_DECIMAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableOptionPersistentContext).extBoolValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 30:
		localctx = NewTableOptionSamplePageContext(p, localctx)
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(1953)
			p.Match(MySqlParserSTATS_SAMPLE_PAGES)
		}
		p.SetState(1955)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1954)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		p.SetState(1959)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserDEFAULT:
			{
				p.SetState(1957)
				p.Match(MySqlParserDEFAULT)
			}

		case MySqlParserZERO_DECIMAL, MySqlParserONE_DECIMAL, MySqlParserTWO_DECIMAL, MySqlParserDECIMAL_LITERAL, MySqlParserREAL_LITERAL:
			{
				p.SetState(1958)
				p.DecimalLiteral()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 31:
		localctx = NewTableOptionTablespaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(1961)
			p.Match(MySqlParserTABLESPACE)
		}
		{
			p.SetState(1962)
			p.Uid()
		}
		p.SetState(1964)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 224, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1963)
				p.TablespaceStorage()
			}

		}

	case 32:
		localctx = NewTableOptionTableTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(1966)
			p.Match(MySqlParserTABLE_TYPE)
		}
		{
			p.SetState(1967)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}
		{
			p.SetState(1968)
			p.TableType()
		}

	case 33:
		localctx = NewTableOptionTablespaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(1969)
			p.TablespaceStorage()
		}

	case 34:
		localctx = NewTableOptionTransactionalContext(p, localctx)
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(1970)
			p.Match(MySqlParserTRANSACTIONAL)
		}
		p.SetState(1972)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1971)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1974)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserZERO_DECIMAL || _la == MySqlParserONE_DECIMAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 35:
		localctx = NewTableOptionUnionContext(p, localctx)
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(1975)
			p.Match(MySqlParserUNION)
		}
		p.SetState(1977)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(1976)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(1979)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(1980)
			p.Tables()
		}
		{
			p.SetState(1981)
			p.Match(MySqlParserRR_BRACKET)
		}

	}

	return localctx
}

// ITableTypeContext is an interface to support dynamic dispatch.
type ITableTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MYSQL() antlr.TerminalNode
	ODBC() antlr.TerminalNode

	// IsTableTypeContext differentiates from other interfaces.
	IsTableTypeContext()
}

type TableTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableTypeContext() *TableTypeContext {
	var p = new(TableTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_tableType
	return p
}

func (*TableTypeContext) IsTableTypeContext() {}

func NewTableTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableTypeContext {
	var p = new(TableTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tableType

	return p
}

func (s *TableTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TableTypeContext) MYSQL() antlr.TerminalNode {
	return s.GetToken(MySqlParserMYSQL, 0)
}

func (s *TableTypeContext) ODBC() antlr.TerminalNode {
	return s.GetToken(MySqlParserODBC, 0)
}

func (s *TableTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableType(s)
	}
}

func (s *TableTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableType(s)
	}
}

func (p *MySqlParser) TableType() (localctx ITableTypeContext) {
	this := p
	_ = this

	localctx = NewTableTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, MySqlParserRULE_tableType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1985)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserMYSQL || _la == MySqlParserODBC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ITablespaceStorageContext is an interface to support dynamic dispatch.
type ITablespaceStorageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STORAGE() antlr.TerminalNode
	DISK() antlr.TerminalNode
	MEMORY() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode

	// IsTablespaceStorageContext differentiates from other interfaces.
	IsTablespaceStorageContext()
}

type TablespaceStorageContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablespaceStorageContext() *TablespaceStorageContext {
	var p = new(TablespaceStorageContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_tablespaceStorage
	return p
}

func (*TablespaceStorageContext) IsTablespaceStorageContext() {}

func NewTablespaceStorageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablespaceStorageContext {
	var p = new(TablespaceStorageContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tablespaceStorage

	return p
}

func (s *TablespaceStorageContext) GetParser() antlr.Parser { return s.parser }

func (s *TablespaceStorageContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTORAGE, 0)
}

func (s *TablespaceStorageContext) DISK() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISK, 0)
}

func (s *TablespaceStorageContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEMORY, 0)
}

func (s *TablespaceStorageContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *TablespaceStorageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablespaceStorageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablespaceStorageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTablespaceStorage(s)
	}
}

func (s *TablespaceStorageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTablespaceStorage(s)
	}
}

func (p *MySqlParser) TablespaceStorage() (localctx ITablespaceStorageContext) {
	this := p
	_ = this

	localctx = NewTablespaceStorageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, MySqlParserRULE_tablespaceStorage)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1987)
		p.Match(MySqlParserSTORAGE)
	}
	{
		p.SetState(1988)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserDEFAULT || _la == MySqlParserDISK || _la == MySqlParserMEMORY) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPartitionDefinitionsContext is an interface to support dynamic dispatch.
type IPartitionDefinitionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCount returns the count rule contexts.
	GetCount() IDecimalLiteralContext

	// GetSubCount returns the subCount rule contexts.
	GetSubCount() IDecimalLiteralContext

	// SetCount sets the count rule contexts.
	SetCount(IDecimalLiteralContext)

	// SetSubCount sets the subCount rule contexts.
	SetSubCount(IDecimalLiteralContext)

	// Getter signatures
	PARTITION() antlr.TerminalNode
	AllBY() []antlr.TerminalNode
	BY(i int) antlr.TerminalNode
	PartitionFunctionDefinition() IPartitionFunctionDefinitionContext
	PARTITIONS() antlr.TerminalNode
	SUBPARTITION() antlr.TerminalNode
	SubpartitionFunctionDefinition() ISubpartitionFunctionDefinitionContext
	LR_BRACKET() antlr.TerminalNode
	AllPartitionDefinition() []IPartitionDefinitionContext
	PartitionDefinition(i int) IPartitionDefinitionContext
	RR_BRACKET() antlr.TerminalNode
	AllDecimalLiteral() []IDecimalLiteralContext
	DecimalLiteral(i int) IDecimalLiteralContext
	SUBPARTITIONS() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPartitionDefinitionsContext differentiates from other interfaces.
	IsPartitionDefinitionsContext()
}

type PartitionDefinitionsContext struct {
	*antlr.BaseParserRuleContext
	parser   antlr.Parser
	count    IDecimalLiteralContext
	subCount IDecimalLiteralContext
}

func NewEmptyPartitionDefinitionsContext() *PartitionDefinitionsContext {
	var p = new(PartitionDefinitionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_partitionDefinitions
	return p
}

func (*PartitionDefinitionsContext) IsPartitionDefinitionsContext() {}

func NewPartitionDefinitionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionDefinitionsContext {
	var p = new(PartitionDefinitionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_partitionDefinitions

	return p
}

func (s *PartitionDefinitionsContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionDefinitionsContext) GetCount() IDecimalLiteralContext { return s.count }

func (s *PartitionDefinitionsContext) GetSubCount() IDecimalLiteralContext { return s.subCount }

func (s *PartitionDefinitionsContext) SetCount(v IDecimalLiteralContext) { s.count = v }

func (s *PartitionDefinitionsContext) SetSubCount(v IDecimalLiteralContext) { s.subCount = v }

func (s *PartitionDefinitionsContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *PartitionDefinitionsContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserBY)
}

func (s *PartitionDefinitionsContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, i)
}

func (s *PartitionDefinitionsContext) PartitionFunctionDefinition() IPartitionFunctionDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionFunctionDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionFunctionDefinitionContext)
}

func (s *PartitionDefinitionsContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITIONS, 0)
}

func (s *PartitionDefinitionsContext) SUBPARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBPARTITION, 0)
}

func (s *PartitionDefinitionsContext) SubpartitionFunctionDefinition() ISubpartitionFunctionDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpartitionFunctionDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpartitionFunctionDefinitionContext)
}

func (s *PartitionDefinitionsContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *PartitionDefinitionsContext) AllPartitionDefinition() []IPartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinitionContext); ok {
			tst[i] = t.(IPartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionDefinitionsContext) PartitionDefinition(i int) IPartitionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinitionContext)
}

func (s *PartitionDefinitionsContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *PartitionDefinitionsContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *PartitionDefinitionsContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *PartitionDefinitionsContext) SUBPARTITIONS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBPARTITIONS, 0)
}

func (s *PartitionDefinitionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *PartitionDefinitionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *PartitionDefinitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefinitionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionDefinitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionDefinitions(s)
	}
}

func (s *PartitionDefinitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionDefinitions(s)
	}
}

func (p *MySqlParser) PartitionDefinitions() (localctx IPartitionDefinitionsContext) {
	this := p
	_ = this

	localctx = NewPartitionDefinitionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, MySqlParserRULE_partitionDefinitions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1990)
		p.Match(MySqlParserPARTITION)
	}
	{
		p.SetState(1991)
		p.Match(MySqlParserBY)
	}
	{
		p.SetState(1992)
		p.PartitionFunctionDefinition()
	}
	p.SetState(1995)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserPARTITIONS {
		{
			p.SetState(1993)
			p.Match(MySqlParserPARTITIONS)
		}
		{
			p.SetState(1994)

			var _x = p.DecimalLiteral()

			localctx.(*PartitionDefinitionsContext).count = _x
		}

	}
	p.SetState(2004)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserSUBPARTITION {
		{
			p.SetState(1997)
			p.Match(MySqlParserSUBPARTITION)
		}
		{
			p.SetState(1998)
			p.Match(MySqlParserBY)
		}
		{
			p.SetState(1999)
			p.SubpartitionFunctionDefinition()
		}
		p.SetState(2002)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserSUBPARTITIONS {
			{
				p.SetState(2000)
				p.Match(MySqlParserSUBPARTITIONS)
			}
			{
				p.SetState(2001)

				var _x = p.DecimalLiteral()

				localctx.(*PartitionDefinitionsContext).subCount = _x
			}

		}

	}
	p.SetState(2017)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 232, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2006)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(2007)
			p.PartitionDefinition()
		}
		p.SetState(2012)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(2008)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(2009)
				p.PartitionDefinition()
			}

			p.SetState(2014)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2015)
			p.Match(MySqlParserRR_BRACKET)
		}

	}

	return localctx
}

// IPartitionFunctionDefinitionContext is an interface to support dynamic dispatch.
type IPartitionFunctionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPartitionFunctionDefinitionContext differentiates from other interfaces.
	IsPartitionFunctionDefinitionContext()
}

type PartitionFunctionDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionFunctionDefinitionContext() *PartitionFunctionDefinitionContext {
	var p = new(PartitionFunctionDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_partitionFunctionDefinition
	return p
}

func (*PartitionFunctionDefinitionContext) IsPartitionFunctionDefinitionContext() {}

func NewPartitionFunctionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionFunctionDefinitionContext {
	var p = new(PartitionFunctionDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_partitionFunctionDefinition

	return p
}

func (s *PartitionFunctionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionFunctionDefinitionContext) CopyFrom(ctx *PartitionFunctionDefinitionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *PartitionFunctionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionFunctionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PartitionFunctionKeyContext struct {
	*PartitionFunctionDefinitionContext
	algType antlr.Token
}

func NewPartitionFunctionKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionFunctionKeyContext {
	var p = new(PartitionFunctionKeyContext)

	p.PartitionFunctionDefinitionContext = NewEmptyPartitionFunctionDefinitionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PartitionFunctionDefinitionContext))

	return p
}

func (s *PartitionFunctionKeyContext) GetAlgType() antlr.Token { return s.algType }

func (s *PartitionFunctionKeyContext) SetAlgType(v antlr.Token) { s.algType = v }

func (s *PartitionFunctionKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionFunctionKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *PartitionFunctionKeyContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *PartitionFunctionKeyContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *PartitionFunctionKeyContext) LINEAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINEAR, 0)
}

func (s *PartitionFunctionKeyContext) ALGORITHM() antlr.TerminalNode {
	return s.GetToken(MySqlParserALGORITHM, 0)
}

func (s *PartitionFunctionKeyContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *PartitionFunctionKeyContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *PartitionFunctionKeyContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *PartitionFunctionKeyContext) TWO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserTWO_DECIMAL, 0)
}

func (s *PartitionFunctionKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionFunctionKey(s)
	}
}

func (s *PartitionFunctionKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionFunctionKey(s)
	}
}

type PartitionFunctionHashContext struct {
	*PartitionFunctionDefinitionContext
}

func NewPartitionFunctionHashContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionFunctionHashContext {
	var p = new(PartitionFunctionHashContext)

	p.PartitionFunctionDefinitionContext = NewEmptyPartitionFunctionDefinitionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PartitionFunctionDefinitionContext))

	return p
}

func (s *PartitionFunctionHashContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionFunctionHashContext) HASH() antlr.TerminalNode {
	return s.GetToken(MySqlParserHASH, 0)
}

func (s *PartitionFunctionHashContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *PartitionFunctionHashContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PartitionFunctionHashContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *PartitionFunctionHashContext) LINEAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINEAR, 0)
}

func (s *PartitionFunctionHashContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionFunctionHash(s)
	}
}

func (s *PartitionFunctionHashContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionFunctionHash(s)
	}
}

type PartitionFunctionListContext struct {
	*PartitionFunctionDefinitionContext
}

func NewPartitionFunctionListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionFunctionListContext {
	var p = new(PartitionFunctionListContext)

	p.PartitionFunctionDefinitionContext = NewEmptyPartitionFunctionDefinitionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PartitionFunctionDefinitionContext))

	return p
}

func (s *PartitionFunctionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionFunctionListContext) LIST() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIST, 0)
}

func (s *PartitionFunctionListContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *PartitionFunctionListContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PartitionFunctionListContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *PartitionFunctionListContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMNS, 0)
}

func (s *PartitionFunctionListContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *PartitionFunctionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionFunctionList(s)
	}
}

func (s *PartitionFunctionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionFunctionList(s)
	}
}

type PartitionFunctionRangeContext struct {
	*PartitionFunctionDefinitionContext
}

func NewPartitionFunctionRangeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionFunctionRangeContext {
	var p = new(PartitionFunctionRangeContext)

	p.PartitionFunctionDefinitionContext = NewEmptyPartitionFunctionDefinitionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PartitionFunctionDefinitionContext))

	return p
}

func (s *PartitionFunctionRangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionFunctionRangeContext) RANGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRANGE, 0)
}

func (s *PartitionFunctionRangeContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *PartitionFunctionRangeContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PartitionFunctionRangeContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *PartitionFunctionRangeContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMNS, 0)
}

func (s *PartitionFunctionRangeContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *PartitionFunctionRangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionFunctionRange(s)
	}
}

func (s *PartitionFunctionRangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionFunctionRange(s)
	}
}

func (p *MySqlParser) PartitionFunctionDefinition() (localctx IPartitionFunctionDefinitionContext) {
	this := p
	_ = this

	localctx = NewPartitionFunctionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, MySqlParserRULE_partitionFunctionDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2065)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 239, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPartitionFunctionHashContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2020)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLINEAR {
			{
				p.SetState(2019)
				p.Match(MySqlParserLINEAR)
			}

		}
		{
			p.SetState(2022)
			p.Match(MySqlParserHASH)
		}
		{
			p.SetState(2023)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(2024)
			p.expression(0)
		}
		{
			p.SetState(2025)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 2:
		localctx = NewPartitionFunctionKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2028)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLINEAR {
			{
				p.SetState(2027)
				p.Match(MySqlParserLINEAR)
			}

		}
		{
			p.SetState(2030)
			p.Match(MySqlParserKEY)
		}
		p.SetState(2034)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserALGORITHM {
			{
				p.SetState(2031)
				p.Match(MySqlParserALGORITHM)
			}
			{
				p.SetState(2032)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}
			{
				p.SetState(2033)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*PartitionFunctionKeyContext).algType = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserONE_DECIMAL || _la == MySqlParserTWO_DECIMAL) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*PartitionFunctionKeyContext).algType = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(2036)
			p.Match(MySqlParserLR_BRACKET)
		}
		p.SetState(2038)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&756891332513120256) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&146666055071174737) != 0) || ((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&134349441) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-2882305960540372993) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-4398063288321) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-16325548649218049) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-81064793296864001) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-68719476801) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-11118270170269697) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-33) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-3073) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&144115188075855871) != 0) || ((int64((_la-1121)) & ^0x3f) == 0 && ((int64(1)<<(_la-1121))&25807552513) != 0) {
			{
				p.SetState(2037)
				p.UidList()
			}

		}
		{
			p.SetState(2040)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 3:
		localctx = NewPartitionFunctionRangeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2041)
			p.Match(MySqlParserRANGE)
		}
		p.SetState(2051)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserLR_BRACKET:
			{
				p.SetState(2042)
				p.Match(MySqlParserLR_BRACKET)
			}
			{
				p.SetState(2043)
				p.expression(0)
			}
			{
				p.SetState(2044)
				p.Match(MySqlParserRR_BRACKET)
			}

		case MySqlParserCOLUMNS:
			{
				p.SetState(2046)
				p.Match(MySqlParserCOLUMNS)
			}
			{
				p.SetState(2047)
				p.Match(MySqlParserLR_BRACKET)
			}
			{
				p.SetState(2048)
				p.UidList()
			}
			{
				p.SetState(2049)
				p.Match(MySqlParserRR_BRACKET)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 4:
		localctx = NewPartitionFunctionListContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2053)
			p.Match(MySqlParserLIST)
		}
		p.SetState(2063)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserLR_BRACKET:
			{
				p.SetState(2054)
				p.Match(MySqlParserLR_BRACKET)
			}
			{
				p.SetState(2055)
				p.expression(0)
			}
			{
				p.SetState(2056)
				p.Match(MySqlParserRR_BRACKET)
			}

		case MySqlParserCOLUMNS:
			{
				p.SetState(2058)
				p.Match(MySqlParserCOLUMNS)
			}
			{
				p.SetState(2059)
				p.Match(MySqlParserLR_BRACKET)
			}
			{
				p.SetState(2060)
				p.UidList()
			}
			{
				p.SetState(2061)
				p.Match(MySqlParserRR_BRACKET)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}

	return localctx
}

// ISubpartitionFunctionDefinitionContext is an interface to support dynamic dispatch.
type ISubpartitionFunctionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSubpartitionFunctionDefinitionContext differentiates from other interfaces.
	IsSubpartitionFunctionDefinitionContext()
}

type SubpartitionFunctionDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubpartitionFunctionDefinitionContext() *SubpartitionFunctionDefinitionContext {
	var p = new(SubpartitionFunctionDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_subpartitionFunctionDefinition
	return p
}

func (*SubpartitionFunctionDefinitionContext) IsSubpartitionFunctionDefinitionContext() {}

func NewSubpartitionFunctionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubpartitionFunctionDefinitionContext {
	var p = new(SubpartitionFunctionDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_subpartitionFunctionDefinition

	return p
}

func (s *SubpartitionFunctionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *SubpartitionFunctionDefinitionContext) CopyFrom(ctx *SubpartitionFunctionDefinitionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *SubpartitionFunctionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubpartitionFunctionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SubPartitionFunctionHashContext struct {
	*SubpartitionFunctionDefinitionContext
}

func NewSubPartitionFunctionHashContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubPartitionFunctionHashContext {
	var p = new(SubPartitionFunctionHashContext)

	p.SubpartitionFunctionDefinitionContext = NewEmptySubpartitionFunctionDefinitionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SubpartitionFunctionDefinitionContext))

	return p
}

func (s *SubPartitionFunctionHashContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubPartitionFunctionHashContext) HASH() antlr.TerminalNode {
	return s.GetToken(MySqlParserHASH, 0)
}

func (s *SubPartitionFunctionHashContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *SubPartitionFunctionHashContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SubPartitionFunctionHashContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *SubPartitionFunctionHashContext) LINEAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINEAR, 0)
}

func (s *SubPartitionFunctionHashContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSubPartitionFunctionHash(s)
	}
}

func (s *SubPartitionFunctionHashContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSubPartitionFunctionHash(s)
	}
}

type SubPartitionFunctionKeyContext struct {
	*SubpartitionFunctionDefinitionContext
	algType antlr.Token
}

func NewSubPartitionFunctionKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubPartitionFunctionKeyContext {
	var p = new(SubPartitionFunctionKeyContext)

	p.SubpartitionFunctionDefinitionContext = NewEmptySubpartitionFunctionDefinitionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SubpartitionFunctionDefinitionContext))

	return p
}

func (s *SubPartitionFunctionKeyContext) GetAlgType() antlr.Token { return s.algType }

func (s *SubPartitionFunctionKeyContext) SetAlgType(v antlr.Token) { s.algType = v }

func (s *SubPartitionFunctionKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubPartitionFunctionKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *SubPartitionFunctionKeyContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *SubPartitionFunctionKeyContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *SubPartitionFunctionKeyContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *SubPartitionFunctionKeyContext) LINEAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINEAR, 0)
}

func (s *SubPartitionFunctionKeyContext) ALGORITHM() antlr.TerminalNode {
	return s.GetToken(MySqlParserALGORITHM, 0)
}

func (s *SubPartitionFunctionKeyContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *SubPartitionFunctionKeyContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *SubPartitionFunctionKeyContext) TWO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserTWO_DECIMAL, 0)
}

func (s *SubPartitionFunctionKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSubPartitionFunctionKey(s)
	}
}

func (s *SubPartitionFunctionKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSubPartitionFunctionKey(s)
	}
}

func (p *MySqlParser) SubpartitionFunctionDefinition() (localctx ISubpartitionFunctionDefinitionContext) {
	this := p
	_ = this

	localctx = NewSubpartitionFunctionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, MySqlParserRULE_subpartitionFunctionDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2088)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 243, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSubPartitionFunctionHashContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2068)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLINEAR {
			{
				p.SetState(2067)
				p.Match(MySqlParserLINEAR)
			}

		}
		{
			p.SetState(2070)
			p.Match(MySqlParserHASH)
		}
		{
			p.SetState(2071)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(2072)
			p.expression(0)
		}
		{
			p.SetState(2073)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 2:
		localctx = NewSubPartitionFunctionKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2076)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLINEAR {
			{
				p.SetState(2075)
				p.Match(MySqlParserLINEAR)
			}

		}
		{
			p.SetState(2078)
			p.Match(MySqlParserKEY)
		}
		p.SetState(2082)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserALGORITHM {
			{
				p.SetState(2079)
				p.Match(MySqlParserALGORITHM)
			}
			{
				p.SetState(2080)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}
			{
				p.SetState(2081)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*SubPartitionFunctionKeyContext).algType = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserONE_DECIMAL || _la == MySqlParserTWO_DECIMAL) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*SubPartitionFunctionKeyContext).algType = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(2084)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(2085)
			p.UidList()
		}
		{
			p.SetState(2086)
			p.Match(MySqlParserRR_BRACKET)
		}

	}

	return localctx
}

// IPartitionDefinitionContext is an interface to support dynamic dispatch.
type IPartitionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPartitionDefinitionContext differentiates from other interfaces.
	IsPartitionDefinitionContext()
}

type PartitionDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionDefinitionContext() *PartitionDefinitionContext {
	var p = new(PartitionDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_partitionDefinition
	return p
}

func (*PartitionDefinitionContext) IsPartitionDefinitionContext() {}

func NewPartitionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionDefinitionContext {
	var p = new(PartitionDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_partitionDefinition

	return p
}

func (s *PartitionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionDefinitionContext) CopyFrom(ctx *PartitionDefinitionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *PartitionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PartitionComparisonContext struct {
	*PartitionDefinitionContext
}

func NewPartitionComparisonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionComparisonContext {
	var p = new(PartitionComparisonContext)

	p.PartitionDefinitionContext = NewEmptyPartitionDefinitionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PartitionDefinitionContext))

	return p
}

func (s *PartitionComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionComparisonContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *PartitionComparisonContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PartitionComparisonContext) VALUES() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUES, 0)
}

func (s *PartitionComparisonContext) LESS() antlr.TerminalNode {
	return s.GetToken(MySqlParserLESS, 0)
}

func (s *PartitionComparisonContext) THAN() antlr.TerminalNode {
	return s.GetToken(MySqlParserTHAN, 0)
}

func (s *PartitionComparisonContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *PartitionComparisonContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *PartitionComparisonContext) AllPartitionDefinerAtom() []IPartitionDefinerAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinerAtomContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinerAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinerAtomContext); ok {
			tst[i] = t.(IPartitionDefinerAtomContext)
			i++
		}
	}

	return tst
}

func (s *PartitionComparisonContext) PartitionDefinerAtom(i int) IPartitionDefinerAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinerAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinerAtomContext)
}

func (s *PartitionComparisonContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *PartitionComparisonContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *PartitionComparisonContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *PartitionComparisonContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *PartitionComparisonContext) AllPartitionOption() []IPartitionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionOptionContext); ok {
			tst[i] = t.(IPartitionOptionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionComparisonContext) PartitionOption(i int) IPartitionOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionOptionContext)
}

func (s *PartitionComparisonContext) AllSubpartitionDefinition() []ISubpartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ISubpartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubpartitionDefinitionContext); ok {
			tst[i] = t.(ISubpartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionComparisonContext) SubpartitionDefinition(i int) ISubpartitionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpartitionDefinitionContext)
}

func (s *PartitionComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionComparison(s)
	}
}

func (s *PartitionComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionComparison(s)
	}
}

type PartitionListAtomContext struct {
	*PartitionDefinitionContext
}

func NewPartitionListAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionListAtomContext {
	var p = new(PartitionListAtomContext)

	p.PartitionDefinitionContext = NewEmptyPartitionDefinitionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PartitionDefinitionContext))

	return p
}

func (s *PartitionListAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionListAtomContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *PartitionListAtomContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PartitionListAtomContext) VALUES() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUES, 0)
}

func (s *PartitionListAtomContext) IN() antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, 0)
}

func (s *PartitionListAtomContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *PartitionListAtomContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *PartitionListAtomContext) AllPartitionDefinerAtom() []IPartitionDefinerAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinerAtomContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinerAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinerAtomContext); ok {
			tst[i] = t.(IPartitionDefinerAtomContext)
			i++
		}
	}

	return tst
}

func (s *PartitionListAtomContext) PartitionDefinerAtom(i int) IPartitionDefinerAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinerAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinerAtomContext)
}

func (s *PartitionListAtomContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *PartitionListAtomContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *PartitionListAtomContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *PartitionListAtomContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *PartitionListAtomContext) AllPartitionOption() []IPartitionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionOptionContext); ok {
			tst[i] = t.(IPartitionOptionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionListAtomContext) PartitionOption(i int) IPartitionOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionOptionContext)
}

func (s *PartitionListAtomContext) AllSubpartitionDefinition() []ISubpartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ISubpartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubpartitionDefinitionContext); ok {
			tst[i] = t.(ISubpartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionListAtomContext) SubpartitionDefinition(i int) ISubpartitionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpartitionDefinitionContext)
}

func (s *PartitionListAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionListAtom(s)
	}
}

func (s *PartitionListAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionListAtom(s)
	}
}

type PartitionListVectorContext struct {
	*PartitionDefinitionContext
}

func NewPartitionListVectorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionListVectorContext {
	var p = new(PartitionListVectorContext)

	p.PartitionDefinitionContext = NewEmptyPartitionDefinitionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PartitionDefinitionContext))

	return p
}

func (s *PartitionListVectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionListVectorContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *PartitionListVectorContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PartitionListVectorContext) VALUES() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUES, 0)
}

func (s *PartitionListVectorContext) IN() antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, 0)
}

func (s *PartitionListVectorContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *PartitionListVectorContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *PartitionListVectorContext) AllPartitionDefinerVector() []IPartitionDefinerVectorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinerVectorContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinerVectorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinerVectorContext); ok {
			tst[i] = t.(IPartitionDefinerVectorContext)
			i++
		}
	}

	return tst
}

func (s *PartitionListVectorContext) PartitionDefinerVector(i int) IPartitionDefinerVectorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinerVectorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinerVectorContext)
}

func (s *PartitionListVectorContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *PartitionListVectorContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *PartitionListVectorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *PartitionListVectorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *PartitionListVectorContext) AllPartitionOption() []IPartitionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionOptionContext); ok {
			tst[i] = t.(IPartitionOptionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionListVectorContext) PartitionOption(i int) IPartitionOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionOptionContext)
}

func (s *PartitionListVectorContext) AllSubpartitionDefinition() []ISubpartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ISubpartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubpartitionDefinitionContext); ok {
			tst[i] = t.(ISubpartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionListVectorContext) SubpartitionDefinition(i int) ISubpartitionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpartitionDefinitionContext)
}

func (s *PartitionListVectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionListVector(s)
	}
}

func (s *PartitionListVectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionListVector(s)
	}
}

type PartitionSimpleContext struct {
	*PartitionDefinitionContext
}

func NewPartitionSimpleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionSimpleContext {
	var p = new(PartitionSimpleContext)

	p.PartitionDefinitionContext = NewEmptyPartitionDefinitionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PartitionDefinitionContext))

	return p
}

func (s *PartitionSimpleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionSimpleContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *PartitionSimpleContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PartitionSimpleContext) AllPartitionOption() []IPartitionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionOptionContext); ok {
			tst[i] = t.(IPartitionOptionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionSimpleContext) PartitionOption(i int) IPartitionOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionOptionContext)
}

func (s *PartitionSimpleContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *PartitionSimpleContext) AllSubpartitionDefinition() []ISubpartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ISubpartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubpartitionDefinitionContext); ok {
			tst[i] = t.(ISubpartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionSimpleContext) SubpartitionDefinition(i int) ISubpartitionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpartitionDefinitionContext)
}

func (s *PartitionSimpleContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *PartitionSimpleContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *PartitionSimpleContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *PartitionSimpleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionSimple(s)
	}
}

func (s *PartitionSimpleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionSimple(s)
	}
}

func (p *MySqlParser) PartitionDefinition() (localctx IPartitionDefinitionContext) {
	this := p
	_ = this

	localctx = NewPartitionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, MySqlParserRULE_partitionDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2236)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 262, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPartitionComparisonContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2090)
			p.Match(MySqlParserPARTITION)
		}
		{
			p.SetState(2091)
			p.Uid()
		}
		{
			p.SetState(2092)
			p.Match(MySqlParserVALUES)
		}
		{
			p.SetState(2093)
			p.Match(MySqlParserLESS)
		}
		{
			p.SetState(2094)
			p.Match(MySqlParserTHAN)
		}
		{
			p.SetState(2095)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(2096)
			p.PartitionDefinerAtom()
		}
		p.SetState(2101)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(2097)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(2098)
				p.PartitionDefinerAtom()
			}

			p.SetState(2103)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2104)
			p.Match(MySqlParserRR_BRACKET)
		}
		p.SetState(2108)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserDEFAULT || _la == MySqlParserINDEX || ((int64((_la-368)) & ^0x3f) == 0 && ((int64(1)<<(_la-368))&2199024304129) != 0) || ((int64((_la-500)) & ^0x3f) == 0 && ((int64(1)<<(_la-500))&268436481) != 0) || _la == MySqlParserSTORAGE || _la == MySqlParserTABLESPACE {
			{
				p.SetState(2105)
				p.PartitionOption()
			}

			p.SetState(2110)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(2122)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(2111)
				p.Match(MySqlParserLR_BRACKET)
			}
			{
				p.SetState(2112)
				p.SubpartitionDefinition()
			}
			p.SetState(2117)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == MySqlParserCOMMA {
				{
					p.SetState(2113)
					p.Match(MySqlParserCOMMA)
				}
				{
					p.SetState(2114)
					p.SubpartitionDefinition()
				}

				p.SetState(2119)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2120)
				p.Match(MySqlParserRR_BRACKET)
			}

		}

	case 2:
		localctx = NewPartitionComparisonContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2124)
			p.Match(MySqlParserPARTITION)
		}
		{
			p.SetState(2125)
			p.Uid()
		}
		{
			p.SetState(2126)
			p.Match(MySqlParserVALUES)
		}
		{
			p.SetState(2127)
			p.Match(MySqlParserLESS)
		}
		{
			p.SetState(2128)
			p.Match(MySqlParserTHAN)
		}
		{
			p.SetState(2129)
			p.PartitionDefinerAtom()
		}
		p.SetState(2133)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserDEFAULT || _la == MySqlParserINDEX || ((int64((_la-368)) & ^0x3f) == 0 && ((int64(1)<<(_la-368))&2199024304129) != 0) || ((int64((_la-500)) & ^0x3f) == 0 && ((int64(1)<<(_la-500))&268436481) != 0) || _la == MySqlParserSTORAGE || _la == MySqlParserTABLESPACE {
			{
				p.SetState(2130)
				p.PartitionOption()
			}

			p.SetState(2135)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(2147)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(2136)
				p.Match(MySqlParserLR_BRACKET)
			}
			{
				p.SetState(2137)
				p.SubpartitionDefinition()
			}
			p.SetState(2142)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == MySqlParserCOMMA {
				{
					p.SetState(2138)
					p.Match(MySqlParserCOMMA)
				}
				{
					p.SetState(2139)
					p.SubpartitionDefinition()
				}

				p.SetState(2144)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2145)
				p.Match(MySqlParserRR_BRACKET)
			}

		}

	case 3:
		localctx = NewPartitionListAtomContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2149)
			p.Match(MySqlParserPARTITION)
		}
		{
			p.SetState(2150)
			p.Uid()
		}
		{
			p.SetState(2151)
			p.Match(MySqlParserVALUES)
		}
		{
			p.SetState(2152)
			p.Match(MySqlParserIN)
		}
		{
			p.SetState(2153)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(2154)
			p.PartitionDefinerAtom()
		}
		p.SetState(2159)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(2155)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(2156)
				p.PartitionDefinerAtom()
			}

			p.SetState(2161)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2162)
			p.Match(MySqlParserRR_BRACKET)
		}
		p.SetState(2166)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserDEFAULT || _la == MySqlParserINDEX || ((int64((_la-368)) & ^0x3f) == 0 && ((int64(1)<<(_la-368))&2199024304129) != 0) || ((int64((_la-500)) & ^0x3f) == 0 && ((int64(1)<<(_la-500))&268436481) != 0) || _la == MySqlParserSTORAGE || _la == MySqlParserTABLESPACE {
			{
				p.SetState(2163)
				p.PartitionOption()
			}

			p.SetState(2168)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(2180)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(2169)
				p.Match(MySqlParserLR_BRACKET)
			}
			{
				p.SetState(2170)
				p.SubpartitionDefinition()
			}
			p.SetState(2175)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == MySqlParserCOMMA {
				{
					p.SetState(2171)
					p.Match(MySqlParserCOMMA)
				}
				{
					p.SetState(2172)
					p.SubpartitionDefinition()
				}

				p.SetState(2177)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2178)
				p.Match(MySqlParserRR_BRACKET)
			}

		}

	case 4:
		localctx = NewPartitionListVectorContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2182)
			p.Match(MySqlParserPARTITION)
		}
		{
			p.SetState(2183)
			p.Uid()
		}
		{
			p.SetState(2184)
			p.Match(MySqlParserVALUES)
		}
		{
			p.SetState(2185)
			p.Match(MySqlParserIN)
		}
		{
			p.SetState(2186)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(2187)
			p.PartitionDefinerVector()
		}
		p.SetState(2192)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(2188)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(2189)
				p.PartitionDefinerVector()
			}

			p.SetState(2194)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2195)
			p.Match(MySqlParserRR_BRACKET)
		}
		p.SetState(2199)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserDEFAULT || _la == MySqlParserINDEX || ((int64((_la-368)) & ^0x3f) == 0 && ((int64(1)<<(_la-368))&2199024304129) != 0) || ((int64((_la-500)) & ^0x3f) == 0 && ((int64(1)<<(_la-500))&268436481) != 0) || _la == MySqlParserSTORAGE || _la == MySqlParserTABLESPACE {
			{
				p.SetState(2196)
				p.PartitionOption()
			}

			p.SetState(2201)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(2213)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(2202)
				p.Match(MySqlParserLR_BRACKET)
			}
			{
				p.SetState(2203)
				p.SubpartitionDefinition()
			}
			p.SetState(2208)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == MySqlParserCOMMA {
				{
					p.SetState(2204)
					p.Match(MySqlParserCOMMA)
				}
				{
					p.SetState(2205)
					p.SubpartitionDefinition()
				}

				p.SetState(2210)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2211)
				p.Match(MySqlParserRR_BRACKET)
			}

		}

	case 5:
		localctx = NewPartitionSimpleContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2215)
			p.Match(MySqlParserPARTITION)
		}
		{
			p.SetState(2216)
			p.Uid()
		}
		p.SetState(2220)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserDEFAULT || _la == MySqlParserINDEX || ((int64((_la-368)) & ^0x3f) == 0 && ((int64(1)<<(_la-368))&2199024304129) != 0) || ((int64((_la-500)) & ^0x3f) == 0 && ((int64(1)<<(_la-500))&268436481) != 0) || _la == MySqlParserSTORAGE || _la == MySqlParserTABLESPACE {
			{
				p.SetState(2217)
				p.PartitionOption()
			}

			p.SetState(2222)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(2234)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(2223)
				p.Match(MySqlParserLR_BRACKET)
			}
			{
				p.SetState(2224)
				p.SubpartitionDefinition()
			}
			p.SetState(2229)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == MySqlParserCOMMA {
				{
					p.SetState(2225)
					p.Match(MySqlParserCOMMA)
				}
				{
					p.SetState(2226)
					p.SubpartitionDefinition()
				}

				p.SetState(2231)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2232)
				p.Match(MySqlParserRR_BRACKET)
			}

		}

	}

	return localctx
}

// IPartitionDefinerAtomContext is an interface to support dynamic dispatch.
type IPartitionDefinerAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Constant() IConstantContext
	Expression() IExpressionContext
	MAXVALUE() antlr.TerminalNode

	// IsPartitionDefinerAtomContext differentiates from other interfaces.
	IsPartitionDefinerAtomContext()
}

type PartitionDefinerAtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionDefinerAtomContext() *PartitionDefinerAtomContext {
	var p = new(PartitionDefinerAtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_partitionDefinerAtom
	return p
}

func (*PartitionDefinerAtomContext) IsPartitionDefinerAtomContext() {}

func NewPartitionDefinerAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionDefinerAtomContext {
	var p = new(PartitionDefinerAtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_partitionDefinerAtom

	return p
}

func (s *PartitionDefinerAtomContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionDefinerAtomContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *PartitionDefinerAtomContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PartitionDefinerAtomContext) MAXVALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAXVALUE, 0)
}

func (s *PartitionDefinerAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefinerAtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionDefinerAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionDefinerAtom(s)
	}
}

func (s *PartitionDefinerAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionDefinerAtom(s)
	}
}

func (p *MySqlParser) PartitionDefinerAtom() (localctx IPartitionDefinerAtomContext) {
	this := p
	_ = this

	localctx = NewPartitionDefinerAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, MySqlParserRULE_partitionDefinerAtom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2241)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 263, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2238)
			p.Constant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2239)
			p.expression(0)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2240)
			p.Match(MySqlParserMAXVALUE)
		}

	}

	return localctx
}

// IPartitionDefinerVectorContext is an interface to support dynamic dispatch.
type IPartitionDefinerVectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	AllPartitionDefinerAtom() []IPartitionDefinerAtomContext
	PartitionDefinerAtom(i int) IPartitionDefinerAtomContext
	RR_BRACKET() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPartitionDefinerVectorContext differentiates from other interfaces.
	IsPartitionDefinerVectorContext()
}

type PartitionDefinerVectorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionDefinerVectorContext() *PartitionDefinerVectorContext {
	var p = new(PartitionDefinerVectorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_partitionDefinerVector
	return p
}

func (*PartitionDefinerVectorContext) IsPartitionDefinerVectorContext() {}

func NewPartitionDefinerVectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionDefinerVectorContext {
	var p = new(PartitionDefinerVectorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_partitionDefinerVector

	return p
}

func (s *PartitionDefinerVectorContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionDefinerVectorContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *PartitionDefinerVectorContext) AllPartitionDefinerAtom() []IPartitionDefinerAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinerAtomContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinerAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinerAtomContext); ok {
			tst[i] = t.(IPartitionDefinerAtomContext)
			i++
		}
	}

	return tst
}

func (s *PartitionDefinerVectorContext) PartitionDefinerAtom(i int) IPartitionDefinerAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinerAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinerAtomContext)
}

func (s *PartitionDefinerVectorContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *PartitionDefinerVectorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *PartitionDefinerVectorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *PartitionDefinerVectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefinerVectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionDefinerVectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionDefinerVector(s)
	}
}

func (s *PartitionDefinerVectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionDefinerVector(s)
	}
}

func (p *MySqlParser) PartitionDefinerVector() (localctx IPartitionDefinerVectorContext) {
	this := p
	_ = this

	localctx = NewPartitionDefinerVectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, MySqlParserRULE_partitionDefinerVector)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2243)
		p.Match(MySqlParserLR_BRACKET)
	}
	{
		p.SetState(2244)
		p.PartitionDefinerAtom()
	}
	p.SetState(2247)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == MySqlParserCOMMA {
		{
			p.SetState(2245)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(2246)
			p.PartitionDefinerAtom()
		}

		p.SetState(2249)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2251)
		p.Match(MySqlParserRR_BRACKET)
	}

	return localctx
}

// ISubpartitionDefinitionContext is an interface to support dynamic dispatch.
type ISubpartitionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUBPARTITION() antlr.TerminalNode
	Uid() IUidContext
	AllPartitionOption() []IPartitionOptionContext
	PartitionOption(i int) IPartitionOptionContext

	// IsSubpartitionDefinitionContext differentiates from other interfaces.
	IsSubpartitionDefinitionContext()
}

type SubpartitionDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubpartitionDefinitionContext() *SubpartitionDefinitionContext {
	var p = new(SubpartitionDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_subpartitionDefinition
	return p
}

func (*SubpartitionDefinitionContext) IsSubpartitionDefinitionContext() {}

func NewSubpartitionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubpartitionDefinitionContext {
	var p = new(SubpartitionDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_subpartitionDefinition

	return p
}

func (s *SubpartitionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *SubpartitionDefinitionContext) SUBPARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBPARTITION, 0)
}

func (s *SubpartitionDefinitionContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SubpartitionDefinitionContext) AllPartitionOption() []IPartitionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionOptionContext); ok {
			tst[i] = t.(IPartitionOptionContext)
			i++
		}
	}

	return tst
}

func (s *SubpartitionDefinitionContext) PartitionOption(i int) IPartitionOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionOptionContext)
}

func (s *SubpartitionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubpartitionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubpartitionDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSubpartitionDefinition(s)
	}
}

func (s *SubpartitionDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSubpartitionDefinition(s)
	}
}

func (p *MySqlParser) SubpartitionDefinition() (localctx ISubpartitionDefinitionContext) {
	this := p
	_ = this

	localctx = NewSubpartitionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, MySqlParserRULE_subpartitionDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2253)
		p.Match(MySqlParserSUBPARTITION)
	}
	{
		p.SetState(2254)
		p.Uid()
	}
	p.SetState(2258)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserDEFAULT || _la == MySqlParserINDEX || ((int64((_la-368)) & ^0x3f) == 0 && ((int64(1)<<(_la-368))&2199024304129) != 0) || ((int64((_la-500)) & ^0x3f) == 0 && ((int64(1)<<(_la-500))&268436481) != 0) || _la == MySqlParserSTORAGE || _la == MySqlParserTABLESPACE {
		{
			p.SetState(2255)
			p.PartitionOption()
		}

		p.SetState(2260)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IPartitionOptionContext is an interface to support dynamic dispatch.
type IPartitionOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPartitionOptionContext differentiates from other interfaces.
	IsPartitionOptionContext()
}

type PartitionOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionOptionContext() *PartitionOptionContext {
	var p = new(PartitionOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_partitionOption
	return p
}

func (*PartitionOptionContext) IsPartitionOptionContext() {}

func NewPartitionOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionOptionContext {
	var p = new(PartitionOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_partitionOption

	return p
}

func (s *PartitionOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionOptionContext) CopyFrom(ctx *PartitionOptionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *PartitionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PartitionOptionCommentContext struct {
	*PartitionOptionContext
	comment antlr.Token
}

func NewPartitionOptionCommentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionCommentContext {
	var p = new(PartitionOptionCommentContext)

	p.PartitionOptionContext = NewEmptyPartitionOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionCommentContext) GetComment() antlr.Token { return s.comment }

func (s *PartitionOptionCommentContext) SetComment(v antlr.Token) { s.comment = v }

func (s *PartitionOptionCommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionCommentContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT, 0)
}

func (s *PartitionOptionCommentContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *PartitionOptionCommentContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionCommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionOptionComment(s)
	}
}

func (s *PartitionOptionCommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionOptionComment(s)
	}
}

type PartitionOptionNodeGroupContext struct {
	*PartitionOptionContext
	nodegroup IUidContext
}

func NewPartitionOptionNodeGroupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionNodeGroupContext {
	var p = new(PartitionOptionNodeGroupContext)

	p.PartitionOptionContext = NewEmptyPartitionOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionNodeGroupContext) GetNodegroup() IUidContext { return s.nodegroup }

func (s *PartitionOptionNodeGroupContext) SetNodegroup(v IUidContext) { s.nodegroup = v }

func (s *PartitionOptionNodeGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionNodeGroupContext) NODEGROUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserNODEGROUP, 0)
}

func (s *PartitionOptionNodeGroupContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PartitionOptionNodeGroupContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionNodeGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionOptionNodeGroup(s)
	}
}

func (s *PartitionOptionNodeGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionOptionNodeGroup(s)
	}
}

type PartitionOptionIndexDirectoryContext struct {
	*PartitionOptionContext
	indexDirectory antlr.Token
}

func NewPartitionOptionIndexDirectoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionIndexDirectoryContext {
	var p = new(PartitionOptionIndexDirectoryContext)

	p.PartitionOptionContext = NewEmptyPartitionOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionIndexDirectoryContext) GetIndexDirectory() antlr.Token {
	return s.indexDirectory
}

func (s *PartitionOptionIndexDirectoryContext) SetIndexDirectory(v antlr.Token) { s.indexDirectory = v }

func (s *PartitionOptionIndexDirectoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionIndexDirectoryContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *PartitionOptionIndexDirectoryContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserDIRECTORY, 0)
}

func (s *PartitionOptionIndexDirectoryContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *PartitionOptionIndexDirectoryContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionIndexDirectoryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionOptionIndexDirectory(s)
	}
}

func (s *PartitionOptionIndexDirectoryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionOptionIndexDirectory(s)
	}
}

type PartitionOptionMaxRowsContext struct {
	*PartitionOptionContext
	maxRows IDecimalLiteralContext
}

func NewPartitionOptionMaxRowsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionMaxRowsContext {
	var p = new(PartitionOptionMaxRowsContext)

	p.PartitionOptionContext = NewEmptyPartitionOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionMaxRowsContext) GetMaxRows() IDecimalLiteralContext { return s.maxRows }

func (s *PartitionOptionMaxRowsContext) SetMaxRows(v IDecimalLiteralContext) { s.maxRows = v }

func (s *PartitionOptionMaxRowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionMaxRowsContext) MAX_ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_ROWS, 0)
}

func (s *PartitionOptionMaxRowsContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *PartitionOptionMaxRowsContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionMaxRowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionOptionMaxRows(s)
	}
}

func (s *PartitionOptionMaxRowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionOptionMaxRows(s)
	}
}

type PartitionOptionTablespaceContext struct {
	*PartitionOptionContext
	tablespace IUidContext
}

func NewPartitionOptionTablespaceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionTablespaceContext {
	var p = new(PartitionOptionTablespaceContext)

	p.PartitionOptionContext = NewEmptyPartitionOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionTablespaceContext) GetTablespace() IUidContext { return s.tablespace }

func (s *PartitionOptionTablespaceContext) SetTablespace(v IUidContext) { s.tablespace = v }

func (s *PartitionOptionTablespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionTablespaceContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLESPACE, 0)
}

func (s *PartitionOptionTablespaceContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PartitionOptionTablespaceContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionTablespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionOptionTablespace(s)
	}
}

func (s *PartitionOptionTablespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionOptionTablespace(s)
	}
}

type PartitionOptionEngineContext struct {
	*PartitionOptionContext
}

func NewPartitionOptionEngineContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionEngineContext {
	var p = new(PartitionOptionEngineContext)

	p.PartitionOptionContext = NewEmptyPartitionOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionEngineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionEngineContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE, 0)
}

func (s *PartitionOptionEngineContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *PartitionOptionEngineContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *PartitionOptionEngineContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTORAGE, 0)
}

func (s *PartitionOptionEngineContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionEngineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionOptionEngine(s)
	}
}

func (s *PartitionOptionEngineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionOptionEngine(s)
	}
}

type PartitionOptionMinRowsContext struct {
	*PartitionOptionContext
	minRows IDecimalLiteralContext
}

func NewPartitionOptionMinRowsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionMinRowsContext {
	var p = new(PartitionOptionMinRowsContext)

	p.PartitionOptionContext = NewEmptyPartitionOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionMinRowsContext) GetMinRows() IDecimalLiteralContext { return s.minRows }

func (s *PartitionOptionMinRowsContext) SetMinRows(v IDecimalLiteralContext) { s.minRows = v }

func (s *PartitionOptionMinRowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionMinRowsContext) MIN_ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMIN_ROWS, 0)
}

func (s *PartitionOptionMinRowsContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *PartitionOptionMinRowsContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionMinRowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionOptionMinRows(s)
	}
}

func (s *PartitionOptionMinRowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionOptionMinRows(s)
	}
}

type PartitionOptionDataDirectoryContext struct {
	*PartitionOptionContext
	dataDirectory antlr.Token
}

func NewPartitionOptionDataDirectoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionOptionDataDirectoryContext {
	var p = new(PartitionOptionDataDirectoryContext)

	p.PartitionOptionContext = NewEmptyPartitionOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PartitionOptionContext))

	return p
}

func (s *PartitionOptionDataDirectoryContext) GetDataDirectory() antlr.Token { return s.dataDirectory }

func (s *PartitionOptionDataDirectoryContext) SetDataDirectory(v antlr.Token) { s.dataDirectory = v }

func (s *PartitionOptionDataDirectoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionDataDirectoryContext) DATA() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATA, 0)
}

func (s *PartitionOptionDataDirectoryContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserDIRECTORY, 0)
}

func (s *PartitionOptionDataDirectoryContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *PartitionOptionDataDirectoryContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *PartitionOptionDataDirectoryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionOptionDataDirectory(s)
	}
}

func (s *PartitionOptionDataDirectoryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionOptionDataDirectory(s)
	}
}

func (p *MySqlParser) PartitionOption() (localctx IPartitionOptionContext) {
	this := p
	_ = this

	localctx = NewPartitionOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, MySqlParserRULE_partitionOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2309)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserDEFAULT, MySqlParserENGINE, MySqlParserSTORAGE:
		localctx = NewPartitionOptionEngineContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2262)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserDEFAULT {
			{
				p.SetState(2261)
				p.Match(MySqlParserDEFAULT)
			}

		}
		p.SetState(2265)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserSTORAGE {
			{
				p.SetState(2264)
				p.Match(MySqlParserSTORAGE)
			}

		}
		{
			p.SetState(2267)
			p.Match(MySqlParserENGINE)
		}
		p.SetState(2269)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(2268)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(2271)
			p.EngineName()
		}

	case MySqlParserCOMMENT:
		localctx = NewPartitionOptionCommentContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2272)
			p.Match(MySqlParserCOMMENT)
		}
		p.SetState(2274)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(2273)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(2276)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*PartitionOptionCommentContext).comment = _m
		}

	case MySqlParserDATA:
		localctx = NewPartitionOptionDataDirectoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2277)
			p.Match(MySqlParserDATA)
		}
		{
			p.SetState(2278)
			p.Match(MySqlParserDIRECTORY)
		}
		p.SetState(2280)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(2279)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(2282)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*PartitionOptionDataDirectoryContext).dataDirectory = _m
		}

	case MySqlParserINDEX:
		localctx = NewPartitionOptionIndexDirectoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2283)
			p.Match(MySqlParserINDEX)
		}
		{
			p.SetState(2284)
			p.Match(MySqlParserDIRECTORY)
		}
		p.SetState(2286)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(2285)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(2288)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*PartitionOptionIndexDirectoryContext).indexDirectory = _m
		}

	case MySqlParserMAX_ROWS:
		localctx = NewPartitionOptionMaxRowsContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2289)
			p.Match(MySqlParserMAX_ROWS)
		}
		p.SetState(2291)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(2290)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(2293)

			var _x = p.DecimalLiteral()

			localctx.(*PartitionOptionMaxRowsContext).maxRows = _x
		}

	case MySqlParserMIN_ROWS:
		localctx = NewPartitionOptionMinRowsContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2294)
			p.Match(MySqlParserMIN_ROWS)
		}
		p.SetState(2296)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(2295)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(2298)

			var _x = p.DecimalLiteral()

			localctx.(*PartitionOptionMinRowsContext).minRows = _x
		}

	case MySqlParserTABLESPACE:
		localctx = NewPartitionOptionTablespaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2299)
			p.Match(MySqlParserTABLESPACE)
		}
		p.SetState(2301)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(2300)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(2303)

			var _x = p.Uid()

			localctx.(*PartitionOptionTablespaceContext).tablespace = _x
		}

	case MySqlParserNODEGROUP:
		localctx = NewPartitionOptionNodeGroupContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2304)
			p.Match(MySqlParserNODEGROUP)
		}
		p.SetState(2306)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(2305)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(2308)

			var _x = p.Uid()

			localctx.(*PartitionOptionNodeGroupContext).nodegroup = _x
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAlterDatabaseContext is an interface to support dynamic dispatch.
type IAlterDatabaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAlterDatabaseContext differentiates from other interfaces.
	IsAlterDatabaseContext()
}

type AlterDatabaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterDatabaseContext() *AlterDatabaseContext {
	var p = new(AlterDatabaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_alterDatabase
	return p
}

func (*AlterDatabaseContext) IsAlterDatabaseContext() {}

func NewAlterDatabaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterDatabaseContext {
	var p = new(AlterDatabaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_alterDatabase

	return p
}

func (s *AlterDatabaseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterDatabaseContext) CopyFrom(ctx *AlterDatabaseContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *AlterDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDatabaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AlterUpgradeNameContext struct {
	*AlterDatabaseContext
	dbFormat antlr.Token
}

func NewAlterUpgradeNameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterUpgradeNameContext {
	var p = new(AlterUpgradeNameContext)

	p.AlterDatabaseContext = NewEmptyAlterDatabaseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterDatabaseContext))

	return p
}

func (s *AlterUpgradeNameContext) GetDbFormat() antlr.Token { return s.dbFormat }

func (s *AlterUpgradeNameContext) SetDbFormat(v antlr.Token) { s.dbFormat = v }

func (s *AlterUpgradeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterUpgradeNameContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterUpgradeNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterUpgradeNameContext) UPGRADE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPGRADE, 0)
}

func (s *AlterUpgradeNameContext) DATA() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATA, 0)
}

func (s *AlterUpgradeNameContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserDIRECTORY, 0)
}

func (s *AlterUpgradeNameContext) NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserNAME, 0)
}

func (s *AlterUpgradeNameContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATABASE, 0)
}

func (s *AlterUpgradeNameContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEMA, 0)
}

func (s *AlterUpgradeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterUpgradeName(s)
	}
}

func (s *AlterUpgradeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterUpgradeName(s)
	}
}

type AlterSimpleDatabaseContext struct {
	*AlterDatabaseContext
	dbFormat antlr.Token
}

func NewAlterSimpleDatabaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterSimpleDatabaseContext {
	var p = new(AlterSimpleDatabaseContext)

	p.AlterDatabaseContext = NewEmptyAlterDatabaseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterDatabaseContext))

	return p
}

func (s *AlterSimpleDatabaseContext) GetDbFormat() antlr.Token { return s.dbFormat }

func (s *AlterSimpleDatabaseContext) SetDbFormat(v antlr.Token) { s.dbFormat = v }

func (s *AlterSimpleDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSimpleDatabaseContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterSimpleDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATABASE, 0)
}

func (s *AlterSimpleDatabaseContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEMA, 0)
}

func (s *AlterSimpleDatabaseContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterSimpleDatabaseContext) AllCreateDatabaseOption() []ICreateDatabaseOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreateDatabaseOptionContext); ok {
			len++
		}
	}

	tst := make([]ICreateDatabaseOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreateDatabaseOptionContext); ok {
			tst[i] = t.(ICreateDatabaseOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterSimpleDatabaseContext) CreateDatabaseOption(i int) ICreateDatabaseOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDatabaseOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDatabaseOptionContext)
}

func (s *AlterSimpleDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterSimpleDatabase(s)
	}
}

func (s *AlterSimpleDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterSimpleDatabase(s)
	}
}

func (p *MySqlParser) AlterDatabase() (localctx IAlterDatabaseContext) {
	this := p
	_ = this

	localctx = NewAlterDatabaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, MySqlParserRULE_alterDatabase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2329)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 279, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAlterSimpleDatabaseContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2311)
			p.Match(MySqlParserALTER)
		}
		{
			p.SetState(2312)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterSimpleDatabaseContext).dbFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDATABASE || _la == MySqlParserSCHEMA) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterSimpleDatabaseContext).dbFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(2314)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 277, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2313)
				p.Uid()
			}

		}
		p.SetState(2317)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4398214283264) != 0) || _la == MySqlParserREAD || _la == MySqlParserCHAR || _la == MySqlParserENCRYPTION || _la == MySqlParserCHARSET {
			{
				p.SetState(2316)
				p.CreateDatabaseOption()
			}

			p.SetState(2319)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewAlterUpgradeNameContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2321)
			p.Match(MySqlParserALTER)
		}
		{
			p.SetState(2322)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterUpgradeNameContext).dbFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDATABASE || _la == MySqlParserSCHEMA) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterUpgradeNameContext).dbFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2323)
			p.Uid()
		}
		{
			p.SetState(2324)
			p.Match(MySqlParserUPGRADE)
		}
		{
			p.SetState(2325)
			p.Match(MySqlParserDATA)
		}
		{
			p.SetState(2326)
			p.Match(MySqlParserDIRECTORY)
		}
		{
			p.SetState(2327)
			p.Match(MySqlParserNAME)
		}

	}

	return localctx
}

// IAlterEventContext is an interface to support dynamic dispatch.
type IAlterEventContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	EVENT() antlr.TerminalNode
	AllFullId() []IFullIdContext
	FullId(i int) IFullIdContext
	OwnerStatement() IOwnerStatementContext
	AllON() []antlr.TerminalNode
	ON(i int) antlr.TerminalNode
	SCHEDULE() antlr.TerminalNode
	ScheduleExpression() IScheduleExpressionContext
	COMPLETION() antlr.TerminalNode
	PRESERVE() antlr.TerminalNode
	RENAME() antlr.TerminalNode
	TO() antlr.TerminalNode
	EnableType() IEnableTypeContext
	COMMENT() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	DO() antlr.TerminalNode
	RoutineBody() IRoutineBodyContext
	NOT() antlr.TerminalNode

	// IsAlterEventContext differentiates from other interfaces.
	IsAlterEventContext()
}

type AlterEventContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterEventContext() *AlterEventContext {
	var p = new(AlterEventContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_alterEvent
	return p
}

func (*AlterEventContext) IsAlterEventContext() {}

func NewAlterEventContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterEventContext {
	var p = new(AlterEventContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_alterEvent

	return p
}

func (s *AlterEventContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterEventContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterEventContext) EVENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVENT, 0)
}

func (s *AlterEventContext) AllFullId() []IFullIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFullIdContext); ok {
			len++
		}
	}

	tst := make([]IFullIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFullIdContext); ok {
			tst[i] = t.(IFullIdContext)
			i++
		}
	}

	return tst
}

func (s *AlterEventContext) FullId(i int) IFullIdContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *AlterEventContext) OwnerStatement() IOwnerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOwnerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOwnerStatementContext)
}

func (s *AlterEventContext) AllON() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserON)
}

func (s *AlterEventContext) ON(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserON, i)
}

func (s *AlterEventContext) SCHEDULE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEDULE, 0)
}

func (s *AlterEventContext) ScheduleExpression() IScheduleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScheduleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScheduleExpressionContext)
}

func (s *AlterEventContext) COMPLETION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMPLETION, 0)
}

func (s *AlterEventContext) PRESERVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRESERVE, 0)
}

func (s *AlterEventContext) RENAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserRENAME, 0)
}

func (s *AlterEventContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *AlterEventContext) EnableType() IEnableTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnableTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnableTypeContext)
}

func (s *AlterEventContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT, 0)
}

func (s *AlterEventContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *AlterEventContext) DO() antlr.TerminalNode {
	return s.GetToken(MySqlParserDO, 0)
}

func (s *AlterEventContext) RoutineBody() IRoutineBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineBodyContext)
}

func (s *AlterEventContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *AlterEventContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterEventContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterEventContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterEvent(s)
	}
}

func (s *AlterEventContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterEvent(s)
	}
}

func (p *MySqlParser) AlterEvent() (localctx IAlterEventContext) {
	this := p
	_ = this

	localctx = NewAlterEventContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, MySqlParserRULE_alterEvent)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2331)
		p.Match(MySqlParserALTER)
	}
	p.SetState(2333)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserDEFINER {
		{
			p.SetState(2332)
			p.OwnerStatement()
		}

	}
	{
		p.SetState(2335)
		p.Match(MySqlParserEVENT)
	}
	{
		p.SetState(2336)
		p.FullId()
	}
	p.SetState(2340)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 281, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2337)
			p.Match(MySqlParserON)
		}
		{
			p.SetState(2338)
			p.Match(MySqlParserSCHEDULE)
		}
		{
			p.SetState(2339)
			p.ScheduleExpression()
		}

	}
	p.SetState(2348)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserON {
		{
			p.SetState(2342)
			p.Match(MySqlParserON)
		}
		{
			p.SetState(2343)
			p.Match(MySqlParserCOMPLETION)
		}
		p.SetState(2345)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserNOT {
			{
				p.SetState(2344)
				p.Match(MySqlParserNOT)
			}

		}
		{
			p.SetState(2347)
			p.Match(MySqlParserPRESERVE)
		}

	}
	p.SetState(2353)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 284, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2350)
			p.Match(MySqlParserRENAME)
		}
		{
			p.SetState(2351)
			p.Match(MySqlParserTO)
		}
		{
			p.SetState(2352)
			p.FullId()
		}

	}
	p.SetState(2356)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserDISABLE || _la == MySqlParserENABLE {
		{
			p.SetState(2355)
			p.EnableType()
		}

	}
	p.SetState(2360)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserCOMMENT {
		{
			p.SetState(2358)
			p.Match(MySqlParserCOMMENT)
		}
		{
			p.SetState(2359)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	}
	p.SetState(2364)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 287, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2362)
			p.Match(MySqlParserDO)
		}
		{
			p.SetState(2363)
			p.RoutineBody()
		}

	}

	return localctx
}

// IAlterFunctionContext is an interface to support dynamic dispatch.
type IAlterFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	FullId() IFullIdContext
	AllRoutineOption() []IRoutineOptionContext
	RoutineOption(i int) IRoutineOptionContext

	// IsAlterFunctionContext differentiates from other interfaces.
	IsAlterFunctionContext()
}

type AlterFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterFunctionContext() *AlterFunctionContext {
	var p = new(AlterFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_alterFunction
	return p
}

func (*AlterFunctionContext) IsAlterFunctionContext() {}

func NewAlterFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterFunctionContext {
	var p = new(AlterFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_alterFunction

	return p
}

func (s *AlterFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterFunctionContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserFUNCTION, 0)
}

func (s *AlterFunctionContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *AlterFunctionContext) AllRoutineOption() []IRoutineOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoutineOptionContext); ok {
			len++
		}
	}

	tst := make([]IRoutineOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoutineOptionContext); ok {
			tst[i] = t.(IRoutineOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterFunctionContext) RoutineOption(i int) IRoutineOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineOptionContext)
}

func (s *AlterFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterFunction(s)
	}
}

func (s *AlterFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterFunction(s)
	}
}

func (p *MySqlParser) AlterFunction() (localctx IAlterFunctionContext) {
	this := p
	_ = this

	localctx = NewAlterFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, MySqlParserRULE_alterFunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2366)
		p.Match(MySqlParserALTER)
	}
	{
		p.SetState(2367)
		p.Match(MySqlParserFUNCTION)
	}
	{
		p.SetState(2368)
		p.FullId()
	}
	p.SetState(2372)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserDETERMINISTIC || ((int64((_la-112)) & ^0x3f) == 0 && ((int64(1)<<(_la-112))&281474985099269) != 0) || _la == MySqlParserCOMMENT || _la == MySqlParserCONTAINS || _la == MySqlParserLANGUAGE || _la == MySqlParserNO {
		{
			p.SetState(2369)
			p.RoutineOption()
		}

		p.SetState(2374)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAlterInstanceContext is an interface to support dynamic dispatch.
type IAlterInstanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	INSTANCE() antlr.TerminalNode
	ROTATE() antlr.TerminalNode
	INNODB() antlr.TerminalNode
	MASTER() antlr.TerminalNode
	KEY() antlr.TerminalNode

	// IsAlterInstanceContext differentiates from other interfaces.
	IsAlterInstanceContext()
}

type AlterInstanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterInstanceContext() *AlterInstanceContext {
	var p = new(AlterInstanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_alterInstance
	return p
}

func (*AlterInstanceContext) IsAlterInstanceContext() {}

func NewAlterInstanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterInstanceContext {
	var p = new(AlterInstanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_alterInstance

	return p
}

func (s *AlterInstanceContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterInstanceContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterInstanceContext) INSTANCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSTANCE, 0)
}

func (s *AlterInstanceContext) ROTATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROTATE, 0)
}

func (s *AlterInstanceContext) INNODB() antlr.TerminalNode {
	return s.GetToken(MySqlParserINNODB, 0)
}

func (s *AlterInstanceContext) MASTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER, 0)
}

func (s *AlterInstanceContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *AlterInstanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterInstanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterInstanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterInstance(s)
	}
}

func (s *AlterInstanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterInstance(s)
	}
}

func (p *MySqlParser) AlterInstance() (localctx IAlterInstanceContext) {
	this := p
	_ = this

	localctx = NewAlterInstanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, MySqlParserRULE_alterInstance)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2375)
		p.Match(MySqlParserALTER)
	}
	{
		p.SetState(2376)
		p.Match(MySqlParserINSTANCE)
	}
	{
		p.SetState(2377)
		p.Match(MySqlParserROTATE)
	}
	{
		p.SetState(2378)
		p.Match(MySqlParserINNODB)
	}
	{
		p.SetState(2379)
		p.Match(MySqlParserMASTER)
	}
	{
		p.SetState(2380)
		p.Match(MySqlParserKEY)
	}

	return localctx
}

// IAlterLogfileGroupContext is an interface to support dynamic dispatch.
type IAlterLogfileGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	LOGFILE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	Uid() IUidContext
	ADD() antlr.TerminalNode
	UNDOFILE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	EngineName() IEngineNameContext
	INITIAL_SIZE() antlr.TerminalNode
	FileSizeLiteral() IFileSizeLiteralContext
	WAIT() antlr.TerminalNode
	AllEQUAL_SYMBOL() []antlr.TerminalNode
	EQUAL_SYMBOL(i int) antlr.TerminalNode

	// IsAlterLogfileGroupContext differentiates from other interfaces.
	IsAlterLogfileGroupContext()
}

type AlterLogfileGroupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterLogfileGroupContext() *AlterLogfileGroupContext {
	var p = new(AlterLogfileGroupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_alterLogfileGroup
	return p
}

func (*AlterLogfileGroupContext) IsAlterLogfileGroupContext() {}

func NewAlterLogfileGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterLogfileGroupContext {
	var p = new(AlterLogfileGroupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_alterLogfileGroup

	return p
}

func (s *AlterLogfileGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterLogfileGroupContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterLogfileGroupContext) LOGFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOGFILE, 0)
}

func (s *AlterLogfileGroupContext) GROUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP, 0)
}

func (s *AlterLogfileGroupContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterLogfileGroupContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *AlterLogfileGroupContext) UNDOFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNDOFILE, 0)
}

func (s *AlterLogfileGroupContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *AlterLogfileGroupContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE, 0)
}

func (s *AlterLogfileGroupContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *AlterLogfileGroupContext) INITIAL_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINITIAL_SIZE, 0)
}

func (s *AlterLogfileGroupContext) FileSizeLiteral() IFileSizeLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileSizeLiteralContext)
}

func (s *AlterLogfileGroupContext) WAIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserWAIT, 0)
}

func (s *AlterLogfileGroupContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *AlterLogfileGroupContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *AlterLogfileGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterLogfileGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterLogfileGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterLogfileGroup(s)
	}
}

func (s *AlterLogfileGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterLogfileGroup(s)
	}
}

func (p *MySqlParser) AlterLogfileGroup() (localctx IAlterLogfileGroupContext) {
	this := p
	_ = this

	localctx = NewAlterLogfileGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, MySqlParserRULE_alterLogfileGroup)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2382)
		p.Match(MySqlParserALTER)
	}
	{
		p.SetState(2383)
		p.Match(MySqlParserLOGFILE)
	}
	{
		p.SetState(2384)
		p.Match(MySqlParserGROUP)
	}
	{
		p.SetState(2385)
		p.Uid()
	}
	{
		p.SetState(2386)
		p.Match(MySqlParserADD)
	}
	{
		p.SetState(2387)
		p.Match(MySqlParserUNDOFILE)
	}
	{
		p.SetState(2388)
		p.Match(MySqlParserSTRING_LITERAL)
	}
	p.SetState(2394)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserINITIAL_SIZE {
		{
			p.SetState(2389)
			p.Match(MySqlParserINITIAL_SIZE)
		}
		p.SetState(2391)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(2390)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(2393)
			p.FileSizeLiteral()
		}

	}
	p.SetState(2397)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserWAIT {
		{
			p.SetState(2396)
			p.Match(MySqlParserWAIT)
		}

	}
	{
		p.SetState(2399)
		p.Match(MySqlParserENGINE)
	}
	p.SetState(2401)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserEQUAL_SYMBOL {
		{
			p.SetState(2400)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}

	}
	{
		p.SetState(2403)
		p.EngineName()
	}

	return localctx
}

// IAlterProcedureContext is an interface to support dynamic dispatch.
type IAlterProcedureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	PROCEDURE() antlr.TerminalNode
	FullId() IFullIdContext
	AllRoutineOption() []IRoutineOptionContext
	RoutineOption(i int) IRoutineOptionContext

	// IsAlterProcedureContext differentiates from other interfaces.
	IsAlterProcedureContext()
}

type AlterProcedureContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterProcedureContext() *AlterProcedureContext {
	var p = new(AlterProcedureContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_alterProcedure
	return p
}

func (*AlterProcedureContext) IsAlterProcedureContext() {}

func NewAlterProcedureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterProcedureContext {
	var p = new(AlterProcedureContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_alterProcedure

	return p
}

func (s *AlterProcedureContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterProcedureContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterProcedureContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROCEDURE, 0)
}

func (s *AlterProcedureContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *AlterProcedureContext) AllRoutineOption() []IRoutineOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoutineOptionContext); ok {
			len++
		}
	}

	tst := make([]IRoutineOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoutineOptionContext); ok {
			tst[i] = t.(IRoutineOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterProcedureContext) RoutineOption(i int) IRoutineOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineOptionContext)
}

func (s *AlterProcedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterProcedureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterProcedureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterProcedure(s)
	}
}

func (s *AlterProcedureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterProcedure(s)
	}
}

func (p *MySqlParser) AlterProcedure() (localctx IAlterProcedureContext) {
	this := p
	_ = this

	localctx = NewAlterProcedureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, MySqlParserRULE_alterProcedure)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2405)
		p.Match(MySqlParserALTER)
	}
	{
		p.SetState(2406)
		p.Match(MySqlParserPROCEDURE)
	}
	{
		p.SetState(2407)
		p.FullId()
	}
	p.SetState(2411)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserDETERMINISTIC || ((int64((_la-112)) & ^0x3f) == 0 && ((int64(1)<<(_la-112))&281474985099269) != 0) || _la == MySqlParserCOMMENT || _la == MySqlParserCONTAINS || _la == MySqlParserLANGUAGE || _la == MySqlParserNO {
		{
			p.SetState(2408)
			p.RoutineOption()
		}

		p.SetState(2413)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAlterServerContext is an interface to support dynamic dispatch.
type IAlterServerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	SERVER() antlr.TerminalNode
	Uid() IUidContext
	OPTIONS() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	AllServerOption() []IServerOptionContext
	ServerOption(i int) IServerOptionContext
	RR_BRACKET() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAlterServerContext differentiates from other interfaces.
	IsAlterServerContext()
}

type AlterServerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterServerContext() *AlterServerContext {
	var p = new(AlterServerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_alterServer
	return p
}

func (*AlterServerContext) IsAlterServerContext() {}

func NewAlterServerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterServerContext {
	var p = new(AlterServerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_alterServer

	return p
}

func (s *AlterServerContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterServerContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterServerContext) SERVER() antlr.TerminalNode {
	return s.GetToken(MySqlParserSERVER, 0)
}

func (s *AlterServerContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterServerContext) OPTIONS() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTIONS, 0)
}

func (s *AlterServerContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AlterServerContext) AllServerOption() []IServerOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IServerOptionContext); ok {
			len++
		}
	}

	tst := make([]IServerOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IServerOptionContext); ok {
			tst[i] = t.(IServerOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterServerContext) ServerOption(i int) IServerOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IServerOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IServerOptionContext)
}

func (s *AlterServerContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AlterServerContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AlterServerContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *AlterServerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterServerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterServerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterServer(s)
	}
}

func (s *AlterServerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterServer(s)
	}
}

func (p *MySqlParser) AlterServer() (localctx IAlterServerContext) {
	this := p
	_ = this

	localctx = NewAlterServerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, MySqlParserRULE_alterServer)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2414)
		p.Match(MySqlParserALTER)
	}
	{
		p.SetState(2415)
		p.Match(MySqlParserSERVER)
	}
	{
		p.SetState(2416)
		p.Uid()
	}
	{
		p.SetState(2417)
		p.Match(MySqlParserOPTIONS)
	}
	{
		p.SetState(2418)
		p.Match(MySqlParserLR_BRACKET)
	}
	{
		p.SetState(2419)
		p.ServerOption()
	}
	p.SetState(2424)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(2420)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(2421)
			p.ServerOption()
		}

		p.SetState(2426)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2427)
		p.Match(MySqlParserRR_BRACKET)
	}

	return localctx
}

// IAlterTableContext is an interface to support dynamic dispatch.
type IAlterTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIntimeAction returns the intimeAction token.
	GetIntimeAction() antlr.Token

	// SetIntimeAction sets the intimeAction token.
	SetIntimeAction(antlr.Token)

	// Getter signatures
	ALTER() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TableName() ITableNameContext
	IGNORE() antlr.TerminalNode
	WaitNowaitClause() IWaitNowaitClauseContext
	AllAlterSpecification() []IAlterSpecificationContext
	AlterSpecification(i int) IAlterSpecificationContext
	PartitionDefinitions() IPartitionDefinitionsContext
	ONLINE() antlr.TerminalNode
	OFFLINE() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAlterTableContext differentiates from other interfaces.
	IsAlterTableContext()
}

type AlterTableContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	intimeAction antlr.Token
}

func NewEmptyAlterTableContext() *AlterTableContext {
	var p = new(AlterTableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_alterTable
	return p
}

func (*AlterTableContext) IsAlterTableContext() {}

func NewAlterTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableContext {
	var p = new(AlterTableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_alterTable

	return p
}

func (s *AlterTableContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableContext) GetIntimeAction() antlr.Token { return s.intimeAction }

func (s *AlterTableContext) SetIntimeAction(v antlr.Token) { s.intimeAction = v }

func (s *AlterTableContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *AlterTableContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *AlterTableContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE, 0)
}

func (s *AlterTableContext) WaitNowaitClause() IWaitNowaitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWaitNowaitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWaitNowaitClauseContext)
}

func (s *AlterTableContext) AllAlterSpecification() []IAlterSpecificationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlterSpecificationContext); ok {
			len++
		}
	}

	tst := make([]IAlterSpecificationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlterSpecificationContext); ok {
			tst[i] = t.(IAlterSpecificationContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableContext) AlterSpecification(i int) IAlterSpecificationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterSpecificationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterSpecificationContext)
}

func (s *AlterTableContext) PartitionDefinitions() IPartitionDefinitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinitionsContext)
}

func (s *AlterTableContext) ONLINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserONLINE, 0)
}

func (s *AlterTableContext) OFFLINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserOFFLINE, 0)
}

func (s *AlterTableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AlterTableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *AlterTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterTable(s)
	}
}

func (s *AlterTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterTable(s)
	}
}

func (p *MySqlParser) AlterTable() (localctx IAlterTableContext) {
	this := p
	_ = this

	localctx = NewAlterTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, MySqlParserRULE_alterTable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2429)
		p.Match(MySqlParserALTER)
	}
	p.SetState(2431)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserOFFLINE || _la == MySqlParserONLINE {
		{
			p.SetState(2430)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterTableContext).intimeAction = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserOFFLINE || _la == MySqlParserONLINE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterTableContext).intimeAction = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(2434)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserIGNORE {
		{
			p.SetState(2433)
			p.Match(MySqlParserIGNORE)
		}

	}
	{
		p.SetState(2436)
		p.Match(MySqlParserTABLE)
	}
	{
		p.SetState(2437)
		p.TableName()
	}
	p.SetState(2439)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserNOWAIT || _la == MySqlParserWAIT {
		{
			p.SetState(2438)
			p.WaitNowaitClause()
		}

	}
	p.SetState(2449)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 299, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2441)
			p.AlterSpecification()
		}
		p.SetState(2446)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(2442)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(2443)
				p.AlterSpecification()
			}

			p.SetState(2448)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(2452)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserPARTITION {
		{
			p.SetState(2451)
			p.PartitionDefinitions()
		}

	}

	return localctx
}

// IAlterTablespaceContext is an interface to support dynamic dispatch.
type IAlterTablespaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetObjectAction returns the objectAction token.
	GetObjectAction() antlr.Token

	// SetObjectAction sets the objectAction token.
	SetObjectAction(antlr.Token)

	// Getter signatures
	ALTER() antlr.TerminalNode
	TABLESPACE() antlr.TerminalNode
	Uid() IUidContext
	DATAFILE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	EngineName() IEngineNameContext
	ADD() antlr.TerminalNode
	DROP() antlr.TerminalNode
	INITIAL_SIZE() antlr.TerminalNode
	AllEQUAL_SYMBOL() []antlr.TerminalNode
	EQUAL_SYMBOL(i int) antlr.TerminalNode
	FileSizeLiteral() IFileSizeLiteralContext
	WAIT() antlr.TerminalNode

	// IsAlterTablespaceContext differentiates from other interfaces.
	IsAlterTablespaceContext()
}

type AlterTablespaceContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	objectAction antlr.Token
}

func NewEmptyAlterTablespaceContext() *AlterTablespaceContext {
	var p = new(AlterTablespaceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_alterTablespace
	return p
}

func (*AlterTablespaceContext) IsAlterTablespaceContext() {}

func NewAlterTablespaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTablespaceContext {
	var p = new(AlterTablespaceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_alterTablespace

	return p
}

func (s *AlterTablespaceContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTablespaceContext) GetObjectAction() antlr.Token { return s.objectAction }

func (s *AlterTablespaceContext) SetObjectAction(v antlr.Token) { s.objectAction = v }

func (s *AlterTablespaceContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterTablespaceContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLESPACE, 0)
}

func (s *AlterTablespaceContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterTablespaceContext) DATAFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATAFILE, 0)
}

func (s *AlterTablespaceContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *AlterTablespaceContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE, 0)
}

func (s *AlterTablespaceContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *AlterTablespaceContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *AlterTablespaceContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *AlterTablespaceContext) INITIAL_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINITIAL_SIZE, 0)
}

func (s *AlterTablespaceContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *AlterTablespaceContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *AlterTablespaceContext) FileSizeLiteral() IFileSizeLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileSizeLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileSizeLiteralContext)
}

func (s *AlterTablespaceContext) WAIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserWAIT, 0)
}

func (s *AlterTablespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTablespaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTablespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterTablespace(s)
	}
}

func (s *AlterTablespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterTablespace(s)
	}
}

func (p *MySqlParser) AlterTablespace() (localctx IAlterTablespaceContext) {
	this := p
	_ = this

	localctx = NewAlterTablespaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, MySqlParserRULE_alterTablespace)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2454)
		p.Match(MySqlParserALTER)
	}
	{
		p.SetState(2455)
		p.Match(MySqlParserTABLESPACE)
	}
	{
		p.SetState(2456)
		p.Uid()
	}
	{
		p.SetState(2457)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*AlterTablespaceContext).objectAction = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserADD || _la == MySqlParserDROP) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*AlterTablespaceContext).objectAction = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2458)
		p.Match(MySqlParserDATAFILE)
	}
	{
		p.SetState(2459)
		p.Match(MySqlParserSTRING_LITERAL)
	}
	p.SetState(2463)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserINITIAL_SIZE {
		{
			p.SetState(2460)
			p.Match(MySqlParserINITIAL_SIZE)
		}
		{
			p.SetState(2461)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}
		{
			p.SetState(2462)
			p.FileSizeLiteral()
		}

	}
	p.SetState(2466)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserWAIT {
		{
			p.SetState(2465)
			p.Match(MySqlParserWAIT)
		}

	}
	{
		p.SetState(2468)
		p.Match(MySqlParserENGINE)
	}
	p.SetState(2470)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserEQUAL_SYMBOL {
		{
			p.SetState(2469)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}

	}
	{
		p.SetState(2472)
		p.EngineName()
	}

	return localctx
}

// IAlterViewContext is an interface to support dynamic dispatch.
type IAlterViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAlgType returns the algType token.
	GetAlgType() antlr.Token

	// GetSecContext returns the secContext token.
	GetSecContext() antlr.Token

	// GetCheckOpt returns the checkOpt token.
	GetCheckOpt() antlr.Token

	// SetAlgType sets the algType token.
	SetAlgType(antlr.Token)

	// SetSecContext sets the secContext token.
	SetSecContext(antlr.Token)

	// SetCheckOpt sets the checkOpt token.
	SetCheckOpt(antlr.Token)

	// Getter signatures
	ALTER() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	FullId() IFullIdContext
	AS() antlr.TerminalNode
	SelectStatement() ISelectStatementContext
	ALGORITHM() antlr.TerminalNode
	EQUAL_SYMBOL() antlr.TerminalNode
	OwnerStatement() IOwnerStatementContext
	SQL() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	UidList() IUidListContext
	RR_BRACKET() antlr.TerminalNode
	WITH() antlr.TerminalNode
	CHECK() antlr.TerminalNode
	OPTION() antlr.TerminalNode
	UNDEFINED() antlr.TerminalNode
	MERGE() antlr.TerminalNode
	TEMPTABLE() antlr.TerminalNode
	DEFINER() antlr.TerminalNode
	INVOKER() antlr.TerminalNode
	CASCADED() antlr.TerminalNode
	LOCAL() antlr.TerminalNode

	// IsAlterViewContext differentiates from other interfaces.
	IsAlterViewContext()
}

type AlterViewContext struct {
	*antlr.BaseParserRuleContext
	parser     antlr.Parser
	algType    antlr.Token
	secContext antlr.Token
	checkOpt   antlr.Token
}

func NewEmptyAlterViewContext() *AlterViewContext {
	var p = new(AlterViewContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_alterView
	return p
}

func (*AlterViewContext) IsAlterViewContext() {}

func NewAlterViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterViewContext {
	var p = new(AlterViewContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_alterView

	return p
}

func (s *AlterViewContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterViewContext) GetAlgType() antlr.Token { return s.algType }

func (s *AlterViewContext) GetSecContext() antlr.Token { return s.secContext }

func (s *AlterViewContext) GetCheckOpt() antlr.Token { return s.checkOpt }

func (s *AlterViewContext) SetAlgType(v antlr.Token) { s.algType = v }

func (s *AlterViewContext) SetSecContext(v antlr.Token) { s.secContext = v }

func (s *AlterViewContext) SetCheckOpt(v antlr.Token) { s.checkOpt = v }

func (s *AlterViewContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(MySqlParserVIEW, 0)
}

func (s *AlterViewContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *AlterViewContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *AlterViewContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *AlterViewContext) ALGORITHM() antlr.TerminalNode {
	return s.GetToken(MySqlParserALGORITHM, 0)
}

func (s *AlterViewContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *AlterViewContext) OwnerStatement() IOwnerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOwnerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOwnerStatementContext)
}

func (s *AlterViewContext) SQL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL, 0)
}

func (s *AlterViewContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserSECURITY, 0)
}

func (s *AlterViewContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AlterViewContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterViewContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AlterViewContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *AlterViewContext) CHECK() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHECK, 0)
}

func (s *AlterViewContext) OPTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTION, 0)
}

func (s *AlterViewContext) UNDEFINED() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNDEFINED, 0)
}

func (s *AlterViewContext) MERGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMERGE, 0)
}

func (s *AlterViewContext) TEMPTABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTEMPTABLE, 0)
}

func (s *AlterViewContext) DEFINER() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFINER, 0)
}

func (s *AlterViewContext) INVOKER() antlr.TerminalNode {
	return s.GetToken(MySqlParserINVOKER, 0)
}

func (s *AlterViewContext) CASCADED() antlr.TerminalNode {
	return s.GetToken(MySqlParserCASCADED, 0)
}

func (s *AlterViewContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL, 0)
}

func (s *AlterViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterView(s)
	}
}

func (s *AlterViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterView(s)
	}
}

func (p *MySqlParser) AlterView() (localctx IAlterViewContext) {
	this := p
	_ = this

	localctx = NewAlterViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, MySqlParserRULE_alterView)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2474)
		p.Match(MySqlParserALTER)
	}
	p.SetState(2478)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserALGORITHM {
		{
			p.SetState(2475)
			p.Match(MySqlParserALGORITHM)
		}
		{
			p.SetState(2476)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}
		{
			p.SetState(2477)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterViewContext).algType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserMERGE || _la == MySqlParserTEMPTABLE || _la == MySqlParserUNDEFINED) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterViewContext).algType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(2481)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserDEFINER {
		{
			p.SetState(2480)
			p.OwnerStatement()
		}

	}
	p.SetState(2486)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserSQL {
		{
			p.SetState(2483)
			p.Match(MySqlParserSQL)
		}
		{
			p.SetState(2484)
			p.Match(MySqlParserSECURITY)
		}
		{
			p.SetState(2485)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterViewContext).secContext = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDEFINER || _la == MySqlParserINVOKER) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterViewContext).secContext = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(2488)
		p.Match(MySqlParserVIEW)
	}
	{
		p.SetState(2489)
		p.FullId()
	}
	p.SetState(2494)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserLR_BRACKET {
		{
			p.SetState(2490)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(2491)
			p.UidList()
		}
		{
			p.SetState(2492)
			p.Match(MySqlParserRR_BRACKET)
		}

	}
	{
		p.SetState(2496)
		p.Match(MySqlParserAS)
	}
	{
		p.SetState(2497)
		p.SelectStatement()
	}
	p.SetState(2504)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 309, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2498)
			p.Match(MySqlParserWITH)
		}
		p.SetState(2500)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCASCADED || _la == MySqlParserLOCAL {
			{
				p.SetState(2499)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*AlterViewContext).checkOpt = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserCASCADED || _la == MySqlParserLOCAL) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*AlterViewContext).checkOpt = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(2502)
			p.Match(MySqlParserCHECK)
		}
		{
			p.SetState(2503)
			p.Match(MySqlParserOPTION)
		}

	}

	return localctx
}

// IAlterSpecificationContext is an interface to support dynamic dispatch.
type IAlterSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAlterSpecificationContext differentiates from other interfaces.
	IsAlterSpecificationContext()
}

type AlterSpecificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterSpecificationContext() *AlterSpecificationContext {
	var p = new(AlterSpecificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_alterSpecification
	return p
}

func (*AlterSpecificationContext) IsAlterSpecificationContext() {}

func NewAlterSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterSpecificationContext {
	var p = new(AlterSpecificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_alterSpecification

	return p
}

func (s *AlterSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterSpecificationContext) CopyFrom(ctx *AlterSpecificationContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *AlterSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AlterByDisableKeysContext struct {
	*AlterSpecificationContext
}

func NewAlterByDisableKeysContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDisableKeysContext {
	var p = new(AlterByDisableKeysContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByDisableKeysContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDisableKeysContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISABLE, 0)
}

func (s *AlterByDisableKeysContext) KEYS() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEYS, 0)
}

func (s *AlterByDisableKeysContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByDisableKeys(s)
	}
}

func (s *AlterByDisableKeysContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByDisableKeys(s)
	}
}

type AlterByDefaultCharsetContext struct {
	*AlterSpecificationContext
}

func NewAlterByDefaultCharsetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDefaultCharsetContext {
	var p = new(AlterByDefaultCharsetContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByDefaultCharsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDefaultCharsetContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER, 0)
}

func (s *AlterByDefaultCharsetContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *AlterByDefaultCharsetContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *AlterByDefaultCharsetContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *AlterByDefaultCharsetContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *AlterByDefaultCharsetContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *AlterByDefaultCharsetContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATE, 0)
}

func (s *AlterByDefaultCharsetContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *AlterByDefaultCharsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByDefaultCharset(s)
	}
}

func (s *AlterByDefaultCharsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByDefaultCharset(s)
	}
}

type AlterByRenameColumnContext struct {
	*AlterSpecificationContext
	oldColumn IUidContext
	newColumn IUidContext
}

func NewAlterByRenameColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByRenameColumnContext {
	var p = new(AlterByRenameColumnContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByRenameColumnContext) GetOldColumn() IUidContext { return s.oldColumn }

func (s *AlterByRenameColumnContext) GetNewColumn() IUidContext { return s.newColumn }

func (s *AlterByRenameColumnContext) SetOldColumn(v IUidContext) { s.oldColumn = v }

func (s *AlterByRenameColumnContext) SetNewColumn(v IUidContext) { s.newColumn = v }

func (s *AlterByRenameColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByRenameColumnContext) RENAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserRENAME, 0)
}

func (s *AlterByRenameColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN, 0)
}

func (s *AlterByRenameColumnContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *AlterByRenameColumnContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByRenameColumnContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByRenameColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByRenameColumn(s)
	}
}

func (s *AlterByRenameColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByRenameColumn(s)
	}
}

type AlterByRenameContext struct {
	*AlterSpecificationContext
	renameFormat antlr.Token
}

func NewAlterByRenameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByRenameContext {
	var p = new(AlterByRenameContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByRenameContext) GetRenameFormat() antlr.Token { return s.renameFormat }

func (s *AlterByRenameContext) SetRenameFormat(v antlr.Token) { s.renameFormat = v }

func (s *AlterByRenameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByRenameContext) RENAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserRENAME, 0)
}

func (s *AlterByRenameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByRenameContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *AlterByRenameContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *AlterByRenameContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *AlterByRenameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByRename(s)
	}
}

func (s *AlterByRenameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByRename(s)
	}
}

type AlterByCoalescePartitionContext struct {
	*AlterSpecificationContext
}

func NewAlterByCoalescePartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByCoalescePartitionContext {
	var p = new(AlterByCoalescePartitionContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByCoalescePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByCoalescePartitionContext) COALESCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOALESCE, 0)
}

func (s *AlterByCoalescePartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByCoalescePartitionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *AlterByCoalescePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByCoalescePartition(s)
	}
}

func (s *AlterByCoalescePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByCoalescePartition(s)
	}
}

type AlterByAlterCheckTableConstraintContext struct {
	*AlterSpecificationContext
	name IUidContext
}

func NewAlterByAlterCheckTableConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAlterCheckTableConstraintContext {
	var p = new(AlterByAlterCheckTableConstraintContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAlterCheckTableConstraintContext) GetName() IUidContext { return s.name }

func (s *AlterByAlterCheckTableConstraintContext) SetName(v IUidContext) { s.name = v }

func (s *AlterByAlterCheckTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAlterCheckTableConstraintContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterByAlterCheckTableConstraintContext) CHECK() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHECK, 0)
}

func (s *AlterByAlterCheckTableConstraintContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAlterCheckTableConstraintContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAlterCheckTableConstraintContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *AlterByAlterCheckTableConstraintContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AlterByAlterCheckTableConstraintContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AlterByAlterCheckTableConstraintContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AlterByAlterCheckTableConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT, 0)
}

func (s *AlterByAlterCheckTableConstraintContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *AlterByAlterCheckTableConstraintContext) ENFORCED() antlr.TerminalNode {
	return s.GetToken(MySqlParserENFORCED, 0)
}

func (s *AlterByAlterCheckTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAlterCheckTableConstraint(s)
	}
}

func (s *AlterByAlterCheckTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAlterCheckTableConstraint(s)
	}
}

type AlterByAlterIndexVisibilityContext struct {
	*AlterSpecificationContext
}

func NewAlterByAlterIndexVisibilityContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAlterIndexVisibilityContext {
	var p = new(AlterByAlterIndexVisibilityContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAlterIndexVisibilityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAlterIndexVisibilityContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterByAlterIndexVisibilityContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *AlterByAlterIndexVisibilityContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAlterIndexVisibilityContext) VISIBLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVISIBLE, 0)
}

func (s *AlterByAlterIndexVisibilityContext) INVISIBLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINVISIBLE, 0)
}

func (s *AlterByAlterIndexVisibilityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAlterIndexVisibility(s)
	}
}

func (s *AlterByAlterIndexVisibilityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAlterIndexVisibility(s)
	}
}

type AlterByDropForeignKeyContext struct {
	*AlterSpecificationContext
}

func NewAlterByDropForeignKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDropForeignKeyContext {
	var p = new(AlterByDropForeignKeyContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByDropForeignKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDropForeignKeyContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *AlterByDropForeignKeyContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOREIGN, 0)
}

func (s *AlterByDropForeignKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *AlterByDropForeignKeyContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByDropForeignKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByDropForeignKey(s)
	}
}

func (s *AlterByDropForeignKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByDropForeignKey(s)
	}
}

type AlterByAddCheckTableConstraintContext struct {
	*AlterSpecificationContext
	name IUidContext
}

func NewAlterByAddCheckTableConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddCheckTableConstraintContext {
	var p = new(AlterByAddCheckTableConstraintContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAddCheckTableConstraintContext) GetName() IUidContext { return s.name }

func (s *AlterByAddCheckTableConstraintContext) SetName(v IUidContext) { s.name = v }

func (s *AlterByAddCheckTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddCheckTableConstraintContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *AlterByAddCheckTableConstraintContext) CHECK() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHECK, 0)
}

func (s *AlterByAddCheckTableConstraintContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddCheckTableConstraintContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAddCheckTableConstraintContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *AlterByAddCheckTableConstraintContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AlterByAddCheckTableConstraintContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AlterByAddCheckTableConstraintContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AlterByAddCheckTableConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT, 0)
}

func (s *AlterByAddCheckTableConstraintContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *AlterByAddCheckTableConstraintContext) ENFORCED() antlr.TerminalNode {
	return s.GetToken(MySqlParserENFORCED, 0)
}

func (s *AlterByAddCheckTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAddCheckTableConstraint(s)
	}
}

func (s *AlterByAddCheckTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAddCheckTableConstraint(s)
	}
}

type AlterByUpgradePartitioningContext struct {
	*AlterSpecificationContext
}

func NewAlterByUpgradePartitioningContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByUpgradePartitioningContext {
	var p = new(AlterByUpgradePartitioningContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByUpgradePartitioningContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByUpgradePartitioningContext) UPGRADE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPGRADE, 0)
}

func (s *AlterByUpgradePartitioningContext) PARTITIONING() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITIONING, 0)
}

func (s *AlterByUpgradePartitioningContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByUpgradePartitioning(s)
	}
}

func (s *AlterByUpgradePartitioningContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByUpgradePartitioning(s)
	}
}

type AlterByRepairPartitionContext struct {
	*AlterSpecificationContext
}

func NewAlterByRepairPartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByRepairPartitionContext {
	var p = new(AlterByRepairPartitionContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByRepairPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByRepairPartitionContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPAIR, 0)
}

func (s *AlterByRepairPartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByRepairPartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByRepairPartitionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *AlterByRepairPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByRepairPartition(s)
	}
}

func (s *AlterByRepairPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByRepairPartition(s)
	}
}

type AlterByAddIndexContext struct {
	*AlterSpecificationContext
	indexFormat antlr.Token
}

func NewAlterByAddIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddIndexContext {
	var p = new(AlterByAddIndexContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAddIndexContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *AlterByAddIndexContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *AlterByAddIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddIndexContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *AlterByAddIndexContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *AlterByAddIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *AlterByAddIndexContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *AlterByAddIndexContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAddIndexContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *AlterByAddIndexContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddIndexContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *AlterByAddIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAddIndex(s)
	}
}

func (s *AlterByAddIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAddIndex(s)
	}
}

type AlterByDropColumnContext struct {
	*AlterSpecificationContext
}

func NewAlterByDropColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDropColumnContext {
	var p = new(AlterByDropColumnContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByDropColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDropColumnContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *AlterByDropColumnContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByDropColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN, 0)
}

func (s *AlterByDropColumnContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESTRICT, 0)
}

func (s *AlterByDropColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByDropColumn(s)
	}
}

func (s *AlterByDropColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByDropColumn(s)
	}
}

type AlterByDropPartitionContext struct {
	*AlterSpecificationContext
}

func NewAlterByDropPartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDropPartitionContext {
	var p = new(AlterByDropPartitionContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByDropPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDropPartitionContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *AlterByDropPartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByDropPartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByDropPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByDropPartition(s)
	}
}

func (s *AlterByDropPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByDropPartition(s)
	}
}

type AlterByAddSpecialIndexContext struct {
	*AlterSpecificationContext
	keyType     antlr.Token
	indexFormat antlr.Token
}

func NewAlterByAddSpecialIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddSpecialIndexContext {
	var p = new(AlterByAddSpecialIndexContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAddSpecialIndexContext) GetKeyType() antlr.Token { return s.keyType }

func (s *AlterByAddSpecialIndexContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *AlterByAddSpecialIndexContext) SetKeyType(v antlr.Token) { s.keyType = v }

func (s *AlterByAddSpecialIndexContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *AlterByAddSpecialIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddSpecialIndexContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *AlterByAddSpecialIndexContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *AlterByAddSpecialIndexContext) FULLTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserFULLTEXT, 0)
}

func (s *AlterByAddSpecialIndexContext) SPATIAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSPATIAL, 0)
}

func (s *AlterByAddSpecialIndexContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAddSpecialIndexContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddSpecialIndexContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *AlterByAddSpecialIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *AlterByAddSpecialIndexContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *AlterByAddSpecialIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAddSpecialIndex(s)
	}
}

func (s *AlterByAddSpecialIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAddSpecialIndex(s)
	}
}

type AlterByModifyColumnContext struct {
	*AlterSpecificationContext
}

func NewAlterByModifyColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByModifyColumnContext {
	var p = new(AlterByModifyColumnContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByModifyColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByModifyColumnContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMODIFY, 0)
}

func (s *AlterByModifyColumnContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByModifyColumnContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByModifyColumnContext) ColumnDefinition() IColumnDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *AlterByModifyColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN, 0)
}

func (s *AlterByModifyColumnContext) FIRST() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIRST, 0)
}

func (s *AlterByModifyColumnContext) AFTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserAFTER, 0)
}

func (s *AlterByModifyColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByModifyColumn(s)
	}
}

func (s *AlterByModifyColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByModifyColumn(s)
	}
}

type AlterByTableOptionContext struct {
	*AlterSpecificationContext
}

func NewAlterByTableOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByTableOptionContext {
	var p = new(AlterByTableOptionContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByTableOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByTableOptionContext) AllTableOption() []ITableOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableOptionContext); ok {
			len++
		}
	}

	tst := make([]ITableOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableOptionContext); ok {
			tst[i] = t.(ITableOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterByTableOptionContext) TableOption(i int) ITableOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOptionContext)
}

func (s *AlterByTableOptionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AlterByTableOptionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *AlterByTableOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByTableOption(s)
	}
}

func (s *AlterByTableOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByTableOption(s)
	}
}

type AlterByDropPrimaryKeyContext struct {
	*AlterSpecificationContext
}

func NewAlterByDropPrimaryKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDropPrimaryKeyContext {
	var p = new(AlterByDropPrimaryKeyContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByDropPrimaryKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDropPrimaryKeyContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *AlterByDropPrimaryKeyContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRIMARY, 0)
}

func (s *AlterByDropPrimaryKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *AlterByDropPrimaryKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByDropPrimaryKey(s)
	}
}

func (s *AlterByDropPrimaryKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByDropPrimaryKey(s)
	}
}

type AlterByLockContext struct {
	*AlterSpecificationContext
	lockType antlr.Token
}

func NewAlterByLockContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByLockContext {
	var p = new(AlterByLockContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByLockContext) GetLockType() antlr.Token { return s.lockType }

func (s *AlterByLockContext) SetLockType(v antlr.Token) { s.lockType = v }

func (s *AlterByLockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByLockContext) LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCK, 0)
}

func (s *AlterByLockContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *AlterByLockContext) NONE() antlr.TerminalNode {
	return s.GetToken(MySqlParserNONE, 0)
}

func (s *AlterByLockContext) SHARED() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHARED, 0)
}

func (s *AlterByLockContext) EXCLUSIVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCLUSIVE, 0)
}

func (s *AlterByLockContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *AlterByLockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByLock(s)
	}
}

func (s *AlterByLockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByLock(s)
	}
}

type AlterByDiscardPartitionContext struct {
	*AlterSpecificationContext
}

func NewAlterByDiscardPartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDiscardPartitionContext {
	var p = new(AlterByDiscardPartitionContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByDiscardPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDiscardPartitionContext) DISCARD() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISCARD, 0)
}

func (s *AlterByDiscardPartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByDiscardPartitionContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLESPACE, 0)
}

func (s *AlterByDiscardPartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByDiscardPartitionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *AlterByDiscardPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByDiscardPartition(s)
	}
}

func (s *AlterByDiscardPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByDiscardPartition(s)
	}
}

type AlterByDiscardTablespaceContext struct {
	*AlterSpecificationContext
}

func NewAlterByDiscardTablespaceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDiscardTablespaceContext {
	var p = new(AlterByDiscardTablespaceContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByDiscardTablespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDiscardTablespaceContext) DISCARD() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISCARD, 0)
}

func (s *AlterByDiscardTablespaceContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLESPACE, 0)
}

func (s *AlterByDiscardTablespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByDiscardTablespace(s)
	}
}

func (s *AlterByDiscardTablespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByDiscardTablespace(s)
	}
}

type AlterByValidateContext struct {
	*AlterSpecificationContext
	validationFormat antlr.Token
}

func NewAlterByValidateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByValidateContext {
	var p = new(AlterByValidateContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByValidateContext) GetValidationFormat() antlr.Token { return s.validationFormat }

func (s *AlterByValidateContext) SetValidationFormat(v antlr.Token) { s.validationFormat = v }

func (s *AlterByValidateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByValidateContext) VALIDATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALIDATION, 0)
}

func (s *AlterByValidateContext) WITHOUT() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITHOUT, 0)
}

func (s *AlterByValidateContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *AlterByValidateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByValidate(s)
	}
}

func (s *AlterByValidateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByValidate(s)
	}
}

type AlterByCheckPartitionContext struct {
	*AlterSpecificationContext
}

func NewAlterByCheckPartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByCheckPartitionContext {
	var p = new(AlterByCheckPartitionContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByCheckPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByCheckPartitionContext) CHECK() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHECK, 0)
}

func (s *AlterByCheckPartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByCheckPartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByCheckPartitionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *AlterByCheckPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByCheckPartition(s)
	}
}

func (s *AlterByCheckPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByCheckPartition(s)
	}
}

type AlterByEnableKeysContext struct {
	*AlterSpecificationContext
}

func NewAlterByEnableKeysContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByEnableKeysContext {
	var p = new(AlterByEnableKeysContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByEnableKeysContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByEnableKeysContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENABLE, 0)
}

func (s *AlterByEnableKeysContext) KEYS() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEYS, 0)
}

func (s *AlterByEnableKeysContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByEnableKeys(s)
	}
}

func (s *AlterByEnableKeysContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByEnableKeys(s)
	}
}

type AlterByReorganizePartitionContext struct {
	*AlterSpecificationContext
}

func NewAlterByReorganizePartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByReorganizePartitionContext {
	var p = new(AlterByReorganizePartitionContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByReorganizePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByReorganizePartitionContext) REORGANIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREORGANIZE, 0)
}

func (s *AlterByReorganizePartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByReorganizePartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByReorganizePartitionContext) INTO() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTO, 0)
}

func (s *AlterByReorganizePartitionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AlterByReorganizePartitionContext) AllPartitionDefinition() []IPartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinitionContext); ok {
			tst[i] = t.(IPartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *AlterByReorganizePartitionContext) PartitionDefinition(i int) IPartitionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinitionContext)
}

func (s *AlterByReorganizePartitionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AlterByReorganizePartitionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AlterByReorganizePartitionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *AlterByReorganizePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByReorganizePartition(s)
	}
}

func (s *AlterByReorganizePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByReorganizePartition(s)
	}
}

type AlterBySetAlgorithmContext struct {
	*AlterSpecificationContext
	algType antlr.Token
}

func NewAlterBySetAlgorithmContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterBySetAlgorithmContext {
	var p = new(AlterBySetAlgorithmContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterBySetAlgorithmContext) GetAlgType() antlr.Token { return s.algType }

func (s *AlterBySetAlgorithmContext) SetAlgType(v antlr.Token) { s.algType = v }

func (s *AlterBySetAlgorithmContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterBySetAlgorithmContext) ALGORITHM() antlr.TerminalNode {
	return s.GetToken(MySqlParserALGORITHM, 0)
}

func (s *AlterBySetAlgorithmContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *AlterBySetAlgorithmContext) INSTANT() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSTANT, 0)
}

func (s *AlterBySetAlgorithmContext) INPLACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINPLACE, 0)
}

func (s *AlterBySetAlgorithmContext) COPY() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOPY, 0)
}

func (s *AlterBySetAlgorithmContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *AlterBySetAlgorithmContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterBySetAlgorithm(s)
	}
}

func (s *AlterBySetAlgorithmContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterBySetAlgorithm(s)
	}
}

type AlterByAddUniqueKeyContext struct {
	*AlterSpecificationContext
	name        IUidContext
	indexFormat antlr.Token
	indexName   IUidContext
}

func NewAlterByAddUniqueKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddUniqueKeyContext {
	var p = new(AlterByAddUniqueKeyContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAddUniqueKeyContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *AlterByAddUniqueKeyContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *AlterByAddUniqueKeyContext) GetName() IUidContext { return s.name }

func (s *AlterByAddUniqueKeyContext) GetIndexName() IUidContext { return s.indexName }

func (s *AlterByAddUniqueKeyContext) SetName(v IUidContext) { s.name = v }

func (s *AlterByAddUniqueKeyContext) SetIndexName(v IUidContext) { s.indexName = v }

func (s *AlterByAddUniqueKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddUniqueKeyContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *AlterByAddUniqueKeyContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNIQUE, 0)
}

func (s *AlterByAddUniqueKeyContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *AlterByAddUniqueKeyContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT, 0)
}

func (s *AlterByAddUniqueKeyContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *AlterByAddUniqueKeyContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddUniqueKeyContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *AlterByAddUniqueKeyContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddUniqueKeyContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAddUniqueKeyContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *AlterByAddUniqueKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *AlterByAddUniqueKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAddUniqueKey(s)
	}
}

func (s *AlterByAddUniqueKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAddUniqueKey(s)
	}
}

type AlterByAlterColumnDefaultContext struct {
	*AlterSpecificationContext
}

func NewAlterByAlterColumnDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAlterColumnDefaultContext {
	var p = new(AlterByAlterColumnDefaultContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAlterColumnDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAlterColumnDefaultContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterByAlterColumnDefaultContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAlterColumnDefaultContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *AlterByAlterColumnDefaultContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *AlterByAlterColumnDefaultContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *AlterByAlterColumnDefaultContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN, 0)
}

func (s *AlterByAlterColumnDefaultContext) VISIBLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVISIBLE, 0)
}

func (s *AlterByAlterColumnDefaultContext) INVISIBLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINVISIBLE, 0)
}

func (s *AlterByAlterColumnDefaultContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *AlterByAlterColumnDefaultContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AlterByAlterColumnDefaultContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AlterByAlterColumnDefaultContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AlterByAlterColumnDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAlterColumnDefault(s)
	}
}

func (s *AlterByAlterColumnDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAlterColumnDefault(s)
	}
}

type AlterByConvertCharsetContext struct {
	*AlterSpecificationContext
}

func NewAlterByConvertCharsetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByConvertCharsetContext {
	var p = new(AlterByConvertCharsetContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByConvertCharsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByConvertCharsetContext) CONVERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONVERT, 0)
}

func (s *AlterByConvertCharsetContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *AlterByConvertCharsetContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *AlterByConvertCharsetContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARSET, 0)
}

func (s *AlterByConvertCharsetContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER, 0)
}

func (s *AlterByConvertCharsetContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *AlterByConvertCharsetContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATE, 0)
}

func (s *AlterByConvertCharsetContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *AlterByConvertCharsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByConvertCharset(s)
	}
}

func (s *AlterByConvertCharsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByConvertCharset(s)
	}
}

type AlterByAddPartitionContext struct {
	*AlterSpecificationContext
}

func NewAlterByAddPartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddPartitionContext {
	var p = new(AlterByAddPartitionContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAddPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddPartitionContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *AlterByAddPartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByAddPartitionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AlterByAddPartitionContext) AllPartitionDefinition() []IPartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinitionContext); ok {
			tst[i] = t.(IPartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddPartitionContext) PartitionDefinition(i int) IPartitionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinitionContext)
}

func (s *AlterByAddPartitionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AlterByAddPartitionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AlterByAddPartitionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *AlterByAddPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAddPartition(s)
	}
}

func (s *AlterByAddPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAddPartition(s)
	}
}

type AlterByAddForeignKeyContext struct {
	*AlterSpecificationContext
	name      IUidContext
	indexName IUidContext
}

func NewAlterByAddForeignKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddForeignKeyContext {
	var p = new(AlterByAddForeignKeyContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAddForeignKeyContext) GetName() IUidContext { return s.name }

func (s *AlterByAddForeignKeyContext) GetIndexName() IUidContext { return s.indexName }

func (s *AlterByAddForeignKeyContext) SetName(v IUidContext) { s.name = v }

func (s *AlterByAddForeignKeyContext) SetIndexName(v IUidContext) { s.indexName = v }

func (s *AlterByAddForeignKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddForeignKeyContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *AlterByAddForeignKeyContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOREIGN, 0)
}

func (s *AlterByAddForeignKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *AlterByAddForeignKeyContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *AlterByAddForeignKeyContext) ReferenceDefinition() IReferenceDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceDefinitionContext)
}

func (s *AlterByAddForeignKeyContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT, 0)
}

func (s *AlterByAddForeignKeyContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddForeignKeyContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAddForeignKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAddForeignKey(s)
	}
}

func (s *AlterByAddForeignKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAddForeignKey(s)
	}
}

type AlterByRenameIndexContext struct {
	*AlterSpecificationContext
	indexFormat antlr.Token
}

func NewAlterByRenameIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByRenameIndexContext {
	var p = new(AlterByRenameIndexContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByRenameIndexContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *AlterByRenameIndexContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *AlterByRenameIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByRenameIndexContext) RENAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserRENAME, 0)
}

func (s *AlterByRenameIndexContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByRenameIndexContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByRenameIndexContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *AlterByRenameIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *AlterByRenameIndexContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *AlterByRenameIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByRenameIndex(s)
	}
}

func (s *AlterByRenameIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByRenameIndex(s)
	}
}

type AlterByRemovePartitioningContext struct {
	*AlterSpecificationContext
}

func NewAlterByRemovePartitioningContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByRemovePartitioningContext {
	var p = new(AlterByRemovePartitioningContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByRemovePartitioningContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByRemovePartitioningContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREMOVE, 0)
}

func (s *AlterByRemovePartitioningContext) PARTITIONING() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITIONING, 0)
}

func (s *AlterByRemovePartitioningContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByRemovePartitioning(s)
	}
}

func (s *AlterByRemovePartitioningContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByRemovePartitioning(s)
	}
}

type AlterByOptimizePartitionContext struct {
	*AlterSpecificationContext
}

func NewAlterByOptimizePartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByOptimizePartitionContext {
	var p = new(AlterByOptimizePartitionContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByOptimizePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByOptimizePartitionContext) OPTIMIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTIMIZE, 0)
}

func (s *AlterByOptimizePartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByOptimizePartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByOptimizePartitionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *AlterByOptimizePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByOptimizePartition(s)
	}
}

func (s *AlterByOptimizePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByOptimizePartition(s)
	}
}

type AlterByImportTablespaceContext struct {
	*AlterSpecificationContext
}

func NewAlterByImportTablespaceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByImportTablespaceContext {
	var p = new(AlterByImportTablespaceContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByImportTablespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByImportTablespaceContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(MySqlParserIMPORT, 0)
}

func (s *AlterByImportTablespaceContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLESPACE, 0)
}

func (s *AlterByImportTablespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByImportTablespace(s)
	}
}

func (s *AlterByImportTablespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByImportTablespace(s)
	}
}

type AlterByAddDefinitionsContext struct {
	*AlterSpecificationContext
}

func NewAlterByAddDefinitionsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddDefinitionsContext {
	var p = new(AlterByAddDefinitionsContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAddDefinitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddDefinitionsContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *AlterByAddDefinitionsContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AlterByAddDefinitionsContext) AllCreateDefinition() []ICreateDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreateDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ICreateDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreateDefinitionContext); ok {
			tst[i] = t.(ICreateDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddDefinitionsContext) CreateDefinition(i int) ICreateDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDefinitionContext)
}

func (s *AlterByAddDefinitionsContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AlterByAddDefinitionsContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN, 0)
}

func (s *AlterByAddDefinitionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AlterByAddDefinitionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *AlterByAddDefinitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAddDefinitions(s)
	}
}

func (s *AlterByAddDefinitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAddDefinitions(s)
	}
}

type AlterByDropConstraintCheckContext struct {
	*AlterSpecificationContext
}

func NewAlterByDropConstraintCheckContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDropConstraintCheckContext {
	var p = new(AlterByDropConstraintCheckContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByDropConstraintCheckContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDropConstraintCheckContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *AlterByDropConstraintCheckContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByDropConstraintCheckContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT, 0)
}

func (s *AlterByDropConstraintCheckContext) CHECK() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHECK, 0)
}

func (s *AlterByDropConstraintCheckContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByDropConstraintCheck(s)
	}
}

func (s *AlterByDropConstraintCheckContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByDropConstraintCheck(s)
	}
}

type AlterByAddColumnsContext struct {
	*AlterSpecificationContext
}

func NewAlterByAddColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddColumnsContext {
	var p = new(AlterByAddColumnsContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAddColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddColumnsContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *AlterByAddColumnsContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AlterByAddColumnsContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddColumnsContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAddColumnsContext) AllColumnDefinition() []IColumnDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IColumnDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnDefinitionContext); ok {
			tst[i] = t.(IColumnDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddColumnsContext) ColumnDefinition(i int) IColumnDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *AlterByAddColumnsContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AlterByAddColumnsContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN, 0)
}

func (s *AlterByAddColumnsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AlterByAddColumnsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *AlterByAddColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAddColumns(s)
	}
}

func (s *AlterByAddColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAddColumns(s)
	}
}

type AlterByRebuildPartitionContext struct {
	*AlterSpecificationContext
}

func NewAlterByRebuildPartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByRebuildPartitionContext {
	var p = new(AlterByRebuildPartitionContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByRebuildPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByRebuildPartitionContext) REBUILD() antlr.TerminalNode {
	return s.GetToken(MySqlParserREBUILD, 0)
}

func (s *AlterByRebuildPartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByRebuildPartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByRebuildPartitionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *AlterByRebuildPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByRebuildPartition(s)
	}
}

func (s *AlterByRebuildPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByRebuildPartition(s)
	}
}

type AlterByExchangePartitionContext struct {
	*AlterSpecificationContext
	validationFormat antlr.Token
}

func NewAlterByExchangePartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByExchangePartitionContext {
	var p = new(AlterByExchangePartitionContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByExchangePartitionContext) GetValidationFormat() antlr.Token {
	return s.validationFormat
}

func (s *AlterByExchangePartitionContext) SetValidationFormat(v antlr.Token) { s.validationFormat = v }

func (s *AlterByExchangePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByExchangePartitionContext) EXCHANGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCHANGE, 0)
}

func (s *AlterByExchangePartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByExchangePartitionContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByExchangePartitionContext) AllWITH() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserWITH)
}

func (s *AlterByExchangePartitionContext) WITH(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, i)
}

func (s *AlterByExchangePartitionContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *AlterByExchangePartitionContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *AlterByExchangePartitionContext) VALIDATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALIDATION, 0)
}

func (s *AlterByExchangePartitionContext) WITHOUT() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITHOUT, 0)
}

func (s *AlterByExchangePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByExchangePartition(s)
	}
}

func (s *AlterByExchangePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByExchangePartition(s)
	}
}

type AlterByImportPartitionContext struct {
	*AlterSpecificationContext
}

func NewAlterByImportPartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByImportPartitionContext {
	var p = new(AlterByImportPartitionContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByImportPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByImportPartitionContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(MySqlParserIMPORT, 0)
}

func (s *AlterByImportPartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByImportPartitionContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLESPACE, 0)
}

func (s *AlterByImportPartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByImportPartitionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *AlterByImportPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByImportPartition(s)
	}
}

func (s *AlterByImportPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByImportPartition(s)
	}
}

type AlterByChangeDefaultContext struct {
	*AlterSpecificationContext
}

func NewAlterByChangeDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByChangeDefaultContext {
	var p = new(AlterByChangeDefaultContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByChangeDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByChangeDefaultContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterByChangeDefaultContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByChangeDefaultContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *AlterByChangeDefaultContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *AlterByChangeDefaultContext) DefaultValue() IDefaultValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultValueContext)
}

func (s *AlterByChangeDefaultContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *AlterByChangeDefaultContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN, 0)
}

func (s *AlterByChangeDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByChangeDefault(s)
	}
}

func (s *AlterByChangeDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByChangeDefault(s)
	}
}

type AlterByForceContext struct {
	*AlterSpecificationContext
}

func NewAlterByForceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByForceContext {
	var p = new(AlterByForceContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByForceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByForceContext) FORCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFORCE, 0)
}

func (s *AlterByForceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByForce(s)
	}
}

func (s *AlterByForceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByForce(s)
	}
}

type AlterByAddPrimaryKeyContext struct {
	*AlterSpecificationContext
	name  IUidContext
	index IUidContext
}

func NewAlterByAddPrimaryKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddPrimaryKeyContext {
	var p = new(AlterByAddPrimaryKeyContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAddPrimaryKeyContext) GetName() IUidContext { return s.name }

func (s *AlterByAddPrimaryKeyContext) GetIndex() IUidContext { return s.index }

func (s *AlterByAddPrimaryKeyContext) SetName(v IUidContext) { s.name = v }

func (s *AlterByAddPrimaryKeyContext) SetIndex(v IUidContext) { s.index = v }

func (s *AlterByAddPrimaryKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddPrimaryKeyContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *AlterByAddPrimaryKeyContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRIMARY, 0)
}

func (s *AlterByAddPrimaryKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *AlterByAddPrimaryKeyContext) IndexColumnNames() IIndexColumnNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNamesContext)
}

func (s *AlterByAddPrimaryKeyContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT, 0)
}

func (s *AlterByAddPrimaryKeyContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *AlterByAddPrimaryKeyContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddPrimaryKeyContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *AlterByAddPrimaryKeyContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddPrimaryKeyContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAddPrimaryKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAddPrimaryKey(s)
	}
}

func (s *AlterByAddPrimaryKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAddPrimaryKey(s)
	}
}

type AlterByAnalyzePartitionContext struct {
	*AlterSpecificationContext
}

func NewAlterByAnalyzePartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAnalyzePartitionContext {
	var p = new(AlterByAnalyzePartitionContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAnalyzePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAnalyzePartitionContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserANALYZE, 0)
}

func (s *AlterByAnalyzePartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByAnalyzePartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByAnalyzePartitionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *AlterByAnalyzePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAnalyzePartition(s)
	}
}

func (s *AlterByAnalyzePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAnalyzePartition(s)
	}
}

type AlterByChangeColumnContext struct {
	*AlterSpecificationContext
	oldColumn   IUidContext
	newColumn   IUidContext
	afterColumn IUidContext
}

func NewAlterByChangeColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByChangeColumnContext {
	var p = new(AlterByChangeColumnContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByChangeColumnContext) GetOldColumn() IUidContext { return s.oldColumn }

func (s *AlterByChangeColumnContext) GetNewColumn() IUidContext { return s.newColumn }

func (s *AlterByChangeColumnContext) GetAfterColumn() IUidContext { return s.afterColumn }

func (s *AlterByChangeColumnContext) SetOldColumn(v IUidContext) { s.oldColumn = v }

func (s *AlterByChangeColumnContext) SetNewColumn(v IUidContext) { s.newColumn = v }

func (s *AlterByChangeColumnContext) SetAfterColumn(v IUidContext) { s.afterColumn = v }

func (s *AlterByChangeColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByChangeColumnContext) CHANGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHANGE, 0)
}

func (s *AlterByChangeColumnContext) ColumnDefinition() IColumnDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *AlterByChangeColumnContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByChangeColumnContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByChangeColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN, 0)
}

func (s *AlterByChangeColumnContext) FIRST() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIRST, 0)
}

func (s *AlterByChangeColumnContext) AFTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserAFTER, 0)
}

func (s *AlterByChangeColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByChangeColumn(s)
	}
}

func (s *AlterByChangeColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByChangeColumn(s)
	}
}

type AlterByTruncatePartitionContext struct {
	*AlterSpecificationContext
}

func NewAlterByTruncatePartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByTruncatePartitionContext {
	var p = new(AlterByTruncatePartitionContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByTruncatePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByTruncatePartitionContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRUNCATE, 0)
}

func (s *AlterByTruncatePartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AlterByTruncatePartitionContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByTruncatePartitionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *AlterByTruncatePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByTruncatePartition(s)
	}
}

func (s *AlterByTruncatePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByTruncatePartition(s)
	}
}

type AlterByDropIndexContext struct {
	*AlterSpecificationContext
	indexFormat antlr.Token
}

func NewAlterByDropIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByDropIndexContext {
	var p = new(AlterByDropIndexContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByDropIndexContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *AlterByDropIndexContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *AlterByDropIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByDropIndexContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *AlterByDropIndexContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByDropIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *AlterByDropIndexContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *AlterByDropIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByDropIndex(s)
	}
}

func (s *AlterByDropIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByDropIndex(s)
	}
}

type AlterByAddColumnContext struct {
	*AlterSpecificationContext
}

func NewAlterByAddColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByAddColumnContext {
	var p = new(AlterByAddColumnContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByAddColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByAddColumnContext) ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserADD, 0)
}

func (s *AlterByAddColumnContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *AlterByAddColumnContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterByAddColumnContext) ColumnDefinition() IColumnDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *AlterByAddColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN, 0)
}

func (s *AlterByAddColumnContext) FIRST() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIRST, 0)
}

func (s *AlterByAddColumnContext) AFTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserAFTER, 0)
}

func (s *AlterByAddColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByAddColumn(s)
	}
}

func (s *AlterByAddColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByAddColumn(s)
	}
}

type AlterByOrderContext struct {
	*AlterSpecificationContext
}

func NewAlterByOrderContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterByOrderContext {
	var p = new(AlterByOrderContext)

	p.AlterSpecificationContext = NewEmptyAlterSpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterSpecificationContext))

	return p
}

func (s *AlterByOrderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterByOrderContext) ORDER() antlr.TerminalNode {
	return s.GetToken(MySqlParserORDER, 0)
}

func (s *AlterByOrderContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *AlterByOrderContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AlterByOrderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterByOrder(s)
	}
}

func (s *AlterByOrderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterByOrder(s)
	}
}

func (p *MySqlParser) AlterSpecification() (localctx IAlterSpecificationContext) {
	this := p
	_ = this

	localctx = NewAlterSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, MySqlParserRULE_alterSpecification)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(2954)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 380, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAlterByTableOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2506)
			p.TableOption()
		}
		p.SetState(2513)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 311, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(2508)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == MySqlParserCOMMA {
					{
						p.SetState(2507)
						p.Match(MySqlParserCOMMA)
					}

				}
				{
					p.SetState(2510)
					p.TableOption()
				}

			}
			p.SetState(2515)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 311, p.GetParserRuleContext())
		}

	case 2:
		localctx = NewAlterByAddColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2516)
			p.Match(MySqlParserADD)
		}
		p.SetState(2518)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCOLUMN {
			{
				p.SetState(2517)
				p.Match(MySqlParserCOLUMN)
			}

		}
		{
			p.SetState(2520)
			p.Uid()
		}
		{
			p.SetState(2521)
			p.ColumnDefinition()
		}
		p.SetState(2525)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserFIRST:
			{
				p.SetState(2522)
				p.Match(MySqlParserFIRST)
			}

		case MySqlParserAFTER:
			{
				p.SetState(2523)
				p.Match(MySqlParserAFTER)
			}
			{
				p.SetState(2524)
				p.Uid()
			}

		case MySqlParserEOF, MySqlParserALTER, MySqlParserANALYZE, MySqlParserCALL, MySqlParserCHANGE, MySqlParserCHECK, MySqlParserCREATE, MySqlParserDELETE, MySqlParserDESC, MySqlParserDESCRIBE, MySqlParserDROP, MySqlParserEXPLAIN, MySqlParserGET, MySqlParserGRANT, MySqlParserINSERT, MySqlParserKILL, MySqlParserLOAD, MySqlParserLOCK, MySqlParserOPTIMIZE, MySqlParserPARTITION, MySqlParserPURGE, MySqlParserRELEASE, MySqlParserRENAME, MySqlParserREPLACE, MySqlParserRESIGNAL, MySqlParserREVOKE, MySqlParserSELECT, MySqlParserSET, MySqlParserSHOW, MySqlParserSIGNAL, MySqlParserUNLOCK, MySqlParserUPDATE, MySqlParserUSE, MySqlParserVALUES, MySqlParserWITH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserCACHE, MySqlParserCHECKSUM, MySqlParserCOMMIT, MySqlParserDEALLOCATE, MySqlParserDO, MySqlParserFLUSH, MySqlParserHANDLER, MySqlParserHELP, MySqlParserINSTALL, MySqlParserPREPARE, MySqlParserREPAIR, MySqlParserRESET, MySqlParserROLLBACK, MySqlParserSAVEPOINT, MySqlParserSTART, MySqlParserSTOP, MySqlParserTRUNCATE, MySqlParserUNINSTALL, MySqlParserXA, MySqlParserEXECUTE, MySqlParserSHUTDOWN, MySqlParserMINUS, MySqlParserLR_BRACKET, MySqlParserCOMMA, MySqlParserSEMI:

		default:
		}

	case 3:
		localctx = NewAlterByAddColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2527)
			p.Match(MySqlParserADD)
		}
		p.SetState(2529)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCOLUMN {
			{
				p.SetState(2528)
				p.Match(MySqlParserCOLUMN)
			}

		}
		{
			p.SetState(2531)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(2532)
			p.Uid()
		}
		{
			p.SetState(2533)
			p.ColumnDefinition()
		}
		p.SetState(2540)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(2534)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(2535)
				p.Uid()
			}
			{
				p.SetState(2536)
				p.ColumnDefinition()
			}

			p.SetState(2542)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2543)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 4:
		localctx = NewAlterByAddIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2545)
			p.Match(MySqlParserADD)
		}
		{
			p.SetState(2546)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterByAddIndexContext).indexFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserINDEX || _la == MySqlParserKEY) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterByAddIndexContext).indexFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(2548)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&756891332513120256) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&146666055071174737) != 0) || ((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&134349441) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-2882305960540372993) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-4398063288321) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-16325548649218049) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-81064793296864001) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-68719476801) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-11118270170269697) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-33) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-3073) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&144115188075855871) != 0) || ((int64((_la-1121)) & ^0x3f) == 0 && ((int64(1)<<(_la-1121))&25807552513) != 0) {
			{
				p.SetState(2547)
				p.Uid()
			}

		}
		p.SetState(2551)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserUSING {
			{
				p.SetState(2550)
				p.IndexType()
			}

		}
		{
			p.SetState(2553)
			p.IndexColumnNames()
		}
		p.SetState(2557)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 318, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2554)
					p.IndexOption()
				}

			}
			p.SetState(2559)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 318, p.GetParserRuleContext())
		}

	case 5:
		localctx = NewAlterByAddPrimaryKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2560)
			p.Match(MySqlParserADD)
		}
		p.SetState(2565)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCONSTRAINT {
			{
				p.SetState(2561)
				p.Match(MySqlParserCONSTRAINT)
			}
			p.SetState(2563)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 319, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(2562)

					var _x = p.Uid()

					localctx.(*AlterByAddPrimaryKeyContext).name = _x
				}

			}

		}
		{
			p.SetState(2567)
			p.Match(MySqlParserPRIMARY)
		}
		{
			p.SetState(2568)
			p.Match(MySqlParserKEY)
		}
		p.SetState(2570)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&756891332513120256) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&146666055071174737) != 0) || ((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&134349441) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-2882305960540372993) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-4398063288321) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-16325548649218049) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-81064793296864001) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-68719476801) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-11118270170269697) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-33) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-3073) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&144115188075855871) != 0) || ((int64((_la-1121)) & ^0x3f) == 0 && ((int64(1)<<(_la-1121))&25807552513) != 0) {
			{
				p.SetState(2569)

				var _x = p.Uid()

				localctx.(*AlterByAddPrimaryKeyContext).index = _x
			}

		}
		p.SetState(2573)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserUSING {
			{
				p.SetState(2572)
				p.IndexType()
			}

		}
		{
			p.SetState(2575)
			p.IndexColumnNames()
		}
		p.SetState(2579)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 323, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2576)
					p.IndexOption()
				}

			}
			p.SetState(2581)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 323, p.GetParserRuleContext())
		}

	case 6:
		localctx = NewAlterByAddUniqueKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2582)
			p.Match(MySqlParserADD)
		}
		p.SetState(2587)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCONSTRAINT {
			{
				p.SetState(2583)
				p.Match(MySqlParserCONSTRAINT)
			}
			p.SetState(2585)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&756891332513120256) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&146666055071174737) != 0) || ((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&134349441) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-2882305960540372993) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-4398063288321) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-16325548649218049) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-81064793296864001) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-68719476801) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-11118270170269697) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-33) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-3073) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&144115188075855871) != 0) || ((int64((_la-1121)) & ^0x3f) == 0 && ((int64(1)<<(_la-1121))&25807552513) != 0) {
				{
					p.SetState(2584)

					var _x = p.Uid()

					localctx.(*AlterByAddUniqueKeyContext).name = _x
				}

			}

		}
		{
			p.SetState(2589)
			p.Match(MySqlParserUNIQUE)
		}
		p.SetState(2591)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserINDEX || _la == MySqlParserKEY {
			{
				p.SetState(2590)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*AlterByAddUniqueKeyContext).indexFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserINDEX || _la == MySqlParserKEY) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*AlterByAddUniqueKeyContext).indexFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(2594)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&756891332513120256) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&146666055071174737) != 0) || ((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&134349441) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-2882305960540372993) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-4398063288321) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-16325548649218049) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-81064793296864001) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-68719476801) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-11118270170269697) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-33) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-3073) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&144115188075855871) != 0) || ((int64((_la-1121)) & ^0x3f) == 0 && ((int64(1)<<(_la-1121))&25807552513) != 0) {
			{
				p.SetState(2593)

				var _x = p.Uid()

				localctx.(*AlterByAddUniqueKeyContext).indexName = _x
			}

		}
		p.SetState(2597)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserUSING {
			{
				p.SetState(2596)
				p.IndexType()
			}

		}
		{
			p.SetState(2599)
			p.IndexColumnNames()
		}
		p.SetState(2603)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 329, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2600)
					p.IndexOption()
				}

			}
			p.SetState(2605)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 329, p.GetParserRuleContext())
		}

	case 7:
		localctx = NewAlterByAddSpecialIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2606)
			p.Match(MySqlParserADD)
		}
		{
			p.SetState(2607)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterByAddSpecialIndexContext).keyType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFULLTEXT || _la == MySqlParserSPATIAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterByAddSpecialIndexContext).keyType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(2609)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserINDEX || _la == MySqlParserKEY {
			{
				p.SetState(2608)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*AlterByAddSpecialIndexContext).indexFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserINDEX || _la == MySqlParserKEY) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*AlterByAddSpecialIndexContext).indexFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(2612)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&756891332513120256) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&146666055071174737) != 0) || ((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&134349441) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-2882305960540372993) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-4398063288321) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-16325548649218049) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-81064793296864001) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-68719476801) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-11118270170269697) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-33) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-3073) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&144115188075855871) != 0) || ((int64((_la-1121)) & ^0x3f) == 0 && ((int64(1)<<(_la-1121))&25807552513) != 0) {
			{
				p.SetState(2611)
				p.Uid()
			}

		}
		{
			p.SetState(2614)
			p.IndexColumnNames()
		}
		p.SetState(2618)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 332, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2615)
					p.IndexOption()
				}

			}
			p.SetState(2620)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 332, p.GetParserRuleContext())
		}

	case 8:
		localctx = NewAlterByAddForeignKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2621)
			p.Match(MySqlParserADD)
		}
		p.SetState(2626)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCONSTRAINT {
			{
				p.SetState(2622)
				p.Match(MySqlParserCONSTRAINT)
			}
			p.SetState(2624)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&756891332513120256) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&146666055071174737) != 0) || ((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&134349441) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-2882305960540372993) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-4398063288321) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-16325548649218049) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-81064793296864001) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-68719476801) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-11118270170269697) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-33) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-3073) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&144115188075855871) != 0) || ((int64((_la-1121)) & ^0x3f) == 0 && ((int64(1)<<(_la-1121))&25807552513) != 0) {
				{
					p.SetState(2623)

					var _x = p.Uid()

					localctx.(*AlterByAddForeignKeyContext).name = _x
				}

			}

		}
		{
			p.SetState(2628)
			p.Match(MySqlParserFOREIGN)
		}
		{
			p.SetState(2629)
			p.Match(MySqlParserKEY)
		}
		p.SetState(2631)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&756891332513120256) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&146666055071174737) != 0) || ((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&134349441) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-2882305960540372993) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-4398063288321) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-16325548649218049) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-81064793296864001) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-68719476801) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-11118270170269697) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-33) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-3073) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&144115188075855871) != 0) || ((int64((_la-1121)) & ^0x3f) == 0 && ((int64(1)<<(_la-1121))&25807552513) != 0) {
			{
				p.SetState(2630)

				var _x = p.Uid()

				localctx.(*AlterByAddForeignKeyContext).indexName = _x
			}

		}
		{
			p.SetState(2633)
			p.IndexColumnNames()
		}
		{
			p.SetState(2634)
			p.ReferenceDefinition()
		}

	case 9:
		localctx = NewAlterByAddCheckTableConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2636)
			p.Match(MySqlParserADD)
		}
		p.SetState(2641)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCONSTRAINT {
			{
				p.SetState(2637)
				p.Match(MySqlParserCONSTRAINT)
			}
			p.SetState(2639)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&756891332513120256) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&146666055071174737) != 0) || ((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&134349441) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-2882305960540372993) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-4398063288321) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-16325548649218049) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-81064793296864001) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-68719476801) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-11118270170269697) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-33) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-3073) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&144115188075855871) != 0) || ((int64((_la-1121)) & ^0x3f) == 0 && ((int64(1)<<(_la-1121))&25807552513) != 0) {
				{
					p.SetState(2638)

					var _x = p.Uid()

					localctx.(*AlterByAddCheckTableConstraintContext).name = _x
				}

			}

		}
		{
			p.SetState(2643)
			p.Match(MySqlParserCHECK)
		}
		p.SetState(2650)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 338, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2644)
				p.Uid()
			}

		case 2:
			{
				p.SetState(2645)
				p.StringLiteral()
			}

		case 3:
			{
				p.SetState(2646)
				p.Match(MySqlParserLR_BRACKET)
			}
			{
				p.SetState(2647)
				p.expression(0)
			}
			{
				p.SetState(2648)
				p.Match(MySqlParserRR_BRACKET)
			}

		}
		p.SetState(2653)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserNOT {
			{
				p.SetState(2652)
				p.Match(MySqlParserNOT)
			}

		}
		p.SetState(2656)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserENFORCED {
			{
				p.SetState(2655)
				p.Match(MySqlParserENFORCED)
			}

		}

	case 10:
		localctx = NewAlterByAlterCheckTableConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2658)
			p.Match(MySqlParserALTER)
		}
		p.SetState(2663)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCONSTRAINT {
			{
				p.SetState(2659)
				p.Match(MySqlParserCONSTRAINT)
			}
			p.SetState(2661)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&756891332513120256) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&146666055071174737) != 0) || ((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&134349441) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-2882305960540372993) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-4398063288321) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-16325548649218049) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-81064793296864001) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-68719476801) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-11118270170269697) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-33) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-3073) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&144115188075855871) != 0) || ((int64((_la-1121)) & ^0x3f) == 0 && ((int64(1)<<(_la-1121))&25807552513) != 0) {
				{
					p.SetState(2660)

					var _x = p.Uid()

					localctx.(*AlterByAlterCheckTableConstraintContext).name = _x
				}

			}

		}
		{
			p.SetState(2665)
			p.Match(MySqlParserCHECK)
		}
		p.SetState(2672)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 343, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2666)
				p.Uid()
			}

		case 2:
			{
				p.SetState(2667)
				p.StringLiteral()
			}

		case 3:
			{
				p.SetState(2668)
				p.Match(MySqlParserLR_BRACKET)
			}
			{
				p.SetState(2669)
				p.expression(0)
			}
			{
				p.SetState(2670)
				p.Match(MySqlParserRR_BRACKET)
			}

		}
		p.SetState(2675)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserNOT {
			{
				p.SetState(2674)
				p.Match(MySqlParserNOT)
			}

		}
		p.SetState(2678)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserENFORCED {
			{
				p.SetState(2677)
				p.Match(MySqlParserENFORCED)
			}

		}

	case 11:
		localctx = NewAlterByAddCheckTableConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2680)
			p.Match(MySqlParserADD)
		}
		p.SetState(2685)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCONSTRAINT {
			{
				p.SetState(2681)
				p.Match(MySqlParserCONSTRAINT)
			}
			p.SetState(2683)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&756891332513120256) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&146666055071174737) != 0) || ((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&134349441) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-2882305960540372993) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-4398063288321) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-16325548649218049) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-81064793296864001) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-68719476801) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-11118270170269697) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-33) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-3073) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&144115188075855871) != 0) || ((int64((_la-1121)) & ^0x3f) == 0 && ((int64(1)<<(_la-1121))&25807552513) != 0) {
				{
					p.SetState(2682)

					var _x = p.Uid()

					localctx.(*AlterByAddCheckTableConstraintContext).name = _x
				}

			}

		}
		{
			p.SetState(2687)
			p.Match(MySqlParserCHECK)
		}
		{
			p.SetState(2688)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(2689)
			p.expression(0)
		}
		{
			p.SetState(2690)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 12:
		localctx = NewAlterBySetAlgorithmContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(2692)
			p.Match(MySqlParserALGORITHM)
		}
		p.SetState(2694)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(2693)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(2696)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterBySetAlgorithmContext).algType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDEFAULT || _la == MySqlParserCOPY || _la == MySqlParserINPLACE || _la == MySqlParserINSTANT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterBySetAlgorithmContext).algType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 13:
		localctx = NewAlterByChangeDefaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(2697)
			p.Match(MySqlParserALTER)
		}
		p.SetState(2699)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCOLUMN {
			{
				p.SetState(2698)
				p.Match(MySqlParserCOLUMN)
			}

		}
		{
			p.SetState(2701)
			p.Uid()
		}
		p.SetState(2707)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserSET:
			{
				p.SetState(2702)
				p.Match(MySqlParserSET)
			}
			{
				p.SetState(2703)
				p.Match(MySqlParserDEFAULT)
			}
			{
				p.SetState(2704)
				p.DefaultValue()
			}

		case MySqlParserDROP:
			{
				p.SetState(2705)
				p.Match(MySqlParserDROP)
			}
			{
				p.SetState(2706)
				p.Match(MySqlParserDEFAULT)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 14:
		localctx = NewAlterByChangeColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(2709)
			p.Match(MySqlParserCHANGE)
		}
		p.SetState(2711)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCOLUMN {
			{
				p.SetState(2710)
				p.Match(MySqlParserCOLUMN)
			}

		}
		{
			p.SetState(2713)

			var _x = p.Uid()

			localctx.(*AlterByChangeColumnContext).oldColumn = _x
		}
		{
			p.SetState(2714)

			var _x = p.Uid()

			localctx.(*AlterByChangeColumnContext).newColumn = _x
		}
		{
			p.SetState(2715)
			p.ColumnDefinition()
		}
		p.SetState(2719)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserFIRST:
			{
				p.SetState(2716)
				p.Match(MySqlParserFIRST)
			}

		case MySqlParserAFTER:
			{
				p.SetState(2717)
				p.Match(MySqlParserAFTER)
			}
			{
				p.SetState(2718)

				var _x = p.Uid()

				localctx.(*AlterByChangeColumnContext).afterColumn = _x
			}

		case MySqlParserEOF, MySqlParserALTER, MySqlParserANALYZE, MySqlParserCALL, MySqlParserCHANGE, MySqlParserCHECK, MySqlParserCREATE, MySqlParserDELETE, MySqlParserDESC, MySqlParserDESCRIBE, MySqlParserDROP, MySqlParserEXPLAIN, MySqlParserGET, MySqlParserGRANT, MySqlParserINSERT, MySqlParserKILL, MySqlParserLOAD, MySqlParserLOCK, MySqlParserOPTIMIZE, MySqlParserPARTITION, MySqlParserPURGE, MySqlParserRELEASE, MySqlParserRENAME, MySqlParserREPLACE, MySqlParserRESIGNAL, MySqlParserREVOKE, MySqlParserSELECT, MySqlParserSET, MySqlParserSHOW, MySqlParserSIGNAL, MySqlParserUNLOCK, MySqlParserUPDATE, MySqlParserUSE, MySqlParserVALUES, MySqlParserWITH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserCACHE, MySqlParserCHECKSUM, MySqlParserCOMMIT, MySqlParserDEALLOCATE, MySqlParserDO, MySqlParserFLUSH, MySqlParserHANDLER, MySqlParserHELP, MySqlParserINSTALL, MySqlParserPREPARE, MySqlParserREPAIR, MySqlParserRESET, MySqlParserROLLBACK, MySqlParserSAVEPOINT, MySqlParserSTART, MySqlParserSTOP, MySqlParserTRUNCATE, MySqlParserUNINSTALL, MySqlParserXA, MySqlParserEXECUTE, MySqlParserSHUTDOWN, MySqlParserMINUS, MySqlParserLR_BRACKET, MySqlParserCOMMA, MySqlParserSEMI:

		default:
		}

	case 15:
		localctx = NewAlterByRenameColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(2721)
			p.Match(MySqlParserRENAME)
		}
		{
			p.SetState(2722)
			p.Match(MySqlParserCOLUMN)
		}
		{
			p.SetState(2723)

			var _x = p.Uid()

			localctx.(*AlterByRenameColumnContext).oldColumn = _x
		}
		{
			p.SetState(2724)
			p.Match(MySqlParserTO)
		}
		{
			p.SetState(2725)

			var _x = p.Uid()

			localctx.(*AlterByRenameColumnContext).newColumn = _x
		}

	case 16:
		localctx = NewAlterByLockContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(2727)
			p.Match(MySqlParserLOCK)
		}
		p.SetState(2729)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(2728)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(2731)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterByLockContext).lockType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDEFAULT || _la == MySqlParserEXCLUSIVE || _la == MySqlParserNONE || _la == MySqlParserSHARED) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterByLockContext).lockType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 17:
		localctx = NewAlterByModifyColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(2732)
			p.Match(MySqlParserMODIFY)
		}
		p.SetState(2734)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCOLUMN {
			{
				p.SetState(2733)
				p.Match(MySqlParserCOLUMN)
			}

		}
		{
			p.SetState(2736)
			p.Uid()
		}
		{
			p.SetState(2737)
			p.ColumnDefinition()
		}
		p.SetState(2741)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserFIRST:
			{
				p.SetState(2738)
				p.Match(MySqlParserFIRST)
			}

		case MySqlParserAFTER:
			{
				p.SetState(2739)
				p.Match(MySqlParserAFTER)
			}
			{
				p.SetState(2740)
				p.Uid()
			}

		case MySqlParserEOF, MySqlParserALTER, MySqlParserANALYZE, MySqlParserCALL, MySqlParserCHANGE, MySqlParserCHECK, MySqlParserCREATE, MySqlParserDELETE, MySqlParserDESC, MySqlParserDESCRIBE, MySqlParserDROP, MySqlParserEXPLAIN, MySqlParserGET, MySqlParserGRANT, MySqlParserINSERT, MySqlParserKILL, MySqlParserLOAD, MySqlParserLOCK, MySqlParserOPTIMIZE, MySqlParserPARTITION, MySqlParserPURGE, MySqlParserRELEASE, MySqlParserRENAME, MySqlParserREPLACE, MySqlParserRESIGNAL, MySqlParserREVOKE, MySqlParserSELECT, MySqlParserSET, MySqlParserSHOW, MySqlParserSIGNAL, MySqlParserUNLOCK, MySqlParserUPDATE, MySqlParserUSE, MySqlParserVALUES, MySqlParserWITH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserCACHE, MySqlParserCHECKSUM, MySqlParserCOMMIT, MySqlParserDEALLOCATE, MySqlParserDO, MySqlParserFLUSH, MySqlParserHANDLER, MySqlParserHELP, MySqlParserINSTALL, MySqlParserPREPARE, MySqlParserREPAIR, MySqlParserRESET, MySqlParserROLLBACK, MySqlParserSAVEPOINT, MySqlParserSTART, MySqlParserSTOP, MySqlParserTRUNCATE, MySqlParserUNINSTALL, MySqlParserXA, MySqlParserEXECUTE, MySqlParserSHUTDOWN, MySqlParserMINUS, MySqlParserLR_BRACKET, MySqlParserCOMMA, MySqlParserSEMI:

		default:
		}

	case 18:
		localctx = NewAlterByDropColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(2743)
			p.Match(MySqlParserDROP)
		}
		p.SetState(2745)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCOLUMN {
			{
				p.SetState(2744)
				p.Match(MySqlParserCOLUMN)
			}

		}
		{
			p.SetState(2747)
			p.Uid()
		}
		p.SetState(2749)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserRESTRICT {
			{
				p.SetState(2748)
				p.Match(MySqlParserRESTRICT)
			}

		}

	case 19:
		localctx = NewAlterByDropConstraintCheckContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(2751)
			p.Match(MySqlParserDROP)
		}
		{
			p.SetState(2752)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCHECK || _la == MySqlParserCONSTRAINT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2753)
			p.Uid()
		}

	case 20:
		localctx = NewAlterByDropPrimaryKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(2754)
			p.Match(MySqlParserDROP)
		}
		{
			p.SetState(2755)
			p.Match(MySqlParserPRIMARY)
		}
		{
			p.SetState(2756)
			p.Match(MySqlParserKEY)
		}

	case 21:
		localctx = NewAlterByDropIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(2757)
			p.Match(MySqlParserDROP)
		}
		{
			p.SetState(2758)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterByDropIndexContext).indexFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserINDEX || _la == MySqlParserKEY) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterByDropIndexContext).indexFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2759)
			p.Uid()
		}

	case 22:
		localctx = NewAlterByRenameIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(2760)
			p.Match(MySqlParserRENAME)
		}
		{
			p.SetState(2761)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterByRenameIndexContext).indexFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserINDEX || _la == MySqlParserKEY) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterByRenameIndexContext).indexFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2762)
			p.Uid()
		}
		{
			p.SetState(2763)
			p.Match(MySqlParserTO)
		}
		{
			p.SetState(2764)
			p.Uid()
		}

	case 23:
		localctx = NewAlterByAlterColumnDefaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(2766)
			p.Match(MySqlParserALTER)
		}
		p.SetState(2768)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCOLUMN {
			{
				p.SetState(2767)
				p.Match(MySqlParserCOLUMN)
			}

		}
		{
			p.SetState(2770)
			p.Uid()
		}
		p.SetState(2784)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 360, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2771)
				p.Match(MySqlParserSET)
			}
			{
				p.SetState(2772)
				p.Match(MySqlParserDEFAULT)
			}
			p.SetState(2778)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case MySqlParserSTART_NATIONAL_STRING_LITERAL, MySqlParserSTRING_LITERAL, MySqlParserSTRING_CHARSET_NAME:
				{
					p.SetState(2773)
					p.StringLiteral()
				}

			case MySqlParserLR_BRACKET:
				{
					p.SetState(2774)
					p.Match(MySqlParserLR_BRACKET)
				}
				{
					p.SetState(2775)
					p.expression(0)
				}
				{
					p.SetState(2776)
					p.Match(MySqlParserRR_BRACKET)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		case 2:
			{
				p.SetState(2780)
				p.Match(MySqlParserSET)
			}
			{
				p.SetState(2781)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserINVISIBLE || _la == MySqlParserVISIBLE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		case 3:
			{
				p.SetState(2782)
				p.Match(MySqlParserDROP)
			}
			{
				p.SetState(2783)
				p.Match(MySqlParserDEFAULT)
			}

		}

	case 24:
		localctx = NewAlterByAlterIndexVisibilityContext(p, localctx)
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(2786)
			p.Match(MySqlParserALTER)
		}
		{
			p.SetState(2787)
			p.Match(MySqlParserINDEX)
		}
		{
			p.SetState(2788)
			p.Uid()
		}
		{
			p.SetState(2789)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserINVISIBLE || _la == MySqlParserVISIBLE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 25:
		localctx = NewAlterByDropForeignKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(2791)
			p.Match(MySqlParserDROP)
		}
		{
			p.SetState(2792)
			p.Match(MySqlParserFOREIGN)
		}
		{
			p.SetState(2793)
			p.Match(MySqlParserKEY)
		}
		{
			p.SetState(2794)
			p.Uid()
		}

	case 26:
		localctx = NewAlterByDisableKeysContext(p, localctx)
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(2795)
			p.Match(MySqlParserDISABLE)
		}
		{
			p.SetState(2796)
			p.Match(MySqlParserKEYS)
		}

	case 27:
		localctx = NewAlterByEnableKeysContext(p, localctx)
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(2797)
			p.Match(MySqlParserENABLE)
		}
		{
			p.SetState(2798)
			p.Match(MySqlParserKEYS)
		}

	case 28:
		localctx = NewAlterByRenameContext(p, localctx)
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(2799)
			p.Match(MySqlParserRENAME)
		}
		p.SetState(2801)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserAS || _la == MySqlParserTO {
			{
				p.SetState(2800)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*AlterByRenameContext).renameFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserAS || _la == MySqlParserTO) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*AlterByRenameContext).renameFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(2805)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 362, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2803)
				p.Uid()
			}

		case 2:
			{
				p.SetState(2804)
				p.FullId()
			}

		}

	case 29:
		localctx = NewAlterByOrderContext(p, localctx)
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(2807)
			p.Match(MySqlParserORDER)
		}
		{
			p.SetState(2808)
			p.Match(MySqlParserBY)
		}
		{
			p.SetState(2809)
			p.UidList()
		}

	case 30:
		localctx = NewAlterByConvertCharsetContext(p, localctx)
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(2810)
			p.Match(MySqlParserCONVERT)
		}
		{
			p.SetState(2811)
			p.Match(MySqlParserTO)
		}
		p.SetState(2815)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserCHARSET:
			{
				p.SetState(2812)
				p.Match(MySqlParserCHARSET)
			}

		case MySqlParserCHARACTER:
			{
				p.SetState(2813)
				p.Match(MySqlParserCHARACTER)
			}
			{
				p.SetState(2814)
				p.Match(MySqlParserSET)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(2817)
			p.CharsetName()
		}
		p.SetState(2820)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCOLLATE {
			{
				p.SetState(2818)
				p.Match(MySqlParserCOLLATE)
			}
			{
				p.SetState(2819)
				p.CollationName()
			}

		}

	case 31:
		localctx = NewAlterByDefaultCharsetContext(p, localctx)
		p.EnterOuterAlt(localctx, 31)
		p.SetState(2823)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserDEFAULT {
			{
				p.SetState(2822)
				p.Match(MySqlParserDEFAULT)
			}

		}
		{
			p.SetState(2825)
			p.Match(MySqlParserCHARACTER)
		}
		{
			p.SetState(2826)
			p.Match(MySqlParserSET)
		}
		{
			p.SetState(2827)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}
		{
			p.SetState(2828)
			p.CharsetName()
		}
		p.SetState(2832)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCOLLATE {
			{
				p.SetState(2829)
				p.Match(MySqlParserCOLLATE)
			}
			{
				p.SetState(2830)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}
			{
				p.SetState(2831)
				p.CollationName()
			}

		}

	case 32:
		localctx = NewAlterByDiscardTablespaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(2834)
			p.Match(MySqlParserDISCARD)
		}
		{
			p.SetState(2835)
			p.Match(MySqlParserTABLESPACE)
		}

	case 33:
		localctx = NewAlterByImportTablespaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(2836)
			p.Match(MySqlParserIMPORT)
		}
		{
			p.SetState(2837)
			p.Match(MySqlParserTABLESPACE)
		}

	case 34:
		localctx = NewAlterByForceContext(p, localctx)
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(2838)
			p.Match(MySqlParserFORCE)
		}

	case 35:
		localctx = NewAlterByValidateContext(p, localctx)
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(2839)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AlterByValidateContext).validationFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserWITH || _la == MySqlParserWITHOUT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AlterByValidateContext).validationFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2840)
			p.Match(MySqlParserVALIDATION)
		}

	case 36:
		localctx = NewAlterByAddPartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(2841)
			p.Match(MySqlParserADD)
		}
		{
			p.SetState(2842)
			p.Match(MySqlParserPARTITION)
		}
		{
			p.SetState(2843)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(2844)
			p.PartitionDefinition()
		}
		p.SetState(2849)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(2845)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(2846)
				p.PartitionDefinition()
			}

			p.SetState(2851)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2852)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 37:
		localctx = NewAlterByDropPartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(2854)
			p.Match(MySqlParserDROP)
		}
		{
			p.SetState(2855)
			p.Match(MySqlParserPARTITION)
		}
		{
			p.SetState(2856)
			p.UidList()
		}

	case 38:
		localctx = NewAlterByDiscardPartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(2857)
			p.Match(MySqlParserDISCARD)
		}
		{
			p.SetState(2858)
			p.Match(MySqlParserPARTITION)
		}
		p.SetState(2861)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID, MySqlParserREVERSE_QUOTE_ID:
			{
				p.SetState(2859)
				p.UidList()
			}

		case MySqlParserALL:
			{
				p.SetState(2860)
				p.Match(MySqlParserALL)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(2863)
			p.Match(MySqlParserTABLESPACE)
		}

	case 39:
		localctx = NewAlterByImportPartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(2864)
			p.Match(MySqlParserIMPORT)
		}
		{
			p.SetState(2865)
			p.Match(MySqlParserPARTITION)
		}
		p.SetState(2868)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID, MySqlParserREVERSE_QUOTE_ID:
			{
				p.SetState(2866)
				p.UidList()
			}

		case MySqlParserALL:
			{
				p.SetState(2867)
				p.Match(MySqlParserALL)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(2870)
			p.Match(MySqlParserTABLESPACE)
		}

	case 40:
		localctx = NewAlterByTruncatePartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(2871)
			p.Match(MySqlParserTRUNCATE)
		}
		{
			p.SetState(2872)
			p.Match(MySqlParserPARTITION)
		}
		p.SetState(2875)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID, MySqlParserREVERSE_QUOTE_ID:
			{
				p.SetState(2873)
				p.UidList()
			}

		case MySqlParserALL:
			{
				p.SetState(2874)
				p.Match(MySqlParserALL)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 41:
		localctx = NewAlterByCoalescePartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(2877)
			p.Match(MySqlParserCOALESCE)
		}
		{
			p.SetState(2878)
			p.Match(MySqlParserPARTITION)
		}
		{
			p.SetState(2879)
			p.DecimalLiteral()
		}

	case 42:
		localctx = NewAlterByReorganizePartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(2880)
			p.Match(MySqlParserREORGANIZE)
		}
		{
			p.SetState(2881)
			p.Match(MySqlParserPARTITION)
		}
		{
			p.SetState(2882)
			p.UidList()
		}
		{
			p.SetState(2883)
			p.Match(MySqlParserINTO)
		}
		{
			p.SetState(2884)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(2885)
			p.PartitionDefinition()
		}
		p.SetState(2890)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(2886)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(2887)
				p.PartitionDefinition()
			}

			p.SetState(2892)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2893)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 43:
		localctx = NewAlterByExchangePartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(2895)
			p.Match(MySqlParserEXCHANGE)
		}
		{
			p.SetState(2896)
			p.Match(MySqlParserPARTITION)
		}
		{
			p.SetState(2897)
			p.Uid()
		}
		{
			p.SetState(2898)
			p.Match(MySqlParserWITH)
		}
		{
			p.SetState(2899)
			p.Match(MySqlParserTABLE)
		}
		{
			p.SetState(2900)
			p.TableName()
		}
		p.SetState(2903)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 372, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2901)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*AlterByExchangePartitionContext).validationFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserWITH || _la == MySqlParserWITHOUT) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*AlterByExchangePartitionContext).validationFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2902)
				p.Match(MySqlParserVALIDATION)
			}

		}

	case 44:
		localctx = NewAlterByAnalyzePartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(2905)
			p.Match(MySqlParserANALYZE)
		}
		{
			p.SetState(2906)
			p.Match(MySqlParserPARTITION)
		}
		p.SetState(2909)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID, MySqlParserREVERSE_QUOTE_ID:
			{
				p.SetState(2907)
				p.UidList()
			}

		case MySqlParserALL:
			{
				p.SetState(2908)
				p.Match(MySqlParserALL)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 45:
		localctx = NewAlterByCheckPartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(2911)
			p.Match(MySqlParserCHECK)
		}
		{
			p.SetState(2912)
			p.Match(MySqlParserPARTITION)
		}
		p.SetState(2915)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID, MySqlParserREVERSE_QUOTE_ID:
			{
				p.SetState(2913)
				p.UidList()
			}

		case MySqlParserALL:
			{
				p.SetState(2914)
				p.Match(MySqlParserALL)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 46:
		localctx = NewAlterByOptimizePartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(2917)
			p.Match(MySqlParserOPTIMIZE)
		}
		{
			p.SetState(2918)
			p.Match(MySqlParserPARTITION)
		}
		p.SetState(2921)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID, MySqlParserREVERSE_QUOTE_ID:
			{
				p.SetState(2919)
				p.UidList()
			}

		case MySqlParserALL:
			{
				p.SetState(2920)
				p.Match(MySqlParserALL)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 47:
		localctx = NewAlterByRebuildPartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(2923)
			p.Match(MySqlParserREBUILD)
		}
		{
			p.SetState(2924)
			p.Match(MySqlParserPARTITION)
		}
		p.SetState(2927)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID, MySqlParserREVERSE_QUOTE_ID:
			{
				p.SetState(2925)
				p.UidList()
			}

		case MySqlParserALL:
			{
				p.SetState(2926)
				p.Match(MySqlParserALL)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 48:
		localctx = NewAlterByRepairPartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(2929)
			p.Match(MySqlParserREPAIR)
		}
		{
			p.SetState(2930)
			p.Match(MySqlParserPARTITION)
		}
		p.SetState(2933)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID, MySqlParserREVERSE_QUOTE_ID:
			{
				p.SetState(2931)
				p.UidList()
			}

		case MySqlParserALL:
			{
				p.SetState(2932)
				p.Match(MySqlParserALL)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 49:
		localctx = NewAlterByRemovePartitioningContext(p, localctx)
		p.EnterOuterAlt(localctx, 49)
		{
			p.SetState(2935)
			p.Match(MySqlParserREMOVE)
		}
		{
			p.SetState(2936)
			p.Match(MySqlParserPARTITIONING)
		}

	case 50:
		localctx = NewAlterByUpgradePartitioningContext(p, localctx)
		p.EnterOuterAlt(localctx, 50)
		{
			p.SetState(2937)
			p.Match(MySqlParserUPGRADE)
		}
		{
			p.SetState(2938)
			p.Match(MySqlParserPARTITIONING)
		}

	case 51:
		localctx = NewAlterByAddDefinitionsContext(p, localctx)
		p.EnterOuterAlt(localctx, 51)
		{
			p.SetState(2939)
			p.Match(MySqlParserADD)
		}
		p.SetState(2941)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCOLUMN {
			{
				p.SetState(2940)
				p.Match(MySqlParserCOLUMN)
			}

		}
		{
			p.SetState(2943)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(2944)
			p.CreateDefinition()
		}
		p.SetState(2949)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(2945)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(2946)
				p.CreateDefinition()
			}

			p.SetState(2951)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2952)
			p.Match(MySqlParserRR_BRACKET)
		}

	}

	return localctx
}

// IDropDatabaseContext is an interface to support dynamic dispatch.
type IDropDatabaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDbFormat returns the dbFormat token.
	GetDbFormat() antlr.Token

	// SetDbFormat sets the dbFormat token.
	SetDbFormat(antlr.Token)

	// Getter signatures
	DROP() antlr.TerminalNode
	Uid() IUidContext
	DATABASE() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	IfExists() IIfExistsContext

	// IsDropDatabaseContext differentiates from other interfaces.
	IsDropDatabaseContext()
}

type DropDatabaseContext struct {
	*antlr.BaseParserRuleContext
	parser   antlr.Parser
	dbFormat antlr.Token
}

func NewEmptyDropDatabaseContext() *DropDatabaseContext {
	var p = new(DropDatabaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_dropDatabase
	return p
}

func (*DropDatabaseContext) IsDropDatabaseContext() {}

func NewDropDatabaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropDatabaseContext {
	var p = new(DropDatabaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropDatabase

	return p
}

func (s *DropDatabaseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropDatabaseContext) GetDbFormat() antlr.Token { return s.dbFormat }

func (s *DropDatabaseContext) SetDbFormat(v antlr.Token) { s.dbFormat = v }

func (s *DropDatabaseContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropDatabaseContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DropDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATABASE, 0)
}

func (s *DropDatabaseContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEMA, 0)
}

func (s *DropDatabaseContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropDatabaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropDatabase(s)
	}
}

func (s *DropDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropDatabase(s)
	}
}

func (p *MySqlParser) DropDatabase() (localctx IDropDatabaseContext) {
	this := p
	_ = this

	localctx = NewDropDatabaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, MySqlParserRULE_dropDatabase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2956)
		p.Match(MySqlParserDROP)
	}
	{
		p.SetState(2957)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*DropDatabaseContext).dbFormat = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserDATABASE || _la == MySqlParserSCHEMA) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*DropDatabaseContext).dbFormat = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(2959)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 381, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2958)
			p.IfExists()
		}

	}
	{
		p.SetState(2961)
		p.Uid()
	}

	return localctx
}

// IDropEventContext is an interface to support dynamic dispatch.
type IDropEventContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	EVENT() antlr.TerminalNode
	FullId() IFullIdContext
	IfExists() IIfExistsContext

	// IsDropEventContext differentiates from other interfaces.
	IsDropEventContext()
}

type DropEventContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropEventContext() *DropEventContext {
	var p = new(DropEventContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_dropEvent
	return p
}

func (*DropEventContext) IsDropEventContext() {}

func NewDropEventContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropEventContext {
	var p = new(DropEventContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropEvent

	return p
}

func (s *DropEventContext) GetParser() antlr.Parser { return s.parser }

func (s *DropEventContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropEventContext) EVENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVENT, 0)
}

func (s *DropEventContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *DropEventContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropEventContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropEventContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropEventContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropEvent(s)
	}
}

func (s *DropEventContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropEvent(s)
	}
}

func (p *MySqlParser) DropEvent() (localctx IDropEventContext) {
	this := p
	_ = this

	localctx = NewDropEventContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, MySqlParserRULE_dropEvent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2963)
		p.Match(MySqlParserDROP)
	}
	{
		p.SetState(2964)
		p.Match(MySqlParserEVENT)
	}
	p.SetState(2966)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 382, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2965)
			p.IfExists()
		}

	}
	{
		p.SetState(2968)
		p.FullId()
	}

	return localctx
}

// IDropIndexContext is an interface to support dynamic dispatch.
type IDropIndexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIntimeAction returns the intimeAction token.
	GetIntimeAction() antlr.Token

	// GetAlgType returns the algType token.
	GetAlgType() antlr.Token

	// GetLockType returns the lockType token.
	GetLockType() antlr.Token

	// SetIntimeAction sets the intimeAction token.
	SetIntimeAction(antlr.Token)

	// SetAlgType sets the algType token.
	SetAlgType(antlr.Token)

	// SetLockType sets the lockType token.
	SetLockType(antlr.Token)

	// Getter signatures
	DROP() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	Uid() IUidContext
	ON() antlr.TerminalNode
	TableName() ITableNameContext
	AllALGORITHM() []antlr.TerminalNode
	ALGORITHM(i int) antlr.TerminalNode
	AllLOCK() []antlr.TerminalNode
	LOCK(i int) antlr.TerminalNode
	ONLINE() antlr.TerminalNode
	OFFLINE() antlr.TerminalNode
	AllDEFAULT() []antlr.TerminalNode
	DEFAULT(i int) antlr.TerminalNode
	AllINPLACE() []antlr.TerminalNode
	INPLACE(i int) antlr.TerminalNode
	AllCOPY() []antlr.TerminalNode
	COPY(i int) antlr.TerminalNode
	AllNONE() []antlr.TerminalNode
	NONE(i int) antlr.TerminalNode
	AllSHARED() []antlr.TerminalNode
	SHARED(i int) antlr.TerminalNode
	AllEXCLUSIVE() []antlr.TerminalNode
	EXCLUSIVE(i int) antlr.TerminalNode
	AllEQUAL_SYMBOL() []antlr.TerminalNode
	EQUAL_SYMBOL(i int) antlr.TerminalNode

	// IsDropIndexContext differentiates from other interfaces.
	IsDropIndexContext()
}

type DropIndexContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	intimeAction antlr.Token
	algType      antlr.Token
	lockType     antlr.Token
}

func NewEmptyDropIndexContext() *DropIndexContext {
	var p = new(DropIndexContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_dropIndex
	return p
}

func (*DropIndexContext) IsDropIndexContext() {}

func NewDropIndexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropIndexContext {
	var p = new(DropIndexContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropIndex

	return p
}

func (s *DropIndexContext) GetParser() antlr.Parser { return s.parser }

func (s *DropIndexContext) GetIntimeAction() antlr.Token { return s.intimeAction }

func (s *DropIndexContext) GetAlgType() antlr.Token { return s.algType }

func (s *DropIndexContext) GetLockType() antlr.Token { return s.lockType }

func (s *DropIndexContext) SetIntimeAction(v antlr.Token) { s.intimeAction = v }

func (s *DropIndexContext) SetAlgType(v antlr.Token) { s.algType = v }

func (s *DropIndexContext) SetLockType(v antlr.Token) { s.lockType = v }

func (s *DropIndexContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *DropIndexContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DropIndexContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *DropIndexContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *DropIndexContext) AllALGORITHM() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserALGORITHM)
}

func (s *DropIndexContext) ALGORITHM(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserALGORITHM, i)
}

func (s *DropIndexContext) AllLOCK() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLOCK)
}

func (s *DropIndexContext) LOCK(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCK, i)
}

func (s *DropIndexContext) ONLINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserONLINE, 0)
}

func (s *DropIndexContext) OFFLINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserOFFLINE, 0)
}

func (s *DropIndexContext) AllDEFAULT() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserDEFAULT)
}

func (s *DropIndexContext) DEFAULT(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, i)
}

func (s *DropIndexContext) AllINPLACE() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserINPLACE)
}

func (s *DropIndexContext) INPLACE(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserINPLACE, i)
}

func (s *DropIndexContext) AllCOPY() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOPY)
}

func (s *DropIndexContext) COPY(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOPY, i)
}

func (s *DropIndexContext) AllNONE() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserNONE)
}

func (s *DropIndexContext) NONE(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserNONE, i)
}

func (s *DropIndexContext) AllSHARED() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSHARED)
}

func (s *DropIndexContext) SHARED(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSHARED, i)
}

func (s *DropIndexContext) AllEXCLUSIVE() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEXCLUSIVE)
}

func (s *DropIndexContext) EXCLUSIVE(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCLUSIVE, i)
}

func (s *DropIndexContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *DropIndexContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *DropIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropIndexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropIndex(s)
	}
}

func (s *DropIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropIndex(s)
	}
}

func (p *MySqlParser) DropIndex() (localctx IDropIndexContext) {
	this := p
	_ = this

	localctx = NewDropIndexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, MySqlParserRULE_dropIndex)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2970)
		p.Match(MySqlParserDROP)
	}
	{
		p.SetState(2971)
		p.Match(MySqlParserINDEX)
	}
	p.SetState(2973)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 383, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2972)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DropIndexContext).intimeAction = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserOFFLINE || _la == MySqlParserONLINE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DropIndexContext).intimeAction = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(2975)
		p.Uid()
	}
	{
		p.SetState(2976)
		p.Match(MySqlParserON)
	}
	{
		p.SetState(2977)
		p.TableName()
	}
	p.SetState(2990)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 387, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2988)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case MySqlParserALGORITHM:
				{
					p.SetState(2978)
					p.Match(MySqlParserALGORITHM)
				}
				p.SetState(2980)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == MySqlParserEQUAL_SYMBOL {
					{
						p.SetState(2979)
						p.Match(MySqlParserEQUAL_SYMBOL)
					}

				}
				{
					p.SetState(2982)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*DropIndexContext).algType = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserDEFAULT || _la == MySqlParserCOPY || _la == MySqlParserINPLACE) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*DropIndexContext).algType = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			case MySqlParserLOCK:
				{
					p.SetState(2983)
					p.Match(MySqlParserLOCK)
				}
				p.SetState(2985)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == MySqlParserEQUAL_SYMBOL {
					{
						p.SetState(2984)
						p.Match(MySqlParserEQUAL_SYMBOL)
					}

				}
				{
					p.SetState(2987)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*DropIndexContext).lockType = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserDEFAULT || _la == MySqlParserEXCLUSIVE || _la == MySqlParserNONE || _la == MySqlParserSHARED) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*DropIndexContext).lockType = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(2992)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 387, p.GetParserRuleContext())
	}

	return localctx
}

// IDropLogfileGroupContext is an interface to support dynamic dispatch.
type IDropLogfileGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	LOGFILE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	Uid() IUidContext
	ENGINE() antlr.TerminalNode
	EQUAL_SYMBOL() antlr.TerminalNode
	EngineName() IEngineNameContext

	// IsDropLogfileGroupContext differentiates from other interfaces.
	IsDropLogfileGroupContext()
}

type DropLogfileGroupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropLogfileGroupContext() *DropLogfileGroupContext {
	var p = new(DropLogfileGroupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_dropLogfileGroup
	return p
}

func (*DropLogfileGroupContext) IsDropLogfileGroupContext() {}

func NewDropLogfileGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropLogfileGroupContext {
	var p = new(DropLogfileGroupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropLogfileGroup

	return p
}

func (s *DropLogfileGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *DropLogfileGroupContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropLogfileGroupContext) LOGFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOGFILE, 0)
}

func (s *DropLogfileGroupContext) GROUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP, 0)
}

func (s *DropLogfileGroupContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DropLogfileGroupContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE, 0)
}

func (s *DropLogfileGroupContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *DropLogfileGroupContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *DropLogfileGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropLogfileGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropLogfileGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropLogfileGroup(s)
	}
}

func (s *DropLogfileGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropLogfileGroup(s)
	}
}

func (p *MySqlParser) DropLogfileGroup() (localctx IDropLogfileGroupContext) {
	this := p
	_ = this

	localctx = NewDropLogfileGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, MySqlParserRULE_dropLogfileGroup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2993)
		p.Match(MySqlParserDROP)
	}
	{
		p.SetState(2994)
		p.Match(MySqlParserLOGFILE)
	}
	{
		p.SetState(2995)
		p.Match(MySqlParserGROUP)
	}
	{
		p.SetState(2996)
		p.Uid()
	}
	{
		p.SetState(2997)
		p.Match(MySqlParserENGINE)
	}
	{
		p.SetState(2998)
		p.Match(MySqlParserEQUAL_SYMBOL)
	}
	{
		p.SetState(2999)
		p.EngineName()
	}

	return localctx
}

// IDropProcedureContext is an interface to support dynamic dispatch.
type IDropProcedureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	PROCEDURE() antlr.TerminalNode
	FullId() IFullIdContext
	IfExists() IIfExistsContext

	// IsDropProcedureContext differentiates from other interfaces.
	IsDropProcedureContext()
}

type DropProcedureContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropProcedureContext() *DropProcedureContext {
	var p = new(DropProcedureContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_dropProcedure
	return p
}

func (*DropProcedureContext) IsDropProcedureContext() {}

func NewDropProcedureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropProcedureContext {
	var p = new(DropProcedureContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropProcedure

	return p
}

func (s *DropProcedureContext) GetParser() antlr.Parser { return s.parser }

func (s *DropProcedureContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropProcedureContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROCEDURE, 0)
}

func (s *DropProcedureContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *DropProcedureContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropProcedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropProcedureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropProcedureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropProcedure(s)
	}
}

func (s *DropProcedureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropProcedure(s)
	}
}

func (p *MySqlParser) DropProcedure() (localctx IDropProcedureContext) {
	this := p
	_ = this

	localctx = NewDropProcedureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, MySqlParserRULE_dropProcedure)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3001)
		p.Match(MySqlParserDROP)
	}
	{
		p.SetState(3002)
		p.Match(MySqlParserPROCEDURE)
	}
	p.SetState(3004)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 388, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3003)
			p.IfExists()
		}

	}
	{
		p.SetState(3006)
		p.FullId()
	}

	return localctx
}

// IDropFunctionContext is an interface to support dynamic dispatch.
type IDropFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	FullId() IFullIdContext
	IfExists() IIfExistsContext

	// IsDropFunctionContext differentiates from other interfaces.
	IsDropFunctionContext()
}

type DropFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropFunctionContext() *DropFunctionContext {
	var p = new(DropFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_dropFunction
	return p
}

func (*DropFunctionContext) IsDropFunctionContext() {}

func NewDropFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropFunctionContext {
	var p = new(DropFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropFunction

	return p
}

func (s *DropFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *DropFunctionContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserFUNCTION, 0)
}

func (s *DropFunctionContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *DropFunctionContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropFunction(s)
	}
}

func (s *DropFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropFunction(s)
	}
}

func (p *MySqlParser) DropFunction() (localctx IDropFunctionContext) {
	this := p
	_ = this

	localctx = NewDropFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, MySqlParserRULE_dropFunction)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3008)
		p.Match(MySqlParserDROP)
	}
	{
		p.SetState(3009)
		p.Match(MySqlParserFUNCTION)
	}
	p.SetState(3011)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 389, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3010)
			p.IfExists()
		}

	}
	{
		p.SetState(3013)
		p.FullId()
	}

	return localctx
}

// IDropServerContext is an interface to support dynamic dispatch.
type IDropServerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	SERVER() antlr.TerminalNode
	Uid() IUidContext
	IfExists() IIfExistsContext

	// IsDropServerContext differentiates from other interfaces.
	IsDropServerContext()
}

type DropServerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropServerContext() *DropServerContext {
	var p = new(DropServerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_dropServer
	return p
}

func (*DropServerContext) IsDropServerContext() {}

func NewDropServerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropServerContext {
	var p = new(DropServerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropServer

	return p
}

func (s *DropServerContext) GetParser() antlr.Parser { return s.parser }

func (s *DropServerContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropServerContext) SERVER() antlr.TerminalNode {
	return s.GetToken(MySqlParserSERVER, 0)
}

func (s *DropServerContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DropServerContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropServerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropServerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropServerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropServer(s)
	}
}

func (s *DropServerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropServer(s)
	}
}

func (p *MySqlParser) DropServer() (localctx IDropServerContext) {
	this := p
	_ = this

	localctx = NewDropServerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, MySqlParserRULE_dropServer)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3015)
		p.Match(MySqlParserDROP)
	}
	{
		p.SetState(3016)
		p.Match(MySqlParserSERVER)
	}
	p.SetState(3018)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 390, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3017)
			p.IfExists()
		}

	}
	{
		p.SetState(3020)
		p.Uid()
	}

	return localctx
}

// IDropTableContext is an interface to support dynamic dispatch.
type IDropTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDropType returns the dropType token.
	GetDropType() antlr.Token

	// SetDropType sets the dropType token.
	SetDropType(antlr.Token)

	// Getter signatures
	DROP() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	Tables() ITablesContext
	TEMPORARY() antlr.TerminalNode
	IfExists() IIfExistsContext
	RESTRICT() antlr.TerminalNode
	CASCADE() antlr.TerminalNode

	// IsDropTableContext differentiates from other interfaces.
	IsDropTableContext()
}

type DropTableContext struct {
	*antlr.BaseParserRuleContext
	parser   antlr.Parser
	dropType antlr.Token
}

func NewEmptyDropTableContext() *DropTableContext {
	var p = new(DropTableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_dropTable
	return p
}

func (*DropTableContext) IsDropTableContext() {}

func NewDropTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTableContext {
	var p = new(DropTableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropTable

	return p
}

func (s *DropTableContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTableContext) GetDropType() antlr.Token { return s.dropType }

func (s *DropTableContext) SetDropType(v antlr.Token) { s.dropType = v }

func (s *DropTableContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *DropTableContext) Tables() ITablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *DropTableContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserTEMPORARY, 0)
}

func (s *DropTableContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropTableContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESTRICT, 0)
}

func (s *DropTableContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCASCADE, 0)
}

func (s *DropTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropTable(s)
	}
}

func (s *DropTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropTable(s)
	}
}

func (p *MySqlParser) DropTable() (localctx IDropTableContext) {
	this := p
	_ = this

	localctx = NewDropTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, MySqlParserRULE_dropTable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3022)
		p.Match(MySqlParserDROP)
	}
	p.SetState(3024)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserTEMPORARY {
		{
			p.SetState(3023)
			p.Match(MySqlParserTEMPORARY)
		}

	}
	{
		p.SetState(3026)
		p.Match(MySqlParserTABLE)
	}
	p.SetState(3028)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 392, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3027)
			p.IfExists()
		}

	}
	{
		p.SetState(3030)
		p.Tables()
	}
	p.SetState(3032)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserCASCADE || _la == MySqlParserRESTRICT {
		{
			p.SetState(3031)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DropTableContext).dropType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCASCADE || _la == MySqlParserRESTRICT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DropTableContext).dropType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IDropTablespaceContext is an interface to support dynamic dispatch.
type IDropTablespaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	TABLESPACE() antlr.TerminalNode
	Uid() IUidContext
	ENGINE() antlr.TerminalNode
	EngineName() IEngineNameContext
	EQUAL_SYMBOL() antlr.TerminalNode

	// IsDropTablespaceContext differentiates from other interfaces.
	IsDropTablespaceContext()
}

type DropTablespaceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropTablespaceContext() *DropTablespaceContext {
	var p = new(DropTablespaceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_dropTablespace
	return p
}

func (*DropTablespaceContext) IsDropTablespaceContext() {}

func NewDropTablespaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTablespaceContext {
	var p = new(DropTablespaceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropTablespace

	return p
}

func (s *DropTablespaceContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTablespaceContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropTablespaceContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLESPACE, 0)
}

func (s *DropTablespaceContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DropTablespaceContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE, 0)
}

func (s *DropTablespaceContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *DropTablespaceContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *DropTablespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTablespaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTablespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropTablespace(s)
	}
}

func (s *DropTablespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropTablespace(s)
	}
}

func (p *MySqlParser) DropTablespace() (localctx IDropTablespaceContext) {
	this := p
	_ = this

	localctx = NewDropTablespaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, MySqlParserRULE_dropTablespace)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3034)
		p.Match(MySqlParserDROP)
	}
	{
		p.SetState(3035)
		p.Match(MySqlParserTABLESPACE)
	}
	{
		p.SetState(3036)
		p.Uid()
	}
	p.SetState(3042)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserENGINE {
		{
			p.SetState(3037)
			p.Match(MySqlParserENGINE)
		}
		p.SetState(3039)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEQUAL_SYMBOL {
			{
				p.SetState(3038)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}

		}
		{
			p.SetState(3041)
			p.EngineName()
		}

	}

	return localctx
}

// IDropTriggerContext is an interface to support dynamic dispatch.
type IDropTriggerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	TRIGGER() antlr.TerminalNode
	FullId() IFullIdContext
	IfExists() IIfExistsContext

	// IsDropTriggerContext differentiates from other interfaces.
	IsDropTriggerContext()
}

type DropTriggerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropTriggerContext() *DropTriggerContext {
	var p = new(DropTriggerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_dropTrigger
	return p
}

func (*DropTriggerContext) IsDropTriggerContext() {}

func NewDropTriggerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTriggerContext {
	var p = new(DropTriggerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropTrigger

	return p
}

func (s *DropTriggerContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTriggerContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropTriggerContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRIGGER, 0)
}

func (s *DropTriggerContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *DropTriggerContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropTriggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTriggerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTriggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropTrigger(s)
	}
}

func (s *DropTriggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropTrigger(s)
	}
}

func (p *MySqlParser) DropTrigger() (localctx IDropTriggerContext) {
	this := p
	_ = this

	localctx = NewDropTriggerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, MySqlParserRULE_dropTrigger)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3044)
		p.Match(MySqlParserDROP)
	}
	{
		p.SetState(3045)
		p.Match(MySqlParserTRIGGER)
	}
	p.SetState(3047)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 396, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3046)
			p.IfExists()
		}

	}
	{
		p.SetState(3049)
		p.FullId()
	}

	return localctx
}

// IDropViewContext is an interface to support dynamic dispatch.
type IDropViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDropType returns the dropType token.
	GetDropType() antlr.Token

	// SetDropType sets the dropType token.
	SetDropType(antlr.Token)

	// Getter signatures
	DROP() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	AllFullId() []IFullIdContext
	FullId(i int) IFullIdContext
	IfExists() IIfExistsContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	RESTRICT() antlr.TerminalNode
	CASCADE() antlr.TerminalNode

	// IsDropViewContext differentiates from other interfaces.
	IsDropViewContext()
}

type DropViewContext struct {
	*antlr.BaseParserRuleContext
	parser   antlr.Parser
	dropType antlr.Token
}

func NewEmptyDropViewContext() *DropViewContext {
	var p = new(DropViewContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_dropView
	return p
}

func (*DropViewContext) IsDropViewContext() {}

func NewDropViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropViewContext {
	var p = new(DropViewContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropView

	return p
}

func (s *DropViewContext) GetParser() antlr.Parser { return s.parser }

func (s *DropViewContext) GetDropType() antlr.Token { return s.dropType }

func (s *DropViewContext) SetDropType(v antlr.Token) { s.dropType = v }

func (s *DropViewContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(MySqlParserVIEW, 0)
}

func (s *DropViewContext) AllFullId() []IFullIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFullIdContext); ok {
			len++
		}
	}

	tst := make([]IFullIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFullIdContext); ok {
			tst[i] = t.(IFullIdContext)
			i++
		}
	}

	return tst
}

func (s *DropViewContext) FullId(i int) IFullIdContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *DropViewContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropViewContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *DropViewContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *DropViewContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESTRICT, 0)
}

func (s *DropViewContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCASCADE, 0)
}

func (s *DropViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropView(s)
	}
}

func (s *DropViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropView(s)
	}
}

func (p *MySqlParser) DropView() (localctx IDropViewContext) {
	this := p
	_ = this

	localctx = NewDropViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, MySqlParserRULE_dropView)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3051)
		p.Match(MySqlParserDROP)
	}
	{
		p.SetState(3052)
		p.Match(MySqlParserVIEW)
	}
	p.SetState(3054)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 397, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3053)
			p.IfExists()
		}

	}
	{
		p.SetState(3056)
		p.FullId()
	}
	p.SetState(3061)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(3057)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(3058)
			p.FullId()
		}

		p.SetState(3063)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3065)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserCASCADE || _la == MySqlParserRESTRICT {
		{
			p.SetState(3064)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DropViewContext).dropType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCASCADE || _la == MySqlParserRESTRICT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DropViewContext).dropType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IDropRoleContext is an interface to support dynamic dispatch.
type IDropRoleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	AllRoleName() []IRoleNameContext
	RoleName(i int) IRoleNameContext
	IfExists() IIfExistsContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDropRoleContext differentiates from other interfaces.
	IsDropRoleContext()
}

type DropRoleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropRoleContext() *DropRoleContext {
	var p = new(DropRoleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_dropRole
	return p
}

func (*DropRoleContext) IsDropRoleContext() {}

func NewDropRoleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropRoleContext {
	var p = new(DropRoleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropRole

	return p
}

func (s *DropRoleContext) GetParser() antlr.Parser { return s.parser }

func (s *DropRoleContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLE, 0)
}

func (s *DropRoleContext) AllRoleName() []IRoleNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoleNameContext); ok {
			len++
		}
	}

	tst := make([]IRoleNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoleNameContext); ok {
			tst[i] = t.(IRoleNameContext)
			i++
		}
	}

	return tst
}

func (s *DropRoleContext) RoleName(i int) IRoleNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleNameContext)
}

func (s *DropRoleContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropRoleContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *DropRoleContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *DropRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRoleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropRole(s)
	}
}

func (s *DropRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropRole(s)
	}
}

func (p *MySqlParser) DropRole() (localctx IDropRoleContext) {
	this := p
	_ = this

	localctx = NewDropRoleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, MySqlParserRULE_dropRole)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3067)
		p.Match(MySqlParserDROP)
	}
	{
		p.SetState(3068)
		p.Match(MySqlParserROLE)
	}
	p.SetState(3070)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 400, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3069)
			p.IfExists()
		}

	}
	{
		p.SetState(3072)
		p.RoleName()
	}
	p.SetState(3077)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(3073)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(3074)
			p.RoleName()
		}

		p.SetState(3079)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISetRoleContext is an interface to support dynamic dispatch.
type ISetRoleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	TO() antlr.TerminalNode
	NONE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	AllRoleName() []IRoleNameContext
	RoleName(i int) IRoleNameContext
	AllUserName() []IUserNameContext
	UserName(i int) IUserNameContext
	AllUid() []IUidContext
	Uid(i int) IUidContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	RoleOption() IRoleOptionContext

	// IsSetRoleContext differentiates from other interfaces.
	IsSetRoleContext()
}

type SetRoleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetRoleContext() *SetRoleContext {
	var p = new(SetRoleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_setRole
	return p
}

func (*SetRoleContext) IsSetRoleContext() {}

func NewSetRoleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetRoleContext {
	var p = new(SetRoleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_setRole

	return p
}

func (s *SetRoleContext) GetParser() antlr.Parser { return s.parser }

func (s *SetRoleContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *SetRoleContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *SetRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLE, 0)
}

func (s *SetRoleContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *SetRoleContext) NONE() antlr.TerminalNode {
	return s.GetToken(MySqlParserNONE, 0)
}

func (s *SetRoleContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *SetRoleContext) AllRoleName() []IRoleNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoleNameContext); ok {
			len++
		}
	}

	tst := make([]IRoleNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoleNameContext); ok {
			tst[i] = t.(IRoleNameContext)
			i++
		}
	}

	return tst
}

func (s *SetRoleContext) RoleName(i int) IRoleNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleNameContext)
}

func (s *SetRoleContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *SetRoleContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *SetRoleContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *SetRoleContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SetRoleContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *SetRoleContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *SetRoleContext) RoleOption() IRoleOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleOptionContext)
}

func (s *SetRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetRoleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSetRole(s)
	}
}

func (s *SetRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSetRole(s)
	}
}

func (p *MySqlParser) SetRole() (localctx ISetRoleContext) {
	this := p
	_ = this

	localctx = NewSetRoleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, MySqlParserRULE_setRole)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3113)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 407, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3080)
			p.Match(MySqlParserSET)
		}
		{
			p.SetState(3081)
			p.Match(MySqlParserDEFAULT)
		}
		{
			p.SetState(3082)
			p.Match(MySqlParserROLE)
		}
		p.SetState(3093)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 403, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3083)
				p.Match(MySqlParserNONE)
			}

		case 2:
			{
				p.SetState(3084)
				p.Match(MySqlParserALL)
			}

		case 3:
			{
				p.SetState(3085)
				p.RoleName()
			}
			p.SetState(3090)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == MySqlParserCOMMA {
				{
					p.SetState(3086)
					p.Match(MySqlParserCOMMA)
				}
				{
					p.SetState(3087)
					p.RoleName()
				}

				p.SetState(3092)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(3095)
			p.Match(MySqlParserTO)
		}
		p.SetState(3098)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 404, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3096)
				p.UserName()
			}

		case 2:
			{
				p.SetState(3097)
				p.Uid()
			}

		}
		p.SetState(3107)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(3100)
				p.Match(MySqlParserCOMMA)
			}
			p.SetState(3103)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 405, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(3101)
					p.UserName()
				}

			case 2:
				{
					p.SetState(3102)
					p.Uid()
				}

			}

			p.SetState(3109)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3110)
			p.Match(MySqlParserSET)
		}
		{
			p.SetState(3111)
			p.Match(MySqlParserROLE)
		}
		{
			p.SetState(3112)
			p.RoleOption()
		}

	}

	return localctx
}

// IRenameTableContext is an interface to support dynamic dispatch.
type IRenameTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RENAME() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	AllRenameTableClause() []IRenameTableClauseContext
	RenameTableClause(i int) IRenameTableClauseContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRenameTableContext differentiates from other interfaces.
	IsRenameTableContext()
}

type RenameTableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRenameTableContext() *RenameTableContext {
	var p = new(RenameTableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_renameTable
	return p
}

func (*RenameTableContext) IsRenameTableContext() {}

func NewRenameTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RenameTableContext {
	var p = new(RenameTableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_renameTable

	return p
}

func (s *RenameTableContext) GetParser() antlr.Parser { return s.parser }

func (s *RenameTableContext) RENAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserRENAME, 0)
}

func (s *RenameTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *RenameTableContext) AllRenameTableClause() []IRenameTableClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRenameTableClauseContext); ok {
			len++
		}
	}

	tst := make([]IRenameTableClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRenameTableClauseContext); ok {
			tst[i] = t.(IRenameTableClauseContext)
			i++
		}
	}

	return tst
}

func (s *RenameTableContext) RenameTableClause(i int) IRenameTableClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRenameTableClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRenameTableClauseContext)
}

func (s *RenameTableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *RenameTableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *RenameTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RenameTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRenameTable(s)
	}
}

func (s *RenameTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRenameTable(s)
	}
}

func (p *MySqlParser) RenameTable() (localctx IRenameTableContext) {
	this := p
	_ = this

	localctx = NewRenameTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, MySqlParserRULE_renameTable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3115)
		p.Match(MySqlParserRENAME)
	}
	{
		p.SetState(3116)
		p.Match(MySqlParserTABLE)
	}
	{
		p.SetState(3117)
		p.RenameTableClause()
	}
	p.SetState(3122)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(3118)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(3119)
			p.RenameTableClause()
		}

		p.SetState(3124)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IRenameTableClauseContext is an interface to support dynamic dispatch.
type IRenameTableClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTableName() []ITableNameContext
	TableName(i int) ITableNameContext
	TO() antlr.TerminalNode

	// IsRenameTableClauseContext differentiates from other interfaces.
	IsRenameTableClauseContext()
}

type RenameTableClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRenameTableClauseContext() *RenameTableClauseContext {
	var p = new(RenameTableClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_renameTableClause
	return p
}

func (*RenameTableClauseContext) IsRenameTableClauseContext() {}

func NewRenameTableClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RenameTableClauseContext {
	var p = new(RenameTableClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_renameTableClause

	return p
}

func (s *RenameTableClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RenameTableClauseContext) AllTableName() []ITableNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableNameContext); ok {
			len++
		}
	}

	tst := make([]ITableNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableNameContext); ok {
			tst[i] = t.(ITableNameContext)
			i++
		}
	}

	return tst
}

func (s *RenameTableClauseContext) TableName(i int) ITableNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *RenameTableClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *RenameTableClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameTableClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RenameTableClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRenameTableClause(s)
	}
}

func (s *RenameTableClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRenameTableClause(s)
	}
}

func (p *MySqlParser) RenameTableClause() (localctx IRenameTableClauseContext) {
	this := p
	_ = this

	localctx = NewRenameTableClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, MySqlParserRULE_renameTableClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3125)
		p.TableName()
	}
	{
		p.SetState(3126)
		p.Match(MySqlParserTO)
	}
	{
		p.SetState(3127)
		p.TableName()
	}

	return localctx
}

// ITruncateTableContext is an interface to support dynamic dispatch.
type ITruncateTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUNCATE() antlr.TerminalNode
	TableName() ITableNameContext
	TABLE() antlr.TerminalNode

	// IsTruncateTableContext differentiates from other interfaces.
	IsTruncateTableContext()
}

type TruncateTableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTruncateTableContext() *TruncateTableContext {
	var p = new(TruncateTableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_truncateTable
	return p
}

func (*TruncateTableContext) IsTruncateTableContext() {}

func NewTruncateTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TruncateTableContext {
	var p = new(TruncateTableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_truncateTable

	return p
}

func (s *TruncateTableContext) GetParser() antlr.Parser { return s.parser }

func (s *TruncateTableContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRUNCATE, 0)
}

func (s *TruncateTableContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TruncateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *TruncateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TruncateTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TruncateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTruncateTable(s)
	}
}

func (s *TruncateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTruncateTable(s)
	}
}

func (p *MySqlParser) TruncateTable() (localctx ITruncateTableContext) {
	this := p
	_ = this

	localctx = NewTruncateTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, MySqlParserRULE_truncateTable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3129)
		p.Match(MySqlParserTRUNCATE)
	}
	p.SetState(3131)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserTABLE {
		{
			p.SetState(3130)
			p.Match(MySqlParserTABLE)
		}

	}
	{
		p.SetState(3133)
		p.TableName()
	}

	return localctx
}

// ICallStatementContext is an interface to support dynamic dispatch.
type ICallStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CALL() antlr.TerminalNode
	FullId() IFullIdContext
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	Constants() IConstantsContext
	Expressions() IExpressionsContext

	// IsCallStatementContext differentiates from other interfaces.
	IsCallStatementContext()
}

type CallStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallStatementContext() *CallStatementContext {
	var p = new(CallStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_callStatement
	return p
}

func (*CallStatementContext) IsCallStatementContext() {}

func NewCallStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallStatementContext {
	var p = new(CallStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_callStatement

	return p
}

func (s *CallStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CallStatementContext) CALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserCALL, 0)
}

func (s *CallStatementContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *CallStatementContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CallStatementContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CallStatementContext) Constants() IConstantsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantsContext)
}

func (s *CallStatementContext) Expressions() IExpressionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *CallStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCallStatement(s)
	}
}

func (s *CallStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCallStatement(s)
	}
}

func (p *MySqlParser) CallStatement() (localctx ICallStatementContext) {
	this := p
	_ = this

	localctx = NewCallStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, MySqlParserRULE_callStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3135)
		p.Match(MySqlParserCALL)
	}
	{
		p.SetState(3136)
		p.FullId()
	}
	p.SetState(3143)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 411, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3137)
			p.Match(MySqlParserLR_BRACKET)
		}
		p.SetState(3140)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 410, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3138)
				p.Constants()
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 410, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(3139)
				p.Expressions()
			}

		}
		{
			p.SetState(3142)
			p.Match(MySqlParserRR_BRACKET)
		}

	}

	return localctx
}

// IDeleteStatementContext is an interface to support dynamic dispatch.
type IDeleteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleDeleteStatement() ISingleDeleteStatementContext
	MultipleDeleteStatement() IMultipleDeleteStatementContext

	// IsDeleteStatementContext differentiates from other interfaces.
	IsDeleteStatementContext()
}

type DeleteStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeleteStatementContext() *DeleteStatementContext {
	var p = new(DeleteStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_deleteStatement
	return p
}

func (*DeleteStatementContext) IsDeleteStatementContext() {}

func NewDeleteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteStatementContext {
	var p = new(DeleteStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_deleteStatement

	return p
}

func (s *DeleteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteStatementContext) SingleDeleteStatement() ISingleDeleteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleDeleteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleDeleteStatementContext)
}

func (s *DeleteStatementContext) MultipleDeleteStatement() IMultipleDeleteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipleDeleteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipleDeleteStatementContext)
}

func (s *DeleteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeleteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDeleteStatement(s)
	}
}

func (s *DeleteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDeleteStatement(s)
	}
}

func (p *MySqlParser) DeleteStatement() (localctx IDeleteStatementContext) {
	this := p
	_ = this

	localctx = NewDeleteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, MySqlParserRULE_deleteStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3147)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 412, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3145)
			p.SingleDeleteStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3146)
			p.MultipleDeleteStatement()
		}

	}

	return localctx
}

// IDoStatementContext is an interface to support dynamic dispatch.
type IDoStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DO() antlr.TerminalNode
	Expressions() IExpressionsContext

	// IsDoStatementContext differentiates from other interfaces.
	IsDoStatementContext()
}

type DoStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoStatementContext() *DoStatementContext {
	var p = new(DoStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_doStatement
	return p
}

func (*DoStatementContext) IsDoStatementContext() {}

func NewDoStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoStatementContext {
	var p = new(DoStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_doStatement

	return p
}

func (s *DoStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DoStatementContext) DO() antlr.TerminalNode {
	return s.GetToken(MySqlParserDO, 0)
}

func (s *DoStatementContext) Expressions() IExpressionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *DoStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DoStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDoStatement(s)
	}
}

func (s *DoStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDoStatement(s)
	}
}

func (p *MySqlParser) DoStatement() (localctx IDoStatementContext) {
	this := p
	_ = this

	localctx = NewDoStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, MySqlParserRULE_doStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3149)
		p.Match(MySqlParserDO)
	}
	{
		p.SetState(3150)
		p.Expressions()
	}

	return localctx
}

// IHandlerStatementContext is an interface to support dynamic dispatch.
type IHandlerStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HandlerOpenStatement() IHandlerOpenStatementContext
	HandlerReadIndexStatement() IHandlerReadIndexStatementContext
	HandlerReadStatement() IHandlerReadStatementContext
	HandlerCloseStatement() IHandlerCloseStatementContext

	// IsHandlerStatementContext differentiates from other interfaces.
	IsHandlerStatementContext()
}

type HandlerStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHandlerStatementContext() *HandlerStatementContext {
	var p = new(HandlerStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_handlerStatement
	return p
}

func (*HandlerStatementContext) IsHandlerStatementContext() {}

func NewHandlerStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HandlerStatementContext {
	var p = new(HandlerStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_handlerStatement

	return p
}

func (s *HandlerStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HandlerStatementContext) HandlerOpenStatement() IHandlerOpenStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHandlerOpenStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHandlerOpenStatementContext)
}

func (s *HandlerStatementContext) HandlerReadIndexStatement() IHandlerReadIndexStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHandlerReadIndexStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHandlerReadIndexStatementContext)
}

func (s *HandlerStatementContext) HandlerReadStatement() IHandlerReadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHandlerReadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHandlerReadStatementContext)
}

func (s *HandlerStatementContext) HandlerCloseStatement() IHandlerCloseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHandlerCloseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHandlerCloseStatementContext)
}

func (s *HandlerStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HandlerStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHandlerStatement(s)
	}
}

func (s *HandlerStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHandlerStatement(s)
	}
}

func (p *MySqlParser) HandlerStatement() (localctx IHandlerStatementContext) {
	this := p
	_ = this

	localctx = NewHandlerStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, MySqlParserRULE_handlerStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3156)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 413, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3152)
			p.HandlerOpenStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3153)
			p.HandlerReadIndexStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3154)
			p.HandlerReadStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3155)
			p.HandlerCloseStatement()
		}

	}

	return localctx
}

// IInsertStatementContext is an interface to support dynamic dispatch.
type IInsertStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPriority returns the priority token.
	GetPriority() antlr.Token

	// SetPriority sets the priority token.
	SetPriority(antlr.Token)

	// GetPartitions returns the partitions rule contexts.
	GetPartitions() IUidListContext

	// GetColumns returns the columns rule contexts.
	GetColumns() IFullColumnNameListContext

	// GetSetFirst returns the setFirst rule contexts.
	GetSetFirst() IUpdatedElementContext

	// Get_updatedElement returns the _updatedElement rule contexts.
	Get_updatedElement() IUpdatedElementContext

	// GetTableAlias returns the tableAlias rule contexts.
	GetTableAlias() IUidContext

	// GetColAlias returns the colAlias rule contexts.
	GetColAlias() IUidContext

	// GetDuplicatedFirst returns the duplicatedFirst rule contexts.
	GetDuplicatedFirst() IUpdatedElementContext

	// SetPartitions sets the partitions rule contexts.
	SetPartitions(IUidListContext)

	// SetColumns sets the columns rule contexts.
	SetColumns(IFullColumnNameListContext)

	// SetSetFirst sets the setFirst rule contexts.
	SetSetFirst(IUpdatedElementContext)

	// Set_updatedElement sets the _updatedElement rule contexts.
	Set_updatedElement(IUpdatedElementContext)

	// SetTableAlias sets the tableAlias rule contexts.
	SetTableAlias(IUidContext)

	// SetColAlias sets the colAlias rule contexts.
	SetColAlias(IUidContext)

	// SetDuplicatedFirst sets the duplicatedFirst rule contexts.
	SetDuplicatedFirst(IUpdatedElementContext)

	// GetSetElements returns the setElements rule context list.
	GetSetElements() []IUpdatedElementContext

	// GetDuplicatedElements returns the duplicatedElements rule context list.
	GetDuplicatedElements() []IUpdatedElementContext

	// SetSetElements sets the setElements rule context list.
	SetSetElements([]IUpdatedElementContext)

	// SetDuplicatedElements sets the duplicatedElements rule context list.
	SetDuplicatedElements([]IUpdatedElementContext)

	// Getter signatures
	INSERT() antlr.TerminalNode
	TableName() ITableNameContext
	InsertStatementValue() IInsertStatementValueContext
	SET() antlr.TerminalNode
	IGNORE() antlr.TerminalNode
	INTO() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	AllUpdatedElement() []IUpdatedElementContext
	UpdatedElement(i int) IUpdatedElementContext
	AS() antlr.TerminalNode
	ON() antlr.TerminalNode
	DUPLICATE() antlr.TerminalNode
	KEY() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	AllUid() []IUidContext
	Uid(i int) IUidContext
	LOW_PRIORITY() antlr.TerminalNode
	DELAYED() antlr.TerminalNode
	HIGH_PRIORITY() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	FullColumnNameList() IFullColumnNameListContext
	UidList() IUidListContext

	// IsInsertStatementContext differentiates from other interfaces.
	IsInsertStatementContext()
}

type InsertStatementContext struct {
	*antlr.BaseParserRuleContext
	parser             antlr.Parser
	priority           antlr.Token
	partitions         IUidListContext
	columns            IFullColumnNameListContext
	setFirst           IUpdatedElementContext
	_updatedElement    IUpdatedElementContext
	setElements        []IUpdatedElementContext
	tableAlias         IUidContext
	colAlias           IUidContext
	duplicatedFirst    IUpdatedElementContext
	duplicatedElements []IUpdatedElementContext
}

func NewEmptyInsertStatementContext() *InsertStatementContext {
	var p = new(InsertStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_insertStatement
	return p
}

func (*InsertStatementContext) IsInsertStatementContext() {}

func NewInsertStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertStatementContext {
	var p = new(InsertStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_insertStatement

	return p
}

func (s *InsertStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertStatementContext) GetPriority() antlr.Token { return s.priority }

func (s *InsertStatementContext) SetPriority(v antlr.Token) { s.priority = v }

func (s *InsertStatementContext) GetPartitions() IUidListContext { return s.partitions }

func (s *InsertStatementContext) GetColumns() IFullColumnNameListContext { return s.columns }

func (s *InsertStatementContext) GetSetFirst() IUpdatedElementContext { return s.setFirst }

func (s *InsertStatementContext) Get_updatedElement() IUpdatedElementContext {
	return s._updatedElement
}

func (s *InsertStatementContext) GetTableAlias() IUidContext { return s.tableAlias }

func (s *InsertStatementContext) GetColAlias() IUidContext { return s.colAlias }

func (s *InsertStatementContext) GetDuplicatedFirst() IUpdatedElementContext {
	return s.duplicatedFirst
}

func (s *InsertStatementContext) SetPartitions(v IUidListContext) { s.partitions = v }

func (s *InsertStatementContext) SetColumns(v IFullColumnNameListContext) { s.columns = v }

func (s *InsertStatementContext) SetSetFirst(v IUpdatedElementContext) { s.setFirst = v }

func (s *InsertStatementContext) Set_updatedElement(v IUpdatedElementContext) { s._updatedElement = v }

func (s *InsertStatementContext) SetTableAlias(v IUidContext) { s.tableAlias = v }

func (s *InsertStatementContext) SetColAlias(v IUidContext) { s.colAlias = v }

func (s *InsertStatementContext) SetDuplicatedFirst(v IUpdatedElementContext) { s.duplicatedFirst = v }

func (s *InsertStatementContext) GetSetElements() []IUpdatedElementContext { return s.setElements }

func (s *InsertStatementContext) GetDuplicatedElements() []IUpdatedElementContext {
	return s.duplicatedElements
}

func (s *InsertStatementContext) SetSetElements(v []IUpdatedElementContext) { s.setElements = v }

func (s *InsertStatementContext) SetDuplicatedElements(v []IUpdatedElementContext) {
	s.duplicatedElements = v
}

func (s *InsertStatementContext) INSERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSERT, 0)
}

func (s *InsertStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *InsertStatementContext) InsertStatementValue() IInsertStatementValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertStatementValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertStatementValueContext)
}

func (s *InsertStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *InsertStatementContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE, 0)
}

func (s *InsertStatementContext) INTO() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTO, 0)
}

func (s *InsertStatementContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *InsertStatementContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *InsertStatementContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *InsertStatementContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *InsertStatementContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *InsertStatementContext) AllUpdatedElement() []IUpdatedElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			len++
		}
	}

	tst := make([]IUpdatedElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdatedElementContext); ok {
			tst[i] = t.(IUpdatedElementContext)
			i++
		}
	}

	return tst
}

func (s *InsertStatementContext) UpdatedElement(i int) IUpdatedElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdatedElementContext)
}

func (s *InsertStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *InsertStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *InsertStatementContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDUPLICATE, 0)
}

func (s *InsertStatementContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *InsertStatementContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPDATE, 0)
}

func (s *InsertStatementContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *InsertStatementContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *InsertStatementContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOW_PRIORITY, 0)
}

func (s *InsertStatementContext) DELAYED() antlr.TerminalNode {
	return s.GetToken(MySqlParserDELAYED, 0)
}

func (s *InsertStatementContext) HIGH_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserHIGH_PRIORITY, 0)
}

func (s *InsertStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *InsertStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *InsertStatementContext) FullColumnNameList() IFullColumnNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameListContext)
}

func (s *InsertStatementContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *InsertStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterInsertStatement(s)
	}
}

func (s *InsertStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitInsertStatement(s)
	}
}

func (p *MySqlParser) InsertStatement() (localctx IInsertStatementContext) {
	this := p
	_ = this

	localctx = NewInsertStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, MySqlParserRULE_insertStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3158)
		p.Match(MySqlParserINSERT)
	}
	p.SetState(3160)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-43)) & ^0x3f) == 0 && ((int64(1)<<(_la-43))&-9223372032559808511) != 0 {
		{
			p.SetState(3159)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*InsertStatementContext).priority = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-43)) & ^0x3f) == 0 && ((int64(1)<<(_la-43))&-9223372032559808511) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*InsertStatementContext).priority = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3163)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserIGNORE {
		{
			p.SetState(3162)
			p.Match(MySqlParserIGNORE)
		}

	}
	p.SetState(3166)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserINTO {
		{
			p.SetState(3165)
			p.Match(MySqlParserINTO)
		}

	}
	{
		p.SetState(3168)
		p.TableName()
	}
	p.SetState(3175)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserPARTITION {
		{
			p.SetState(3169)
			p.Match(MySqlParserPARTITION)
		}
		{
			p.SetState(3170)
			p.Match(MySqlParserLR_BRACKET)
		}
		p.SetState(3172)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&756891332513120256) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&146666055071174737) != 0) || ((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&134349441) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-2882305960540372993) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-4398063288321) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-16325548649218049) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-81064793296864001) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-68719476801) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-11118270170269697) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-33) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-3073) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&144115188075855871) != 0) || ((int64((_la-1121)) & ^0x3f) == 0 && ((int64(1)<<(_la-1121))&25807552513) != 0) {
			{
				p.SetState(3171)

				var _x = p.UidList()

				localctx.(*InsertStatementContext).partitions = _x
			}

		}
		{
			p.SetState(3174)
			p.Match(MySqlParserRR_BRACKET)
		}

	}
	p.SetState(3193)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSELECT, MySqlParserVALUES, MySqlParserVALUE, MySqlParserLR_BRACKET:
		p.SetState(3181)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 419, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3177)
				p.Match(MySqlParserLR_BRACKET)
			}
			{
				p.SetState(3178)

				var _x = p.FullColumnNameList()

				localctx.(*InsertStatementContext).columns = _x
			}
			{
				p.SetState(3179)
				p.Match(MySqlParserRR_BRACKET)
			}

		}
		{
			p.SetState(3183)
			p.InsertStatementValue()
		}

	case MySqlParserSET:
		{
			p.SetState(3184)
			p.Match(MySqlParserSET)
		}
		{
			p.SetState(3185)

			var _x = p.UpdatedElement()

			localctx.(*InsertStatementContext).setFirst = _x
		}
		p.SetState(3190)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(3186)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(3187)

				var _x = p.UpdatedElement()

				localctx.(*InsertStatementContext)._updatedElement = _x
			}
			localctx.(*InsertStatementContext).setElements = append(localctx.(*InsertStatementContext).setElements, localctx.(*InsertStatementContext)._updatedElement)

			p.SetState(3192)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(3210)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserAS {
		{
			p.SetState(3195)
			p.Match(MySqlParserAS)
		}
		{
			p.SetState(3196)

			var _x = p.Uid()

			localctx.(*InsertStatementContext).tableAlias = _x
		}
		p.SetState(3208)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 423, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3197)
				p.Match(MySqlParserLR_BRACKET)
			}
			{
				p.SetState(3198)

				var _x = p.Uid()

				localctx.(*InsertStatementContext).colAlias = _x
			}
			p.SetState(3203)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == MySqlParserCOMMA {
				{
					p.SetState(3199)
					p.Match(MySqlParserCOMMA)
				}
				{
					p.SetState(3200)

					var _x = p.Uid()

					localctx.(*InsertStatementContext).colAlias = _x
				}

				p.SetState(3205)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(3206)
				p.Match(MySqlParserRR_BRACKET)
			}

		}

	}
	p.SetState(3224)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserON {
		{
			p.SetState(3212)
			p.Match(MySqlParserON)
		}
		{
			p.SetState(3213)
			p.Match(MySqlParserDUPLICATE)
		}
		{
			p.SetState(3214)
			p.Match(MySqlParserKEY)
		}
		{
			p.SetState(3215)
			p.Match(MySqlParserUPDATE)
		}
		{
			p.SetState(3216)

			var _x = p.UpdatedElement()

			localctx.(*InsertStatementContext).duplicatedFirst = _x
		}
		p.SetState(3221)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(3217)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(3218)

				var _x = p.UpdatedElement()

				localctx.(*InsertStatementContext)._updatedElement = _x
			}
			localctx.(*InsertStatementContext).duplicatedElements = append(localctx.(*InsertStatementContext).duplicatedElements, localctx.(*InsertStatementContext)._updatedElement)

			p.SetState(3223)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// ILoadDataStatementContext is an interface to support dynamic dispatch.
type ILoadDataStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPriority returns the priority token.
	GetPriority() antlr.Token

	// GetFilename returns the filename token.
	GetFilename() antlr.Token

	// GetViolation returns the violation token.
	GetViolation() antlr.Token

	// GetFieldsFormat returns the fieldsFormat token.
	GetFieldsFormat() antlr.Token

	// GetLinesFormat returns the linesFormat token.
	GetLinesFormat() antlr.Token

	// SetPriority sets the priority token.
	SetPriority(antlr.Token)

	// SetFilename sets the filename token.
	SetFilename(antlr.Token)

	// SetViolation sets the violation token.
	SetViolation(antlr.Token)

	// SetFieldsFormat sets the fieldsFormat token.
	SetFieldsFormat(antlr.Token)

	// SetLinesFormat sets the linesFormat token.
	SetLinesFormat(antlr.Token)

	// GetCharset returns the charset rule contexts.
	GetCharset() ICharsetNameContext

	// SetCharset sets the charset rule contexts.
	SetCharset(ICharsetNameContext)

	// Getter signatures
	LOAD() antlr.TerminalNode
	DATA() antlr.TerminalNode
	INFILE() antlr.TerminalNode
	INTO() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TableName() ITableNameContext
	STRING_LITERAL() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	UidList() IUidListContext
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	CHARACTER() antlr.TerminalNode
	AllSET() []antlr.TerminalNode
	SET(i int) antlr.TerminalNode
	AllLINES() []antlr.TerminalNode
	LINES(i int) antlr.TerminalNode
	AllIGNORE() []antlr.TerminalNode
	IGNORE(i int) antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	AllAssignmentField() []IAssignmentFieldContext
	AssignmentField(i int) IAssignmentFieldContext
	AllUpdatedElement() []IUpdatedElementContext
	UpdatedElement(i int) IUpdatedElementContext
	CharsetName() ICharsetNameContext
	LOW_PRIORITY() antlr.TerminalNode
	CONCURRENT() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	FIELDS() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	ROWS() antlr.TerminalNode
	AllSelectFieldsInto() []ISelectFieldsIntoContext
	SelectFieldsInto(i int) ISelectFieldsIntoContext
	AllSelectLinesInto() []ISelectLinesIntoContext
	SelectLinesInto(i int) ISelectLinesIntoContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsLoadDataStatementContext differentiates from other interfaces.
	IsLoadDataStatementContext()
}

type LoadDataStatementContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	priority     antlr.Token
	filename     antlr.Token
	violation    antlr.Token
	charset      ICharsetNameContext
	fieldsFormat antlr.Token
	linesFormat  antlr.Token
}

func NewEmptyLoadDataStatementContext() *LoadDataStatementContext {
	var p = new(LoadDataStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_loadDataStatement
	return p
}

func (*LoadDataStatementContext) IsLoadDataStatementContext() {}

func NewLoadDataStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoadDataStatementContext {
	var p = new(LoadDataStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_loadDataStatement

	return p
}

func (s *LoadDataStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LoadDataStatementContext) GetPriority() antlr.Token { return s.priority }

func (s *LoadDataStatementContext) GetFilename() antlr.Token { return s.filename }

func (s *LoadDataStatementContext) GetViolation() antlr.Token { return s.violation }

func (s *LoadDataStatementContext) GetFieldsFormat() antlr.Token { return s.fieldsFormat }

func (s *LoadDataStatementContext) GetLinesFormat() antlr.Token { return s.linesFormat }

func (s *LoadDataStatementContext) SetPriority(v antlr.Token) { s.priority = v }

func (s *LoadDataStatementContext) SetFilename(v antlr.Token) { s.filename = v }

func (s *LoadDataStatementContext) SetViolation(v antlr.Token) { s.violation = v }

func (s *LoadDataStatementContext) SetFieldsFormat(v antlr.Token) { s.fieldsFormat = v }

func (s *LoadDataStatementContext) SetLinesFormat(v antlr.Token) { s.linesFormat = v }

func (s *LoadDataStatementContext) GetCharset() ICharsetNameContext { return s.charset }

func (s *LoadDataStatementContext) SetCharset(v ICharsetNameContext) { s.charset = v }

func (s *LoadDataStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOAD, 0)
}

func (s *LoadDataStatementContext) DATA() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATA, 0)
}

func (s *LoadDataStatementContext) INFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINFILE, 0)
}

func (s *LoadDataStatementContext) INTO() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTO, 0)
}

func (s *LoadDataStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *LoadDataStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *LoadDataStatementContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *LoadDataStatementContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL, 0)
}

func (s *LoadDataStatementContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *LoadDataStatementContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *LoadDataStatementContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *LoadDataStatementContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *LoadDataStatementContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *LoadDataStatementContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *LoadDataStatementContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER, 0)
}

func (s *LoadDataStatementContext) AllSET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSET)
}

func (s *LoadDataStatementContext) SET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, i)
}

func (s *LoadDataStatementContext) AllLINES() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLINES)
}

func (s *LoadDataStatementContext) LINES(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLINES, i)
}

func (s *LoadDataStatementContext) AllIGNORE() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserIGNORE)
}

func (s *LoadDataStatementContext) IGNORE(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE, i)
}

func (s *LoadDataStatementContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LoadDataStatementContext) AllAssignmentField() []IAssignmentFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignmentFieldContext); ok {
			len++
		}
	}

	tst := make([]IAssignmentFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignmentFieldContext); ok {
			tst[i] = t.(IAssignmentFieldContext)
			i++
		}
	}

	return tst
}

func (s *LoadDataStatementContext) AssignmentField(i int) IAssignmentFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentFieldContext)
}

func (s *LoadDataStatementContext) AllUpdatedElement() []IUpdatedElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			len++
		}
	}

	tst := make([]IUpdatedElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdatedElementContext); ok {
			tst[i] = t.(IUpdatedElementContext)
			i++
		}
	}

	return tst
}

func (s *LoadDataStatementContext) UpdatedElement(i int) IUpdatedElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdatedElementContext)
}

func (s *LoadDataStatementContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *LoadDataStatementContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOW_PRIORITY, 0)
}

func (s *LoadDataStatementContext) CONCURRENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONCURRENT, 0)
}

func (s *LoadDataStatementContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLACE, 0)
}

func (s *LoadDataStatementContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIELDS, 0)
}

func (s *LoadDataStatementContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMNS, 0)
}

func (s *LoadDataStatementContext) ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserROWS, 0)
}

func (s *LoadDataStatementContext) AllSelectFieldsInto() []ISelectFieldsIntoContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectFieldsIntoContext); ok {
			len++
		}
	}

	tst := make([]ISelectFieldsIntoContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectFieldsIntoContext); ok {
			tst[i] = t.(ISelectFieldsIntoContext)
			i++
		}
	}

	return tst
}

func (s *LoadDataStatementContext) SelectFieldsInto(i int) ISelectFieldsIntoContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectFieldsIntoContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectFieldsIntoContext)
}

func (s *LoadDataStatementContext) AllSelectLinesInto() []ISelectLinesIntoContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectLinesIntoContext); ok {
			len++
		}
	}

	tst := make([]ISelectLinesIntoContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectLinesIntoContext); ok {
			tst[i] = t.(ISelectLinesIntoContext)
			i++
		}
	}

	return tst
}

func (s *LoadDataStatementContext) SelectLinesInto(i int) ISelectLinesIntoContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectLinesIntoContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectLinesIntoContext)
}

func (s *LoadDataStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *LoadDataStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *LoadDataStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadDataStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoadDataStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLoadDataStatement(s)
	}
}

func (s *LoadDataStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLoadDataStatement(s)
	}
}

func (p *MySqlParser) LoadDataStatement() (localctx ILoadDataStatementContext) {
	this := p
	_ = this

	localctx = NewLoadDataStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, MySqlParserRULE_loadDataStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3226)
		p.Match(MySqlParserLOAD)
	}
	{
		p.SetState(3227)
		p.Match(MySqlParserDATA)
	}
	p.SetState(3229)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserLOW_PRIORITY || _la == MySqlParserCONCURRENT {
		{
			p.SetState(3228)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LoadDataStatementContext).priority = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserLOW_PRIORITY || _la == MySqlParserCONCURRENT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LoadDataStatementContext).priority = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3232)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserLOCAL {
		{
			p.SetState(3231)
			p.Match(MySqlParserLOCAL)
		}

	}
	{
		p.SetState(3234)
		p.Match(MySqlParserINFILE)
	}
	{
		p.SetState(3235)

		var _m = p.Match(MySqlParserSTRING_LITERAL)

		localctx.(*LoadDataStatementContext).filename = _m
	}
	p.SetState(3237)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserIGNORE || _la == MySqlParserREPLACE {
		{
			p.SetState(3236)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LoadDataStatementContext).violation = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserIGNORE || _la == MySqlParserREPLACE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LoadDataStatementContext).violation = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(3239)
		p.Match(MySqlParserINTO)
	}
	{
		p.SetState(3240)
		p.Match(MySqlParserTABLE)
	}
	{
		p.SetState(3241)
		p.TableName()
	}
	p.SetState(3247)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserPARTITION {
		{
			p.SetState(3242)
			p.Match(MySqlParserPARTITION)
		}
		{
			p.SetState(3243)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(3244)
			p.UidList()
		}
		{
			p.SetState(3245)
			p.Match(MySqlParserRR_BRACKET)
		}

	}
	p.SetState(3252)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserCHARACTER {
		{
			p.SetState(3249)
			p.Match(MySqlParserCHARACTER)
		}
		{
			p.SetState(3250)
			p.Match(MySqlParserSET)
		}
		{
			p.SetState(3251)

			var _x = p.CharsetName()

			localctx.(*LoadDataStatementContext).charset = _x
		}

	}
	p.SetState(3260)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserCOLUMNS || _la == MySqlParserFIELDS {
		{
			p.SetState(3254)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LoadDataStatementContext).fieldsFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCOLUMNS || _la == MySqlParserFIELDS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LoadDataStatementContext).fieldsFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(3256)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == MySqlParserENCLOSED || _la == MySqlParserESCAPED || _la == MySqlParserOPTIONALLY || _la == MySqlParserTERMINATED {
			{
				p.SetState(3255)
				p.SelectFieldsInto()
			}

			p.SetState(3258)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3268)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserLINES {
		{
			p.SetState(3262)
			p.Match(MySqlParserLINES)
		}
		p.SetState(3264)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == MySqlParserSTARTING || _la == MySqlParserTERMINATED {
			{
				p.SetState(3263)
				p.SelectLinesInto()
			}

			p.SetState(3266)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3274)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserIGNORE {
		{
			p.SetState(3270)
			p.Match(MySqlParserIGNORE)
		}
		{
			p.SetState(3271)
			p.DecimalLiteral()
		}
		{
			p.SetState(3272)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LoadDataStatementContext).linesFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserLINES || _la == MySqlParserROWS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LoadDataStatementContext).linesFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3287)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 438, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3276)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(3277)
			p.AssignmentField()
		}
		p.SetState(3282)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(3278)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(3279)
				p.AssignmentField()
			}

			p.SetState(3284)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3285)
			p.Match(MySqlParserRR_BRACKET)
		}

	}
	p.SetState(3298)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 440, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3289)
			p.Match(MySqlParserSET)
		}
		{
			p.SetState(3290)
			p.UpdatedElement()
		}
		p.SetState(3295)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(3291)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(3292)
				p.UpdatedElement()
			}

			p.SetState(3297)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// ILoadXmlStatementContext is an interface to support dynamic dispatch.
type ILoadXmlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPriority returns the priority token.
	GetPriority() antlr.Token

	// GetFilename returns the filename token.
	GetFilename() antlr.Token

	// GetViolation returns the violation token.
	GetViolation() antlr.Token

	// GetTag returns the tag token.
	GetTag() antlr.Token

	// GetLinesFormat returns the linesFormat token.
	GetLinesFormat() antlr.Token

	// SetPriority sets the priority token.
	SetPriority(antlr.Token)

	// SetFilename sets the filename token.
	SetFilename(antlr.Token)

	// SetViolation sets the violation token.
	SetViolation(antlr.Token)

	// SetTag sets the tag token.
	SetTag(antlr.Token)

	// SetLinesFormat sets the linesFormat token.
	SetLinesFormat(antlr.Token)

	// GetCharset returns the charset rule contexts.
	GetCharset() ICharsetNameContext

	// SetCharset sets the charset rule contexts.
	SetCharset(ICharsetNameContext)

	// Getter signatures
	LOAD() antlr.TerminalNode
	XML() antlr.TerminalNode
	INFILE() antlr.TerminalNode
	INTO() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TableName() ITableNameContext
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	CHARACTER() antlr.TerminalNode
	AllSET() []antlr.TerminalNode
	SET(i int) antlr.TerminalNode
	AllROWS() []antlr.TerminalNode
	ROWS(i int) antlr.TerminalNode
	IDENTIFIED() antlr.TerminalNode
	BY() antlr.TerminalNode
	LESS_SYMBOL() antlr.TerminalNode
	GREATER_SYMBOL() antlr.TerminalNode
	AllIGNORE() []antlr.TerminalNode
	IGNORE(i int) antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	LR_BRACKET() antlr.TerminalNode
	AllAssignmentField() []IAssignmentFieldContext
	AssignmentField(i int) IAssignmentFieldContext
	RR_BRACKET() antlr.TerminalNode
	AllUpdatedElement() []IUpdatedElementContext
	UpdatedElement(i int) IUpdatedElementContext
	CharsetName() ICharsetNameContext
	LOW_PRIORITY() antlr.TerminalNode
	CONCURRENT() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	LINES() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsLoadXmlStatementContext differentiates from other interfaces.
	IsLoadXmlStatementContext()
}

type LoadXmlStatementContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	priority    antlr.Token
	filename    antlr.Token
	violation   antlr.Token
	charset     ICharsetNameContext
	tag         antlr.Token
	linesFormat antlr.Token
}

func NewEmptyLoadXmlStatementContext() *LoadXmlStatementContext {
	var p = new(LoadXmlStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_loadXmlStatement
	return p
}

func (*LoadXmlStatementContext) IsLoadXmlStatementContext() {}

func NewLoadXmlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoadXmlStatementContext {
	var p = new(LoadXmlStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_loadXmlStatement

	return p
}

func (s *LoadXmlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LoadXmlStatementContext) GetPriority() antlr.Token { return s.priority }

func (s *LoadXmlStatementContext) GetFilename() antlr.Token { return s.filename }

func (s *LoadXmlStatementContext) GetViolation() antlr.Token { return s.violation }

func (s *LoadXmlStatementContext) GetTag() antlr.Token { return s.tag }

func (s *LoadXmlStatementContext) GetLinesFormat() antlr.Token { return s.linesFormat }

func (s *LoadXmlStatementContext) SetPriority(v antlr.Token) { s.priority = v }

func (s *LoadXmlStatementContext) SetFilename(v antlr.Token) { s.filename = v }

func (s *LoadXmlStatementContext) SetViolation(v antlr.Token) { s.violation = v }

func (s *LoadXmlStatementContext) SetTag(v antlr.Token) { s.tag = v }

func (s *LoadXmlStatementContext) SetLinesFormat(v antlr.Token) { s.linesFormat = v }

func (s *LoadXmlStatementContext) GetCharset() ICharsetNameContext { return s.charset }

func (s *LoadXmlStatementContext) SetCharset(v ICharsetNameContext) { s.charset = v }

func (s *LoadXmlStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOAD, 0)
}

func (s *LoadXmlStatementContext) XML() antlr.TerminalNode {
	return s.GetToken(MySqlParserXML, 0)
}

func (s *LoadXmlStatementContext) INFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINFILE, 0)
}

func (s *LoadXmlStatementContext) INTO() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTO, 0)
}

func (s *LoadXmlStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *LoadXmlStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *LoadXmlStatementContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSTRING_LITERAL)
}

func (s *LoadXmlStatementContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, i)
}

func (s *LoadXmlStatementContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL, 0)
}

func (s *LoadXmlStatementContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER, 0)
}

func (s *LoadXmlStatementContext) AllSET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSET)
}

func (s *LoadXmlStatementContext) SET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, i)
}

func (s *LoadXmlStatementContext) AllROWS() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserROWS)
}

func (s *LoadXmlStatementContext) ROWS(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserROWS, i)
}

func (s *LoadXmlStatementContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(MySqlParserIDENTIFIED, 0)
}

func (s *LoadXmlStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *LoadXmlStatementContext) LESS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLESS_SYMBOL, 0)
}

func (s *LoadXmlStatementContext) GREATER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserGREATER_SYMBOL, 0)
}

func (s *LoadXmlStatementContext) AllIGNORE() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserIGNORE)
}

func (s *LoadXmlStatementContext) IGNORE(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE, i)
}

func (s *LoadXmlStatementContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LoadXmlStatementContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *LoadXmlStatementContext) AllAssignmentField() []IAssignmentFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignmentFieldContext); ok {
			len++
		}
	}

	tst := make([]IAssignmentFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignmentFieldContext); ok {
			tst[i] = t.(IAssignmentFieldContext)
			i++
		}
	}

	return tst
}

func (s *LoadXmlStatementContext) AssignmentField(i int) IAssignmentFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentFieldContext)
}

func (s *LoadXmlStatementContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *LoadXmlStatementContext) AllUpdatedElement() []IUpdatedElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			len++
		}
	}

	tst := make([]IUpdatedElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdatedElementContext); ok {
			tst[i] = t.(IUpdatedElementContext)
			i++
		}
	}

	return tst
}

func (s *LoadXmlStatementContext) UpdatedElement(i int) IUpdatedElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdatedElementContext)
}

func (s *LoadXmlStatementContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *LoadXmlStatementContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOW_PRIORITY, 0)
}

func (s *LoadXmlStatementContext) CONCURRENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONCURRENT, 0)
}

func (s *LoadXmlStatementContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLACE, 0)
}

func (s *LoadXmlStatementContext) LINES() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINES, 0)
}

func (s *LoadXmlStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *LoadXmlStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *LoadXmlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadXmlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoadXmlStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLoadXmlStatement(s)
	}
}

func (s *LoadXmlStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLoadXmlStatement(s)
	}
}

func (p *MySqlParser) LoadXmlStatement() (localctx ILoadXmlStatementContext) {
	this := p
	_ = this

	localctx = NewLoadXmlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, MySqlParserRULE_loadXmlStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3300)
		p.Match(MySqlParserLOAD)
	}
	{
		p.SetState(3301)
		p.Match(MySqlParserXML)
	}
	p.SetState(3303)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserLOW_PRIORITY || _la == MySqlParserCONCURRENT {
		{
			p.SetState(3302)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LoadXmlStatementContext).priority = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserLOW_PRIORITY || _la == MySqlParserCONCURRENT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LoadXmlStatementContext).priority = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3306)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserLOCAL {
		{
			p.SetState(3305)
			p.Match(MySqlParserLOCAL)
		}

	}
	{
		p.SetState(3308)
		p.Match(MySqlParserINFILE)
	}
	{
		p.SetState(3309)

		var _m = p.Match(MySqlParserSTRING_LITERAL)

		localctx.(*LoadXmlStatementContext).filename = _m
	}
	p.SetState(3311)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserIGNORE || _la == MySqlParserREPLACE {
		{
			p.SetState(3310)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LoadXmlStatementContext).violation = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserIGNORE || _la == MySqlParserREPLACE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LoadXmlStatementContext).violation = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(3313)
		p.Match(MySqlParserINTO)
	}
	{
		p.SetState(3314)
		p.Match(MySqlParserTABLE)
	}
	{
		p.SetState(3315)
		p.TableName()
	}
	p.SetState(3319)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserCHARACTER {
		{
			p.SetState(3316)
			p.Match(MySqlParserCHARACTER)
		}
		{
			p.SetState(3317)
			p.Match(MySqlParserSET)
		}
		{
			p.SetState(3318)

			var _x = p.CharsetName()

			localctx.(*LoadXmlStatementContext).charset = _x
		}

	}
	p.SetState(3327)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserROWS {
		{
			p.SetState(3321)
			p.Match(MySqlParserROWS)
		}
		{
			p.SetState(3322)
			p.Match(MySqlParserIDENTIFIED)
		}
		{
			p.SetState(3323)
			p.Match(MySqlParserBY)
		}
		{
			p.SetState(3324)
			p.Match(MySqlParserLESS_SYMBOL)
		}
		{
			p.SetState(3325)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*LoadXmlStatementContext).tag = _m
		}
		{
			p.SetState(3326)
			p.Match(MySqlParserGREATER_SYMBOL)
		}

	}
	p.SetState(3333)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserIGNORE {
		{
			p.SetState(3329)
			p.Match(MySqlParserIGNORE)
		}
		{
			p.SetState(3330)
			p.DecimalLiteral()
		}
		{
			p.SetState(3331)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LoadXmlStatementContext).linesFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserLINES || _la == MySqlParserROWS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LoadXmlStatementContext).linesFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3346)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 448, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3335)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(3336)
			p.AssignmentField()
		}
		p.SetState(3341)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(3337)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(3338)
				p.AssignmentField()
			}

			p.SetState(3343)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3344)
			p.Match(MySqlParserRR_BRACKET)
		}

	}
	p.SetState(3357)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 450, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3348)
			p.Match(MySqlParserSET)
		}
		{
			p.SetState(3349)
			p.UpdatedElement()
		}
		p.SetState(3354)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(3350)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(3351)
				p.UpdatedElement()
			}

			p.SetState(3356)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IReplaceStatementContext is an interface to support dynamic dispatch.
type IReplaceStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPriority returns the priority token.
	GetPriority() antlr.Token

	// SetPriority sets the priority token.
	SetPriority(antlr.Token)

	// GetPartitions returns the partitions rule contexts.
	GetPartitions() IUidListContext

	// GetColumns returns the columns rule contexts.
	GetColumns() IUidListContext

	// GetSetFirst returns the setFirst rule contexts.
	GetSetFirst() IUpdatedElementContext

	// Get_updatedElement returns the _updatedElement rule contexts.
	Get_updatedElement() IUpdatedElementContext

	// SetPartitions sets the partitions rule contexts.
	SetPartitions(IUidListContext)

	// SetColumns sets the columns rule contexts.
	SetColumns(IUidListContext)

	// SetSetFirst sets the setFirst rule contexts.
	SetSetFirst(IUpdatedElementContext)

	// Set_updatedElement sets the _updatedElement rule contexts.
	Set_updatedElement(IUpdatedElementContext)

	// GetSetElements returns the setElements rule context list.
	GetSetElements() []IUpdatedElementContext

	// SetSetElements sets the setElements rule context list.
	SetSetElements([]IUpdatedElementContext)

	// Getter signatures
	REPLACE() antlr.TerminalNode
	TableName() ITableNameContext
	InsertStatementValue() IInsertStatementValueContext
	SET() antlr.TerminalNode
	INTO() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	AllUpdatedElement() []IUpdatedElementContext
	UpdatedElement(i int) IUpdatedElementContext
	AllUidList() []IUidListContext
	UidList(i int) IUidListContext
	LOW_PRIORITY() antlr.TerminalNode
	DELAYED() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsReplaceStatementContext differentiates from other interfaces.
	IsReplaceStatementContext()
}

type ReplaceStatementContext struct {
	*antlr.BaseParserRuleContext
	parser          antlr.Parser
	priority        antlr.Token
	partitions      IUidListContext
	columns         IUidListContext
	setFirst        IUpdatedElementContext
	_updatedElement IUpdatedElementContext
	setElements     []IUpdatedElementContext
}

func NewEmptyReplaceStatementContext() *ReplaceStatementContext {
	var p = new(ReplaceStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_replaceStatement
	return p
}

func (*ReplaceStatementContext) IsReplaceStatementContext() {}

func NewReplaceStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplaceStatementContext {
	var p = new(ReplaceStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_replaceStatement

	return p
}

func (s *ReplaceStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplaceStatementContext) GetPriority() antlr.Token { return s.priority }

func (s *ReplaceStatementContext) SetPriority(v antlr.Token) { s.priority = v }

func (s *ReplaceStatementContext) GetPartitions() IUidListContext { return s.partitions }

func (s *ReplaceStatementContext) GetColumns() IUidListContext { return s.columns }

func (s *ReplaceStatementContext) GetSetFirst() IUpdatedElementContext { return s.setFirst }

func (s *ReplaceStatementContext) Get_updatedElement() IUpdatedElementContext {
	return s._updatedElement
}

func (s *ReplaceStatementContext) SetPartitions(v IUidListContext) { s.partitions = v }

func (s *ReplaceStatementContext) SetColumns(v IUidListContext) { s.columns = v }

func (s *ReplaceStatementContext) SetSetFirst(v IUpdatedElementContext) { s.setFirst = v }

func (s *ReplaceStatementContext) Set_updatedElement(v IUpdatedElementContext) { s._updatedElement = v }

func (s *ReplaceStatementContext) GetSetElements() []IUpdatedElementContext { return s.setElements }

func (s *ReplaceStatementContext) SetSetElements(v []IUpdatedElementContext) { s.setElements = v }

func (s *ReplaceStatementContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLACE, 0)
}

func (s *ReplaceStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *ReplaceStatementContext) InsertStatementValue() IInsertStatementValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertStatementValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertStatementValueContext)
}

func (s *ReplaceStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *ReplaceStatementContext) INTO() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTO, 0)
}

func (s *ReplaceStatementContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *ReplaceStatementContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *ReplaceStatementContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *ReplaceStatementContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *ReplaceStatementContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *ReplaceStatementContext) AllUpdatedElement() []IUpdatedElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			len++
		}
	}

	tst := make([]IUpdatedElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdatedElementContext); ok {
			tst[i] = t.(IUpdatedElementContext)
			i++
		}
	}

	return tst
}

func (s *ReplaceStatementContext) UpdatedElement(i int) IUpdatedElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdatedElementContext)
}

func (s *ReplaceStatementContext) AllUidList() []IUidListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidListContext); ok {
			len++
		}
	}

	tst := make([]IUidListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidListContext); ok {
			tst[i] = t.(IUidListContext)
			i++
		}
	}

	return tst
}

func (s *ReplaceStatementContext) UidList(i int) IUidListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *ReplaceStatementContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOW_PRIORITY, 0)
}

func (s *ReplaceStatementContext) DELAYED() antlr.TerminalNode {
	return s.GetToken(MySqlParserDELAYED, 0)
}

func (s *ReplaceStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *ReplaceStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *ReplaceStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplaceStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplaceStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterReplaceStatement(s)
	}
}

func (s *ReplaceStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitReplaceStatement(s)
	}
}

func (p *MySqlParser) ReplaceStatement() (localctx IReplaceStatementContext) {
	this := p
	_ = this

	localctx = NewReplaceStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, MySqlParserRULE_replaceStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3359)
		p.Match(MySqlParserREPLACE)
	}
	p.SetState(3361)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserDELAYED || _la == MySqlParserLOW_PRIORITY {
		{
			p.SetState(3360)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ReplaceStatementContext).priority = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDELAYED || _la == MySqlParserLOW_PRIORITY) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ReplaceStatementContext).priority = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3364)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserINTO {
		{
			p.SetState(3363)
			p.Match(MySqlParserINTO)
		}

	}
	{
		p.SetState(3366)
		p.TableName()
	}
	p.SetState(3372)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserPARTITION {
		{
			p.SetState(3367)
			p.Match(MySqlParserPARTITION)
		}
		{
			p.SetState(3368)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(3369)

			var _x = p.UidList()

			localctx.(*ReplaceStatementContext).partitions = _x
		}
		{
			p.SetState(3370)
			p.Match(MySqlParserRR_BRACKET)
		}

	}
	p.SetState(3390)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSELECT, MySqlParserVALUES, MySqlParserVALUE, MySqlParserLR_BRACKET:
		p.SetState(3378)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 454, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3374)
				p.Match(MySqlParserLR_BRACKET)
			}
			{
				p.SetState(3375)

				var _x = p.UidList()

				localctx.(*ReplaceStatementContext).columns = _x
			}
			{
				p.SetState(3376)
				p.Match(MySqlParserRR_BRACKET)
			}

		}
		{
			p.SetState(3380)
			p.InsertStatementValue()
		}

	case MySqlParserSET:
		{
			p.SetState(3381)
			p.Match(MySqlParserSET)
		}
		{
			p.SetState(3382)

			var _x = p.UpdatedElement()

			localctx.(*ReplaceStatementContext).setFirst = _x
		}
		p.SetState(3387)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(3383)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(3384)

				var _x = p.UpdatedElement()

				localctx.(*ReplaceStatementContext)._updatedElement = _x
			}
			localctx.(*ReplaceStatementContext).setElements = append(localctx.(*ReplaceStatementContext).setElements, localctx.(*ReplaceStatementContext)._updatedElement)

			p.SetState(3389)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISelectStatementContext is an interface to support dynamic dispatch.
type ISelectStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSelectStatementContext differentiates from other interfaces.
	IsSelectStatementContext()
}

type SelectStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectStatementContext() *SelectStatementContext {
	var p = new(SelectStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_selectStatement
	return p
}

func (*SelectStatementContext) IsSelectStatementContext() {}

func NewSelectStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectStatementContext {
	var p = new(SelectStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_selectStatement

	return p
}

func (s *SelectStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectStatementContext) CopyFrom(ctx *SelectStatementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *SelectStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UnionSelectContext struct {
	*SelectStatementContext
	unionType antlr.Token
}

func NewUnionSelectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnionSelectContext {
	var p = new(UnionSelectContext)

	p.SelectStatementContext = NewEmptySelectStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectStatementContext))

	return p
}

func (s *UnionSelectContext) GetUnionType() antlr.Token { return s.unionType }

func (s *UnionSelectContext) SetUnionType(v antlr.Token) { s.unionType = v }

func (s *UnionSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionSelectContext) QuerySpecificationNointo() IQuerySpecificationNointoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationNointoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationNointoContext)
}

func (s *UnionSelectContext) AllUnionStatement() []IUnionStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnionStatementContext); ok {
			len++
		}
	}

	tst := make([]IUnionStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnionStatementContext); ok {
			tst[i] = t.(IUnionStatementContext)
			i++
		}
	}

	return tst
}

func (s *UnionSelectContext) UnionStatement(i int) IUnionStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnionStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnionStatementContext)
}

func (s *UnionSelectContext) UNION() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNION, 0)
}

func (s *UnionSelectContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *UnionSelectContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *UnionSelectContext) LockClause() ILockClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockClauseContext)
}

func (s *UnionSelectContext) QuerySpecification() IQuerySpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *UnionSelectContext) QueryExpression() IQueryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionContext)
}

func (s *UnionSelectContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *UnionSelectContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISTINCT, 0)
}

func (s *UnionSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUnionSelect(s)
	}
}

func (s *UnionSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUnionSelect(s)
	}
}

type UnionParenthesisSelectContext struct {
	*SelectStatementContext
	unionType antlr.Token
}

func NewUnionParenthesisSelectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnionParenthesisSelectContext {
	var p = new(UnionParenthesisSelectContext)

	p.SelectStatementContext = NewEmptySelectStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectStatementContext))

	return p
}

func (s *UnionParenthesisSelectContext) GetUnionType() antlr.Token { return s.unionType }

func (s *UnionParenthesisSelectContext) SetUnionType(v antlr.Token) { s.unionType = v }

func (s *UnionParenthesisSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionParenthesisSelectContext) QueryExpressionNointo() IQueryExpressionNointoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionNointoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionNointoContext)
}

func (s *UnionParenthesisSelectContext) AllUnionParenthesis() []IUnionParenthesisContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnionParenthesisContext); ok {
			len++
		}
	}

	tst := make([]IUnionParenthesisContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnionParenthesisContext); ok {
			tst[i] = t.(IUnionParenthesisContext)
			i++
		}
	}

	return tst
}

func (s *UnionParenthesisSelectContext) UnionParenthesis(i int) IUnionParenthesisContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnionParenthesisContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnionParenthesisContext)
}

func (s *UnionParenthesisSelectContext) UNION() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNION, 0)
}

func (s *UnionParenthesisSelectContext) QueryExpression() IQueryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionContext)
}

func (s *UnionParenthesisSelectContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *UnionParenthesisSelectContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *UnionParenthesisSelectContext) LockClause() ILockClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockClauseContext)
}

func (s *UnionParenthesisSelectContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *UnionParenthesisSelectContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISTINCT, 0)
}

func (s *UnionParenthesisSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUnionParenthesisSelect(s)
	}
}

func (s *UnionParenthesisSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUnionParenthesisSelect(s)
	}
}

type SimpleSelectContext struct {
	*SelectStatementContext
}

func NewSimpleSelectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleSelectContext {
	var p = new(SimpleSelectContext)

	p.SelectStatementContext = NewEmptySelectStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectStatementContext))

	return p
}

func (s *SimpleSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleSelectContext) QuerySpecification() IQuerySpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *SimpleSelectContext) LockClause() ILockClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockClauseContext)
}

func (s *SimpleSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSimpleSelect(s)
	}
}

func (s *SimpleSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSimpleSelect(s)
	}
}

type ParenthesisSelectContext struct {
	*SelectStatementContext
}

func NewParenthesisSelectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesisSelectContext {
	var p = new(ParenthesisSelectContext)

	p.SelectStatementContext = NewEmptySelectStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectStatementContext))

	return p
}

func (s *ParenthesisSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesisSelectContext) QueryExpression() IQueryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionContext)
}

func (s *ParenthesisSelectContext) LockClause() ILockClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockClauseContext)
}

func (s *ParenthesisSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterParenthesisSelect(s)
	}
}

func (s *ParenthesisSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitParenthesisSelect(s)
	}
}

type WithLateralStatementContext struct {
	*SelectStatementContext
}

func NewWithLateralStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WithLateralStatementContext {
	var p = new(WithLateralStatementContext)

	p.SelectStatementContext = NewEmptySelectStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectStatementContext))

	return p
}

func (s *WithLateralStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithLateralStatementContext) QuerySpecificationNointo() IQuerySpecificationNointoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationNointoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationNointoContext)
}

func (s *WithLateralStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *WithLateralStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *WithLateralStatementContext) AllLateralStatement() []ILateralStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILateralStatementContext); ok {
			len++
		}
	}

	tst := make([]ILateralStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILateralStatementContext); ok {
			tst[i] = t.(ILateralStatementContext)
			i++
		}
	}

	return tst
}

func (s *WithLateralStatementContext) LateralStatement(i int) ILateralStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILateralStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILateralStatementContext)
}

func (s *WithLateralStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterWithLateralStatement(s)
	}
}

func (s *WithLateralStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitWithLateralStatement(s)
	}
}

func (p *MySqlParser) SelectStatement() (localctx ISelectStatementContext) {
	this := p
	_ = this

	localctx = NewSelectStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, MySqlParserRULE_selectStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(3454)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 473, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSimpleSelectContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3392)
			p.QuerySpecification()
		}
		p.SetState(3394)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 457, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3393)
				p.LockClause()
			}

		}

	case 2:
		localctx = NewParenthesisSelectContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3396)
			p.QueryExpression()
		}
		p.SetState(3398)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 458, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3397)
				p.LockClause()
			}

		}

	case 3:
		localctx = NewUnionSelectContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3400)
			p.QuerySpecificationNointo()
		}
		p.SetState(3402)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(3401)
					p.UnionStatement()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(3404)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 459, p.GetParserRuleContext())
		}
		p.SetState(3414)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserUNION {
			{
				p.SetState(3406)
				p.Match(MySqlParserUNION)
			}
			p.SetState(3408)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserALL || _la == MySqlParserDISTINCT {
				{
					p.SetState(3407)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*UnionSelectContext).unionType = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserALL || _la == MySqlParserDISTINCT) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*UnionSelectContext).unionType = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			p.SetState(3412)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case MySqlParserSELECT:
				{
					p.SetState(3410)
					p.QuerySpecification()
				}

			case MySqlParserLR_BRACKET:
				{
					p.SetState(3411)
					p.QueryExpression()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(3417)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 463, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3416)
				p.OrderByClause()
			}

		}
		p.SetState(3420)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLIMIT {
			{
				p.SetState(3419)
				p.LimitClause()
			}

		}
		p.SetState(3423)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 465, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3422)
				p.LockClause()
			}

		}

	case 4:
		localctx = NewUnionParenthesisSelectContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3425)
			p.QueryExpressionNointo()
		}
		p.SetState(3427)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(3426)
					p.UnionParenthesis()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(3429)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 466, p.GetParserRuleContext())
		}
		p.SetState(3436)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserUNION {
			{
				p.SetState(3431)
				p.Match(MySqlParserUNION)
			}
			p.SetState(3433)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserALL || _la == MySqlParserDISTINCT {
				{
					p.SetState(3432)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*UnionParenthesisSelectContext).unionType = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserALL || _la == MySqlParserDISTINCT) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*UnionParenthesisSelectContext).unionType = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(3435)
				p.QueryExpression()
			}

		}
		p.SetState(3439)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 469, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3438)
				p.OrderByClause()
			}

		}
		p.SetState(3442)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLIMIT {
			{
				p.SetState(3441)
				p.LimitClause()
			}

		}
		p.SetState(3445)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 471, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3444)
				p.LockClause()
			}

		}

	case 5:
		localctx = NewWithLateralStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3447)
			p.QuerySpecificationNointo()
		}
		p.SetState(3450)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == MySqlParserCOMMA {
			{
				p.SetState(3448)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(3449)
				p.LateralStatement()
			}

			p.SetState(3452)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IUpdateStatementContext is an interface to support dynamic dispatch.
type IUpdateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleUpdateStatement() ISingleUpdateStatementContext
	MultipleUpdateStatement() IMultipleUpdateStatementContext

	// IsUpdateStatementContext differentiates from other interfaces.
	IsUpdateStatementContext()
}

type UpdateStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdateStatementContext() *UpdateStatementContext {
	var p = new(UpdateStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_updateStatement
	return p
}

func (*UpdateStatementContext) IsUpdateStatementContext() {}

func NewUpdateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateStatementContext {
	var p = new(UpdateStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_updateStatement

	return p
}

func (s *UpdateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateStatementContext) SingleUpdateStatement() ISingleUpdateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleUpdateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleUpdateStatementContext)
}

func (s *UpdateStatementContext) MultipleUpdateStatement() IMultipleUpdateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipleUpdateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipleUpdateStatementContext)
}

func (s *UpdateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUpdateStatement(s)
	}
}

func (s *UpdateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUpdateStatement(s)
	}
}

func (p *MySqlParser) UpdateStatement() (localctx IUpdateStatementContext) {
	this := p
	_ = this

	localctx = NewUpdateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, MySqlParserRULE_updateStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3458)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 474, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3456)
			p.SingleUpdateStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3457)
			p.MultipleUpdateStatement()
		}

	}

	return localctx
}

// IValuesStatementContext is an interface to support dynamic dispatch.
type IValuesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VALUES() antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	AllExpressionsWithDefaults() []IExpressionsWithDefaultsContext
	ExpressionsWithDefaults(i int) IExpressionsWithDefaultsContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsValuesStatementContext differentiates from other interfaces.
	IsValuesStatementContext()
}

type ValuesStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValuesStatementContext() *ValuesStatementContext {
	var p = new(ValuesStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_valuesStatement
	return p
}

func (*ValuesStatementContext) IsValuesStatementContext() {}

func NewValuesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValuesStatementContext {
	var p = new(ValuesStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_valuesStatement

	return p
}

func (s *ValuesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ValuesStatementContext) VALUES() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUES, 0)
}

func (s *ValuesStatementContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *ValuesStatementContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *ValuesStatementContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *ValuesStatementContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *ValuesStatementContext) AllExpressionsWithDefaults() []IExpressionsWithDefaultsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionsWithDefaultsContext); ok {
			len++
		}
	}

	tst := make([]IExpressionsWithDefaultsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionsWithDefaultsContext); ok {
			tst[i] = t.(IExpressionsWithDefaultsContext)
			i++
		}
	}

	return tst
}

func (s *ValuesStatementContext) ExpressionsWithDefaults(i int) IExpressionsWithDefaultsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionsWithDefaultsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionsWithDefaultsContext)
}

func (s *ValuesStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *ValuesStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *ValuesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValuesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValuesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterValuesStatement(s)
	}
}

func (s *ValuesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitValuesStatement(s)
	}
}

func (p *MySqlParser) ValuesStatement() (localctx IValuesStatementContext) {
	this := p
	_ = this

	localctx = NewValuesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, MySqlParserRULE_valuesStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3460)
		p.Match(MySqlParserVALUES)
	}
	{
		p.SetState(3461)
		p.Match(MySqlParserLR_BRACKET)
	}
	p.SetState(3463)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 475, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3462)
			p.ExpressionsWithDefaults()
		}

	}
	{
		p.SetState(3465)
		p.Match(MySqlParserRR_BRACKET)
	}
	p.SetState(3474)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(3466)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(3467)
			p.Match(MySqlParserLR_BRACKET)
		}
		p.SetState(3469)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 476, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3468)
				p.ExpressionsWithDefaults()
			}

		}
		{
			p.SetState(3471)
			p.Match(MySqlParserRR_BRACKET)
		}

		p.SetState(3476)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInsertStatementValueContext is an interface to support dynamic dispatch.
type IInsertStatementValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetInsertFormat returns the insertFormat token.
	GetInsertFormat() antlr.Token

	// SetInsertFormat sets the insertFormat token.
	SetInsertFormat(antlr.Token)

	// Getter signatures
	SelectStatement() ISelectStatementContext
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	VALUES() antlr.TerminalNode
	VALUE() antlr.TerminalNode
	AllExpressionsWithDefaults() []IExpressionsWithDefaultsContext
	ExpressionsWithDefaults(i int) IExpressionsWithDefaultsContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsInsertStatementValueContext differentiates from other interfaces.
	IsInsertStatementValueContext()
}

type InsertStatementValueContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	insertFormat antlr.Token
}

func NewEmptyInsertStatementValueContext() *InsertStatementValueContext {
	var p = new(InsertStatementValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_insertStatementValue
	return p
}

func (*InsertStatementValueContext) IsInsertStatementValueContext() {}

func NewInsertStatementValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertStatementValueContext {
	var p = new(InsertStatementValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_insertStatementValue

	return p
}

func (s *InsertStatementValueContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertStatementValueContext) GetInsertFormat() antlr.Token { return s.insertFormat }

func (s *InsertStatementValueContext) SetInsertFormat(v antlr.Token) { s.insertFormat = v }

func (s *InsertStatementValueContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *InsertStatementValueContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *InsertStatementValueContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *InsertStatementValueContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *InsertStatementValueContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *InsertStatementValueContext) VALUES() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUES, 0)
}

func (s *InsertStatementValueContext) VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUE, 0)
}

func (s *InsertStatementValueContext) AllExpressionsWithDefaults() []IExpressionsWithDefaultsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionsWithDefaultsContext); ok {
			len++
		}
	}

	tst := make([]IExpressionsWithDefaultsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionsWithDefaultsContext); ok {
			tst[i] = t.(IExpressionsWithDefaultsContext)
			i++
		}
	}

	return tst
}

func (s *InsertStatementValueContext) ExpressionsWithDefaults(i int) IExpressionsWithDefaultsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionsWithDefaultsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionsWithDefaultsContext)
}

func (s *InsertStatementValueContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *InsertStatementValueContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *InsertStatementValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertStatementValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertStatementValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterInsertStatementValue(s)
	}
}

func (s *InsertStatementValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitInsertStatementValue(s)
	}
}

func (p *MySqlParser) InsertStatementValue() (localctx IInsertStatementValueContext) {
	this := p
	_ = this

	localctx = NewInsertStatementValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, MySqlParserRULE_insertStatementValue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3495)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSELECT, MySqlParserLR_BRACKET:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3477)
			p.SelectStatement()
		}

	case MySqlParserVALUES, MySqlParserVALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3478)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*InsertStatementValueContext).insertFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserVALUES || _la == MySqlParserVALUE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*InsertStatementValueContext).insertFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3479)
			p.Match(MySqlParserLR_BRACKET)
		}
		p.SetState(3481)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 478, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3480)
				p.ExpressionsWithDefaults()
			}

		}
		{
			p.SetState(3483)
			p.Match(MySqlParserRR_BRACKET)
		}
		p.SetState(3492)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(3484)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(3485)
				p.Match(MySqlParserLR_BRACKET)
			}
			p.SetState(3487)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 479, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(3486)
					p.ExpressionsWithDefaults()
				}

			}
			{
				p.SetState(3489)
				p.Match(MySqlParserRR_BRACKET)
			}

			p.SetState(3494)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUpdatedElementContext is an interface to support dynamic dispatch.
type IUpdatedElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FullColumnName() IFullColumnNameContext
	EQUAL_SYMBOL() antlr.TerminalNode
	Expression() IExpressionContext
	DEFAULT() antlr.TerminalNode

	// IsUpdatedElementContext differentiates from other interfaces.
	IsUpdatedElementContext()
}

type UpdatedElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdatedElementContext() *UpdatedElementContext {
	var p = new(UpdatedElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_updatedElement
	return p
}

func (*UpdatedElementContext) IsUpdatedElementContext() {}

func NewUpdatedElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdatedElementContext {
	var p = new(UpdatedElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_updatedElement

	return p
}

func (s *UpdatedElementContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdatedElementContext) FullColumnName() IFullColumnNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *UpdatedElementContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *UpdatedElementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UpdatedElementContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *UpdatedElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdatedElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdatedElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUpdatedElement(s)
	}
}

func (s *UpdatedElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUpdatedElement(s)
	}
}

func (p *MySqlParser) UpdatedElement() (localctx IUpdatedElementContext) {
	this := p
	_ = this

	localctx = NewUpdatedElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, MySqlParserRULE_updatedElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3497)
		p.FullColumnName()
	}
	{
		p.SetState(3498)
		p.Match(MySqlParserEQUAL_SYMBOL)
	}
	p.SetState(3501)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 482, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3499)
			p.expression(0)
		}

	case 2:
		{
			p.SetState(3500)
			p.Match(MySqlParserDEFAULT)
		}

	}

	return localctx
}

// IAssignmentFieldContext is an interface to support dynamic dispatch.
type IAssignmentFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext
	LOCAL_ID() antlr.TerminalNode

	// IsAssignmentFieldContext differentiates from other interfaces.
	IsAssignmentFieldContext()
}

type AssignmentFieldContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentFieldContext() *AssignmentFieldContext {
	var p = new(AssignmentFieldContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_assignmentField
	return p
}

func (*AssignmentFieldContext) IsAssignmentFieldContext() {}

func NewAssignmentFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentFieldContext {
	var p = new(AssignmentFieldContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_assignmentField

	return p
}

func (s *AssignmentFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentFieldContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AssignmentFieldContext) LOCAL_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL_ID, 0)
}

func (s *AssignmentFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAssignmentField(s)
	}
}

func (s *AssignmentFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAssignmentField(s)
	}
}

func (p *MySqlParser) AssignmentField() (localctx IAssignmentFieldContext) {
	this := p
	_ = this

	localctx = NewAssignmentFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, MySqlParserRULE_assignmentField)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3505)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID, MySqlParserREVERSE_QUOTE_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3503)
			p.Uid()
		}

	case MySqlParserLOCAL_ID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3504)
			p.Match(MySqlParserLOCAL_ID)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILockClauseContext is an interface to support dynamic dispatch.
type ILockClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	LOCK() antlr.TerminalNode
	IN() antlr.TerminalNode
	SHARE() antlr.TerminalNode
	MODE() antlr.TerminalNode

	// IsLockClauseContext differentiates from other interfaces.
	IsLockClauseContext()
}

type LockClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLockClauseContext() *LockClauseContext {
	var p = new(LockClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_lockClause
	return p
}

func (*LockClauseContext) IsLockClauseContext() {}

func NewLockClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockClauseContext {
	var p = new(LockClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_lockClause

	return p
}

func (s *LockClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LockClauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *LockClauseContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPDATE, 0)
}

func (s *LockClauseContext) LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCK, 0)
}

func (s *LockClauseContext) IN() antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, 0)
}

func (s *LockClauseContext) SHARE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHARE, 0)
}

func (s *LockClauseContext) MODE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMODE, 0)
}

func (s *LockClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LockClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLockClause(s)
	}
}

func (s *LockClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLockClause(s)
	}
}

func (p *MySqlParser) LockClause() (localctx ILockClauseContext) {
	this := p
	_ = this

	localctx = NewLockClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, MySqlParserRULE_lockClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3513)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserFOR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3507)
			p.Match(MySqlParserFOR)
		}
		{
			p.SetState(3508)
			p.Match(MySqlParserUPDATE)
		}

	case MySqlParserLOCK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3509)
			p.Match(MySqlParserLOCK)
		}
		{
			p.SetState(3510)
			p.Match(MySqlParserIN)
		}
		{
			p.SetState(3511)
			p.Match(MySqlParserSHARE)
		}
		{
			p.SetState(3512)
			p.Match(MySqlParserMODE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISingleDeleteStatementContext is an interface to support dynamic dispatch.
type ISingleDeleteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPriority returns the priority token.
	GetPriority() antlr.Token

	// SetPriority sets the priority token.
	SetPriority(antlr.Token)

	// Getter signatures
	DELETE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	TableName() ITableNameContext
	QUICK() antlr.TerminalNode
	IGNORE() antlr.TerminalNode
	Uid() IUidContext
	PARTITION() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	UidList() IUidListContext
	RR_BRACKET() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	OrderByClause() IOrderByClauseContext
	LIMIT() antlr.TerminalNode
	LimitClauseAtom() ILimitClauseAtomContext
	LOW_PRIORITY() antlr.TerminalNode
	AS() antlr.TerminalNode

	// IsSingleDeleteStatementContext differentiates from other interfaces.
	IsSingleDeleteStatementContext()
}

type SingleDeleteStatementContext struct {
	*antlr.BaseParserRuleContext
	parser   antlr.Parser
	priority antlr.Token
}

func NewEmptySingleDeleteStatementContext() *SingleDeleteStatementContext {
	var p = new(SingleDeleteStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_singleDeleteStatement
	return p
}

func (*SingleDeleteStatementContext) IsSingleDeleteStatementContext() {}

func NewSingleDeleteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleDeleteStatementContext {
	var p = new(SingleDeleteStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_singleDeleteStatement

	return p
}

func (s *SingleDeleteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleDeleteStatementContext) GetPriority() antlr.Token { return s.priority }

func (s *SingleDeleteStatementContext) SetPriority(v antlr.Token) { s.priority = v }

func (s *SingleDeleteStatementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDELETE, 0)
}

func (s *SingleDeleteStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *SingleDeleteStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *SingleDeleteStatementContext) QUICK() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUICK, 0)
}

func (s *SingleDeleteStatementContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE, 0)
}

func (s *SingleDeleteStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SingleDeleteStatementContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *SingleDeleteStatementContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *SingleDeleteStatementContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *SingleDeleteStatementContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *SingleDeleteStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWHERE, 0)
}

func (s *SingleDeleteStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SingleDeleteStatementContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *SingleDeleteStatementContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIMIT, 0)
}

func (s *SingleDeleteStatementContext) LimitClauseAtom() ILimitClauseAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseAtomContext)
}

func (s *SingleDeleteStatementContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOW_PRIORITY, 0)
}

func (s *SingleDeleteStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *SingleDeleteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleDeleteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleDeleteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSingleDeleteStatement(s)
	}
}

func (s *SingleDeleteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSingleDeleteStatement(s)
	}
}

func (p *MySqlParser) SingleDeleteStatement() (localctx ISingleDeleteStatementContext) {
	this := p
	_ = this

	localctx = NewSingleDeleteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, MySqlParserRULE_singleDeleteStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3515)
		p.Match(MySqlParserDELETE)
	}
	p.SetState(3517)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserLOW_PRIORITY {
		{
			p.SetState(3516)

			var _m = p.Match(MySqlParserLOW_PRIORITY)

			localctx.(*SingleDeleteStatementContext).priority = _m
		}

	}
	p.SetState(3520)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserQUICK {
		{
			p.SetState(3519)
			p.Match(MySqlParserQUICK)
		}

	}
	p.SetState(3523)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserIGNORE {
		{
			p.SetState(3522)
			p.Match(MySqlParserIGNORE)
		}

	}
	{
		p.SetState(3525)
		p.Match(MySqlParserFROM)
	}
	{
		p.SetState(3526)
		p.TableName()
	}
	p.SetState(3531)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 489, p.GetParserRuleContext()) == 1 {
		p.SetState(3528)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserAS {
			{
				p.SetState(3527)
				p.Match(MySqlParserAS)
			}

		}
		{
			p.SetState(3530)
			p.Uid()
		}

	}
	p.SetState(3538)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserPARTITION {
		{
			p.SetState(3533)
			p.Match(MySqlParserPARTITION)
		}
		{
			p.SetState(3534)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(3535)
			p.UidList()
		}
		{
			p.SetState(3536)
			p.Match(MySqlParserRR_BRACKET)
		}

	}
	p.SetState(3542)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserWHERE {
		{
			p.SetState(3540)
			p.Match(MySqlParserWHERE)
		}
		{
			p.SetState(3541)
			p.expression(0)
		}

	}
	p.SetState(3545)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserORDER {
		{
			p.SetState(3544)
			p.OrderByClause()
		}

	}
	p.SetState(3549)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserLIMIT {
		{
			p.SetState(3547)
			p.Match(MySqlParserLIMIT)
		}
		{
			p.SetState(3548)
			p.LimitClauseAtom()
		}

	}

	return localctx
}

// IMultipleDeleteStatementContext is an interface to support dynamic dispatch.
type IMultipleDeleteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPriority returns the priority token.
	GetPriority() antlr.Token

	// SetPriority sets the priority token.
	SetPriority(antlr.Token)

	// Getter signatures
	DELETE() antlr.TerminalNode
	AllTableName() []ITableNameContext
	TableName(i int) ITableNameContext
	FROM() antlr.TerminalNode
	TableSources() ITableSourcesContext
	USING() antlr.TerminalNode
	QUICK() antlr.TerminalNode
	IGNORE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	LOW_PRIORITY() antlr.TerminalNode
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	AllSTAR() []antlr.TerminalNode
	STAR(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsMultipleDeleteStatementContext differentiates from other interfaces.
	IsMultipleDeleteStatementContext()
}

type MultipleDeleteStatementContext struct {
	*antlr.BaseParserRuleContext
	parser   antlr.Parser
	priority antlr.Token
}

func NewEmptyMultipleDeleteStatementContext() *MultipleDeleteStatementContext {
	var p = new(MultipleDeleteStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_multipleDeleteStatement
	return p
}

func (*MultipleDeleteStatementContext) IsMultipleDeleteStatementContext() {}

func NewMultipleDeleteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultipleDeleteStatementContext {
	var p = new(MultipleDeleteStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_multipleDeleteStatement

	return p
}

func (s *MultipleDeleteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MultipleDeleteStatementContext) GetPriority() antlr.Token { return s.priority }

func (s *MultipleDeleteStatementContext) SetPriority(v antlr.Token) { s.priority = v }

func (s *MultipleDeleteStatementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDELETE, 0)
}

func (s *MultipleDeleteStatementContext) AllTableName() []ITableNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableNameContext); ok {
			len++
		}
	}

	tst := make([]ITableNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableNameContext); ok {
			tst[i] = t.(ITableNameContext)
			i++
		}
	}

	return tst
}

func (s *MultipleDeleteStatementContext) TableName(i int) ITableNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *MultipleDeleteStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *MultipleDeleteStatementContext) TableSources() ITableSourcesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourcesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourcesContext)
}

func (s *MultipleDeleteStatementContext) USING() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSING, 0)
}

func (s *MultipleDeleteStatementContext) QUICK() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUICK, 0)
}

func (s *MultipleDeleteStatementContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE, 0)
}

func (s *MultipleDeleteStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWHERE, 0)
}

func (s *MultipleDeleteStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MultipleDeleteStatementContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOW_PRIORITY, 0)
}

func (s *MultipleDeleteStatementContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserDOT)
}

func (s *MultipleDeleteStatementContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT, i)
}

func (s *MultipleDeleteStatementContext) AllSTAR() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSTAR)
}

func (s *MultipleDeleteStatementContext) STAR(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSTAR, i)
}

func (s *MultipleDeleteStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *MultipleDeleteStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *MultipleDeleteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipleDeleteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultipleDeleteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMultipleDeleteStatement(s)
	}
}

func (s *MultipleDeleteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMultipleDeleteStatement(s)
	}
}

func (p *MySqlParser) MultipleDeleteStatement() (localctx IMultipleDeleteStatementContext) {
	this := p
	_ = this

	localctx = NewMultipleDeleteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, MySqlParserRULE_multipleDeleteStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3551)
		p.Match(MySqlParserDELETE)
	}
	p.SetState(3553)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserLOW_PRIORITY {
		{
			p.SetState(3552)

			var _m = p.Match(MySqlParserLOW_PRIORITY)

			localctx.(*MultipleDeleteStatementContext).priority = _m
		}

	}
	p.SetState(3556)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 495, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3555)
			p.Match(MySqlParserQUICK)
		}

	}
	p.SetState(3559)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserIGNORE {
		{
			p.SetState(3558)
			p.Match(MySqlParserIGNORE)
		}

	}
	p.SetState(3600)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID, MySqlParserREVERSE_QUOTE_ID:
		{
			p.SetState(3561)
			p.TableName()
		}
		p.SetState(3564)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserDOT {
			{
				p.SetState(3562)
				p.Match(MySqlParserDOT)
			}
			{
				p.SetState(3563)
				p.Match(MySqlParserSTAR)
			}

		}
		p.SetState(3574)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(3566)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(3567)
				p.TableName()
			}
			p.SetState(3570)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserDOT {
				{
					p.SetState(3568)
					p.Match(MySqlParserDOT)
				}
				{
					p.SetState(3569)
					p.Match(MySqlParserSTAR)
				}

			}

			p.SetState(3576)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3577)
			p.Match(MySqlParserFROM)
		}
		{
			p.SetState(3578)
			p.TableSources()
		}

	case MySqlParserFROM:
		{
			p.SetState(3580)
			p.Match(MySqlParserFROM)
		}
		{
			p.SetState(3581)
			p.TableName()
		}
		p.SetState(3584)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserDOT {
			{
				p.SetState(3582)
				p.Match(MySqlParserDOT)
			}
			{
				p.SetState(3583)
				p.Match(MySqlParserSTAR)
			}

		}
		p.SetState(3594)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(3586)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(3587)
				p.TableName()
			}
			p.SetState(3590)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserDOT {
				{
					p.SetState(3588)
					p.Match(MySqlParserDOT)
				}
				{
					p.SetState(3589)
					p.Match(MySqlParserSTAR)
				}

			}

			p.SetState(3596)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3597)
			p.Match(MySqlParserUSING)
		}
		{
			p.SetState(3598)
			p.TableSources()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(3604)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserWHERE {
		{
			p.SetState(3602)
			p.Match(MySqlParserWHERE)
		}
		{
			p.SetState(3603)
			p.expression(0)
		}

	}

	return localctx
}

// IHandlerOpenStatementContext is an interface to support dynamic dispatch.
type IHandlerOpenStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HANDLER() antlr.TerminalNode
	TableName() ITableNameContext
	OPEN() antlr.TerminalNode
	Uid() IUidContext
	AS() antlr.TerminalNode

	// IsHandlerOpenStatementContext differentiates from other interfaces.
	IsHandlerOpenStatementContext()
}

type HandlerOpenStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHandlerOpenStatementContext() *HandlerOpenStatementContext {
	var p = new(HandlerOpenStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_handlerOpenStatement
	return p
}

func (*HandlerOpenStatementContext) IsHandlerOpenStatementContext() {}

func NewHandlerOpenStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HandlerOpenStatementContext {
	var p = new(HandlerOpenStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_handlerOpenStatement

	return p
}

func (s *HandlerOpenStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HandlerOpenStatementContext) HANDLER() antlr.TerminalNode {
	return s.GetToken(MySqlParserHANDLER, 0)
}

func (s *HandlerOpenStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *HandlerOpenStatementContext) OPEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPEN, 0)
}

func (s *HandlerOpenStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *HandlerOpenStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *HandlerOpenStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerOpenStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HandlerOpenStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHandlerOpenStatement(s)
	}
}

func (s *HandlerOpenStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHandlerOpenStatement(s)
	}
}

func (p *MySqlParser) HandlerOpenStatement() (localctx IHandlerOpenStatementContext) {
	this := p
	_ = this

	localctx = NewHandlerOpenStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, MySqlParserRULE_handlerOpenStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3606)
		p.Match(MySqlParserHANDLER)
	}
	{
		p.SetState(3607)
		p.TableName()
	}
	{
		p.SetState(3608)
		p.Match(MySqlParserOPEN)
	}
	p.SetState(3613)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 506, p.GetParserRuleContext()) == 1 {
		p.SetState(3610)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserAS {
			{
				p.SetState(3609)
				p.Match(MySqlParserAS)
			}

		}
		{
			p.SetState(3612)
			p.Uid()
		}

	}

	return localctx
}

// IHandlerReadIndexStatementContext is an interface to support dynamic dispatch.
type IHandlerReadIndexStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMoveOrder returns the moveOrder token.
	GetMoveOrder() antlr.Token

	// SetMoveOrder sets the moveOrder token.
	SetMoveOrder(antlr.Token)

	// GetIndex returns the index rule contexts.
	GetIndex() IUidContext

	// SetIndex sets the index rule contexts.
	SetIndex(IUidContext)

	// Getter signatures
	HANDLER() antlr.TerminalNode
	TableName() ITableNameContext
	READ() antlr.TerminalNode
	Uid() IUidContext
	ComparisonOperator() IComparisonOperatorContext
	LR_BRACKET() antlr.TerminalNode
	Constants() IConstantsContext
	RR_BRACKET() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	LIMIT() antlr.TerminalNode
	LimitClauseAtom() ILimitClauseAtomContext
	FIRST() antlr.TerminalNode
	NEXT() antlr.TerminalNode
	PREV() antlr.TerminalNode
	LAST() antlr.TerminalNode

	// IsHandlerReadIndexStatementContext differentiates from other interfaces.
	IsHandlerReadIndexStatementContext()
}

type HandlerReadIndexStatementContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	index     IUidContext
	moveOrder antlr.Token
}

func NewEmptyHandlerReadIndexStatementContext() *HandlerReadIndexStatementContext {
	var p = new(HandlerReadIndexStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_handlerReadIndexStatement
	return p
}

func (*HandlerReadIndexStatementContext) IsHandlerReadIndexStatementContext() {}

func NewHandlerReadIndexStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HandlerReadIndexStatementContext {
	var p = new(HandlerReadIndexStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_handlerReadIndexStatement

	return p
}

func (s *HandlerReadIndexStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HandlerReadIndexStatementContext) GetMoveOrder() antlr.Token { return s.moveOrder }

func (s *HandlerReadIndexStatementContext) SetMoveOrder(v antlr.Token) { s.moveOrder = v }

func (s *HandlerReadIndexStatementContext) GetIndex() IUidContext { return s.index }

func (s *HandlerReadIndexStatementContext) SetIndex(v IUidContext) { s.index = v }

func (s *HandlerReadIndexStatementContext) HANDLER() antlr.TerminalNode {
	return s.GetToken(MySqlParserHANDLER, 0)
}

func (s *HandlerReadIndexStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *HandlerReadIndexStatementContext) READ() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAD, 0)
}

func (s *HandlerReadIndexStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *HandlerReadIndexStatementContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *HandlerReadIndexStatementContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *HandlerReadIndexStatementContext) Constants() IConstantsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantsContext)
}

func (s *HandlerReadIndexStatementContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *HandlerReadIndexStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWHERE, 0)
}

func (s *HandlerReadIndexStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *HandlerReadIndexStatementContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIMIT, 0)
}

func (s *HandlerReadIndexStatementContext) LimitClauseAtom() ILimitClauseAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseAtomContext)
}

func (s *HandlerReadIndexStatementContext) FIRST() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIRST, 0)
}

func (s *HandlerReadIndexStatementContext) NEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNEXT, 0)
}

func (s *HandlerReadIndexStatementContext) PREV() antlr.TerminalNode {
	return s.GetToken(MySqlParserPREV, 0)
}

func (s *HandlerReadIndexStatementContext) LAST() antlr.TerminalNode {
	return s.GetToken(MySqlParserLAST, 0)
}

func (s *HandlerReadIndexStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerReadIndexStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HandlerReadIndexStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHandlerReadIndexStatement(s)
	}
}

func (s *HandlerReadIndexStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHandlerReadIndexStatement(s)
	}
}

func (p *MySqlParser) HandlerReadIndexStatement() (localctx IHandlerReadIndexStatementContext) {
	this := p
	_ = this

	localctx = NewHandlerReadIndexStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, MySqlParserRULE_handlerReadIndexStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3615)
		p.Match(MySqlParserHANDLER)
	}
	{
		p.SetState(3616)
		p.TableName()
	}
	{
		p.SetState(3617)
		p.Match(MySqlParserREAD)
	}
	{
		p.SetState(3618)

		var _x = p.Uid()

		localctx.(*HandlerReadIndexStatementContext).index = _x
	}
	p.SetState(3625)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserEQUAL_SYMBOL, MySqlParserGREATER_SYMBOL, MySqlParserLESS_SYMBOL, MySqlParserEXCLAMATION_SYMBOL:
		{
			p.SetState(3619)
			p.ComparisonOperator()
		}
		{
			p.SetState(3620)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(3621)
			p.Constants()
		}
		{
			p.SetState(3622)
			p.Match(MySqlParserRR_BRACKET)
		}

	case MySqlParserFIRST, MySqlParserLAST, MySqlParserNEXT, MySqlParserPREV:
		{
			p.SetState(3624)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*HandlerReadIndexStatementContext).moveOrder = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFIRST || _la == MySqlParserLAST || _la == MySqlParserNEXT || _la == MySqlParserPREV) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*HandlerReadIndexStatementContext).moveOrder = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(3629)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserWHERE {
		{
			p.SetState(3627)
			p.Match(MySqlParserWHERE)
		}
		{
			p.SetState(3628)
			p.expression(0)
		}

	}
	p.SetState(3633)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserLIMIT {
		{
			p.SetState(3631)
			p.Match(MySqlParserLIMIT)
		}
		{
			p.SetState(3632)
			p.LimitClauseAtom()
		}

	}

	return localctx
}

// IHandlerReadStatementContext is an interface to support dynamic dispatch.
type IHandlerReadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMoveOrder returns the moveOrder token.
	GetMoveOrder() antlr.Token

	// SetMoveOrder sets the moveOrder token.
	SetMoveOrder(antlr.Token)

	// Getter signatures
	HANDLER() antlr.TerminalNode
	TableName() ITableNameContext
	READ() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	NEXT() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	LIMIT() antlr.TerminalNode
	LimitClauseAtom() ILimitClauseAtomContext

	// IsHandlerReadStatementContext differentiates from other interfaces.
	IsHandlerReadStatementContext()
}

type HandlerReadStatementContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	moveOrder antlr.Token
}

func NewEmptyHandlerReadStatementContext() *HandlerReadStatementContext {
	var p = new(HandlerReadStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_handlerReadStatement
	return p
}

func (*HandlerReadStatementContext) IsHandlerReadStatementContext() {}

func NewHandlerReadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HandlerReadStatementContext {
	var p = new(HandlerReadStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_handlerReadStatement

	return p
}

func (s *HandlerReadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HandlerReadStatementContext) GetMoveOrder() antlr.Token { return s.moveOrder }

func (s *HandlerReadStatementContext) SetMoveOrder(v antlr.Token) { s.moveOrder = v }

func (s *HandlerReadStatementContext) HANDLER() antlr.TerminalNode {
	return s.GetToken(MySqlParserHANDLER, 0)
}

func (s *HandlerReadStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *HandlerReadStatementContext) READ() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAD, 0)
}

func (s *HandlerReadStatementContext) FIRST() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIRST, 0)
}

func (s *HandlerReadStatementContext) NEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNEXT, 0)
}

func (s *HandlerReadStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWHERE, 0)
}

func (s *HandlerReadStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *HandlerReadStatementContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIMIT, 0)
}

func (s *HandlerReadStatementContext) LimitClauseAtom() ILimitClauseAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseAtomContext)
}

func (s *HandlerReadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerReadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HandlerReadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHandlerReadStatement(s)
	}
}

func (s *HandlerReadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHandlerReadStatement(s)
	}
}

func (p *MySqlParser) HandlerReadStatement() (localctx IHandlerReadStatementContext) {
	this := p
	_ = this

	localctx = NewHandlerReadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, MySqlParserRULE_handlerReadStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3635)
		p.Match(MySqlParserHANDLER)
	}
	{
		p.SetState(3636)
		p.TableName()
	}
	{
		p.SetState(3637)
		p.Match(MySqlParserREAD)
	}
	{
		p.SetState(3638)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*HandlerReadStatementContext).moveOrder = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserFIRST || _la == MySqlParserNEXT) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*HandlerReadStatementContext).moveOrder = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3641)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserWHERE {
		{
			p.SetState(3639)
			p.Match(MySqlParserWHERE)
		}
		{
			p.SetState(3640)
			p.expression(0)
		}

	}
	p.SetState(3645)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserLIMIT {
		{
			p.SetState(3643)
			p.Match(MySqlParserLIMIT)
		}
		{
			p.SetState(3644)
			p.LimitClauseAtom()
		}

	}

	return localctx
}

// IHandlerCloseStatementContext is an interface to support dynamic dispatch.
type IHandlerCloseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HANDLER() antlr.TerminalNode
	TableName() ITableNameContext
	CLOSE() antlr.TerminalNode

	// IsHandlerCloseStatementContext differentiates from other interfaces.
	IsHandlerCloseStatementContext()
}

type HandlerCloseStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHandlerCloseStatementContext() *HandlerCloseStatementContext {
	var p = new(HandlerCloseStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_handlerCloseStatement
	return p
}

func (*HandlerCloseStatementContext) IsHandlerCloseStatementContext() {}

func NewHandlerCloseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HandlerCloseStatementContext {
	var p = new(HandlerCloseStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_handlerCloseStatement

	return p
}

func (s *HandlerCloseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HandlerCloseStatementContext) HANDLER() antlr.TerminalNode {
	return s.GetToken(MySqlParserHANDLER, 0)
}

func (s *HandlerCloseStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *HandlerCloseStatementContext) CLOSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCLOSE, 0)
}

func (s *HandlerCloseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerCloseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HandlerCloseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHandlerCloseStatement(s)
	}
}

func (s *HandlerCloseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHandlerCloseStatement(s)
	}
}

func (p *MySqlParser) HandlerCloseStatement() (localctx IHandlerCloseStatementContext) {
	this := p
	_ = this

	localctx = NewHandlerCloseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, MySqlParserRULE_handlerCloseStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3647)
		p.Match(MySqlParserHANDLER)
	}
	{
		p.SetState(3648)
		p.TableName()
	}
	{
		p.SetState(3649)
		p.Match(MySqlParserCLOSE)
	}

	return localctx
}

// ISingleUpdateStatementContext is an interface to support dynamic dispatch.
type ISingleUpdateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPriority returns the priority token.
	GetPriority() antlr.Token

	// SetPriority sets the priority token.
	SetPriority(antlr.Token)

	// Getter signatures
	UPDATE() antlr.TerminalNode
	TableName() ITableNameContext
	SET() antlr.TerminalNode
	AllUpdatedElement() []IUpdatedElementContext
	UpdatedElement(i int) IUpdatedElementContext
	IGNORE() antlr.TerminalNode
	Uid() IUidContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	OrderByClause() IOrderByClauseContext
	LimitClause() ILimitClauseContext
	LOW_PRIORITY() antlr.TerminalNode
	AS() antlr.TerminalNode

	// IsSingleUpdateStatementContext differentiates from other interfaces.
	IsSingleUpdateStatementContext()
}

type SingleUpdateStatementContext struct {
	*antlr.BaseParserRuleContext
	parser   antlr.Parser
	priority antlr.Token
}

func NewEmptySingleUpdateStatementContext() *SingleUpdateStatementContext {
	var p = new(SingleUpdateStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_singleUpdateStatement
	return p
}

func (*SingleUpdateStatementContext) IsSingleUpdateStatementContext() {}

func NewSingleUpdateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleUpdateStatementContext {
	var p = new(SingleUpdateStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_singleUpdateStatement

	return p
}

func (s *SingleUpdateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleUpdateStatementContext) GetPriority() antlr.Token { return s.priority }

func (s *SingleUpdateStatementContext) SetPriority(v antlr.Token) { s.priority = v }

func (s *SingleUpdateStatementContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPDATE, 0)
}

func (s *SingleUpdateStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *SingleUpdateStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *SingleUpdateStatementContext) AllUpdatedElement() []IUpdatedElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			len++
		}
	}

	tst := make([]IUpdatedElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdatedElementContext); ok {
			tst[i] = t.(IUpdatedElementContext)
			i++
		}
	}

	return tst
}

func (s *SingleUpdateStatementContext) UpdatedElement(i int) IUpdatedElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdatedElementContext)
}

func (s *SingleUpdateStatementContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE, 0)
}

func (s *SingleUpdateStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SingleUpdateStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *SingleUpdateStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *SingleUpdateStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWHERE, 0)
}

func (s *SingleUpdateStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SingleUpdateStatementContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *SingleUpdateStatementContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *SingleUpdateStatementContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOW_PRIORITY, 0)
}

func (s *SingleUpdateStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *SingleUpdateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleUpdateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleUpdateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSingleUpdateStatement(s)
	}
}

func (s *SingleUpdateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSingleUpdateStatement(s)
	}
}

func (p *MySqlParser) SingleUpdateStatement() (localctx ISingleUpdateStatementContext) {
	this := p
	_ = this

	localctx = NewSingleUpdateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, MySqlParserRULE_singleUpdateStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3651)
		p.Match(MySqlParserUPDATE)
	}
	p.SetState(3653)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserLOW_PRIORITY {
		{
			p.SetState(3652)

			var _m = p.Match(MySqlParserLOW_PRIORITY)

			localctx.(*SingleUpdateStatementContext).priority = _m
		}

	}
	p.SetState(3656)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserIGNORE {
		{
			p.SetState(3655)
			p.Match(MySqlParserIGNORE)
		}

	}
	{
		p.SetState(3658)
		p.TableName()
	}
	p.SetState(3663)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&756891332513124352) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&146666055071174737) != 0) || ((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&134349441) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-2882305960540372993) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-4398063288321) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-16325548649218049) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-81064793296864001) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-68719476801) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-11118270170269697) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-33) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-3073) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&144115188075855871) != 0) || ((int64((_la-1121)) & ^0x3f) == 0 && ((int64(1)<<(_la-1121))&25807552513) != 0) {
		p.SetState(3660)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserAS {
			{
				p.SetState(3659)
				p.Match(MySqlParserAS)
			}

		}
		{
			p.SetState(3662)
			p.Uid()
		}

	}
	{
		p.SetState(3665)
		p.Match(MySqlParserSET)
	}
	{
		p.SetState(3666)
		p.UpdatedElement()
	}
	p.SetState(3671)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(3667)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(3668)
			p.UpdatedElement()
		}

		p.SetState(3673)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3676)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserWHERE {
		{
			p.SetState(3674)
			p.Match(MySqlParserWHERE)
		}
		{
			p.SetState(3675)
			p.expression(0)
		}

	}
	p.SetState(3679)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserORDER {
		{
			p.SetState(3678)
			p.OrderByClause()
		}

	}
	p.SetState(3682)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserLIMIT {
		{
			p.SetState(3681)
			p.LimitClause()
		}

	}

	return localctx
}

// IMultipleUpdateStatementContext is an interface to support dynamic dispatch.
type IMultipleUpdateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPriority returns the priority token.
	GetPriority() antlr.Token

	// SetPriority sets the priority token.
	SetPriority(antlr.Token)

	// Getter signatures
	UPDATE() antlr.TerminalNode
	TableSources() ITableSourcesContext
	SET() antlr.TerminalNode
	AllUpdatedElement() []IUpdatedElementContext
	UpdatedElement(i int) IUpdatedElementContext
	IGNORE() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	LOW_PRIORITY() antlr.TerminalNode

	// IsMultipleUpdateStatementContext differentiates from other interfaces.
	IsMultipleUpdateStatementContext()
}

type MultipleUpdateStatementContext struct {
	*antlr.BaseParserRuleContext
	parser   antlr.Parser
	priority antlr.Token
}

func NewEmptyMultipleUpdateStatementContext() *MultipleUpdateStatementContext {
	var p = new(MultipleUpdateStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_multipleUpdateStatement
	return p
}

func (*MultipleUpdateStatementContext) IsMultipleUpdateStatementContext() {}

func NewMultipleUpdateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultipleUpdateStatementContext {
	var p = new(MultipleUpdateStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_multipleUpdateStatement

	return p
}

func (s *MultipleUpdateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MultipleUpdateStatementContext) GetPriority() antlr.Token { return s.priority }

func (s *MultipleUpdateStatementContext) SetPriority(v antlr.Token) { s.priority = v }

func (s *MultipleUpdateStatementContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPDATE, 0)
}

func (s *MultipleUpdateStatementContext) TableSources() ITableSourcesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourcesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourcesContext)
}

func (s *MultipleUpdateStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *MultipleUpdateStatementContext) AllUpdatedElement() []IUpdatedElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			len++
		}
	}

	tst := make([]IUpdatedElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdatedElementContext); ok {
			tst[i] = t.(IUpdatedElementContext)
			i++
		}
	}

	return tst
}

func (s *MultipleUpdateStatementContext) UpdatedElement(i int) IUpdatedElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdatedElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdatedElementContext)
}

func (s *MultipleUpdateStatementContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE, 0)
}

func (s *MultipleUpdateStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *MultipleUpdateStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *MultipleUpdateStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWHERE, 0)
}

func (s *MultipleUpdateStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MultipleUpdateStatementContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOW_PRIORITY, 0)
}

func (s *MultipleUpdateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipleUpdateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultipleUpdateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMultipleUpdateStatement(s)
	}
}

func (s *MultipleUpdateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMultipleUpdateStatement(s)
	}
}

func (p *MySqlParser) MultipleUpdateStatement() (localctx IMultipleUpdateStatementContext) {
	this := p
	_ = this

	localctx = NewMultipleUpdateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, MySqlParserRULE_multipleUpdateStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3684)
		p.Match(MySqlParserUPDATE)
	}
	p.SetState(3686)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserLOW_PRIORITY {
		{
			p.SetState(3685)

			var _m = p.Match(MySqlParserLOW_PRIORITY)

			localctx.(*MultipleUpdateStatementContext).priority = _m
		}

	}
	p.SetState(3689)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserIGNORE {
		{
			p.SetState(3688)
			p.Match(MySqlParserIGNORE)
		}

	}
	{
		p.SetState(3691)
		p.TableSources()
	}
	{
		p.SetState(3692)
		p.Match(MySqlParserSET)
	}
	{
		p.SetState(3693)
		p.UpdatedElement()
	}
	p.SetState(3698)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(3694)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(3695)
			p.UpdatedElement()
		}

		p.SetState(3700)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3703)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserWHERE {
		{
			p.SetState(3701)
			p.Match(MySqlParserWHERE)
		}
		{
			p.SetState(3702)
			p.expression(0)
		}

	}

	return localctx
}

// IOrderByClauseContext is an interface to support dynamic dispatch.
type IOrderByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllOrderByExpression() []IOrderByExpressionContext
	OrderByExpression(i int) IOrderByExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsOrderByClauseContext differentiates from other interfaces.
	IsOrderByClauseContext()
}

type OrderByClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderByClauseContext() *OrderByClauseContext {
	var p = new(OrderByClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_orderByClause
	return p
}

func (*OrderByClauseContext) IsOrderByClauseContext() {}

func NewOrderByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderByClauseContext {
	var p = new(OrderByClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_orderByClause

	return p
}

func (s *OrderByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderByClauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(MySqlParserORDER, 0)
}

func (s *OrderByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *OrderByClauseContext) AllOrderByExpression() []IOrderByExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOrderByExpressionContext); ok {
			len++
		}
	}

	tst := make([]IOrderByExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOrderByExpressionContext); ok {
			tst[i] = t.(IOrderByExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OrderByClauseContext) OrderByExpression(i int) IOrderByExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByExpressionContext)
}

func (s *OrderByClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *OrderByClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *OrderByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterOrderByClause(s)
	}
}

func (s *OrderByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitOrderByClause(s)
	}
}

func (p *MySqlParser) OrderByClause() (localctx IOrderByClauseContext) {
	this := p
	_ = this

	localctx = NewOrderByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, MySqlParserRULE_orderByClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3705)
		p.Match(MySqlParserORDER)
	}
	{
		p.SetState(3706)
		p.Match(MySqlParserBY)
	}
	{
		p.SetState(3707)
		p.OrderByExpression()
	}
	p.SetState(3712)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 524, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3708)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(3709)
				p.OrderByExpression()
			}

		}
		p.SetState(3714)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 524, p.GetParserRuleContext())
	}

	return localctx
}

// IOrderByExpressionContext is an interface to support dynamic dispatch.
type IOrderByExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOrder returns the order token.
	GetOrder() antlr.Token

	// SetOrder sets the order token.
	SetOrder(antlr.Token)

	// Getter signatures
	Expression() IExpressionContext
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode

	// IsOrderByExpressionContext differentiates from other interfaces.
	IsOrderByExpressionContext()
}

type OrderByExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	order  antlr.Token
}

func NewEmptyOrderByExpressionContext() *OrderByExpressionContext {
	var p = new(OrderByExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_orderByExpression
	return p
}

func (*OrderByExpressionContext) IsOrderByExpressionContext() {}

func NewOrderByExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderByExpressionContext {
	var p = new(OrderByExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_orderByExpression

	return p
}

func (s *OrderByExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderByExpressionContext) GetOrder() antlr.Token { return s.order }

func (s *OrderByExpressionContext) SetOrder(v antlr.Token) { s.order = v }

func (s *OrderByExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *OrderByExpressionContext) ASC() antlr.TerminalNode {
	return s.GetToken(MySqlParserASC, 0)
}

func (s *OrderByExpressionContext) DESC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDESC, 0)
}

func (s *OrderByExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderByExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderByExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterOrderByExpression(s)
	}
}

func (s *OrderByExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitOrderByExpression(s)
	}
}

func (p *MySqlParser) OrderByExpression() (localctx IOrderByExpressionContext) {
	this := p
	_ = this

	localctx = NewOrderByExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, MySqlParserRULE_orderByExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3715)
		p.expression(0)
	}
	p.SetState(3717)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 525, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3716)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*OrderByExpressionContext).order = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserASC || _la == MySqlParserDESC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*OrderByExpressionContext).order = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// ITableSourcesContext is an interface to support dynamic dispatch.
type ITableSourcesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTableSource() []ITableSourceContext
	TableSource(i int) ITableSourceContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTableSourcesContext differentiates from other interfaces.
	IsTableSourcesContext()
}

type TableSourcesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableSourcesContext() *TableSourcesContext {
	var p = new(TableSourcesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_tableSources
	return p
}

func (*TableSourcesContext) IsTableSourcesContext() {}

func NewTableSourcesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableSourcesContext {
	var p = new(TableSourcesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tableSources

	return p
}

func (s *TableSourcesContext) GetParser() antlr.Parser { return s.parser }

func (s *TableSourcesContext) AllTableSource() []ITableSourceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableSourceContext); ok {
			len++
		}
	}

	tst := make([]ITableSourceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableSourceContext); ok {
			tst[i] = t.(ITableSourceContext)
			i++
		}
	}

	return tst
}

func (s *TableSourcesContext) TableSource(i int) ITableSourceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourceContext)
}

func (s *TableSourcesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *TableSourcesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *TableSourcesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSourcesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableSourcesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableSources(s)
	}
}

func (s *TableSourcesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableSources(s)
	}
}

func (p *MySqlParser) TableSources() (localctx ITableSourcesContext) {
	this := p
	_ = this

	localctx = NewTableSourcesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, MySqlParserRULE_tableSources)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3719)
		p.TableSource()
	}
	p.SetState(3724)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 526, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3720)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(3721)
				p.TableSource()
			}

		}
		p.SetState(3726)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 526, p.GetParserRuleContext())
	}

	return localctx
}

// ITableSourceContext is an interface to support dynamic dispatch.
type ITableSourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTableSourceContext differentiates from other interfaces.
	IsTableSourceContext()
}

type TableSourceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableSourceContext() *TableSourceContext {
	var p = new(TableSourceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_tableSource
	return p
}

func (*TableSourceContext) IsTableSourceContext() {}

func NewTableSourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableSourceContext {
	var p = new(TableSourceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tableSource

	return p
}

func (s *TableSourceContext) GetParser() antlr.Parser { return s.parser }

func (s *TableSourceContext) CopyFrom(ctx *TableSourceContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *TableSourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TableJsonContext struct {
	*TableSourceContext
}

func NewTableJsonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableJsonContext {
	var p = new(TableJsonContext)

	p.TableSourceContext = NewEmptyTableSourceContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableSourceContext))

	return p
}

func (s *TableJsonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableJsonContext) JsonTable() IJsonTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonTableContext)
}

func (s *TableJsonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableJson(s)
	}
}

func (s *TableJsonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableJson(s)
	}
}

type TableSourceNestedContext struct {
	*TableSourceContext
}

func NewTableSourceNestedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableSourceNestedContext {
	var p = new(TableSourceNestedContext)

	p.TableSourceContext = NewEmptyTableSourceContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableSourceContext))

	return p
}

func (s *TableSourceNestedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSourceNestedContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *TableSourceNestedContext) TableSourceItem() ITableSourceItemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourceItemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourceItemContext)
}

func (s *TableSourceNestedContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *TableSourceNestedContext) AllJoinPart() []IJoinPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinPartContext); ok {
			len++
		}
	}

	tst := make([]IJoinPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinPartContext); ok {
			tst[i] = t.(IJoinPartContext)
			i++
		}
	}

	return tst
}

func (s *TableSourceNestedContext) JoinPart(i int) IJoinPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinPartContext)
}

func (s *TableSourceNestedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableSourceNested(s)
	}
}

func (s *TableSourceNestedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableSourceNested(s)
	}
}

type TableSourceBaseContext struct {
	*TableSourceContext
}

func NewTableSourceBaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableSourceBaseContext {
	var p = new(TableSourceBaseContext)

	p.TableSourceContext = NewEmptyTableSourceContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableSourceContext))

	return p
}

func (s *TableSourceBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSourceBaseContext) TableSourceItem() ITableSourceItemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourceItemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourceItemContext)
}

func (s *TableSourceBaseContext) AllJoinPart() []IJoinPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinPartContext); ok {
			len++
		}
	}

	tst := make([]IJoinPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinPartContext); ok {
			tst[i] = t.(IJoinPartContext)
			i++
		}
	}

	return tst
}

func (s *TableSourceBaseContext) JoinPart(i int) IJoinPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinPartContext)
}

func (s *TableSourceBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableSourceBase(s)
	}
}

func (s *TableSourceBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableSourceBase(s)
	}
}

func (p *MySqlParser) TableSource() (localctx ITableSourceContext) {
	this := p
	_ = this

	localctx = NewTableSourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, MySqlParserRULE_tableSource)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(3745)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 529, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTableSourceBaseContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3727)
			p.TableSourceItem()
		}
		p.SetState(3731)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 527, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3728)
					p.JoinPart()
				}

			}
			p.SetState(3733)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 527, p.GetParserRuleContext())
		}

	case 2:
		localctx = NewTableSourceNestedContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3734)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(3735)
			p.TableSourceItem()
		}
		p.SetState(3739)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ((int64((_la-34)) & ^0x3f) == 0 && ((int64(1)<<(_la-34))&-9150751492863426559) != 0) || ((int64((_la-113)) & ^0x3f) == 0 && ((int64(1)<<(_la-113))&288230410511450113) != 0) {
			{
				p.SetState(3736)
				p.JoinPart()
			}

			p.SetState(3741)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3742)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 3:
		localctx = NewTableJsonContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3744)
			p.JsonTable()
		}

	}

	return localctx
}

// ITableSourceItemContext is an interface to support dynamic dispatch.
type ITableSourceItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTableSourceItemContext differentiates from other interfaces.
	IsTableSourceItemContext()
}

type TableSourceItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableSourceItemContext() *TableSourceItemContext {
	var p = new(TableSourceItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_tableSourceItem
	return p
}

func (*TableSourceItemContext) IsTableSourceItemContext() {}

func NewTableSourceItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableSourceItemContext {
	var p = new(TableSourceItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tableSourceItem

	return p
}

func (s *TableSourceItemContext) GetParser() antlr.Parser { return s.parser }

func (s *TableSourceItemContext) CopyFrom(ctx *TableSourceItemContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *TableSourceItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSourceItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SubqueryTableItemContext struct {
	*TableSourceItemContext
	parenthesisSubquery ISelectStatementContext
	alias               IUidContext
}

func NewSubqueryTableItemContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryTableItemContext {
	var p = new(SubqueryTableItemContext)

	p.TableSourceItemContext = NewEmptyTableSourceItemContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableSourceItemContext))

	return p
}

func (s *SubqueryTableItemContext) GetParenthesisSubquery() ISelectStatementContext {
	return s.parenthesisSubquery
}

func (s *SubqueryTableItemContext) GetAlias() IUidContext { return s.alias }

func (s *SubqueryTableItemContext) SetParenthesisSubquery(v ISelectStatementContext) {
	s.parenthesisSubquery = v
}

func (s *SubqueryTableItemContext) SetAlias(v IUidContext) { s.alias = v }

func (s *SubqueryTableItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryTableItemContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SubqueryTableItemContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *SubqueryTableItemContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *SubqueryTableItemContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *SubqueryTableItemContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *SubqueryTableItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSubqueryTableItem(s)
	}
}

func (s *SubqueryTableItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSubqueryTableItem(s)
	}
}

type AtomTableItemContext struct {
	*TableSourceItemContext
	alias IUidContext
}

func NewAtomTableItemContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AtomTableItemContext {
	var p = new(AtomTableItemContext)

	p.TableSourceItemContext = NewEmptyTableSourceItemContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableSourceItemContext))

	return p
}

func (s *AtomTableItemContext) GetAlias() IUidContext { return s.alias }

func (s *AtomTableItemContext) SetAlias(v IUidContext) { s.alias = v }

func (s *AtomTableItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomTableItemContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *AtomTableItemContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AtomTableItemContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AtomTableItemContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AtomTableItemContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AtomTableItemContext) AllIndexHint() []IIndexHintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexHintContext); ok {
			len++
		}
	}

	tst := make([]IIndexHintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexHintContext); ok {
			tst[i] = t.(IIndexHintContext)
			i++
		}
	}

	return tst
}

func (s *AtomTableItemContext) IndexHint(i int) IIndexHintContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexHintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexHintContext)
}

func (s *AtomTableItemContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AtomTableItemContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *AtomTableItemContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AtomTableItemContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *AtomTableItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAtomTableItem(s)
	}
}

func (s *AtomTableItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAtomTableItem(s)
	}
}

type TableSourcesItemContext struct {
	*TableSourceItemContext
}

func NewTableSourcesItemContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableSourcesItemContext {
	var p = new(TableSourcesItemContext)

	p.TableSourceItemContext = NewEmptyTableSourceItemContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableSourceItemContext))

	return p
}

func (s *TableSourcesItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSourcesItemContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *TableSourcesItemContext) TableSources() ITableSourcesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourcesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourcesContext)
}

func (s *TableSourcesItemContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *TableSourcesItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableSourcesItem(s)
	}
}

func (s *TableSourcesItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableSourcesItem(s)
	}
}

func (p *MySqlParser) TableSourceItem() (localctx ITableSourceItemContext) {
	this := p
	_ = this

	localctx = NewTableSourceItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, MySqlParserRULE_tableSourceItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(3787)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 537, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAtomTableItemContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3747)
			p.TableName()
		}
		p.SetState(3753)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserPARTITION {
			{
				p.SetState(3748)
				p.Match(MySqlParserPARTITION)
			}
			{
				p.SetState(3749)
				p.Match(MySqlParserLR_BRACKET)
			}
			{
				p.SetState(3750)
				p.UidList()
			}
			{
				p.SetState(3751)
				p.Match(MySqlParserRR_BRACKET)
			}

		}
		p.SetState(3759)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 532, p.GetParserRuleContext()) == 1 {
			p.SetState(3756)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserAS {
				{
					p.SetState(3755)
					p.Match(MySqlParserAS)
				}

			}
			{
				p.SetState(3758)

				var _x = p.Uid()

				localctx.(*AtomTableItemContext).alias = _x
			}

		}
		p.SetState(3769)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 534, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3761)
				p.IndexHint()
			}
			p.SetState(3766)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 533, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(3762)
						p.Match(MySqlParserCOMMA)
					}
					{
						p.SetState(3763)
						p.IndexHint()
					}

				}
				p.SetState(3768)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 533, p.GetParserRuleContext())
			}

		}

	case 2:
		localctx = NewSubqueryTableItemContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(3776)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 535, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3771)
				p.SelectStatement()
			}

		case 2:
			{
				p.SetState(3772)
				p.Match(MySqlParserLR_BRACKET)
			}
			{
				p.SetState(3773)

				var _x = p.SelectStatement()

				localctx.(*SubqueryTableItemContext).parenthesisSubquery = _x
			}
			{
				p.SetState(3774)
				p.Match(MySqlParserRR_BRACKET)
			}

		}
		p.SetState(3779)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserAS {
			{
				p.SetState(3778)
				p.Match(MySqlParserAS)
			}

		}
		{
			p.SetState(3781)

			var _x = p.Uid()

			localctx.(*SubqueryTableItemContext).alias = _x
		}

	case 3:
		localctx = NewTableSourcesItemContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3783)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(3784)
			p.TableSources()
		}
		{
			p.SetState(3785)
			p.Match(MySqlParserRR_BRACKET)
		}

	}

	return localctx
}

// IIndexHintContext is an interface to support dynamic dispatch.
type IIndexHintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndexHintAction returns the indexHintAction token.
	GetIndexHintAction() antlr.Token

	// GetKeyFormat returns the keyFormat token.
	GetKeyFormat() antlr.Token

	// SetIndexHintAction sets the indexHintAction token.
	SetIndexHintAction(antlr.Token)

	// SetKeyFormat sets the keyFormat token.
	SetKeyFormat(antlr.Token)

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	UidList() IUidListContext
	RR_BRACKET() antlr.TerminalNode
	USE() antlr.TerminalNode
	IGNORE() antlr.TerminalNode
	FORCE() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	KEY() antlr.TerminalNode
	FOR() antlr.TerminalNode
	IndexHintType() IIndexHintTypeContext

	// IsIndexHintContext differentiates from other interfaces.
	IsIndexHintContext()
}

type IndexHintContext struct {
	*antlr.BaseParserRuleContext
	parser          antlr.Parser
	indexHintAction antlr.Token
	keyFormat       antlr.Token
}

func NewEmptyIndexHintContext() *IndexHintContext {
	var p = new(IndexHintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_indexHint
	return p
}

func (*IndexHintContext) IsIndexHintContext() {}

func NewIndexHintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexHintContext {
	var p = new(IndexHintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_indexHint

	return p
}

func (s *IndexHintContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexHintContext) GetIndexHintAction() antlr.Token { return s.indexHintAction }

func (s *IndexHintContext) GetKeyFormat() antlr.Token { return s.keyFormat }

func (s *IndexHintContext) SetIndexHintAction(v antlr.Token) { s.indexHintAction = v }

func (s *IndexHintContext) SetKeyFormat(v antlr.Token) { s.keyFormat = v }

func (s *IndexHintContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *IndexHintContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *IndexHintContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *IndexHintContext) USE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSE, 0)
}

func (s *IndexHintContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE, 0)
}

func (s *IndexHintContext) FORCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFORCE, 0)
}

func (s *IndexHintContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *IndexHintContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *IndexHintContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *IndexHintContext) IndexHintType() IIndexHintTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexHintTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexHintTypeContext)
}

func (s *IndexHintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexHintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexHintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIndexHint(s)
	}
}

func (s *IndexHintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIndexHint(s)
	}
}

func (p *MySqlParser) IndexHint() (localctx IIndexHintContext) {
	this := p
	_ = this

	localctx = NewIndexHintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, MySqlParserRULE_indexHint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3789)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*IndexHintContext).indexHintAction = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserFORCE || _la == MySqlParserIGNORE || _la == MySqlParserUSE) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*IndexHintContext).indexHintAction = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(3790)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*IndexHintContext).keyFormat = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserINDEX || _la == MySqlParserKEY) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*IndexHintContext).keyFormat = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3793)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserFOR {
		{
			p.SetState(3791)
			p.Match(MySqlParserFOR)
		}
		{
			p.SetState(3792)
			p.IndexHintType()
		}

	}
	{
		p.SetState(3795)
		p.Match(MySqlParserLR_BRACKET)
	}
	{
		p.SetState(3796)
		p.UidList()
	}
	{
		p.SetState(3797)
		p.Match(MySqlParserRR_BRACKET)
	}

	return localctx
}

// IIndexHintTypeContext is an interface to support dynamic dispatch.
type IIndexHintTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JOIN() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	GROUP() antlr.TerminalNode

	// IsIndexHintTypeContext differentiates from other interfaces.
	IsIndexHintTypeContext()
}

type IndexHintTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexHintTypeContext() *IndexHintTypeContext {
	var p = new(IndexHintTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_indexHintType
	return p
}

func (*IndexHintTypeContext) IsIndexHintTypeContext() {}

func NewIndexHintTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexHintTypeContext {
	var p = new(IndexHintTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_indexHintType

	return p
}

func (s *IndexHintTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexHintTypeContext) JOIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserJOIN, 0)
}

func (s *IndexHintTypeContext) ORDER() antlr.TerminalNode {
	return s.GetToken(MySqlParserORDER, 0)
}

func (s *IndexHintTypeContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *IndexHintTypeContext) GROUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP, 0)
}

func (s *IndexHintTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexHintTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexHintTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIndexHintType(s)
	}
}

func (s *IndexHintTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIndexHintType(s)
	}
}

func (p *MySqlParser) IndexHintType() (localctx IIndexHintTypeContext) {
	this := p
	_ = this

	localctx = NewIndexHintTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, MySqlParserRULE_indexHintType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3804)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserJOIN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3799)
			p.Match(MySqlParserJOIN)
		}

	case MySqlParserORDER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3800)
			p.Match(MySqlParserORDER)
		}
		{
			p.SetState(3801)
			p.Match(MySqlParserBY)
		}

	case MySqlParserGROUP:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3802)
			p.Match(MySqlParserGROUP)
		}
		{
			p.SetState(3803)
			p.Match(MySqlParserBY)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IJoinPartContext is an interface to support dynamic dispatch.
type IJoinPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsJoinPartContext differentiates from other interfaces.
	IsJoinPartContext()
}

type JoinPartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinPartContext() *JoinPartContext {
	var p = new(JoinPartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_joinPart
	return p
}

func (*JoinPartContext) IsJoinPartContext() {}

func NewJoinPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinPartContext {
	var p = new(JoinPartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_joinPart

	return p
}

func (s *JoinPartContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinPartContext) CopyFrom(ctx *JoinPartContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *JoinPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type InnerJoinContext struct {
	*JoinPartContext
}

func NewInnerJoinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InnerJoinContext {
	var p = new(InnerJoinContext)

	p.JoinPartContext = NewEmptyJoinPartContext()
	p.parser = parser
	p.CopyFrom(ctx.(*JoinPartContext))

	return p
}

func (s *InnerJoinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InnerJoinContext) JOIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserJOIN, 0)
}

func (s *InnerJoinContext) TableSourceItem() ITableSourceItemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourceItemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourceItemContext)
}

func (s *InnerJoinContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLATERAL, 0)
}

func (s *InnerJoinContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *InnerJoinContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InnerJoinContext) USING() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSING, 0)
}

func (s *InnerJoinContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *InnerJoinContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *InnerJoinContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *InnerJoinContext) INNER() antlr.TerminalNode {
	return s.GetToken(MySqlParserINNER, 0)
}

func (s *InnerJoinContext) CROSS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCROSS, 0)
}

func (s *InnerJoinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterInnerJoin(s)
	}
}

func (s *InnerJoinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitInnerJoin(s)
	}
}

type NaturalJoinContext struct {
	*JoinPartContext
}

func NewNaturalJoinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NaturalJoinContext {
	var p = new(NaturalJoinContext)

	p.JoinPartContext = NewEmptyJoinPartContext()
	p.parser = parser
	p.CopyFrom(ctx.(*JoinPartContext))

	return p
}

func (s *NaturalJoinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NaturalJoinContext) NATURAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserNATURAL, 0)
}

func (s *NaturalJoinContext) JOIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserJOIN, 0)
}

func (s *NaturalJoinContext) TableSourceItem() ITableSourceItemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourceItemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourceItemContext)
}

func (s *NaturalJoinContext) LEFT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEFT, 0)
}

func (s *NaturalJoinContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(MySqlParserRIGHT, 0)
}

func (s *NaturalJoinContext) OUTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserOUTER, 0)
}

func (s *NaturalJoinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterNaturalJoin(s)
	}
}

func (s *NaturalJoinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitNaturalJoin(s)
	}
}

type OuterJoinContext struct {
	*JoinPartContext
}

func NewOuterJoinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *OuterJoinContext {
	var p = new(OuterJoinContext)

	p.JoinPartContext = NewEmptyJoinPartContext()
	p.parser = parser
	p.CopyFrom(ctx.(*JoinPartContext))

	return p
}

func (s *OuterJoinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OuterJoinContext) JOIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserJOIN, 0)
}

func (s *OuterJoinContext) TableSourceItem() ITableSourceItemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourceItemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourceItemContext)
}

func (s *OuterJoinContext) LEFT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEFT, 0)
}

func (s *OuterJoinContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(MySqlParserRIGHT, 0)
}

func (s *OuterJoinContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *OuterJoinContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *OuterJoinContext) USING() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSING, 0)
}

func (s *OuterJoinContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *OuterJoinContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *OuterJoinContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *OuterJoinContext) OUTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserOUTER, 0)
}

func (s *OuterJoinContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLATERAL, 0)
}

func (s *OuterJoinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterOuterJoin(s)
	}
}

func (s *OuterJoinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitOuterJoin(s)
	}
}

type StraightJoinContext struct {
	*JoinPartContext
}

func NewStraightJoinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StraightJoinContext {
	var p = new(StraightJoinContext)

	p.JoinPartContext = NewEmptyJoinPartContext()
	p.parser = parser
	p.CopyFrom(ctx.(*JoinPartContext))

	return p
}

func (s *StraightJoinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StraightJoinContext) STRAIGHT_JOIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRAIGHT_JOIN, 0)
}

func (s *StraightJoinContext) TableSourceItem() ITableSourceItemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourceItemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourceItemContext)
}

func (s *StraightJoinContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *StraightJoinContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StraightJoinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterStraightJoin(s)
	}
}

func (s *StraightJoinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitStraightJoin(s)
	}
}

func (p *MySqlParser) JoinPart() (localctx IJoinPartContext) {
	this := p
	_ = this

	localctx = NewJoinPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, MySqlParserRULE_joinPart)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3856)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserCROSS, MySqlParserINNER, MySqlParserJOIN:
		localctx = NewInnerJoinContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3807)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCROSS || _la == MySqlParserINNER {
			{
				p.SetState(3806)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserCROSS || _la == MySqlParserINNER) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(3809)
			p.Match(MySqlParserJOIN)
		}
		p.SetState(3811)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 541, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3810)
				p.Match(MySqlParserLATERAL)
			}

		}
		{
			p.SetState(3813)
			p.TableSourceItem()
		}
		p.SetState(3821)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 542, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3814)
				p.Match(MySqlParserON)
			}
			{
				p.SetState(3815)
				p.expression(0)
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 542, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(3816)
				p.Match(MySqlParserUSING)
			}
			{
				p.SetState(3817)
				p.Match(MySqlParserLR_BRACKET)
			}
			{
				p.SetState(3818)
				p.UidList()
			}
			{
				p.SetState(3819)
				p.Match(MySqlParserRR_BRACKET)
			}

		}

	case MySqlParserSTRAIGHT_JOIN:
		localctx = NewStraightJoinContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3823)
			p.Match(MySqlParserSTRAIGHT_JOIN)
		}
		{
			p.SetState(3824)
			p.TableSourceItem()
		}
		p.SetState(3827)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 543, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3825)
				p.Match(MySqlParserON)
			}
			{
				p.SetState(3826)
				p.expression(0)
			}

		}

	case MySqlParserLEFT, MySqlParserRIGHT:
		localctx = NewOuterJoinContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3829)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserLEFT || _la == MySqlParserRIGHT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(3831)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserOUTER {
			{
				p.SetState(3830)
				p.Match(MySqlParserOUTER)
			}

		}
		{
			p.SetState(3833)
			p.Match(MySqlParserJOIN)
		}
		p.SetState(3835)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 545, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3834)
				p.Match(MySqlParserLATERAL)
			}

		}
		{
			p.SetState(3837)
			p.TableSourceItem()
		}
		p.SetState(3845)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserON:
			{
				p.SetState(3838)
				p.Match(MySqlParserON)
			}
			{
				p.SetState(3839)
				p.expression(0)
			}

		case MySqlParserUSING:
			{
				p.SetState(3840)
				p.Match(MySqlParserUSING)
			}
			{
				p.SetState(3841)
				p.Match(MySqlParserLR_BRACKET)
			}
			{
				p.SetState(3842)
				p.UidList()
			}
			{
				p.SetState(3843)
				p.Match(MySqlParserRR_BRACKET)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case MySqlParserNATURAL:
		localctx = NewNaturalJoinContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3847)
			p.Match(MySqlParserNATURAL)
		}
		p.SetState(3852)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLEFT || _la == MySqlParserRIGHT {
			{
				p.SetState(3848)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserLEFT || _la == MySqlParserRIGHT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			p.SetState(3850)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserOUTER {
				{
					p.SetState(3849)
					p.Match(MySqlParserOUTER)
				}

			}

		}
		{
			p.SetState(3854)
			p.Match(MySqlParserJOIN)
		}
		{
			p.SetState(3855)
			p.TableSourceItem()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IQueryExpressionContext is an interface to support dynamic dispatch.
type IQueryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	QuerySpecification() IQuerySpecificationContext
	RR_BRACKET() antlr.TerminalNode
	QueryExpression() IQueryExpressionContext

	// IsQueryExpressionContext differentiates from other interfaces.
	IsQueryExpressionContext()
}

type QueryExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryExpressionContext() *QueryExpressionContext {
	var p = new(QueryExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_queryExpression
	return p
}

func (*QueryExpressionContext) IsQueryExpressionContext() {}

func NewQueryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryExpressionContext {
	var p = new(QueryExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_queryExpression

	return p
}

func (s *QueryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryExpressionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *QueryExpressionContext) QuerySpecification() IQuerySpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *QueryExpressionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *QueryExpressionContext) QueryExpression() IQueryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionContext)
}

func (s *QueryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterQueryExpression(s)
	}
}

func (s *QueryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitQueryExpression(s)
	}
}

func (p *MySqlParser) QueryExpression() (localctx IQueryExpressionContext) {
	this := p
	_ = this

	localctx = NewQueryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, MySqlParserRULE_queryExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3866)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 550, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3858)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(3859)
			p.QuerySpecification()
		}
		{
			p.SetState(3860)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3862)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(3863)
			p.QueryExpression()
		}
		{
			p.SetState(3864)
			p.Match(MySqlParserRR_BRACKET)
		}

	}

	return localctx
}

// IQueryExpressionNointoContext is an interface to support dynamic dispatch.
type IQueryExpressionNointoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	QuerySpecificationNointo() IQuerySpecificationNointoContext
	RR_BRACKET() antlr.TerminalNode
	QueryExpressionNointo() IQueryExpressionNointoContext

	// IsQueryExpressionNointoContext differentiates from other interfaces.
	IsQueryExpressionNointoContext()
}

type QueryExpressionNointoContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryExpressionNointoContext() *QueryExpressionNointoContext {
	var p = new(QueryExpressionNointoContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_queryExpressionNointo
	return p
}

func (*QueryExpressionNointoContext) IsQueryExpressionNointoContext() {}

func NewQueryExpressionNointoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryExpressionNointoContext {
	var p = new(QueryExpressionNointoContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_queryExpressionNointo

	return p
}

func (s *QueryExpressionNointoContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryExpressionNointoContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *QueryExpressionNointoContext) QuerySpecificationNointo() IQuerySpecificationNointoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationNointoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationNointoContext)
}

func (s *QueryExpressionNointoContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *QueryExpressionNointoContext) QueryExpressionNointo() IQueryExpressionNointoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionNointoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionNointoContext)
}

func (s *QueryExpressionNointoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryExpressionNointoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryExpressionNointoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterQueryExpressionNointo(s)
	}
}

func (s *QueryExpressionNointoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitQueryExpressionNointo(s)
	}
}

func (p *MySqlParser) QueryExpressionNointo() (localctx IQueryExpressionNointoContext) {
	this := p
	_ = this

	localctx = NewQueryExpressionNointoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, MySqlParserRULE_queryExpressionNointo)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3876)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 551, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3868)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(3869)
			p.QuerySpecificationNointo()
		}
		{
			p.SetState(3870)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3872)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(3873)
			p.QueryExpressionNointo()
		}
		{
			p.SetState(3874)
			p.Match(MySqlParserRR_BRACKET)
		}

	}

	return localctx
}

// IQuerySpecificationContext is an interface to support dynamic dispatch.
type IQuerySpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SELECT() antlr.TerminalNode
	SelectElements() ISelectElementsContext
	FromClause() IFromClauseContext
	AllSelectSpec() []ISelectSpecContext
	SelectSpec(i int) ISelectSpecContext
	SelectIntoExpression() ISelectIntoExpressionContext
	GroupByClause() IGroupByClauseContext
	HavingClause() IHavingClauseContext
	WindowClause() IWindowClauseContext
	OrderByClause() IOrderByClauseContext
	LimitClause() ILimitClauseContext

	// IsQuerySpecificationContext differentiates from other interfaces.
	IsQuerySpecificationContext()
}

type QuerySpecificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuerySpecificationContext() *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_querySpecification
	return p
}

func (*QuerySpecificationContext) IsQuerySpecificationContext() {}

func NewQuerySpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_querySpecification

	return p
}

func (s *QuerySpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *QuerySpecificationContext) SELECT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSELECT, 0)
}

func (s *QuerySpecificationContext) SelectElements() ISelectElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectElementsContext)
}

func (s *QuerySpecificationContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *QuerySpecificationContext) AllSelectSpec() []ISelectSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectSpecContext); ok {
			len++
		}
	}

	tst := make([]ISelectSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectSpecContext); ok {
			tst[i] = t.(ISelectSpecContext)
			i++
		}
	}

	return tst
}

func (s *QuerySpecificationContext) SelectSpec(i int) ISelectSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectSpecContext)
}

func (s *QuerySpecificationContext) SelectIntoExpression() ISelectIntoExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectIntoExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectIntoExpressionContext)
}

func (s *QuerySpecificationContext) GroupByClause() IGroupByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByClauseContext)
}

func (s *QuerySpecificationContext) HavingClause() IHavingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHavingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHavingClauseContext)
}

func (s *QuerySpecificationContext) WindowClause() IWindowClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowClauseContext)
}

func (s *QuerySpecificationContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *QuerySpecificationContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *QuerySpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuerySpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuerySpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterQuerySpecification(s)
	}
}

func (s *QuerySpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitQuerySpecification(s)
	}
}

func (p *MySqlParser) QuerySpecification() (localctx IQuerySpecificationContext) {
	this := p
	_ = this

	localctx = NewQuerySpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, MySqlParserRULE_querySpecification)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(3932)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 566, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3878)
			p.Match(MySqlParserSELECT)
		}
		p.SetState(3882)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 552, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3879)
					p.SelectSpec()
				}

			}
			p.SetState(3884)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 552, p.GetParserRuleContext())
		}
		{
			p.SetState(3885)
			p.SelectElements()
		}
		p.SetState(3887)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserINTO {
			{
				p.SetState(3886)
				p.SelectIntoExpression()
			}

		}
		{
			p.SetState(3889)
			p.FromClause()
		}
		p.SetState(3891)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 554, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3890)
				p.GroupByClause()
			}

		}
		p.SetState(3894)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserHAVING {
			{
				p.SetState(3893)
				p.HavingClause()
			}

		}
		p.SetState(3897)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserWINDOW {
			{
				p.SetState(3896)
				p.WindowClause()
			}

		}
		p.SetState(3900)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 557, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3899)
				p.OrderByClause()
			}

		}
		p.SetState(3903)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 558, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3902)
				p.LimitClause()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3905)
			p.Match(MySqlParserSELECT)
		}
		p.SetState(3909)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 559, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3906)
					p.SelectSpec()
				}

			}
			p.SetState(3911)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 559, p.GetParserRuleContext())
		}
		{
			p.SetState(3912)
			p.SelectElements()
		}
		{
			p.SetState(3913)
			p.FromClause()
		}
		p.SetState(3915)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 560, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3914)
				p.GroupByClause()
			}

		}
		p.SetState(3918)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserHAVING {
			{
				p.SetState(3917)
				p.HavingClause()
			}

		}
		p.SetState(3921)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserWINDOW {
			{
				p.SetState(3920)
				p.WindowClause()
			}

		}
		p.SetState(3924)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 563, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3923)
				p.OrderByClause()
			}

		}
		p.SetState(3927)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 564, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3926)
				p.LimitClause()
			}

		}
		p.SetState(3930)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserINTO {
			{
				p.SetState(3929)
				p.SelectIntoExpression()
			}

		}

	}

	return localctx
}

// IQuerySpecificationNointoContext is an interface to support dynamic dispatch.
type IQuerySpecificationNointoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SELECT() antlr.TerminalNode
	SelectElements() ISelectElementsContext
	FromClause() IFromClauseContext
	AllSelectSpec() []ISelectSpecContext
	SelectSpec(i int) ISelectSpecContext
	GroupByClause() IGroupByClauseContext
	HavingClause() IHavingClauseContext
	WindowClause() IWindowClauseContext
	OrderByClause() IOrderByClauseContext
	LimitClause() ILimitClauseContext

	// IsQuerySpecificationNointoContext differentiates from other interfaces.
	IsQuerySpecificationNointoContext()
}

type QuerySpecificationNointoContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuerySpecificationNointoContext() *QuerySpecificationNointoContext {
	var p = new(QuerySpecificationNointoContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_querySpecificationNointo
	return p
}

func (*QuerySpecificationNointoContext) IsQuerySpecificationNointoContext() {}

func NewQuerySpecificationNointoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuerySpecificationNointoContext {
	var p = new(QuerySpecificationNointoContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_querySpecificationNointo

	return p
}

func (s *QuerySpecificationNointoContext) GetParser() antlr.Parser { return s.parser }

func (s *QuerySpecificationNointoContext) SELECT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSELECT, 0)
}

func (s *QuerySpecificationNointoContext) SelectElements() ISelectElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectElementsContext)
}

func (s *QuerySpecificationNointoContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *QuerySpecificationNointoContext) AllSelectSpec() []ISelectSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectSpecContext); ok {
			len++
		}
	}

	tst := make([]ISelectSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectSpecContext); ok {
			tst[i] = t.(ISelectSpecContext)
			i++
		}
	}

	return tst
}

func (s *QuerySpecificationNointoContext) SelectSpec(i int) ISelectSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectSpecContext)
}

func (s *QuerySpecificationNointoContext) GroupByClause() IGroupByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByClauseContext)
}

func (s *QuerySpecificationNointoContext) HavingClause() IHavingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHavingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHavingClauseContext)
}

func (s *QuerySpecificationNointoContext) WindowClause() IWindowClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowClauseContext)
}

func (s *QuerySpecificationNointoContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *QuerySpecificationNointoContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *QuerySpecificationNointoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuerySpecificationNointoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuerySpecificationNointoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterQuerySpecificationNointo(s)
	}
}

func (s *QuerySpecificationNointoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitQuerySpecificationNointo(s)
	}
}

func (p *MySqlParser) QuerySpecificationNointo() (localctx IQuerySpecificationNointoContext) {
	this := p
	_ = this

	localctx = NewQuerySpecificationNointoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, MySqlParserRULE_querySpecificationNointo)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3934)
		p.Match(MySqlParserSELECT)
	}
	p.SetState(3938)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 567, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3935)
				p.SelectSpec()
			}

		}
		p.SetState(3940)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 567, p.GetParserRuleContext())
	}
	{
		p.SetState(3941)
		p.SelectElements()
	}
	{
		p.SetState(3942)
		p.FromClause()
	}
	p.SetState(3944)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 568, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3943)
			p.GroupByClause()
		}

	}
	p.SetState(3947)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserHAVING {
		{
			p.SetState(3946)
			p.HavingClause()
		}

	}
	p.SetState(3950)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserWINDOW {
		{
			p.SetState(3949)
			p.WindowClause()
		}

	}
	p.SetState(3953)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 571, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3952)
			p.OrderByClause()
		}

	}
	p.SetState(3956)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 572, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3955)
			p.LimitClause()
		}

	}

	return localctx
}

// IUnionParenthesisContext is an interface to support dynamic dispatch.
type IUnionParenthesisContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUnionType returns the unionType token.
	GetUnionType() antlr.Token

	// SetUnionType sets the unionType token.
	SetUnionType(antlr.Token)

	// Getter signatures
	UNION() antlr.TerminalNode
	QueryExpressionNointo() IQueryExpressionNointoContext
	ALL() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode

	// IsUnionParenthesisContext differentiates from other interfaces.
	IsUnionParenthesisContext()
}

type UnionParenthesisContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	unionType antlr.Token
}

func NewEmptyUnionParenthesisContext() *UnionParenthesisContext {
	var p = new(UnionParenthesisContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_unionParenthesis
	return p
}

func (*UnionParenthesisContext) IsUnionParenthesisContext() {}

func NewUnionParenthesisContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionParenthesisContext {
	var p = new(UnionParenthesisContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_unionParenthesis

	return p
}

func (s *UnionParenthesisContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionParenthesisContext) GetUnionType() antlr.Token { return s.unionType }

func (s *UnionParenthesisContext) SetUnionType(v antlr.Token) { s.unionType = v }

func (s *UnionParenthesisContext) UNION() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNION, 0)
}

func (s *UnionParenthesisContext) QueryExpressionNointo() IQueryExpressionNointoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionNointoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionNointoContext)
}

func (s *UnionParenthesisContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *UnionParenthesisContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISTINCT, 0)
}

func (s *UnionParenthesisContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionParenthesisContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionParenthesisContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUnionParenthesis(s)
	}
}

func (s *UnionParenthesisContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUnionParenthesis(s)
	}
}

func (p *MySqlParser) UnionParenthesis() (localctx IUnionParenthesisContext) {
	this := p
	_ = this

	localctx = NewUnionParenthesisContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, MySqlParserRULE_unionParenthesis)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3958)
		p.Match(MySqlParserUNION)
	}
	p.SetState(3960)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserALL || _la == MySqlParserDISTINCT {
		{
			p.SetState(3959)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*UnionParenthesisContext).unionType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserALL || _la == MySqlParserDISTINCT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*UnionParenthesisContext).unionType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(3962)
		p.QueryExpressionNointo()
	}

	return localctx
}

// IUnionStatementContext is an interface to support dynamic dispatch.
type IUnionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUnionType returns the unionType token.
	GetUnionType() antlr.Token

	// SetUnionType sets the unionType token.
	SetUnionType(antlr.Token)

	// Getter signatures
	UNION() antlr.TerminalNode
	QuerySpecificationNointo() IQuerySpecificationNointoContext
	QueryExpressionNointo() IQueryExpressionNointoContext
	ALL() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode

	// IsUnionStatementContext differentiates from other interfaces.
	IsUnionStatementContext()
}

type UnionStatementContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	unionType antlr.Token
}

func NewEmptyUnionStatementContext() *UnionStatementContext {
	var p = new(UnionStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_unionStatement
	return p
}

func (*UnionStatementContext) IsUnionStatementContext() {}

func NewUnionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionStatementContext {
	var p = new(UnionStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_unionStatement

	return p
}

func (s *UnionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionStatementContext) GetUnionType() antlr.Token { return s.unionType }

func (s *UnionStatementContext) SetUnionType(v antlr.Token) { s.unionType = v }

func (s *UnionStatementContext) UNION() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNION, 0)
}

func (s *UnionStatementContext) QuerySpecificationNointo() IQuerySpecificationNointoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationNointoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationNointoContext)
}

func (s *UnionStatementContext) QueryExpressionNointo() IQueryExpressionNointoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionNointoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionNointoContext)
}

func (s *UnionStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *UnionStatementContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISTINCT, 0)
}

func (s *UnionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUnionStatement(s)
	}
}

func (s *UnionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUnionStatement(s)
	}
}

func (p *MySqlParser) UnionStatement() (localctx IUnionStatementContext) {
	this := p
	_ = this

	localctx = NewUnionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, MySqlParserRULE_unionStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3964)
		p.Match(MySqlParserUNION)
	}
	p.SetState(3966)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserALL || _la == MySqlParserDISTINCT {
		{
			p.SetState(3965)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*UnionStatementContext).unionType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserALL || _la == MySqlParserDISTINCT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*UnionStatementContext).unionType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3970)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSELECT:
		{
			p.SetState(3968)
			p.QuerySpecificationNointo()
		}

	case MySqlParserLR_BRACKET:
		{
			p.SetState(3969)
			p.QueryExpressionNointo()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILateralStatementContext is an interface to support dynamic dispatch.
type ILateralStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LATERAL() antlr.TerminalNode
	QuerySpecificationNointo() IQuerySpecificationNointoContext
	QueryExpressionNointo() IQueryExpressionNointoContext
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	Uid() IUidContext
	AS() antlr.TerminalNode

	// IsLateralStatementContext differentiates from other interfaces.
	IsLateralStatementContext()
}

type LateralStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLateralStatementContext() *LateralStatementContext {
	var p = new(LateralStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_lateralStatement
	return p
}

func (*LateralStatementContext) IsLateralStatementContext() {}

func NewLateralStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LateralStatementContext {
	var p = new(LateralStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_lateralStatement

	return p
}

func (s *LateralStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LateralStatementContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLATERAL, 0)
}

func (s *LateralStatementContext) QuerySpecificationNointo() IQuerySpecificationNointoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationNointoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationNointoContext)
}

func (s *LateralStatementContext) QueryExpressionNointo() IQueryExpressionNointoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionNointoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionNointoContext)
}

func (s *LateralStatementContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *LateralStatementContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *LateralStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *LateralStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *LateralStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LateralStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LateralStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLateralStatement(s)
	}
}

func (s *LateralStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLateralStatement(s)
	}
}

func (p *MySqlParser) LateralStatement() (localctx ILateralStatementContext) {
	this := p
	_ = this

	localctx = NewLateralStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, MySqlParserRULE_lateralStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3972)
		p.Match(MySqlParserLATERAL)
	}
	p.SetState(3987)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 579, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3973)
			p.QuerySpecificationNointo()
		}

	case 2:
		{
			p.SetState(3974)
			p.QueryExpressionNointo()
		}

	case 3:
		{
			p.SetState(3975)
			p.Match(MySqlParserLR_BRACKET)
		}
		p.SetState(3978)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserSELECT:
			{
				p.SetState(3976)
				p.QuerySpecificationNointo()
			}

		case MySqlParserLR_BRACKET:
			{
				p.SetState(3977)
				p.QueryExpressionNointo()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(3980)
			p.Match(MySqlParserRR_BRACKET)
		}
		p.SetState(3985)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 578, p.GetParserRuleContext()) == 1 {
			p.SetState(3982)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserAS {
				{
					p.SetState(3981)
					p.Match(MySqlParserAS)
				}

			}
			{
				p.SetState(3984)
				p.Uid()
			}

		}

	}

	return localctx
}

// IJsonTableContext is an interface to support dynamic dispatch.
type IJsonTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JSON_TABLE() antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	COMMA() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	JsonColumnList() IJsonColumnListContext
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	Uid() IUidContext
	AS() antlr.TerminalNode

	// IsJsonTableContext differentiates from other interfaces.
	IsJsonTableContext()
}

type JsonTableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonTableContext() *JsonTableContext {
	var p = new(JsonTableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_jsonTable
	return p
}

func (*JsonTableContext) IsJsonTableContext() {}

func NewJsonTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonTableContext {
	var p = new(JsonTableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_jsonTable

	return p
}

func (s *JsonTableContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonTableContext) JSON_TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_TABLE, 0)
}

func (s *JsonTableContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *JsonTableContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *JsonTableContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSTRING_LITERAL)
}

func (s *JsonTableContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, i)
}

func (s *JsonTableContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *JsonTableContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMNS, 0)
}

func (s *JsonTableContext) JsonColumnList() IJsonColumnListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonColumnListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonColumnListContext)
}

func (s *JsonTableContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *JsonTableContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *JsonTableContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *JsonTableContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *JsonTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterJsonTable(s)
	}
}

func (s *JsonTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitJsonTable(s)
	}
}

func (p *MySqlParser) JsonTable() (localctx IJsonTableContext) {
	this := p
	_ = this

	localctx = NewJsonTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, MySqlParserRULE_jsonTable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3989)
		p.Match(MySqlParserJSON_TABLE)
	}
	{
		p.SetState(3990)
		p.Match(MySqlParserLR_BRACKET)
	}
	{
		p.SetState(3991)
		p.Match(MySqlParserSTRING_LITERAL)
	}
	{
		p.SetState(3992)
		p.Match(MySqlParserCOMMA)
	}
	{
		p.SetState(3993)
		p.Match(MySqlParserSTRING_LITERAL)
	}
	{
		p.SetState(3994)
		p.Match(MySqlParserCOLUMNS)
	}
	{
		p.SetState(3995)
		p.Match(MySqlParserLR_BRACKET)
	}
	{
		p.SetState(3996)
		p.JsonColumnList()
	}
	{
		p.SetState(3997)
		p.Match(MySqlParserRR_BRACKET)
	}
	{
		p.SetState(3998)
		p.Match(MySqlParserRR_BRACKET)
	}
	p.SetState(4003)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 581, p.GetParserRuleContext()) == 1 {
		p.SetState(4000)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserAS {
			{
				p.SetState(3999)
				p.Match(MySqlParserAS)
			}

		}
		{
			p.SetState(4002)
			p.Uid()
		}

	}

	return localctx
}

// IJsonColumnListContext is an interface to support dynamic dispatch.
type IJsonColumnListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllJsonColumn() []IJsonColumnContext
	JsonColumn(i int) IJsonColumnContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsJsonColumnListContext differentiates from other interfaces.
	IsJsonColumnListContext()
}

type JsonColumnListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonColumnListContext() *JsonColumnListContext {
	var p = new(JsonColumnListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_jsonColumnList
	return p
}

func (*JsonColumnListContext) IsJsonColumnListContext() {}

func NewJsonColumnListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonColumnListContext {
	var p = new(JsonColumnListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_jsonColumnList

	return p
}

func (s *JsonColumnListContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonColumnListContext) AllJsonColumn() []IJsonColumnContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJsonColumnContext); ok {
			len++
		}
	}

	tst := make([]IJsonColumnContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJsonColumnContext); ok {
			tst[i] = t.(IJsonColumnContext)
			i++
		}
	}

	return tst
}

func (s *JsonColumnListContext) JsonColumn(i int) IJsonColumnContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonColumnContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonColumnContext)
}

func (s *JsonColumnListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *JsonColumnListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *JsonColumnListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonColumnListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonColumnListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterJsonColumnList(s)
	}
}

func (s *JsonColumnListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitJsonColumnList(s)
	}
}

func (p *MySqlParser) JsonColumnList() (localctx IJsonColumnListContext) {
	this := p
	_ = this

	localctx = NewJsonColumnListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, MySqlParserRULE_jsonColumnList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4005)
		p.JsonColumn()
	}
	p.SetState(4010)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(4006)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(4007)
			p.JsonColumn()
		}

		p.SetState(4012)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IJsonColumnContext is an interface to support dynamic dispatch.
type IJsonColumnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FullColumnName() IFullColumnNameContext
	FOR() antlr.TerminalNode
	ORDINALITY() antlr.TerminalNode
	DataType() IDataTypeContext
	PATH() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	JsonOnEmpty() IJsonOnEmptyContext
	JsonOnError() IJsonOnErrorContext
	NESTED() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	JsonColumnList() IJsonColumnListContext
	RR_BRACKET() antlr.TerminalNode

	// IsJsonColumnContext differentiates from other interfaces.
	IsJsonColumnContext()
}

type JsonColumnContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonColumnContext() *JsonColumnContext {
	var p = new(JsonColumnContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_jsonColumn
	return p
}

func (*JsonColumnContext) IsJsonColumnContext() {}

func NewJsonColumnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonColumnContext {
	var p = new(JsonColumnContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_jsonColumn

	return p
}

func (s *JsonColumnContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonColumnContext) FullColumnName() IFullColumnNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *JsonColumnContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *JsonColumnContext) ORDINALITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserORDINALITY, 0)
}

func (s *JsonColumnContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *JsonColumnContext) PATH() antlr.TerminalNode {
	return s.GetToken(MySqlParserPATH, 0)
}

func (s *JsonColumnContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *JsonColumnContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXISTS, 0)
}

func (s *JsonColumnContext) JsonOnEmpty() IJsonOnEmptyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonOnEmptyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonOnEmptyContext)
}

func (s *JsonColumnContext) JsonOnError() IJsonOnErrorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonOnErrorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonOnErrorContext)
}

func (s *JsonColumnContext) NESTED() antlr.TerminalNode {
	return s.GetToken(MySqlParserNESTED, 0)
}

func (s *JsonColumnContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMNS, 0)
}

func (s *JsonColumnContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *JsonColumnContext) JsonColumnList() IJsonColumnListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonColumnListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonColumnListContext)
}

func (s *JsonColumnContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *JsonColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonColumnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterJsonColumn(s)
	}
}

func (s *JsonColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitJsonColumn(s)
	}
}

func (p *MySqlParser) JsonColumn() (localctx IJsonColumnContext) {
	this := p
	_ = this

	localctx = NewJsonColumnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, MySqlParserRULE_jsonColumn)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4042)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 588, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4013)
			p.FullColumnName()
		}
		p.SetState(4030)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserFOR:
			{
				p.SetState(4014)
				p.Match(MySqlParserFOR)
			}
			{
				p.SetState(4015)
				p.Match(MySqlParserORDINALITY)
			}

		case MySqlParserCHARACTER, MySqlParserSET, MySqlParserTINYINT, MySqlParserSMALLINT, MySqlParserMEDIUMINT, MySqlParserMIDDLEINT, MySqlParserINT, MySqlParserINT1, MySqlParserINT2, MySqlParserINT3, MySqlParserINT4, MySqlParserINT8, MySqlParserINTEGER, MySqlParserBIGINT, MySqlParserREAL, MySqlParserDOUBLE, MySqlParserFLOAT, MySqlParserFLOAT4, MySqlParserFLOAT8, MySqlParserDECIMAL, MySqlParserDEC, MySqlParserNUMERIC, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserCHAR, MySqlParserVARCHAR, MySqlParserNVARCHAR, MySqlParserNATIONAL, MySqlParserBINARY, MySqlParserVARBINARY, MySqlParserTINYBLOB, MySqlParserBLOB, MySqlParserMEDIUMBLOB, MySqlParserLONG, MySqlParserLONGBLOB, MySqlParserTINYTEXT, MySqlParserTEXT, MySqlParserMEDIUMTEXT, MySqlParserLONGTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserBIT, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserFIXED, MySqlParserJSON, MySqlParserNCHAR, MySqlParserGEOMETRYCOLLECTION, MySqlParserGEOMCOLLECTION, MySqlParserGEOMETRY, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON:
			{
				p.SetState(4016)
				p.DataType()
			}
			p.SetState(4028)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case MySqlParserPATH:
				{
					p.SetState(4017)
					p.Match(MySqlParserPATH)
				}
				{
					p.SetState(4018)
					p.Match(MySqlParserSTRING_LITERAL)
				}
				p.SetState(4020)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 583, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(4019)
						p.JsonOnEmpty()
					}

				}
				p.SetState(4023)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == MySqlParserDEFAULT || _la == MySqlParserNULL_LITERAL || _la == MySqlParserERROR {
					{
						p.SetState(4022)
						p.JsonOnError()
					}

				}

			case MySqlParserEXISTS:
				{
					p.SetState(4025)
					p.Match(MySqlParserEXISTS)
				}
				{
					p.SetState(4026)
					p.Match(MySqlParserPATH)
				}
				{
					p.SetState(4027)
					p.Match(MySqlParserSTRING_LITERAL)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4032)
			p.Match(MySqlParserNESTED)
		}
		p.SetState(4034)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserPATH {
			{
				p.SetState(4033)
				p.Match(MySqlParserPATH)
			}

		}
		{
			p.SetState(4036)
			p.Match(MySqlParserSTRING_LITERAL)
		}
		{
			p.SetState(4037)
			p.Match(MySqlParserCOLUMNS)
		}
		{
			p.SetState(4038)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(4039)
			p.JsonColumnList()
		}
		{
			p.SetState(4040)
			p.Match(MySqlParserRR_BRACKET)
		}

	}

	return localctx
}

// IJsonOnEmptyContext is an interface to support dynamic dispatch.
type IJsonOnEmptyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	EMPTY() antlr.TerminalNode
	NULL_LITERAL() antlr.TerminalNode
	ERROR() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	DefaultValue() IDefaultValueContext

	// IsJsonOnEmptyContext differentiates from other interfaces.
	IsJsonOnEmptyContext()
}

type JsonOnEmptyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonOnEmptyContext() *JsonOnEmptyContext {
	var p = new(JsonOnEmptyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_jsonOnEmpty
	return p
}

func (*JsonOnEmptyContext) IsJsonOnEmptyContext() {}

func NewJsonOnEmptyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonOnEmptyContext {
	var p = new(JsonOnEmptyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_jsonOnEmpty

	return p
}

func (s *JsonOnEmptyContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonOnEmptyContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *JsonOnEmptyContext) EMPTY() antlr.TerminalNode {
	return s.GetToken(MySqlParserEMPTY, 0)
}

func (s *JsonOnEmptyContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserNULL_LITERAL, 0)
}

func (s *JsonOnEmptyContext) ERROR() antlr.TerminalNode {
	return s.GetToken(MySqlParserERROR, 0)
}

func (s *JsonOnEmptyContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *JsonOnEmptyContext) DefaultValue() IDefaultValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultValueContext)
}

func (s *JsonOnEmptyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonOnEmptyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonOnEmptyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterJsonOnEmpty(s)
	}
}

func (s *JsonOnEmptyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitJsonOnEmpty(s)
	}
}

func (p *MySqlParser) JsonOnEmpty() (localctx IJsonOnEmptyContext) {
	this := p
	_ = this

	localctx = NewJsonOnEmptyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, MySqlParserRULE_jsonOnEmpty)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4048)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserNULL_LITERAL:
		{
			p.SetState(4044)
			p.Match(MySqlParserNULL_LITERAL)
		}

	case MySqlParserERROR:
		{
			p.SetState(4045)
			p.Match(MySqlParserERROR)
		}

	case MySqlParserDEFAULT:
		{
			p.SetState(4046)
			p.Match(MySqlParserDEFAULT)
		}
		{
			p.SetState(4047)
			p.DefaultValue()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(4050)
		p.Match(MySqlParserON)
	}
	{
		p.SetState(4051)
		p.Match(MySqlParserEMPTY)
	}

	return localctx
}

// IJsonOnErrorContext is an interface to support dynamic dispatch.
type IJsonOnErrorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	AllERROR() []antlr.TerminalNode
	ERROR(i int) antlr.TerminalNode
	NULL_LITERAL() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	DefaultValue() IDefaultValueContext

	// IsJsonOnErrorContext differentiates from other interfaces.
	IsJsonOnErrorContext()
}

type JsonOnErrorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonOnErrorContext() *JsonOnErrorContext {
	var p = new(JsonOnErrorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_jsonOnError
	return p
}

func (*JsonOnErrorContext) IsJsonOnErrorContext() {}

func NewJsonOnErrorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonOnErrorContext {
	var p = new(JsonOnErrorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_jsonOnError

	return p
}

func (s *JsonOnErrorContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonOnErrorContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *JsonOnErrorContext) AllERROR() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserERROR)
}

func (s *JsonOnErrorContext) ERROR(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserERROR, i)
}

func (s *JsonOnErrorContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserNULL_LITERAL, 0)
}

func (s *JsonOnErrorContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *JsonOnErrorContext) DefaultValue() IDefaultValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultValueContext)
}

func (s *JsonOnErrorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonOnErrorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonOnErrorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterJsonOnError(s)
	}
}

func (s *JsonOnErrorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitJsonOnError(s)
	}
}

func (p *MySqlParser) JsonOnError() (localctx IJsonOnErrorContext) {
	this := p
	_ = this

	localctx = NewJsonOnErrorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, MySqlParserRULE_jsonOnError)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4057)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserNULL_LITERAL:
		{
			p.SetState(4053)
			p.Match(MySqlParserNULL_LITERAL)
		}

	case MySqlParserERROR:
		{
			p.SetState(4054)
			p.Match(MySqlParserERROR)
		}

	case MySqlParserDEFAULT:
		{
			p.SetState(4055)
			p.Match(MySqlParserDEFAULT)
		}
		{
			p.SetState(4056)
			p.DefaultValue()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(4059)
		p.Match(MySqlParserON)
	}
	{
		p.SetState(4060)
		p.Match(MySqlParserERROR)
	}

	return localctx
}

// ISelectSpecContext is an interface to support dynamic dispatch.
type ISelectSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode
	DISTINCTROW() antlr.TerminalNode
	HIGH_PRIORITY() antlr.TerminalNode
	STRAIGHT_JOIN() antlr.TerminalNode
	SQL_SMALL_RESULT() antlr.TerminalNode
	SQL_BIG_RESULT() antlr.TerminalNode
	SQL_BUFFER_RESULT() antlr.TerminalNode
	SQL_CACHE() antlr.TerminalNode
	SQL_NO_CACHE() antlr.TerminalNode
	SQL_CALC_FOUND_ROWS() antlr.TerminalNode

	// IsSelectSpecContext differentiates from other interfaces.
	IsSelectSpecContext()
}

type SelectSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectSpecContext() *SelectSpecContext {
	var p = new(SelectSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_selectSpec
	return p
}

func (*SelectSpecContext) IsSelectSpecContext() {}

func NewSelectSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectSpecContext {
	var p = new(SelectSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_selectSpec

	return p
}

func (s *SelectSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectSpecContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *SelectSpecContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISTINCT, 0)
}

func (s *SelectSpecContext) DISTINCTROW() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISTINCTROW, 0)
}

func (s *SelectSpecContext) HIGH_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserHIGH_PRIORITY, 0)
}

func (s *SelectSpecContext) STRAIGHT_JOIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRAIGHT_JOIN, 0)
}

func (s *SelectSpecContext) SQL_SMALL_RESULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_SMALL_RESULT, 0)
}

func (s *SelectSpecContext) SQL_BIG_RESULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_BIG_RESULT, 0)
}

func (s *SelectSpecContext) SQL_BUFFER_RESULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_BUFFER_RESULT, 0)
}

func (s *SelectSpecContext) SQL_CACHE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_CACHE, 0)
}

func (s *SelectSpecContext) SQL_NO_CACHE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_NO_CACHE, 0)
}

func (s *SelectSpecContext) SQL_CALC_FOUND_ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_CALC_FOUND_ROWS, 0)
}

func (s *SelectSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectSpec(s)
	}
}

func (s *SelectSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectSpec(s)
	}
}

func (p *MySqlParser) SelectSpec() (localctx ISelectSpecContext) {
	this := p
	_ = this

	localctx = NewSelectSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, MySqlParserRULE_selectSpec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4070)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserALL, MySqlParserDISTINCT, MySqlParserDISTINCTROW:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4062)
			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1688849860264000) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case MySqlParserHIGH_PRIORITY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4063)
			p.Match(MySqlParserHIGH_PRIORITY)
		}

	case MySqlParserSTRAIGHT_JOIN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4064)
			p.Match(MySqlParserSTRAIGHT_JOIN)
		}

	case MySqlParserSQL_SMALL_RESULT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4065)
			p.Match(MySqlParserSQL_SMALL_RESULT)
		}

	case MySqlParserSQL_BIG_RESULT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4066)
			p.Match(MySqlParserSQL_BIG_RESULT)
		}

	case MySqlParserSQL_BUFFER_RESULT:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4067)
			p.Match(MySqlParserSQL_BUFFER_RESULT)
		}

	case MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4068)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserSQL_CACHE || _la == MySqlParserSQL_NO_CACHE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case MySqlParserSQL_CALC_FOUND_ROWS:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4069)
			p.Match(MySqlParserSQL_CALC_FOUND_ROWS)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISelectElementsContext is an interface to support dynamic dispatch.
type ISelectElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetStar returns the star token.
	GetStar() antlr.Token

	// SetStar sets the star token.
	SetStar(antlr.Token)

	// Getter signatures
	AllSelectElement() []ISelectElementContext
	SelectElement(i int) ISelectElementContext
	STAR() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSelectElementsContext differentiates from other interfaces.
	IsSelectElementsContext()
}

type SelectElementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	star   antlr.Token
}

func NewEmptySelectElementsContext() *SelectElementsContext {
	var p = new(SelectElementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_selectElements
	return p
}

func (*SelectElementsContext) IsSelectElementsContext() {}

func NewSelectElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectElementsContext {
	var p = new(SelectElementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_selectElements

	return p
}

func (s *SelectElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectElementsContext) GetStar() antlr.Token { return s.star }

func (s *SelectElementsContext) SetStar(v antlr.Token) { s.star = v }

func (s *SelectElementsContext) AllSelectElement() []ISelectElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectElementContext); ok {
			len++
		}
	}

	tst := make([]ISelectElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectElementContext); ok {
			tst[i] = t.(ISelectElementContext)
			i++
		}
	}

	return tst
}

func (s *SelectElementsContext) SelectElement(i int) ISelectElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectElementContext)
}

func (s *SelectElementsContext) STAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTAR, 0)
}

func (s *SelectElementsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *SelectElementsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *SelectElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectElements(s)
	}
}

func (s *SelectElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectElements(s)
	}
}

func (p *MySqlParser) SelectElements() (localctx ISelectElementsContext) {
	this := p
	_ = this

	localctx = NewSelectElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, MySqlParserRULE_selectElements)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4074)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 592, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4072)

			var _m = p.Match(MySqlParserSTAR)

			localctx.(*SelectElementsContext).star = _m
		}

	case 2:
		{
			p.SetState(4073)
			p.SelectElement()
		}

	}
	p.SetState(4080)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 593, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4076)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(4077)
				p.SelectElement()
			}

		}
		p.SetState(4082)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 593, p.GetParserRuleContext())
	}

	return localctx
}

// ISelectElementContext is an interface to support dynamic dispatch.
type ISelectElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSelectElementContext differentiates from other interfaces.
	IsSelectElementContext()
}

type SelectElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectElementContext() *SelectElementContext {
	var p = new(SelectElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_selectElement
	return p
}

func (*SelectElementContext) IsSelectElementContext() {}

func NewSelectElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectElementContext {
	var p = new(SelectElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_selectElement

	return p
}

func (s *SelectElementContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectElementContext) CopyFrom(ctx *SelectElementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *SelectElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SelectExpressionElementContext struct {
	*SelectElementContext
}

func NewSelectExpressionElementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectExpressionElementContext {
	var p = new(SelectExpressionElementContext)

	p.SelectElementContext = NewEmptySelectElementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectElementContext))

	return p
}

func (s *SelectExpressionElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectExpressionElementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SelectExpressionElementContext) LOCAL_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL_ID, 0)
}

func (s *SelectExpressionElementContext) VAR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserVAR_ASSIGN, 0)
}

func (s *SelectExpressionElementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SelectExpressionElementContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *SelectExpressionElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectExpressionElement(s)
	}
}

func (s *SelectExpressionElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectExpressionElement(s)
	}
}

type SelectFunctionElementContext struct {
	*SelectElementContext
}

func NewSelectFunctionElementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectFunctionElementContext {
	var p = new(SelectFunctionElementContext)

	p.SelectElementContext = NewEmptySelectElementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectElementContext))

	return p
}

func (s *SelectFunctionElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectFunctionElementContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *SelectFunctionElementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SelectFunctionElementContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *SelectFunctionElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectFunctionElement(s)
	}
}

func (s *SelectFunctionElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectFunctionElement(s)
	}
}

type SelectStarElementContext struct {
	*SelectElementContext
}

func NewSelectStarElementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectStarElementContext {
	var p = new(SelectStarElementContext)

	p.SelectElementContext = NewEmptySelectElementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectElementContext))

	return p
}

func (s *SelectStarElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectStarElementContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *SelectStarElementContext) DOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT, 0)
}

func (s *SelectStarElementContext) STAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTAR, 0)
}

func (s *SelectStarElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectStarElement(s)
	}
}

func (s *SelectStarElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectStarElement(s)
	}
}

type SelectColumnElementContext struct {
	*SelectElementContext
}

func NewSelectColumnElementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectColumnElementContext {
	var p = new(SelectColumnElementContext)

	p.SelectElementContext = NewEmptySelectElementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectElementContext))

	return p
}

func (s *SelectColumnElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectColumnElementContext) FullColumnName() IFullColumnNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *SelectColumnElementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SelectColumnElementContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *SelectColumnElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectColumnElement(s)
	}
}

func (s *SelectColumnElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectColumnElement(s)
	}
}

func (p *MySqlParser) SelectElement() (localctx ISelectElementContext) {
	this := p
	_ = this

	localctx = NewSelectElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, MySqlParserRULE_selectElement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4112)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 601, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSelectStarElementContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4083)
			p.FullId()
		}
		{
			p.SetState(4084)
			p.Match(MySqlParserDOT)
		}
		{
			p.SetState(4085)
			p.Match(MySqlParserSTAR)
		}

	case 2:
		localctx = NewSelectColumnElementContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4087)
			p.FullColumnName()
		}
		p.SetState(4092)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 595, p.GetParserRuleContext()) == 1 {
			p.SetState(4089)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserAS {
				{
					p.SetState(4088)
					p.Match(MySqlParserAS)
				}

			}
			{
				p.SetState(4091)
				p.Uid()
			}

		}

	case 3:
		localctx = NewSelectFunctionElementContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4094)
			p.FunctionCall()
		}
		p.SetState(4099)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 597, p.GetParserRuleContext()) == 1 {
			p.SetState(4096)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserAS {
				{
					p.SetState(4095)
					p.Match(MySqlParserAS)
				}

			}
			{
				p.SetState(4098)
				p.Uid()
			}

		}

	case 4:
		localctx = NewSelectExpressionElementContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		p.SetState(4103)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 598, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4101)
				p.Match(MySqlParserLOCAL_ID)
			}
			{
				p.SetState(4102)
				p.Match(MySqlParserVAR_ASSIGN)
			}

		}
		{
			p.SetState(4105)
			p.expression(0)
		}
		p.SetState(4110)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 600, p.GetParserRuleContext()) == 1 {
			p.SetState(4107)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserAS {
				{
					p.SetState(4106)
					p.Match(MySqlParserAS)
				}

			}
			{
				p.SetState(4109)
				p.Uid()
			}

		}

	}

	return localctx
}

// ISelectIntoExpressionContext is an interface to support dynamic dispatch.
type ISelectIntoExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSelectIntoExpressionContext differentiates from other interfaces.
	IsSelectIntoExpressionContext()
}

type SelectIntoExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectIntoExpressionContext() *SelectIntoExpressionContext {
	var p = new(SelectIntoExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_selectIntoExpression
	return p
}

func (*SelectIntoExpressionContext) IsSelectIntoExpressionContext() {}

func NewSelectIntoExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectIntoExpressionContext {
	var p = new(SelectIntoExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_selectIntoExpression

	return p
}

func (s *SelectIntoExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectIntoExpressionContext) CopyFrom(ctx *SelectIntoExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *SelectIntoExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectIntoExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SelectIntoVariablesContext struct {
	*SelectIntoExpressionContext
}

func NewSelectIntoVariablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectIntoVariablesContext {
	var p = new(SelectIntoVariablesContext)

	p.SelectIntoExpressionContext = NewEmptySelectIntoExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectIntoExpressionContext))

	return p
}

func (s *SelectIntoVariablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectIntoVariablesContext) INTO() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTO, 0)
}

func (s *SelectIntoVariablesContext) AllAssignmentField() []IAssignmentFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignmentFieldContext); ok {
			len++
		}
	}

	tst := make([]IAssignmentFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignmentFieldContext); ok {
			tst[i] = t.(IAssignmentFieldContext)
			i++
		}
	}

	return tst
}

func (s *SelectIntoVariablesContext) AssignmentField(i int) IAssignmentFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentFieldContext)
}

func (s *SelectIntoVariablesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *SelectIntoVariablesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *SelectIntoVariablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectIntoVariables(s)
	}
}

func (s *SelectIntoVariablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectIntoVariables(s)
	}
}

type SelectIntoTextFileContext struct {
	*SelectIntoExpressionContext
	filename     antlr.Token
	charset      ICharsetNameContext
	fieldsFormat antlr.Token
}

func NewSelectIntoTextFileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectIntoTextFileContext {
	var p = new(SelectIntoTextFileContext)

	p.SelectIntoExpressionContext = NewEmptySelectIntoExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectIntoExpressionContext))

	return p
}

func (s *SelectIntoTextFileContext) GetFilename() antlr.Token { return s.filename }

func (s *SelectIntoTextFileContext) GetFieldsFormat() antlr.Token { return s.fieldsFormat }

func (s *SelectIntoTextFileContext) SetFilename(v antlr.Token) { s.filename = v }

func (s *SelectIntoTextFileContext) SetFieldsFormat(v antlr.Token) { s.fieldsFormat = v }

func (s *SelectIntoTextFileContext) GetCharset() ICharsetNameContext { return s.charset }

func (s *SelectIntoTextFileContext) SetCharset(v ICharsetNameContext) { s.charset = v }

func (s *SelectIntoTextFileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectIntoTextFileContext) INTO() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTO, 0)
}

func (s *SelectIntoTextFileContext) OUTFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserOUTFILE, 0)
}

func (s *SelectIntoTextFileContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *SelectIntoTextFileContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER, 0)
}

func (s *SelectIntoTextFileContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *SelectIntoTextFileContext) LINES() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINES, 0)
}

func (s *SelectIntoTextFileContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *SelectIntoTextFileContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIELDS, 0)
}

func (s *SelectIntoTextFileContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMNS, 0)
}

func (s *SelectIntoTextFileContext) AllSelectFieldsInto() []ISelectFieldsIntoContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectFieldsIntoContext); ok {
			len++
		}
	}

	tst := make([]ISelectFieldsIntoContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectFieldsIntoContext); ok {
			tst[i] = t.(ISelectFieldsIntoContext)
			i++
		}
	}

	return tst
}

func (s *SelectIntoTextFileContext) SelectFieldsInto(i int) ISelectFieldsIntoContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectFieldsIntoContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectFieldsIntoContext)
}

func (s *SelectIntoTextFileContext) AllSelectLinesInto() []ISelectLinesIntoContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectLinesIntoContext); ok {
			len++
		}
	}

	tst := make([]ISelectLinesIntoContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectLinesIntoContext); ok {
			tst[i] = t.(ISelectLinesIntoContext)
			i++
		}
	}

	return tst
}

func (s *SelectIntoTextFileContext) SelectLinesInto(i int) ISelectLinesIntoContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectLinesIntoContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectLinesIntoContext)
}

func (s *SelectIntoTextFileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectIntoTextFile(s)
	}
}

func (s *SelectIntoTextFileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectIntoTextFile(s)
	}
}

type SelectIntoDumpFileContext struct {
	*SelectIntoExpressionContext
}

func NewSelectIntoDumpFileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectIntoDumpFileContext {
	var p = new(SelectIntoDumpFileContext)

	p.SelectIntoExpressionContext = NewEmptySelectIntoExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectIntoExpressionContext))

	return p
}

func (s *SelectIntoDumpFileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectIntoDumpFileContext) INTO() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTO, 0)
}

func (s *SelectIntoDumpFileContext) DUMPFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDUMPFILE, 0)
}

func (s *SelectIntoDumpFileContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *SelectIntoDumpFileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectIntoDumpFile(s)
	}
}

func (s *SelectIntoDumpFileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectIntoDumpFile(s)
	}
}

func (p *MySqlParser) SelectIntoExpression() (localctx ISelectIntoExpressionContext) {
	this := p
	_ = this

	localctx = NewSelectIntoExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, MySqlParserRULE_selectIntoExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4150)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 608, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSelectIntoVariablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4114)
			p.Match(MySqlParserINTO)
		}
		{
			p.SetState(4115)
			p.AssignmentField()
		}
		p.SetState(4120)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(4116)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(4117)
				p.AssignmentField()
			}

			p.SetState(4122)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewSelectIntoDumpFileContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4123)
			p.Match(MySqlParserINTO)
		}
		{
			p.SetState(4124)
			p.Match(MySqlParserDUMPFILE)
		}
		{
			p.SetState(4125)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	case 3:
		localctx = NewSelectIntoTextFileContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4126)
			p.Match(MySqlParserINTO)
		}
		{
			p.SetState(4127)
			p.Match(MySqlParserOUTFILE)
		}
		{
			p.SetState(4128)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*SelectIntoTextFileContext).filename = _m
		}
		p.SetState(4132)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCHARACTER {
			{
				p.SetState(4129)
				p.Match(MySqlParserCHARACTER)
			}
			{
				p.SetState(4130)
				p.Match(MySqlParserSET)
			}
			{
				p.SetState(4131)

				var _x = p.CharsetName()

				localctx.(*SelectIntoTextFileContext).charset = _x
			}

		}
		p.SetState(4140)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 605, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4134)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*SelectIntoTextFileContext).fieldsFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserCOLUMNS || _la == MySqlParserFIELDS) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*SelectIntoTextFileContext).fieldsFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			p.SetState(4136)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == MySqlParserENCLOSED || _la == MySqlParserESCAPED || _la == MySqlParserOPTIONALLY || _la == MySqlParserTERMINATED {
				{
					p.SetState(4135)
					p.SelectFieldsInto()
				}

				p.SetState(4138)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(4148)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLINES {
			{
				p.SetState(4142)
				p.Match(MySqlParserLINES)
			}
			p.SetState(4144)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == MySqlParserSTARTING || _la == MySqlParserTERMINATED {
				{
					p.SetState(4143)
					p.SelectLinesInto()
				}

				p.SetState(4146)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}

	}

	return localctx
}

// ISelectFieldsIntoContext is an interface to support dynamic dispatch.
type ISelectFieldsIntoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTerminationField returns the terminationField token.
	GetTerminationField() antlr.Token

	// GetEnclosion returns the enclosion token.
	GetEnclosion() antlr.Token

	// GetEscaping returns the escaping token.
	GetEscaping() antlr.Token

	// SetTerminationField sets the terminationField token.
	SetTerminationField(antlr.Token)

	// SetEnclosion sets the enclosion token.
	SetEnclosion(antlr.Token)

	// SetEscaping sets the escaping token.
	SetEscaping(antlr.Token)

	// Getter signatures
	TERMINATED() antlr.TerminalNode
	BY() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	ENCLOSED() antlr.TerminalNode
	OPTIONALLY() antlr.TerminalNode
	ESCAPED() antlr.TerminalNode

	// IsSelectFieldsIntoContext differentiates from other interfaces.
	IsSelectFieldsIntoContext()
}

type SelectFieldsIntoContext struct {
	*antlr.BaseParserRuleContext
	parser           antlr.Parser
	terminationField antlr.Token
	enclosion        antlr.Token
	escaping         antlr.Token
}

func NewEmptySelectFieldsIntoContext() *SelectFieldsIntoContext {
	var p = new(SelectFieldsIntoContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_selectFieldsInto
	return p
}

func (*SelectFieldsIntoContext) IsSelectFieldsIntoContext() {}

func NewSelectFieldsIntoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectFieldsIntoContext {
	var p = new(SelectFieldsIntoContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_selectFieldsInto

	return p
}

func (s *SelectFieldsIntoContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectFieldsIntoContext) GetTerminationField() antlr.Token { return s.terminationField }

func (s *SelectFieldsIntoContext) GetEnclosion() antlr.Token { return s.enclosion }

func (s *SelectFieldsIntoContext) GetEscaping() antlr.Token { return s.escaping }

func (s *SelectFieldsIntoContext) SetTerminationField(v antlr.Token) { s.terminationField = v }

func (s *SelectFieldsIntoContext) SetEnclosion(v antlr.Token) { s.enclosion = v }

func (s *SelectFieldsIntoContext) SetEscaping(v antlr.Token) { s.escaping = v }

func (s *SelectFieldsIntoContext) TERMINATED() antlr.TerminalNode {
	return s.GetToken(MySqlParserTERMINATED, 0)
}

func (s *SelectFieldsIntoContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *SelectFieldsIntoContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *SelectFieldsIntoContext) ENCLOSED() antlr.TerminalNode {
	return s.GetToken(MySqlParserENCLOSED, 0)
}

func (s *SelectFieldsIntoContext) OPTIONALLY() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTIONALLY, 0)
}

func (s *SelectFieldsIntoContext) ESCAPED() antlr.TerminalNode {
	return s.GetToken(MySqlParserESCAPED, 0)
}

func (s *SelectFieldsIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectFieldsIntoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectFieldsIntoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectFieldsInto(s)
	}
}

func (s *SelectFieldsIntoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectFieldsInto(s)
	}
}

func (p *MySqlParser) SelectFieldsInto() (localctx ISelectFieldsIntoContext) {
	this := p
	_ = this

	localctx = NewSelectFieldsIntoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, MySqlParserRULE_selectFieldsInto)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4164)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserTERMINATED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4152)
			p.Match(MySqlParserTERMINATED)
		}
		{
			p.SetState(4153)
			p.Match(MySqlParserBY)
		}
		{
			p.SetState(4154)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*SelectFieldsIntoContext).terminationField = _m
		}

	case MySqlParserENCLOSED, MySqlParserOPTIONALLY:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4156)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserOPTIONALLY {
			{
				p.SetState(4155)
				p.Match(MySqlParserOPTIONALLY)
			}

		}
		{
			p.SetState(4158)
			p.Match(MySqlParserENCLOSED)
		}
		{
			p.SetState(4159)
			p.Match(MySqlParserBY)
		}
		{
			p.SetState(4160)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*SelectFieldsIntoContext).enclosion = _m
		}

	case MySqlParserESCAPED:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4161)
			p.Match(MySqlParserESCAPED)
		}
		{
			p.SetState(4162)
			p.Match(MySqlParserBY)
		}
		{
			p.SetState(4163)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*SelectFieldsIntoContext).escaping = _m
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISelectLinesIntoContext is an interface to support dynamic dispatch.
type ISelectLinesIntoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetStarting returns the starting token.
	GetStarting() antlr.Token

	// GetTerminationLine returns the terminationLine token.
	GetTerminationLine() antlr.Token

	// SetStarting sets the starting token.
	SetStarting(antlr.Token)

	// SetTerminationLine sets the terminationLine token.
	SetTerminationLine(antlr.Token)

	// Getter signatures
	STARTING() antlr.TerminalNode
	BY() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	TERMINATED() antlr.TerminalNode

	// IsSelectLinesIntoContext differentiates from other interfaces.
	IsSelectLinesIntoContext()
}

type SelectLinesIntoContext struct {
	*antlr.BaseParserRuleContext
	parser          antlr.Parser
	starting        antlr.Token
	terminationLine antlr.Token
}

func NewEmptySelectLinesIntoContext() *SelectLinesIntoContext {
	var p = new(SelectLinesIntoContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_selectLinesInto
	return p
}

func (*SelectLinesIntoContext) IsSelectLinesIntoContext() {}

func NewSelectLinesIntoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectLinesIntoContext {
	var p = new(SelectLinesIntoContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_selectLinesInto

	return p
}

func (s *SelectLinesIntoContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectLinesIntoContext) GetStarting() antlr.Token { return s.starting }

func (s *SelectLinesIntoContext) GetTerminationLine() antlr.Token { return s.terminationLine }

func (s *SelectLinesIntoContext) SetStarting(v antlr.Token) { s.starting = v }

func (s *SelectLinesIntoContext) SetTerminationLine(v antlr.Token) { s.terminationLine = v }

func (s *SelectLinesIntoContext) STARTING() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTARTING, 0)
}

func (s *SelectLinesIntoContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *SelectLinesIntoContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *SelectLinesIntoContext) TERMINATED() antlr.TerminalNode {
	return s.GetToken(MySqlParserTERMINATED, 0)
}

func (s *SelectLinesIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectLinesIntoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectLinesIntoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectLinesInto(s)
	}
}

func (s *SelectLinesIntoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectLinesInto(s)
	}
}

func (p *MySqlParser) SelectLinesInto() (localctx ISelectLinesIntoContext) {
	this := p
	_ = this

	localctx = NewSelectLinesIntoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, MySqlParserRULE_selectLinesInto)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4172)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSTARTING:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4166)
			p.Match(MySqlParserSTARTING)
		}
		{
			p.SetState(4167)
			p.Match(MySqlParserBY)
		}
		{
			p.SetState(4168)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*SelectLinesIntoContext).starting = _m
		}

	case MySqlParserTERMINATED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4169)
			p.Match(MySqlParserTERMINATED)
		}
		{
			p.SetState(4170)
			p.Match(MySqlParserBY)
		}
		{
			p.SetState(4171)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*SelectLinesIntoContext).terminationLine = _m
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFromClauseContext is an interface to support dynamic dispatch.
type IFromClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWhereExpr returns the whereExpr rule contexts.
	GetWhereExpr() IExpressionContext

	// SetWhereExpr sets the whereExpr rule contexts.
	SetWhereExpr(IExpressionContext)

	// Getter signatures
	FROM() antlr.TerminalNode
	TableSources() ITableSourcesContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsFromClauseContext differentiates from other interfaces.
	IsFromClauseContext()
}

type FromClauseContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	whereExpr IExpressionContext
}

func NewEmptyFromClauseContext() *FromClauseContext {
	var p = new(FromClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_fromClause
	return p
}

func (*FromClauseContext) IsFromClauseContext() {}

func NewFromClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromClauseContext {
	var p = new(FromClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_fromClause

	return p
}

func (s *FromClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FromClauseContext) GetWhereExpr() IExpressionContext { return s.whereExpr }

func (s *FromClauseContext) SetWhereExpr(v IExpressionContext) { s.whereExpr = v }

func (s *FromClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *FromClauseContext) TableSources() ITableSourcesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSourcesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSourcesContext)
}

func (s *FromClauseContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWHERE, 0)
}

func (s *FromClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FromClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFromClause(s)
	}
}

func (s *FromClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFromClause(s)
	}
}

func (p *MySqlParser) FromClause() (localctx IFromClauseContext) {
	this := p
	_ = this

	localctx = NewFromClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, MySqlParserRULE_fromClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4176)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserFROM {
		{
			p.SetState(4174)
			p.Match(MySqlParserFROM)
		}
		{
			p.SetState(4175)
			p.TableSources()
		}

	}
	p.SetState(4180)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserWHERE {
		{
			p.SetState(4178)
			p.Match(MySqlParserWHERE)
		}
		{
			p.SetState(4179)

			var _x = p.expression(0)

			localctx.(*FromClauseContext).whereExpr = _x
		}

	}

	return localctx
}

// IGroupByClauseContext is an interface to support dynamic dispatch.
type IGroupByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GROUP() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllGroupByItem() []IGroupByItemContext
	GroupByItem(i int) IGroupByItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	WITH() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode

	// IsGroupByClauseContext differentiates from other interfaces.
	IsGroupByClauseContext()
}

type GroupByClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupByClauseContext() *GroupByClauseContext {
	var p = new(GroupByClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_groupByClause
	return p
}

func (*GroupByClauseContext) IsGroupByClauseContext() {}

func NewGroupByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByClauseContext {
	var p = new(GroupByClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_groupByClause

	return p
}

func (s *GroupByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByClauseContext) GROUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP, 0)
}

func (s *GroupByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *GroupByClauseContext) AllGroupByItem() []IGroupByItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGroupByItemContext); ok {
			len++
		}
	}

	tst := make([]IGroupByItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGroupByItemContext); ok {
			tst[i] = t.(IGroupByItemContext)
			i++
		}
	}

	return tst
}

func (s *GroupByClauseContext) GroupByItem(i int) IGroupByItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByItemContext)
}

func (s *GroupByClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *GroupByClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *GroupByClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *GroupByClauseContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLLUP, 0)
}

func (s *GroupByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterGroupByClause(s)
	}
}

func (s *GroupByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitGroupByClause(s)
	}
}

func (p *MySqlParser) GroupByClause() (localctx IGroupByClauseContext) {
	this := p
	_ = this

	localctx = NewGroupByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, MySqlParserRULE_groupByClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4182)
		p.Match(MySqlParserGROUP)
	}
	{
		p.SetState(4183)
		p.Match(MySqlParserBY)
	}
	{
		p.SetState(4184)
		p.GroupByItem()
	}
	p.SetState(4189)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 614, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4185)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(4186)
				p.GroupByItem()
			}

		}
		p.SetState(4191)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 614, p.GetParserRuleContext())
	}
	p.SetState(4194)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 615, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4192)
			p.Match(MySqlParserWITH)
		}
		{
			p.SetState(4193)
			p.Match(MySqlParserROLLUP)
		}

	}

	return localctx
}

// IHavingClauseContext is an interface to support dynamic dispatch.
type IHavingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetHavingExpr returns the havingExpr rule contexts.
	GetHavingExpr() IExpressionContext

	// SetHavingExpr sets the havingExpr rule contexts.
	SetHavingExpr(IExpressionContext)

	// Getter signatures
	HAVING() antlr.TerminalNode
	Expression() IExpressionContext

	// IsHavingClauseContext differentiates from other interfaces.
	IsHavingClauseContext()
}

type HavingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser     antlr.Parser
	havingExpr IExpressionContext
}

func NewEmptyHavingClauseContext() *HavingClauseContext {
	var p = new(HavingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_havingClause
	return p
}

func (*HavingClauseContext) IsHavingClauseContext() {}

func NewHavingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HavingClauseContext {
	var p = new(HavingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_havingClause

	return p
}

func (s *HavingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *HavingClauseContext) GetHavingExpr() IExpressionContext { return s.havingExpr }

func (s *HavingClauseContext) SetHavingExpr(v IExpressionContext) { s.havingExpr = v }

func (s *HavingClauseContext) HAVING() antlr.TerminalNode {
	return s.GetToken(MySqlParserHAVING, 0)
}

func (s *HavingClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *HavingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HavingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HavingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHavingClause(s)
	}
}

func (s *HavingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHavingClause(s)
	}
}

func (p *MySqlParser) HavingClause() (localctx IHavingClauseContext) {
	this := p
	_ = this

	localctx = NewHavingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, MySqlParserRULE_havingClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4196)
		p.Match(MySqlParserHAVING)
	}
	{
		p.SetState(4197)

		var _x = p.expression(0)

		localctx.(*HavingClauseContext).havingExpr = _x
	}

	return localctx
}

// IWindowClauseContext is an interface to support dynamic dispatch.
type IWindowClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WINDOW() antlr.TerminalNode
	AllWindowName() []IWindowNameContext
	WindowName(i int) IWindowNameContext
	AllAS() []antlr.TerminalNode
	AS(i int) antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	AllWindowSpec() []IWindowSpecContext
	WindowSpec(i int) IWindowSpecContext
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWindowClauseContext differentiates from other interfaces.
	IsWindowClauseContext()
}

type WindowClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowClauseContext() *WindowClauseContext {
	var p = new(WindowClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_windowClause
	return p
}

func (*WindowClauseContext) IsWindowClauseContext() {}

func NewWindowClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowClauseContext {
	var p = new(WindowClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_windowClause

	return p
}

func (s *WindowClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowClauseContext) WINDOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserWINDOW, 0)
}

func (s *WindowClauseContext) AllWindowName() []IWindowNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWindowNameContext); ok {
			len++
		}
	}

	tst := make([]IWindowNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWindowNameContext); ok {
			tst[i] = t.(IWindowNameContext)
			i++
		}
	}

	return tst
}

func (s *WindowClauseContext) WindowName(i int) IWindowNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowNameContext)
}

func (s *WindowClauseContext) AllAS() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserAS)
}

func (s *WindowClauseContext) AS(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, i)
}

func (s *WindowClauseContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *WindowClauseContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *WindowClauseContext) AllWindowSpec() []IWindowSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWindowSpecContext); ok {
			len++
		}
	}

	tst := make([]IWindowSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWindowSpecContext); ok {
			tst[i] = t.(IWindowSpecContext)
			i++
		}
	}

	return tst
}

func (s *WindowClauseContext) WindowSpec(i int) IWindowSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowSpecContext)
}

func (s *WindowClauseContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *WindowClauseContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *WindowClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *WindowClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *WindowClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterWindowClause(s)
	}
}

func (s *WindowClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitWindowClause(s)
	}
}

func (p *MySqlParser) WindowClause() (localctx IWindowClauseContext) {
	this := p
	_ = this

	localctx = NewWindowClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, MySqlParserRULE_windowClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4199)
		p.Match(MySqlParserWINDOW)
	}
	{
		p.SetState(4200)
		p.WindowName()
	}
	{
		p.SetState(4201)
		p.Match(MySqlParserAS)
	}
	{
		p.SetState(4202)
		p.Match(MySqlParserLR_BRACKET)
	}
	{
		p.SetState(4203)
		p.WindowSpec()
	}
	{
		p.SetState(4204)
		p.Match(MySqlParserRR_BRACKET)
	}
	p.SetState(4214)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 616, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4205)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(4206)
				p.WindowName()
			}
			{
				p.SetState(4207)
				p.Match(MySqlParserAS)
			}
			{
				p.SetState(4208)
				p.Match(MySqlParserLR_BRACKET)
			}
			{
				p.SetState(4209)
				p.WindowSpec()
			}
			{
				p.SetState(4210)
				p.Match(MySqlParserRR_BRACKET)
			}

		}
		p.SetState(4216)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 616, p.GetParserRuleContext())
	}

	return localctx
}

// IGroupByItemContext is an interface to support dynamic dispatch.
type IGroupByItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOrder returns the order token.
	GetOrder() antlr.Token

	// SetOrder sets the order token.
	SetOrder(antlr.Token)

	// Getter signatures
	Expression() IExpressionContext
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode

	// IsGroupByItemContext differentiates from other interfaces.
	IsGroupByItemContext()
}

type GroupByItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	order  antlr.Token
}

func NewEmptyGroupByItemContext() *GroupByItemContext {
	var p = new(GroupByItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_groupByItem
	return p
}

func (*GroupByItemContext) IsGroupByItemContext() {}

func NewGroupByItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByItemContext {
	var p = new(GroupByItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_groupByItem

	return p
}

func (s *GroupByItemContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByItemContext) GetOrder() antlr.Token { return s.order }

func (s *GroupByItemContext) SetOrder(v antlr.Token) { s.order = v }

func (s *GroupByItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GroupByItemContext) ASC() antlr.TerminalNode {
	return s.GetToken(MySqlParserASC, 0)
}

func (s *GroupByItemContext) DESC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDESC, 0)
}

func (s *GroupByItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupByItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterGroupByItem(s)
	}
}

func (s *GroupByItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitGroupByItem(s)
	}
}

func (p *MySqlParser) GroupByItem() (localctx IGroupByItemContext) {
	this := p
	_ = this

	localctx = NewGroupByItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, MySqlParserRULE_groupByItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4217)
		p.expression(0)
	}
	p.SetState(4219)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 617, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4218)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*GroupByItemContext).order = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserASC || _la == MySqlParserDESC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*GroupByItemContext).order = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// ILimitClauseContext is an interface to support dynamic dispatch.
type ILimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOffset returns the offset rule contexts.
	GetOffset() ILimitClauseAtomContext

	// GetLimit returns the limit rule contexts.
	GetLimit() ILimitClauseAtomContext

	// SetOffset sets the offset rule contexts.
	SetOffset(ILimitClauseAtomContext)

	// SetLimit sets the limit rule contexts.
	SetLimit(ILimitClauseAtomContext)

	// Getter signatures
	LIMIT() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	AllLimitClauseAtom() []ILimitClauseAtomContext
	LimitClauseAtom(i int) ILimitClauseAtomContext
	COMMA() antlr.TerminalNode

	// IsLimitClauseContext differentiates from other interfaces.
	IsLimitClauseContext()
}

type LimitClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	offset ILimitClauseAtomContext
	limit  ILimitClauseAtomContext
}

func NewEmptyLimitClauseContext() *LimitClauseContext {
	var p = new(LimitClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_limitClause
	return p
}

func (*LimitClauseContext) IsLimitClauseContext() {}

func NewLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitClauseContext {
	var p = new(LimitClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_limitClause

	return p
}

func (s *LimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitClauseContext) GetOffset() ILimitClauseAtomContext { return s.offset }

func (s *LimitClauseContext) GetLimit() ILimitClauseAtomContext { return s.limit }

func (s *LimitClauseContext) SetOffset(v ILimitClauseAtomContext) { s.offset = v }

func (s *LimitClauseContext) SetLimit(v ILimitClauseAtomContext) { s.limit = v }

func (s *LimitClauseContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIMIT, 0)
}

func (s *LimitClauseContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(MySqlParserOFFSET, 0)
}

func (s *LimitClauseContext) AllLimitClauseAtom() []ILimitClauseAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILimitClauseAtomContext); ok {
			len++
		}
	}

	tst := make([]ILimitClauseAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILimitClauseAtomContext); ok {
			tst[i] = t.(ILimitClauseAtomContext)
			i++
		}
	}

	return tst
}

func (s *LimitClauseContext) LimitClauseAtom(i int) ILimitClauseAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseAtomContext)
}

func (s *LimitClauseContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *LimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLimitClause(s)
	}
}

func (s *LimitClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLimitClause(s)
	}
}

func (p *MySqlParser) LimitClause() (localctx ILimitClauseContext) {
	this := p
	_ = this

	localctx = NewLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, MySqlParserRULE_limitClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4221)
		p.Match(MySqlParserLIMIT)
	}
	p.SetState(4232)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 619, p.GetParserRuleContext()) {
	case 1:
		p.SetState(4225)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 618, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4222)

				var _x = p.LimitClauseAtom()

				localctx.(*LimitClauseContext).offset = _x
			}
			{
				p.SetState(4223)
				p.Match(MySqlParserCOMMA)
			}

		}
		{
			p.SetState(4227)

			var _x = p.LimitClauseAtom()

			localctx.(*LimitClauseContext).limit = _x
		}

	case 2:
		{
			p.SetState(4228)

			var _x = p.LimitClauseAtom()

			localctx.(*LimitClauseContext).limit = _x
		}
		{
			p.SetState(4229)
			p.Match(MySqlParserOFFSET)
		}
		{
			p.SetState(4230)

			var _x = p.LimitClauseAtom()

			localctx.(*LimitClauseContext).offset = _x
		}

	}

	return localctx
}

// ILimitClauseAtomContext is an interface to support dynamic dispatch.
type ILimitClauseAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DecimalLiteral() IDecimalLiteralContext
	MysqlVariable() IMysqlVariableContext
	SimpleId() ISimpleIdContext

	// IsLimitClauseAtomContext differentiates from other interfaces.
	IsLimitClauseAtomContext()
}

type LimitClauseAtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitClauseAtomContext() *LimitClauseAtomContext {
	var p = new(LimitClauseAtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_limitClauseAtom
	return p
}

func (*LimitClauseAtomContext) IsLimitClauseAtomContext() {}

func NewLimitClauseAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitClauseAtomContext {
	var p = new(LimitClauseAtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_limitClauseAtom

	return p
}

func (s *LimitClauseAtomContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitClauseAtomContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LimitClauseAtomContext) MysqlVariable() IMysqlVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMysqlVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMysqlVariableContext)
}

func (s *LimitClauseAtomContext) SimpleId() ISimpleIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdContext)
}

func (s *LimitClauseAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitClauseAtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitClauseAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLimitClauseAtom(s)
	}
}

func (s *LimitClauseAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLimitClauseAtom(s)
	}
}

func (p *MySqlParser) LimitClauseAtom() (localctx ILimitClauseAtomContext) {
	this := p
	_ = this

	localctx = NewLimitClauseAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, MySqlParserRULE_limitClauseAtom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4237)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserZERO_DECIMAL, MySqlParserONE_DECIMAL, MySqlParserTWO_DECIMAL, MySqlParserDECIMAL_LITERAL, MySqlParserREAL_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4234)
			p.DecimalLiteral()
		}

	case MySqlParserLOCAL_ID, MySqlParserGLOBAL_ID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4235)
			p.MysqlVariable()
		}

	case MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserSTRING_LITERAL, MySqlParserID, MySqlParserREVERSE_QUOTE_ID:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4236)
			p.SimpleId()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IStartTransactionContext is an interface to support dynamic dispatch.
type IStartTransactionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	START() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	AllTransactionMode() []ITransactionModeContext
	TransactionMode(i int) ITransactionModeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsStartTransactionContext differentiates from other interfaces.
	IsStartTransactionContext()
}

type StartTransactionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartTransactionContext() *StartTransactionContext {
	var p = new(StartTransactionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_startTransaction
	return p
}

func (*StartTransactionContext) IsStartTransactionContext() {}

func NewStartTransactionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartTransactionContext {
	var p = new(StartTransactionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_startTransaction

	return p
}

func (s *StartTransactionContext) GetParser() antlr.Parser { return s.parser }

func (s *StartTransactionContext) START() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTART, 0)
}

func (s *StartTransactionContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRANSACTION, 0)
}

func (s *StartTransactionContext) AllTransactionMode() []ITransactionModeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITransactionModeContext); ok {
			len++
		}
	}

	tst := make([]ITransactionModeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITransactionModeContext); ok {
			tst[i] = t.(ITransactionModeContext)
			i++
		}
	}

	return tst
}

func (s *StartTransactionContext) TransactionMode(i int) ITransactionModeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionModeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionModeContext)
}

func (s *StartTransactionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *StartTransactionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *StartTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartTransactionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StartTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterStartTransaction(s)
	}
}

func (s *StartTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitStartTransaction(s)
	}
}

func (p *MySqlParser) StartTransaction() (localctx IStartTransactionContext) {
	this := p
	_ = this

	localctx = NewStartTransactionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, MySqlParserRULE_startTransaction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4239)
		p.Match(MySqlParserSTART)
	}
	{
		p.SetState(4240)
		p.Match(MySqlParserTRANSACTION)
	}
	p.SetState(4249)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 622, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4241)
			p.TransactionMode()
		}
		p.SetState(4246)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(4242)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(4243)
				p.TransactionMode()
			}

			p.SetState(4248)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IBeginWorkContext is an interface to support dynamic dispatch.
type IBeginWorkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BEGIN() antlr.TerminalNode
	WORK() antlr.TerminalNode

	// IsBeginWorkContext differentiates from other interfaces.
	IsBeginWorkContext()
}

type BeginWorkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBeginWorkContext() *BeginWorkContext {
	var p = new(BeginWorkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_beginWork
	return p
}

func (*BeginWorkContext) IsBeginWorkContext() {}

func NewBeginWorkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BeginWorkContext {
	var p = new(BeginWorkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_beginWork

	return p
}

func (s *BeginWorkContext) GetParser() antlr.Parser { return s.parser }

func (s *BeginWorkContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBEGIN, 0)
}

func (s *BeginWorkContext) WORK() antlr.TerminalNode {
	return s.GetToken(MySqlParserWORK, 0)
}

func (s *BeginWorkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BeginWorkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BeginWorkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterBeginWork(s)
	}
}

func (s *BeginWorkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitBeginWork(s)
	}
}

func (p *MySqlParser) BeginWork() (localctx IBeginWorkContext) {
	this := p
	_ = this

	localctx = NewBeginWorkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, MySqlParserRULE_beginWork)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4251)
		p.Match(MySqlParserBEGIN)
	}
	p.SetState(4253)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserWORK {
		{
			p.SetState(4252)
			p.Match(MySqlParserWORK)
		}

	}

	return localctx
}

// ICommitWorkContext is an interface to support dynamic dispatch.
type ICommitWorkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNochain returns the nochain token.
	GetNochain() antlr.Token

	// GetNorelease returns the norelease token.
	GetNorelease() antlr.Token

	// SetNochain sets the nochain token.
	SetNochain(antlr.Token)

	// SetNorelease sets the norelease token.
	SetNorelease(antlr.Token)

	// Getter signatures
	COMMIT() antlr.TerminalNode
	WORK() antlr.TerminalNode
	AND() antlr.TerminalNode
	CHAIN() antlr.TerminalNode
	RELEASE() antlr.TerminalNode
	AllNO() []antlr.TerminalNode
	NO(i int) antlr.TerminalNode

	// IsCommitWorkContext differentiates from other interfaces.
	IsCommitWorkContext()
}

type CommitWorkContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	nochain   antlr.Token
	norelease antlr.Token
}

func NewEmptyCommitWorkContext() *CommitWorkContext {
	var p = new(CommitWorkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_commitWork
	return p
}

func (*CommitWorkContext) IsCommitWorkContext() {}

func NewCommitWorkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommitWorkContext {
	var p = new(CommitWorkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_commitWork

	return p
}

func (s *CommitWorkContext) GetParser() antlr.Parser { return s.parser }

func (s *CommitWorkContext) GetNochain() antlr.Token { return s.nochain }

func (s *CommitWorkContext) GetNorelease() antlr.Token { return s.norelease }

func (s *CommitWorkContext) SetNochain(v antlr.Token) { s.nochain = v }

func (s *CommitWorkContext) SetNorelease(v antlr.Token) { s.norelease = v }

func (s *CommitWorkContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMIT, 0)
}

func (s *CommitWorkContext) WORK() antlr.TerminalNode {
	return s.GetToken(MySqlParserWORK, 0)
}

func (s *CommitWorkContext) AND() antlr.TerminalNode {
	return s.GetToken(MySqlParserAND, 0)
}

func (s *CommitWorkContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAIN, 0)
}

func (s *CommitWorkContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELEASE, 0)
}

func (s *CommitWorkContext) AllNO() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserNO)
}

func (s *CommitWorkContext) NO(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserNO, i)
}

func (s *CommitWorkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommitWorkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommitWorkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCommitWork(s)
	}
}

func (s *CommitWorkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCommitWork(s)
	}
}

func (p *MySqlParser) CommitWork() (localctx ICommitWorkContext) {
	this := p
	_ = this

	localctx = NewCommitWorkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, MySqlParserRULE_commitWork)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4255)
		p.Match(MySqlParserCOMMIT)
	}
	p.SetState(4257)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserWORK {
		{
			p.SetState(4256)
			p.Match(MySqlParserWORK)
		}

	}
	p.SetState(4264)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserAND {
		{
			p.SetState(4259)
			p.Match(MySqlParserAND)
		}
		p.SetState(4261)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserNO {
			{
				p.SetState(4260)

				var _m = p.Match(MySqlParserNO)

				localctx.(*CommitWorkContext).nochain = _m
			}

		}
		{
			p.SetState(4263)
			p.Match(MySqlParserCHAIN)
		}

	}
	p.SetState(4270)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 628, p.GetParserRuleContext()) == 1 {
		p.SetState(4267)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserNO {
			{
				p.SetState(4266)

				var _m = p.Match(MySqlParserNO)

				localctx.(*CommitWorkContext).norelease = _m
			}

		}
		{
			p.SetState(4269)
			p.Match(MySqlParserRELEASE)
		}

	}

	return localctx
}

// IRollbackWorkContext is an interface to support dynamic dispatch.
type IRollbackWorkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNochain returns the nochain token.
	GetNochain() antlr.Token

	// GetNorelease returns the norelease token.
	GetNorelease() antlr.Token

	// SetNochain sets the nochain token.
	SetNochain(antlr.Token)

	// SetNorelease sets the norelease token.
	SetNorelease(antlr.Token)

	// Getter signatures
	ROLLBACK() antlr.TerminalNode
	WORK() antlr.TerminalNode
	AND() antlr.TerminalNode
	CHAIN() antlr.TerminalNode
	RELEASE() antlr.TerminalNode
	AllNO() []antlr.TerminalNode
	NO(i int) antlr.TerminalNode

	// IsRollbackWorkContext differentiates from other interfaces.
	IsRollbackWorkContext()
}

type RollbackWorkContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	nochain   antlr.Token
	norelease antlr.Token
}

func NewEmptyRollbackWorkContext() *RollbackWorkContext {
	var p = new(RollbackWorkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_rollbackWork
	return p
}

func (*RollbackWorkContext) IsRollbackWorkContext() {}

func NewRollbackWorkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollbackWorkContext {
	var p = new(RollbackWorkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_rollbackWork

	return p
}

func (s *RollbackWorkContext) GetParser() antlr.Parser { return s.parser }

func (s *RollbackWorkContext) GetNochain() antlr.Token { return s.nochain }

func (s *RollbackWorkContext) GetNorelease() antlr.Token { return s.norelease }

func (s *RollbackWorkContext) SetNochain(v antlr.Token) { s.nochain = v }

func (s *RollbackWorkContext) SetNorelease(v antlr.Token) { s.norelease = v }

func (s *RollbackWorkContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLLBACK, 0)
}

func (s *RollbackWorkContext) WORK() antlr.TerminalNode {
	return s.GetToken(MySqlParserWORK, 0)
}

func (s *RollbackWorkContext) AND() antlr.TerminalNode {
	return s.GetToken(MySqlParserAND, 0)
}

func (s *RollbackWorkContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAIN, 0)
}

func (s *RollbackWorkContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELEASE, 0)
}

func (s *RollbackWorkContext) AllNO() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserNO)
}

func (s *RollbackWorkContext) NO(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserNO, i)
}

func (s *RollbackWorkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollbackWorkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RollbackWorkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRollbackWork(s)
	}
}

func (s *RollbackWorkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRollbackWork(s)
	}
}

func (p *MySqlParser) RollbackWork() (localctx IRollbackWorkContext) {
	this := p
	_ = this

	localctx = NewRollbackWorkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, MySqlParserRULE_rollbackWork)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4272)
		p.Match(MySqlParserROLLBACK)
	}
	p.SetState(4274)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserWORK {
		{
			p.SetState(4273)
			p.Match(MySqlParserWORK)
		}

	}
	p.SetState(4281)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserAND {
		{
			p.SetState(4276)
			p.Match(MySqlParserAND)
		}
		p.SetState(4278)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserNO {
			{
				p.SetState(4277)

				var _m = p.Match(MySqlParserNO)

				localctx.(*RollbackWorkContext).nochain = _m
			}

		}
		{
			p.SetState(4280)
			p.Match(MySqlParserCHAIN)
		}

	}
	p.SetState(4287)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 633, p.GetParserRuleContext()) == 1 {
		p.SetState(4284)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserNO {
			{
				p.SetState(4283)

				var _m = p.Match(MySqlParserNO)

				localctx.(*RollbackWorkContext).norelease = _m
			}

		}
		{
			p.SetState(4286)
			p.Match(MySqlParserRELEASE)
		}

	}

	return localctx
}

// ISavepointStatementContext is an interface to support dynamic dispatch.
type ISavepointStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SAVEPOINT() antlr.TerminalNode
	Uid() IUidContext

	// IsSavepointStatementContext differentiates from other interfaces.
	IsSavepointStatementContext()
}

type SavepointStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySavepointStatementContext() *SavepointStatementContext {
	var p = new(SavepointStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_savepointStatement
	return p
}

func (*SavepointStatementContext) IsSavepointStatementContext() {}

func NewSavepointStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SavepointStatementContext {
	var p = new(SavepointStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_savepointStatement

	return p
}

func (s *SavepointStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SavepointStatementContext) SAVEPOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSAVEPOINT, 0)
}

func (s *SavepointStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SavepointStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SavepointStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SavepointStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSavepointStatement(s)
	}
}

func (s *SavepointStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSavepointStatement(s)
	}
}

func (p *MySqlParser) SavepointStatement() (localctx ISavepointStatementContext) {
	this := p
	_ = this

	localctx = NewSavepointStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, MySqlParserRULE_savepointStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4289)
		p.Match(MySqlParserSAVEPOINT)
	}
	{
		p.SetState(4290)
		p.Uid()
	}

	return localctx
}

// IRollbackStatementContext is an interface to support dynamic dispatch.
type IRollbackStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROLLBACK() antlr.TerminalNode
	TO() antlr.TerminalNode
	Uid() IUidContext
	WORK() antlr.TerminalNode
	SAVEPOINT() antlr.TerminalNode

	// IsRollbackStatementContext differentiates from other interfaces.
	IsRollbackStatementContext()
}

type RollbackStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRollbackStatementContext() *RollbackStatementContext {
	var p = new(RollbackStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_rollbackStatement
	return p
}

func (*RollbackStatementContext) IsRollbackStatementContext() {}

func NewRollbackStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollbackStatementContext {
	var p = new(RollbackStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_rollbackStatement

	return p
}

func (s *RollbackStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RollbackStatementContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLLBACK, 0)
}

func (s *RollbackStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *RollbackStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *RollbackStatementContext) WORK() antlr.TerminalNode {
	return s.GetToken(MySqlParserWORK, 0)
}

func (s *RollbackStatementContext) SAVEPOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSAVEPOINT, 0)
}

func (s *RollbackStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollbackStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RollbackStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRollbackStatement(s)
	}
}

func (s *RollbackStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRollbackStatement(s)
	}
}

func (p *MySqlParser) RollbackStatement() (localctx IRollbackStatementContext) {
	this := p
	_ = this

	localctx = NewRollbackStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, MySqlParserRULE_rollbackStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4292)
		p.Match(MySqlParserROLLBACK)
	}
	p.SetState(4294)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserWORK {
		{
			p.SetState(4293)
			p.Match(MySqlParserWORK)
		}

	}
	{
		p.SetState(4296)
		p.Match(MySqlParserTO)
	}
	p.SetState(4298)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 635, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4297)
			p.Match(MySqlParserSAVEPOINT)
		}

	}
	{
		p.SetState(4300)
		p.Uid()
	}

	return localctx
}

// IReleaseStatementContext is an interface to support dynamic dispatch.
type IReleaseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RELEASE() antlr.TerminalNode
	SAVEPOINT() antlr.TerminalNode
	Uid() IUidContext

	// IsReleaseStatementContext differentiates from other interfaces.
	IsReleaseStatementContext()
}

type ReleaseStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReleaseStatementContext() *ReleaseStatementContext {
	var p = new(ReleaseStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_releaseStatement
	return p
}

func (*ReleaseStatementContext) IsReleaseStatementContext() {}

func NewReleaseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReleaseStatementContext {
	var p = new(ReleaseStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_releaseStatement

	return p
}

func (s *ReleaseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReleaseStatementContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELEASE, 0)
}

func (s *ReleaseStatementContext) SAVEPOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSAVEPOINT, 0)
}

func (s *ReleaseStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ReleaseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReleaseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReleaseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterReleaseStatement(s)
	}
}

func (s *ReleaseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitReleaseStatement(s)
	}
}

func (p *MySqlParser) ReleaseStatement() (localctx IReleaseStatementContext) {
	this := p
	_ = this

	localctx = NewReleaseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, MySqlParserRULE_releaseStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4302)
		p.Match(MySqlParserRELEASE)
	}
	{
		p.SetState(4303)
		p.Match(MySqlParserSAVEPOINT)
	}
	{
		p.SetState(4304)
		p.Uid()
	}

	return localctx
}

// ILockTablesContext is an interface to support dynamic dispatch.
type ILockTablesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCK() antlr.TerminalNode
	AllLockTableElement() []ILockTableElementContext
	LockTableElement(i int) ILockTableElementContext
	TABLE() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	WaitNowaitClause() IWaitNowaitClauseContext

	// IsLockTablesContext differentiates from other interfaces.
	IsLockTablesContext()
}

type LockTablesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLockTablesContext() *LockTablesContext {
	var p = new(LockTablesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_lockTables
	return p
}

func (*LockTablesContext) IsLockTablesContext() {}

func NewLockTablesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockTablesContext {
	var p = new(LockTablesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_lockTables

	return p
}

func (s *LockTablesContext) GetParser() antlr.Parser { return s.parser }

func (s *LockTablesContext) LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCK, 0)
}

func (s *LockTablesContext) AllLockTableElement() []ILockTableElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILockTableElementContext); ok {
			len++
		}
	}

	tst := make([]ILockTableElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILockTableElementContext); ok {
			tst[i] = t.(ILockTableElementContext)
			i++
		}
	}

	return tst
}

func (s *LockTablesContext) LockTableElement(i int) ILockTableElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockTableElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockTableElementContext)
}

func (s *LockTablesContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *LockTablesContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLES, 0)
}

func (s *LockTablesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *LockTablesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *LockTablesContext) WaitNowaitClause() IWaitNowaitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWaitNowaitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWaitNowaitClauseContext)
}

func (s *LockTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockTablesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LockTablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLockTables(s)
	}
}

func (s *LockTablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLockTables(s)
	}
}

func (p *MySqlParser) LockTables() (localctx ILockTablesContext) {
	this := p
	_ = this

	localctx = NewLockTablesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, MySqlParserRULE_lockTables)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4306)
		p.Match(MySqlParserLOCK)
	}
	{
		p.SetState(4307)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserTABLE || _la == MySqlParserTABLES) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4308)
		p.LockTableElement()
	}
	p.SetState(4313)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(4309)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(4310)
			p.LockTableElement()
		}

		p.SetState(4315)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4317)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserNOWAIT || _la == MySqlParserWAIT {
		{
			p.SetState(4316)
			p.WaitNowaitClause()
		}

	}

	return localctx
}

// IUnlockTablesContext is an interface to support dynamic dispatch.
type IUnlockTablesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNLOCK() antlr.TerminalNode
	TABLES() antlr.TerminalNode

	// IsUnlockTablesContext differentiates from other interfaces.
	IsUnlockTablesContext()
}

type UnlockTablesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnlockTablesContext() *UnlockTablesContext {
	var p = new(UnlockTablesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_unlockTables
	return p
}

func (*UnlockTablesContext) IsUnlockTablesContext() {}

func NewUnlockTablesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnlockTablesContext {
	var p = new(UnlockTablesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_unlockTables

	return p
}

func (s *UnlockTablesContext) GetParser() antlr.Parser { return s.parser }

func (s *UnlockTablesContext) UNLOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNLOCK, 0)
}

func (s *UnlockTablesContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLES, 0)
}

func (s *UnlockTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnlockTablesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnlockTablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUnlockTables(s)
	}
}

func (s *UnlockTablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUnlockTables(s)
	}
}

func (p *MySqlParser) UnlockTables() (localctx IUnlockTablesContext) {
	this := p
	_ = this

	localctx = NewUnlockTablesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, MySqlParserRULE_unlockTables)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4319)
		p.Match(MySqlParserUNLOCK)
	}
	{
		p.SetState(4320)
		p.Match(MySqlParserTABLES)
	}

	return localctx
}

// ISetAutocommitStatementContext is an interface to support dynamic dispatch.
type ISetAutocommitStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAutocommitValue returns the autocommitValue token.
	GetAutocommitValue() antlr.Token

	// SetAutocommitValue sets the autocommitValue token.
	SetAutocommitValue(antlr.Token)

	// Getter signatures
	SET() antlr.TerminalNode
	AUTOCOMMIT() antlr.TerminalNode
	EQUAL_SYMBOL() antlr.TerminalNode
	ZERO_DECIMAL() antlr.TerminalNode
	ONE_DECIMAL() antlr.TerminalNode

	// IsSetAutocommitStatementContext differentiates from other interfaces.
	IsSetAutocommitStatementContext()
}

type SetAutocommitStatementContext struct {
	*antlr.BaseParserRuleContext
	parser          antlr.Parser
	autocommitValue antlr.Token
}

func NewEmptySetAutocommitStatementContext() *SetAutocommitStatementContext {
	var p = new(SetAutocommitStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_setAutocommitStatement
	return p
}

func (*SetAutocommitStatementContext) IsSetAutocommitStatementContext() {}

func NewSetAutocommitStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetAutocommitStatementContext {
	var p = new(SetAutocommitStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_setAutocommitStatement

	return p
}

func (s *SetAutocommitStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetAutocommitStatementContext) GetAutocommitValue() antlr.Token { return s.autocommitValue }

func (s *SetAutocommitStatementContext) SetAutocommitValue(v antlr.Token) { s.autocommitValue = v }

func (s *SetAutocommitStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *SetAutocommitStatementContext) AUTOCOMMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUTOCOMMIT, 0)
}

func (s *SetAutocommitStatementContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *SetAutocommitStatementContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserZERO_DECIMAL, 0)
}

func (s *SetAutocommitStatementContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *SetAutocommitStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetAutocommitStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetAutocommitStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSetAutocommitStatement(s)
	}
}

func (s *SetAutocommitStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSetAutocommitStatement(s)
	}
}

func (p *MySqlParser) SetAutocommitStatement() (localctx ISetAutocommitStatementContext) {
	this := p
	_ = this

	localctx = NewSetAutocommitStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, MySqlParserRULE_setAutocommitStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4322)
		p.Match(MySqlParserSET)
	}
	{
		p.SetState(4323)
		p.Match(MySqlParserAUTOCOMMIT)
	}
	{
		p.SetState(4324)
		p.Match(MySqlParserEQUAL_SYMBOL)
	}
	{
		p.SetState(4325)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*SetAutocommitStatementContext).autocommitValue = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserZERO_DECIMAL || _la == MySqlParserONE_DECIMAL) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*SetAutocommitStatementContext).autocommitValue = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISetTransactionStatementContext is an interface to support dynamic dispatch.
type ISetTransactionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTransactionContext returns the transactionContext token.
	GetTransactionContext() antlr.Token

	// SetTransactionContext sets the transactionContext token.
	SetTransactionContext(antlr.Token)

	// Getter signatures
	SET() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	AllTransactionOption() []ITransactionOptionContext
	TransactionOption(i int) ITransactionOptionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	SESSION() antlr.TerminalNode

	// IsSetTransactionStatementContext differentiates from other interfaces.
	IsSetTransactionStatementContext()
}

type SetTransactionStatementContext struct {
	*antlr.BaseParserRuleContext
	parser             antlr.Parser
	transactionContext antlr.Token
}

func NewEmptySetTransactionStatementContext() *SetTransactionStatementContext {
	var p = new(SetTransactionStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_setTransactionStatement
	return p
}

func (*SetTransactionStatementContext) IsSetTransactionStatementContext() {}

func NewSetTransactionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetTransactionStatementContext {
	var p = new(SetTransactionStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_setTransactionStatement

	return p
}

func (s *SetTransactionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetTransactionStatementContext) GetTransactionContext() antlr.Token {
	return s.transactionContext
}

func (s *SetTransactionStatementContext) SetTransactionContext(v antlr.Token) {
	s.transactionContext = v
}

func (s *SetTransactionStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *SetTransactionStatementContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRANSACTION, 0)
}

func (s *SetTransactionStatementContext) AllTransactionOption() []ITransactionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITransactionOptionContext); ok {
			len++
		}
	}

	tst := make([]ITransactionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITransactionOptionContext); ok {
			tst[i] = t.(ITransactionOptionContext)
			i++
		}
	}

	return tst
}

func (s *SetTransactionStatementContext) TransactionOption(i int) ITransactionOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionOptionContext)
}

func (s *SetTransactionStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *SetTransactionStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *SetTransactionStatementContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserGLOBAL, 0)
}

func (s *SetTransactionStatementContext) SESSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserSESSION, 0)
}

func (s *SetTransactionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetTransactionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetTransactionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSetTransactionStatement(s)
	}
}

func (s *SetTransactionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSetTransactionStatement(s)
	}
}

func (p *MySqlParser) SetTransactionStatement() (localctx ISetTransactionStatementContext) {
	this := p
	_ = this

	localctx = NewSetTransactionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, MySqlParserRULE_setTransactionStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4327)
		p.Match(MySqlParserSET)
	}
	p.SetState(4329)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserGLOBAL || _la == MySqlParserSESSION {
		{
			p.SetState(4328)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SetTransactionStatementContext).transactionContext = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserGLOBAL || _la == MySqlParserSESSION) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SetTransactionStatementContext).transactionContext = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(4331)
		p.Match(MySqlParserTRANSACTION)
	}
	{
		p.SetState(4332)
		p.TransactionOption()
	}
	p.SetState(4337)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(4333)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(4334)
			p.TransactionOption()
		}

		p.SetState(4339)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITransactionModeContext is an interface to support dynamic dispatch.
type ITransactionModeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	CONSISTENT() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	READ() antlr.TerminalNode
	WRITE() antlr.TerminalNode
	ONLY() antlr.TerminalNode

	// IsTransactionModeContext differentiates from other interfaces.
	IsTransactionModeContext()
}

type TransactionModeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionModeContext() *TransactionModeContext {
	var p = new(TransactionModeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_transactionMode
	return p
}

func (*TransactionModeContext) IsTransactionModeContext() {}

func NewTransactionModeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionModeContext {
	var p = new(TransactionModeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_transactionMode

	return p
}

func (s *TransactionModeContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionModeContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *TransactionModeContext) CONSISTENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSISTENT, 0)
}

func (s *TransactionModeContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSNAPSHOT, 0)
}

func (s *TransactionModeContext) READ() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAD, 0)
}

func (s *TransactionModeContext) WRITE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWRITE, 0)
}

func (s *TransactionModeContext) ONLY() antlr.TerminalNode {
	return s.GetToken(MySqlParserONLY, 0)
}

func (s *TransactionModeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionModeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionModeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTransactionMode(s)
	}
}

func (s *TransactionModeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTransactionMode(s)
	}
}

func (p *MySqlParser) TransactionMode() (localctx ITransactionModeContext) {
	this := p
	_ = this

	localctx = NewTransactionModeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, MySqlParserRULE_transactionMode)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4347)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 640, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4340)
			p.Match(MySqlParserWITH)
		}
		{
			p.SetState(4341)
			p.Match(MySqlParserCONSISTENT)
		}
		{
			p.SetState(4342)
			p.Match(MySqlParserSNAPSHOT)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4343)
			p.Match(MySqlParserREAD)
		}
		{
			p.SetState(4344)
			p.Match(MySqlParserWRITE)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4345)
			p.Match(MySqlParserREAD)
		}
		{
			p.SetState(4346)
			p.Match(MySqlParserONLY)
		}

	}

	return localctx
}

// ILockTableElementContext is an interface to support dynamic dispatch.
type ILockTableElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableName() ITableNameContext
	LockAction() ILockActionContext
	Uid() IUidContext
	AS() antlr.TerminalNode

	// IsLockTableElementContext differentiates from other interfaces.
	IsLockTableElementContext()
}

type LockTableElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLockTableElementContext() *LockTableElementContext {
	var p = new(LockTableElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_lockTableElement
	return p
}

func (*LockTableElementContext) IsLockTableElementContext() {}

func NewLockTableElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockTableElementContext {
	var p = new(LockTableElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_lockTableElement

	return p
}

func (s *LockTableElementContext) GetParser() antlr.Parser { return s.parser }

func (s *LockTableElementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *LockTableElementContext) LockAction() ILockActionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockActionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockActionContext)
}

func (s *LockTableElementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *LockTableElementContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *LockTableElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockTableElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LockTableElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLockTableElement(s)
	}
}

func (s *LockTableElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLockTableElement(s)
	}
}

func (p *MySqlParser) LockTableElement() (localctx ILockTableElementContext) {
	this := p
	_ = this

	localctx = NewLockTableElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, MySqlParserRULE_lockTableElement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4349)
		p.TableName()
	}
	p.SetState(4354)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&756891332513124352) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&146666055071174737) != 0) || ((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&134349441) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-2882305960540372993) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-4398063288321) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-16325548649218049) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-81064793296864001) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-68719476801) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-11118270170269697) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-33) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-3073) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&144115188075855871) != 0) || ((int64((_la-1121)) & ^0x3f) == 0 && ((int64(1)<<(_la-1121))&25807552513) != 0) {
		p.SetState(4351)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserAS {
			{
				p.SetState(4350)
				p.Match(MySqlParserAS)
			}

		}
		{
			p.SetState(4353)
			p.Uid()
		}

	}
	{
		p.SetState(4356)
		p.LockAction()
	}

	return localctx
}

// ILockActionContext is an interface to support dynamic dispatch.
type ILockActionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READ() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	WRITE() antlr.TerminalNode
	LOW_PRIORITY() antlr.TerminalNode

	// IsLockActionContext differentiates from other interfaces.
	IsLockActionContext()
}

type LockActionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLockActionContext() *LockActionContext {
	var p = new(LockActionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_lockAction
	return p
}

func (*LockActionContext) IsLockActionContext() {}

func NewLockActionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockActionContext {
	var p = new(LockActionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_lockAction

	return p
}

func (s *LockActionContext) GetParser() antlr.Parser { return s.parser }

func (s *LockActionContext) READ() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAD, 0)
}

func (s *LockActionContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL, 0)
}

func (s *LockActionContext) WRITE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWRITE, 0)
}

func (s *LockActionContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOW_PRIORITY, 0)
}

func (s *LockActionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockActionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LockActionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLockAction(s)
	}
}

func (s *LockActionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLockAction(s)
	}
}

func (p *MySqlParser) LockAction() (localctx ILockActionContext) {
	this := p
	_ = this

	localctx = NewLockActionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, MySqlParserRULE_lockAction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4366)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserREAD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4358)
			p.Match(MySqlParserREAD)
		}
		p.SetState(4360)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLOCAL {
			{
				p.SetState(4359)
				p.Match(MySqlParserLOCAL)
			}

		}

	case MySqlParserLOW_PRIORITY, MySqlParserWRITE:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4363)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLOW_PRIORITY {
			{
				p.SetState(4362)
				p.Match(MySqlParserLOW_PRIORITY)
			}

		}
		{
			p.SetState(4365)
			p.Match(MySqlParserWRITE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITransactionOptionContext is an interface to support dynamic dispatch.
type ITransactionOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ISOLATION() antlr.TerminalNode
	LEVEL() antlr.TerminalNode
	TransactionLevel() ITransactionLevelContext
	READ() antlr.TerminalNode
	WRITE() antlr.TerminalNode
	ONLY() antlr.TerminalNode

	// IsTransactionOptionContext differentiates from other interfaces.
	IsTransactionOptionContext()
}

type TransactionOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionOptionContext() *TransactionOptionContext {
	var p = new(TransactionOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_transactionOption
	return p
}

func (*TransactionOptionContext) IsTransactionOptionContext() {}

func NewTransactionOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionOptionContext {
	var p = new(TransactionOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_transactionOption

	return p
}

func (s *TransactionOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionOptionContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserISOLATION, 0)
}

func (s *TransactionOptionContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEVEL, 0)
}

func (s *TransactionOptionContext) TransactionLevel() ITransactionLevelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionLevelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionLevelContext)
}

func (s *TransactionOptionContext) READ() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAD, 0)
}

func (s *TransactionOptionContext) WRITE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWRITE, 0)
}

func (s *TransactionOptionContext) ONLY() antlr.TerminalNode {
	return s.GetToken(MySqlParserONLY, 0)
}

func (s *TransactionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTransactionOption(s)
	}
}

func (s *TransactionOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTransactionOption(s)
	}
}

func (p *MySqlParser) TransactionOption() (localctx ITransactionOptionContext) {
	this := p
	_ = this

	localctx = NewTransactionOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, MySqlParserRULE_transactionOption)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4375)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 646, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4368)
			p.Match(MySqlParserISOLATION)
		}
		{
			p.SetState(4369)
			p.Match(MySqlParserLEVEL)
		}
		{
			p.SetState(4370)
			p.TransactionLevel()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4371)
			p.Match(MySqlParserREAD)
		}
		{
			p.SetState(4372)
			p.Match(MySqlParserWRITE)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4373)
			p.Match(MySqlParserREAD)
		}
		{
			p.SetState(4374)
			p.Match(MySqlParserONLY)
		}

	}

	return localctx
}

// ITransactionLevelContext is an interface to support dynamic dispatch.
type ITransactionLevelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPEATABLE() antlr.TerminalNode
	READ() antlr.TerminalNode
	COMMITTED() antlr.TerminalNode
	UNCOMMITTED() antlr.TerminalNode
	SERIALIZABLE() antlr.TerminalNode

	// IsTransactionLevelContext differentiates from other interfaces.
	IsTransactionLevelContext()
}

type TransactionLevelContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionLevelContext() *TransactionLevelContext {
	var p = new(TransactionLevelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_transactionLevel
	return p
}

func (*TransactionLevelContext) IsTransactionLevelContext() {}

func NewTransactionLevelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionLevelContext {
	var p = new(TransactionLevelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_transactionLevel

	return p
}

func (s *TransactionLevelContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionLevelContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPEATABLE, 0)
}

func (s *TransactionLevelContext) READ() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAD, 0)
}

func (s *TransactionLevelContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMITTED, 0)
}

func (s *TransactionLevelContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNCOMMITTED, 0)
}

func (s *TransactionLevelContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSERIALIZABLE, 0)
}

func (s *TransactionLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionLevelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTransactionLevel(s)
	}
}

func (s *TransactionLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTransactionLevel(s)
	}
}

func (p *MySqlParser) TransactionLevel() (localctx ITransactionLevelContext) {
	this := p
	_ = this

	localctx = NewTransactionLevelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, MySqlParserRULE_transactionLevel)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4384)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 647, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4377)
			p.Match(MySqlParserREPEATABLE)
		}
		{
			p.SetState(4378)
			p.Match(MySqlParserREAD)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4379)
			p.Match(MySqlParserREAD)
		}
		{
			p.SetState(4380)
			p.Match(MySqlParserCOMMITTED)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4381)
			p.Match(MySqlParserREAD)
		}
		{
			p.SetState(4382)
			p.Match(MySqlParserUNCOMMITTED)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4383)
			p.Match(MySqlParserSERIALIZABLE)
		}

	}

	return localctx
}

// IChangeMasterContext is an interface to support dynamic dispatch.
type IChangeMasterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHANGE() antlr.TerminalNode
	MASTER() antlr.TerminalNode
	TO() antlr.TerminalNode
	AllMasterOption() []IMasterOptionContext
	MasterOption(i int) IMasterOptionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	ChannelOption() IChannelOptionContext

	// IsChangeMasterContext differentiates from other interfaces.
	IsChangeMasterContext()
}

type ChangeMasterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChangeMasterContext() *ChangeMasterContext {
	var p = new(ChangeMasterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_changeMaster
	return p
}

func (*ChangeMasterContext) IsChangeMasterContext() {}

func NewChangeMasterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChangeMasterContext {
	var p = new(ChangeMasterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_changeMaster

	return p
}

func (s *ChangeMasterContext) GetParser() antlr.Parser { return s.parser }

func (s *ChangeMasterContext) CHANGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHANGE, 0)
}

func (s *ChangeMasterContext) MASTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER, 0)
}

func (s *ChangeMasterContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *ChangeMasterContext) AllMasterOption() []IMasterOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMasterOptionContext); ok {
			len++
		}
	}

	tst := make([]IMasterOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMasterOptionContext); ok {
			tst[i] = t.(IMasterOptionContext)
			i++
		}
	}

	return tst
}

func (s *ChangeMasterContext) MasterOption(i int) IMasterOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMasterOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMasterOptionContext)
}

func (s *ChangeMasterContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *ChangeMasterContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *ChangeMasterContext) ChannelOption() IChannelOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChannelOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChannelOptionContext)
}

func (s *ChangeMasterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChangeMasterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChangeMasterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterChangeMaster(s)
	}
}

func (s *ChangeMasterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitChangeMaster(s)
	}
}

func (p *MySqlParser) ChangeMaster() (localctx IChangeMasterContext) {
	this := p
	_ = this

	localctx = NewChangeMasterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, MySqlParserRULE_changeMaster)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4386)
		p.Match(MySqlParserCHANGE)
	}
	{
		p.SetState(4387)
		p.Match(MySqlParserMASTER)
	}
	{
		p.SetState(4388)
		p.Match(MySqlParserTO)
	}
	{
		p.SetState(4389)
		p.MasterOption()
	}
	p.SetState(4394)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(4390)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(4391)
			p.MasterOption()
		}

		p.SetState(4396)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4398)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserFOR {
		{
			p.SetState(4397)
			p.ChannelOption()
		}

	}

	return localctx
}

// IChangeReplicationFilterContext is an interface to support dynamic dispatch.
type IChangeReplicationFilterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHANGE() antlr.TerminalNode
	REPLICATION() antlr.TerminalNode
	FILTER() antlr.TerminalNode
	AllReplicationFilter() []IReplicationFilterContext
	ReplicationFilter(i int) IReplicationFilterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsChangeReplicationFilterContext differentiates from other interfaces.
	IsChangeReplicationFilterContext()
}

type ChangeReplicationFilterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChangeReplicationFilterContext() *ChangeReplicationFilterContext {
	var p = new(ChangeReplicationFilterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_changeReplicationFilter
	return p
}

func (*ChangeReplicationFilterContext) IsChangeReplicationFilterContext() {}

func NewChangeReplicationFilterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChangeReplicationFilterContext {
	var p = new(ChangeReplicationFilterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_changeReplicationFilter

	return p
}

func (s *ChangeReplicationFilterContext) GetParser() antlr.Parser { return s.parser }

func (s *ChangeReplicationFilterContext) CHANGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHANGE, 0)
}

func (s *ChangeReplicationFilterContext) REPLICATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATION, 0)
}

func (s *ChangeReplicationFilterContext) FILTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserFILTER, 0)
}

func (s *ChangeReplicationFilterContext) AllReplicationFilter() []IReplicationFilterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReplicationFilterContext); ok {
			len++
		}
	}

	tst := make([]IReplicationFilterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReplicationFilterContext); ok {
			tst[i] = t.(IReplicationFilterContext)
			i++
		}
	}

	return tst
}

func (s *ChangeReplicationFilterContext) ReplicationFilter(i int) IReplicationFilterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplicationFilterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplicationFilterContext)
}

func (s *ChangeReplicationFilterContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *ChangeReplicationFilterContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *ChangeReplicationFilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChangeReplicationFilterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChangeReplicationFilterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterChangeReplicationFilter(s)
	}
}

func (s *ChangeReplicationFilterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitChangeReplicationFilter(s)
	}
}

func (p *MySqlParser) ChangeReplicationFilter() (localctx IChangeReplicationFilterContext) {
	this := p
	_ = this

	localctx = NewChangeReplicationFilterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, MySqlParserRULE_changeReplicationFilter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4400)
		p.Match(MySqlParserCHANGE)
	}
	{
		p.SetState(4401)
		p.Match(MySqlParserREPLICATION)
	}
	{
		p.SetState(4402)
		p.Match(MySqlParserFILTER)
	}
	{
		p.SetState(4403)
		p.ReplicationFilter()
	}
	p.SetState(4408)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(4404)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(4405)
			p.ReplicationFilter()
		}

		p.SetState(4410)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IPurgeBinaryLogsContext is an interface to support dynamic dispatch.
type IPurgeBinaryLogsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPurgeFormat returns the purgeFormat token.
	GetPurgeFormat() antlr.Token

	// GetFileName returns the fileName token.
	GetFileName() antlr.Token

	// GetTimeValue returns the timeValue token.
	GetTimeValue() antlr.Token

	// SetPurgeFormat sets the purgeFormat token.
	SetPurgeFormat(antlr.Token)

	// SetFileName sets the fileName token.
	SetFileName(antlr.Token)

	// SetTimeValue sets the timeValue token.
	SetTimeValue(antlr.Token)

	// Getter signatures
	PURGE() antlr.TerminalNode
	LOGS() antlr.TerminalNode
	BINARY() antlr.TerminalNode
	MASTER() antlr.TerminalNode
	TO() antlr.TerminalNode
	BEFORE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsPurgeBinaryLogsContext differentiates from other interfaces.
	IsPurgeBinaryLogsContext()
}

type PurgeBinaryLogsContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	purgeFormat antlr.Token
	fileName    antlr.Token
	timeValue   antlr.Token
}

func NewEmptyPurgeBinaryLogsContext() *PurgeBinaryLogsContext {
	var p = new(PurgeBinaryLogsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_purgeBinaryLogs
	return p
}

func (*PurgeBinaryLogsContext) IsPurgeBinaryLogsContext() {}

func NewPurgeBinaryLogsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PurgeBinaryLogsContext {
	var p = new(PurgeBinaryLogsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_purgeBinaryLogs

	return p
}

func (s *PurgeBinaryLogsContext) GetParser() antlr.Parser { return s.parser }

func (s *PurgeBinaryLogsContext) GetPurgeFormat() antlr.Token { return s.purgeFormat }

func (s *PurgeBinaryLogsContext) GetFileName() antlr.Token { return s.fileName }

func (s *PurgeBinaryLogsContext) GetTimeValue() antlr.Token { return s.timeValue }

func (s *PurgeBinaryLogsContext) SetPurgeFormat(v antlr.Token) { s.purgeFormat = v }

func (s *PurgeBinaryLogsContext) SetFileName(v antlr.Token) { s.fileName = v }

func (s *PurgeBinaryLogsContext) SetTimeValue(v antlr.Token) { s.timeValue = v }

func (s *PurgeBinaryLogsContext) PURGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPURGE, 0)
}

func (s *PurgeBinaryLogsContext) LOGS() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOGS, 0)
}

func (s *PurgeBinaryLogsContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *PurgeBinaryLogsContext) MASTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER, 0)
}

func (s *PurgeBinaryLogsContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *PurgeBinaryLogsContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(MySqlParserBEFORE, 0)
}

func (s *PurgeBinaryLogsContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *PurgeBinaryLogsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PurgeBinaryLogsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PurgeBinaryLogsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPurgeBinaryLogs(s)
	}
}

func (s *PurgeBinaryLogsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPurgeBinaryLogs(s)
	}
}

func (p *MySqlParser) PurgeBinaryLogs() (localctx IPurgeBinaryLogsContext) {
	this := p
	_ = this

	localctx = NewPurgeBinaryLogsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, MySqlParserRULE_purgeBinaryLogs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4411)
		p.Match(MySqlParserPURGE)
	}
	{
		p.SetState(4412)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*PurgeBinaryLogsContext).purgeFormat = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserBINARY || _la == MySqlParserMASTER) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*PurgeBinaryLogsContext).purgeFormat = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4413)
		p.Match(MySqlParserLOGS)
	}
	p.SetState(4418)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserTO:
		{
			p.SetState(4414)
			p.Match(MySqlParserTO)
		}
		{
			p.SetState(4415)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*PurgeBinaryLogsContext).fileName = _m
		}

	case MySqlParserBEFORE:
		{
			p.SetState(4416)
			p.Match(MySqlParserBEFORE)
		}
		{
			p.SetState(4417)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*PurgeBinaryLogsContext).timeValue = _m
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IResetMasterContext is an interface to support dynamic dispatch.
type IResetMasterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESET() antlr.TerminalNode
	MASTER() antlr.TerminalNode

	// IsResetMasterContext differentiates from other interfaces.
	IsResetMasterContext()
}

type ResetMasterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResetMasterContext() *ResetMasterContext {
	var p = new(ResetMasterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_resetMaster
	return p
}

func (*ResetMasterContext) IsResetMasterContext() {}

func NewResetMasterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResetMasterContext {
	var p = new(ResetMasterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_resetMaster

	return p
}

func (s *ResetMasterContext) GetParser() antlr.Parser { return s.parser }

func (s *ResetMasterContext) RESET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESET, 0)
}

func (s *ResetMasterContext) MASTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER, 0)
}

func (s *ResetMasterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResetMasterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResetMasterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterResetMaster(s)
	}
}

func (s *ResetMasterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitResetMaster(s)
	}
}

func (p *MySqlParser) ResetMaster() (localctx IResetMasterContext) {
	this := p
	_ = this

	localctx = NewResetMasterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, MySqlParserRULE_resetMaster)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4420)
		p.Match(MySqlParserRESET)
	}
	{
		p.SetState(4421)
		p.Match(MySqlParserMASTER)
	}

	return localctx
}

// IResetSlaveContext is an interface to support dynamic dispatch.
type IResetSlaveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESET() antlr.TerminalNode
	SLAVE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	ChannelOption() IChannelOptionContext

	// IsResetSlaveContext differentiates from other interfaces.
	IsResetSlaveContext()
}

type ResetSlaveContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResetSlaveContext() *ResetSlaveContext {
	var p = new(ResetSlaveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_resetSlave
	return p
}

func (*ResetSlaveContext) IsResetSlaveContext() {}

func NewResetSlaveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResetSlaveContext {
	var p = new(ResetSlaveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_resetSlave

	return p
}

func (s *ResetSlaveContext) GetParser() antlr.Parser { return s.parser }

func (s *ResetSlaveContext) RESET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESET, 0)
}

func (s *ResetSlaveContext) SLAVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSLAVE, 0)
}

func (s *ResetSlaveContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *ResetSlaveContext) ChannelOption() IChannelOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChannelOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChannelOptionContext)
}

func (s *ResetSlaveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResetSlaveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResetSlaveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterResetSlave(s)
	}
}

func (s *ResetSlaveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitResetSlave(s)
	}
}

func (p *MySqlParser) ResetSlave() (localctx IResetSlaveContext) {
	this := p
	_ = this

	localctx = NewResetSlaveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, MySqlParserRULE_resetSlave)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4423)
		p.Match(MySqlParserRESET)
	}
	{
		p.SetState(4424)
		p.Match(MySqlParserSLAVE)
	}
	p.SetState(4426)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserALL {
		{
			p.SetState(4425)
			p.Match(MySqlParserALL)
		}

	}
	p.SetState(4429)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserFOR {
		{
			p.SetState(4428)
			p.ChannelOption()
		}

	}

	return localctx
}

// IStartSlaveContext is an interface to support dynamic dispatch.
type IStartSlaveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	START() antlr.TerminalNode
	SLAVE() antlr.TerminalNode
	AllThreadType() []IThreadTypeContext
	ThreadType(i int) IThreadTypeContext
	UNTIL() antlr.TerminalNode
	UntilOption() IUntilOptionContext
	AllConnectionOption() []IConnectionOptionContext
	ConnectionOption(i int) IConnectionOptionContext
	ChannelOption() IChannelOptionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsStartSlaveContext differentiates from other interfaces.
	IsStartSlaveContext()
}

type StartSlaveContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartSlaveContext() *StartSlaveContext {
	var p = new(StartSlaveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_startSlave
	return p
}

func (*StartSlaveContext) IsStartSlaveContext() {}

func NewStartSlaveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartSlaveContext {
	var p = new(StartSlaveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_startSlave

	return p
}

func (s *StartSlaveContext) GetParser() antlr.Parser { return s.parser }

func (s *StartSlaveContext) START() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTART, 0)
}

func (s *StartSlaveContext) SLAVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSLAVE, 0)
}

func (s *StartSlaveContext) AllThreadType() []IThreadTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IThreadTypeContext); ok {
			len++
		}
	}

	tst := make([]IThreadTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IThreadTypeContext); ok {
			tst[i] = t.(IThreadTypeContext)
			i++
		}
	}

	return tst
}

func (s *StartSlaveContext) ThreadType(i int) IThreadTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IThreadTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IThreadTypeContext)
}

func (s *StartSlaveContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNTIL, 0)
}

func (s *StartSlaveContext) UntilOption() IUntilOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUntilOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUntilOptionContext)
}

func (s *StartSlaveContext) AllConnectionOption() []IConnectionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConnectionOptionContext); ok {
			len++
		}
	}

	tst := make([]IConnectionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConnectionOptionContext); ok {
			tst[i] = t.(IConnectionOptionContext)
			i++
		}
	}

	return tst
}

func (s *StartSlaveContext) ConnectionOption(i int) IConnectionOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConnectionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConnectionOptionContext)
}

func (s *StartSlaveContext) ChannelOption() IChannelOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChannelOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChannelOptionContext)
}

func (s *StartSlaveContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *StartSlaveContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *StartSlaveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartSlaveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StartSlaveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterStartSlave(s)
	}
}

func (s *StartSlaveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitStartSlave(s)
	}
}

func (p *MySqlParser) StartSlave() (localctx IStartSlaveContext) {
	this := p
	_ = this

	localctx = NewStartSlaveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, MySqlParserRULE_startSlave)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4431)
		p.Match(MySqlParserSTART)
	}
	{
		p.SetState(4432)
		p.Match(MySqlParserSLAVE)
	}
	p.SetState(4441)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserIO_THREAD || _la == MySqlParserSQL_THREAD {
		{
			p.SetState(4433)
			p.ThreadType()
		}
		p.SetState(4438)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(4434)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(4435)
				p.ThreadType()
			}

			p.SetState(4440)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(4445)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserUNTIL {
		{
			p.SetState(4443)
			p.Match(MySqlParserUNTIL)
		}
		{
			p.SetState(4444)
			p.UntilOption()
		}

	}
	p.SetState(4450)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserDEFAULT_AUTH || _la == MySqlParserPASSWORD || _la == MySqlParserPLUGIN_DIR || _la == MySqlParserUSER {
		{
			p.SetState(4447)
			p.ConnectionOption()
		}

		p.SetState(4452)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4454)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserFOR {
		{
			p.SetState(4453)
			p.ChannelOption()
		}

	}

	return localctx
}

// IStopSlaveContext is an interface to support dynamic dispatch.
type IStopSlaveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STOP() antlr.TerminalNode
	SLAVE() antlr.TerminalNode
	AllThreadType() []IThreadTypeContext
	ThreadType(i int) IThreadTypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsStopSlaveContext differentiates from other interfaces.
	IsStopSlaveContext()
}

type StopSlaveContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStopSlaveContext() *StopSlaveContext {
	var p = new(StopSlaveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_stopSlave
	return p
}

func (*StopSlaveContext) IsStopSlaveContext() {}

func NewStopSlaveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StopSlaveContext {
	var p = new(StopSlaveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_stopSlave

	return p
}

func (s *StopSlaveContext) GetParser() antlr.Parser { return s.parser }

func (s *StopSlaveContext) STOP() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTOP, 0)
}

func (s *StopSlaveContext) SLAVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSLAVE, 0)
}

func (s *StopSlaveContext) AllThreadType() []IThreadTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IThreadTypeContext); ok {
			len++
		}
	}

	tst := make([]IThreadTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IThreadTypeContext); ok {
			tst[i] = t.(IThreadTypeContext)
			i++
		}
	}

	return tst
}

func (s *StopSlaveContext) ThreadType(i int) IThreadTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IThreadTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IThreadTypeContext)
}

func (s *StopSlaveContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *StopSlaveContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *StopSlaveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StopSlaveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StopSlaveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterStopSlave(s)
	}
}

func (s *StopSlaveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitStopSlave(s)
	}
}

func (p *MySqlParser) StopSlave() (localctx IStopSlaveContext) {
	this := p
	_ = this

	localctx = NewStopSlaveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, MySqlParserRULE_stopSlave)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4456)
		p.Match(MySqlParserSTOP)
	}
	{
		p.SetState(4457)
		p.Match(MySqlParserSLAVE)
	}
	p.SetState(4466)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserIO_THREAD || _la == MySqlParserSQL_THREAD {
		{
			p.SetState(4458)
			p.ThreadType()
		}
		p.SetState(4463)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(4459)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(4460)
				p.ThreadType()
			}

			p.SetState(4465)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IStartGroupReplicationContext is an interface to support dynamic dispatch.
type IStartGroupReplicationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	START() antlr.TerminalNode
	GROUP_REPLICATION() antlr.TerminalNode

	// IsStartGroupReplicationContext differentiates from other interfaces.
	IsStartGroupReplicationContext()
}

type StartGroupReplicationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartGroupReplicationContext() *StartGroupReplicationContext {
	var p = new(StartGroupReplicationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_startGroupReplication
	return p
}

func (*StartGroupReplicationContext) IsStartGroupReplicationContext() {}

func NewStartGroupReplicationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartGroupReplicationContext {
	var p = new(StartGroupReplicationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_startGroupReplication

	return p
}

func (s *StartGroupReplicationContext) GetParser() antlr.Parser { return s.parser }

func (s *StartGroupReplicationContext) START() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTART, 0)
}

func (s *StartGroupReplicationContext) GROUP_REPLICATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP_REPLICATION, 0)
}

func (s *StartGroupReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartGroupReplicationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StartGroupReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterStartGroupReplication(s)
	}
}

func (s *StartGroupReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitStartGroupReplication(s)
	}
}

func (p *MySqlParser) StartGroupReplication() (localctx IStartGroupReplicationContext) {
	this := p
	_ = this

	localctx = NewStartGroupReplicationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, MySqlParserRULE_startGroupReplication)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4468)
		p.Match(MySqlParserSTART)
	}
	{
		p.SetState(4469)
		p.Match(MySqlParserGROUP_REPLICATION)
	}

	return localctx
}

// IStopGroupReplicationContext is an interface to support dynamic dispatch.
type IStopGroupReplicationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STOP() antlr.TerminalNode
	GROUP_REPLICATION() antlr.TerminalNode

	// IsStopGroupReplicationContext differentiates from other interfaces.
	IsStopGroupReplicationContext()
}

type StopGroupReplicationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStopGroupReplicationContext() *StopGroupReplicationContext {
	var p = new(StopGroupReplicationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_stopGroupReplication
	return p
}

func (*StopGroupReplicationContext) IsStopGroupReplicationContext() {}

func NewStopGroupReplicationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StopGroupReplicationContext {
	var p = new(StopGroupReplicationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_stopGroupReplication

	return p
}

func (s *StopGroupReplicationContext) GetParser() antlr.Parser { return s.parser }

func (s *StopGroupReplicationContext) STOP() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTOP, 0)
}

func (s *StopGroupReplicationContext) GROUP_REPLICATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP_REPLICATION, 0)
}

func (s *StopGroupReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StopGroupReplicationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StopGroupReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterStopGroupReplication(s)
	}
}

func (s *StopGroupReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitStopGroupReplication(s)
	}
}

func (p *MySqlParser) StopGroupReplication() (localctx IStopGroupReplicationContext) {
	this := p
	_ = this

	localctx = NewStopGroupReplicationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, MySqlParserRULE_stopGroupReplication)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4471)
		p.Match(MySqlParserSTOP)
	}
	{
		p.SetState(4472)
		p.Match(MySqlParserGROUP_REPLICATION)
	}

	return localctx
}

// IMasterOptionContext is an interface to support dynamic dispatch.
type IMasterOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsMasterOptionContext differentiates from other interfaces.
	IsMasterOptionContext()
}

type MasterOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMasterOptionContext() *MasterOptionContext {
	var p = new(MasterOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_masterOption
	return p
}

func (*MasterOptionContext) IsMasterOptionContext() {}

func NewMasterOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MasterOptionContext {
	var p = new(MasterOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_masterOption

	return p
}

func (s *MasterOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *MasterOptionContext) CopyFrom(ctx *MasterOptionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *MasterOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MasterOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type MasterStringOptionContext struct {
	*MasterOptionContext
}

func NewMasterStringOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MasterStringOptionContext {
	var p = new(MasterStringOptionContext)

	p.MasterOptionContext = NewEmptyMasterOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*MasterOptionContext))

	return p
}

func (s *MasterStringOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MasterStringOptionContext) StringMasterOption() IStringMasterOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringMasterOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringMasterOptionContext)
}

func (s *MasterStringOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *MasterStringOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *MasterStringOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMasterStringOption(s)
	}
}

func (s *MasterStringOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMasterStringOption(s)
	}
}

type MasterRealOptionContext struct {
	*MasterOptionContext
}

func NewMasterRealOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MasterRealOptionContext {
	var p = new(MasterRealOptionContext)

	p.MasterOptionContext = NewEmptyMasterOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*MasterOptionContext))

	return p
}

func (s *MasterRealOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MasterRealOptionContext) MASTER_HEARTBEAT_PERIOD() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_HEARTBEAT_PERIOD, 0)
}

func (s *MasterRealOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *MasterRealOptionContext) REAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAL_LITERAL, 0)
}

func (s *MasterRealOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMasterRealOption(s)
	}
}

func (s *MasterRealOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMasterRealOption(s)
	}
}

type MasterBoolOptionContext struct {
	*MasterOptionContext
	boolVal antlr.Token
}

func NewMasterBoolOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MasterBoolOptionContext {
	var p = new(MasterBoolOptionContext)

	p.MasterOptionContext = NewEmptyMasterOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*MasterOptionContext))

	return p
}

func (s *MasterBoolOptionContext) GetBoolVal() antlr.Token { return s.boolVal }

func (s *MasterBoolOptionContext) SetBoolVal(v antlr.Token) { s.boolVal = v }

func (s *MasterBoolOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MasterBoolOptionContext) BoolMasterOption() IBoolMasterOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBoolMasterOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBoolMasterOptionContext)
}

func (s *MasterBoolOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *MasterBoolOptionContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserZERO_DECIMAL, 0)
}

func (s *MasterBoolOptionContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *MasterBoolOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMasterBoolOption(s)
	}
}

func (s *MasterBoolOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMasterBoolOption(s)
	}
}

type MasterUidListOptionContext struct {
	*MasterOptionContext
}

func NewMasterUidListOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MasterUidListOptionContext {
	var p = new(MasterUidListOptionContext)

	p.MasterOptionContext = NewEmptyMasterOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*MasterOptionContext))

	return p
}

func (s *MasterUidListOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MasterUidListOptionContext) IGNORE_SERVER_IDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE_SERVER_IDS, 0)
}

func (s *MasterUidListOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *MasterUidListOptionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *MasterUidListOptionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *MasterUidListOptionContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *MasterUidListOptionContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *MasterUidListOptionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *MasterUidListOptionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *MasterUidListOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMasterUidListOption(s)
	}
}

func (s *MasterUidListOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMasterUidListOption(s)
	}
}

type MasterDecimalOptionContext struct {
	*MasterOptionContext
}

func NewMasterDecimalOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MasterDecimalOptionContext {
	var p = new(MasterDecimalOptionContext)

	p.MasterOptionContext = NewEmptyMasterOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*MasterOptionContext))

	return p
}

func (s *MasterDecimalOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MasterDecimalOptionContext) DecimalMasterOption() IDecimalMasterOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalMasterOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalMasterOptionContext)
}

func (s *MasterDecimalOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *MasterDecimalOptionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *MasterDecimalOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMasterDecimalOption(s)
	}
}

func (s *MasterDecimalOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMasterDecimalOption(s)
	}
}

func (p *MySqlParser) MasterOption() (localctx IMasterOptionContext) {
	this := p
	_ = this

	localctx = NewMasterOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, MySqlParserRULE_masterOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4503)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserMASTER_BIND, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserRELAY_LOG_FILE:
		localctx = NewMasterStringOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4474)
			p.StringMasterOption()
		}
		{
			p.SetState(4475)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}
		{
			p.SetState(4476)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	case MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserRELAY_LOG_POS:
		localctx = NewMasterDecimalOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4478)
			p.DecimalMasterOption()
		}
		{
			p.SetState(4479)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}
		{
			p.SetState(4480)
			p.DecimalLiteral()
		}

	case MySqlParserMASTER_SSL_VERIFY_SERVER_CERT, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_SSL:
		localctx = NewMasterBoolOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4482)
			p.BoolMasterOption()
		}
		{
			p.SetState(4483)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}
		{
			p.SetState(4484)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*MasterBoolOptionContext).boolVal = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserZERO_DECIMAL || _la == MySqlParserONE_DECIMAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*MasterBoolOptionContext).boolVal = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case MySqlParserMASTER_HEARTBEAT_PERIOD:
		localctx = NewMasterRealOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4486)
			p.Match(MySqlParserMASTER_HEARTBEAT_PERIOD)
		}
		{
			p.SetState(4487)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}
		{
			p.SetState(4488)
			p.Match(MySqlParserREAL_LITERAL)
		}

	case MySqlParserIGNORE_SERVER_IDS:
		localctx = NewMasterUidListOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4489)
			p.Match(MySqlParserIGNORE_SERVER_IDS)
		}
		{
			p.SetState(4490)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}
		{
			p.SetState(4491)
			p.Match(MySqlParserLR_BRACKET)
		}
		p.SetState(4500)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&756891332513120256) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&146666055071174737) != 0) || ((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&134349441) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-2882305960540372993) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-4398063288321) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-16325548649218049) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-81064793296864001) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-68719476801) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-11118270170269697) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-33) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-3073) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&144115188075855871) != 0) || ((int64((_la-1121)) & ^0x3f) == 0 && ((int64(1)<<(_la-1121))&25807552513) != 0) {
			{
				p.SetState(4492)
				p.Uid()
			}
			p.SetState(4497)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == MySqlParserCOMMA {
				{
					p.SetState(4493)
					p.Match(MySqlParserCOMMA)
				}
				{
					p.SetState(4494)
					p.Uid()
				}

				p.SetState(4499)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(4502)
			p.Match(MySqlParserRR_BRACKET)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IStringMasterOptionContext is an interface to support dynamic dispatch.
type IStringMasterOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MASTER_BIND() antlr.TerminalNode
	MASTER_HOST() antlr.TerminalNode
	MASTER_USER() antlr.TerminalNode
	MASTER_PASSWORD() antlr.TerminalNode
	MASTER_LOG_FILE() antlr.TerminalNode
	RELAY_LOG_FILE() antlr.TerminalNode
	MASTER_SSL_CA() antlr.TerminalNode
	MASTER_SSL_CAPATH() antlr.TerminalNode
	MASTER_SSL_CERT() antlr.TerminalNode
	MASTER_SSL_CRL() antlr.TerminalNode
	MASTER_SSL_CRLPATH() antlr.TerminalNode
	MASTER_SSL_KEY() antlr.TerminalNode
	MASTER_SSL_CIPHER() antlr.TerminalNode
	MASTER_TLS_VERSION() antlr.TerminalNode

	// IsStringMasterOptionContext differentiates from other interfaces.
	IsStringMasterOptionContext()
}

type StringMasterOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringMasterOptionContext() *StringMasterOptionContext {
	var p = new(StringMasterOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_stringMasterOption
	return p
}

func (*StringMasterOptionContext) IsStringMasterOptionContext() {}

func NewStringMasterOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringMasterOptionContext {
	var p = new(StringMasterOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_stringMasterOption

	return p
}

func (s *StringMasterOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *StringMasterOptionContext) MASTER_BIND() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_BIND, 0)
}

func (s *StringMasterOptionContext) MASTER_HOST() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_HOST, 0)
}

func (s *StringMasterOptionContext) MASTER_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_USER, 0)
}

func (s *StringMasterOptionContext) MASTER_PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_PASSWORD, 0)
}

func (s *StringMasterOptionContext) MASTER_LOG_FILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_LOG_FILE, 0)
}

func (s *StringMasterOptionContext) RELAY_LOG_FILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELAY_LOG_FILE, 0)
}

func (s *StringMasterOptionContext) MASTER_SSL_CA() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CA, 0)
}

func (s *StringMasterOptionContext) MASTER_SSL_CAPATH() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CAPATH, 0)
}

func (s *StringMasterOptionContext) MASTER_SSL_CERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CERT, 0)
}

func (s *StringMasterOptionContext) MASTER_SSL_CRL() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CRL, 0)
}

func (s *StringMasterOptionContext) MASTER_SSL_CRLPATH() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CRLPATH, 0)
}

func (s *StringMasterOptionContext) MASTER_SSL_KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_KEY, 0)
}

func (s *StringMasterOptionContext) MASTER_SSL_CIPHER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CIPHER, 0)
}

func (s *StringMasterOptionContext) MASTER_TLS_VERSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_TLS_VERSION, 0)
}

func (s *StringMasterOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringMasterOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringMasterOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterStringMasterOption(s)
	}
}

func (s *StringMasterOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitStringMasterOption(s)
	}
}

func (p *MySqlParser) StringMasterOption() (localctx IStringMasterOptionContext) {
	this := p
	_ = this

	localctx = NewStringMasterOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, MySqlParserRULE_stringMasterOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4505)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserMASTER_BIND || ((int64((_la-482)) & ^0x3f) == 0 && ((int64(1)<<(_la-482))&65419) != 0) || _la == MySqlParserRELAY_LOG_FILE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDecimalMasterOptionContext is an interface to support dynamic dispatch.
type IDecimalMasterOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MASTER_PORT() antlr.TerminalNode
	MASTER_CONNECT_RETRY() antlr.TerminalNode
	MASTER_RETRY_COUNT() antlr.TerminalNode
	MASTER_DELAY() antlr.TerminalNode
	MASTER_LOG_POS() antlr.TerminalNode
	RELAY_LOG_POS() antlr.TerminalNode

	// IsDecimalMasterOptionContext differentiates from other interfaces.
	IsDecimalMasterOptionContext()
}

type DecimalMasterOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecimalMasterOptionContext() *DecimalMasterOptionContext {
	var p = new(DecimalMasterOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_decimalMasterOption
	return p
}

func (*DecimalMasterOptionContext) IsDecimalMasterOptionContext() {}

func NewDecimalMasterOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecimalMasterOptionContext {
	var p = new(DecimalMasterOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_decimalMasterOption

	return p
}

func (s *DecimalMasterOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *DecimalMasterOptionContext) MASTER_PORT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_PORT, 0)
}

func (s *DecimalMasterOptionContext) MASTER_CONNECT_RETRY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_CONNECT_RETRY, 0)
}

func (s *DecimalMasterOptionContext) MASTER_RETRY_COUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_RETRY_COUNT, 0)
}

func (s *DecimalMasterOptionContext) MASTER_DELAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_DELAY, 0)
}

func (s *DecimalMasterOptionContext) MASTER_LOG_POS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_LOG_POS, 0)
}

func (s *DecimalMasterOptionContext) RELAY_LOG_POS() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELAY_LOG_POS, 0)
}

func (s *DecimalMasterOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalMasterOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecimalMasterOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDecimalMasterOption(s)
	}
}

func (s *DecimalMasterOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDecimalMasterOption(s)
	}
}

func (p *MySqlParser) DecimalMasterOption() (localctx IDecimalMasterOptionContext) {
	this := p
	_ = this

	localctx = NewDecimalMasterOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, MySqlParserRULE_decimalMasterOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4507)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-479)) & ^0x3f) == 0 && ((int64(1)<<(_la-479))&419) != 0) || _la == MySqlParserRELAY_LOG_POS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBoolMasterOptionContext is an interface to support dynamic dispatch.
type IBoolMasterOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MASTER_AUTO_POSITION() antlr.TerminalNode
	MASTER_SSL() antlr.TerminalNode
	MASTER_SSL_VERIFY_SERVER_CERT() antlr.TerminalNode

	// IsBoolMasterOptionContext differentiates from other interfaces.
	IsBoolMasterOptionContext()
}

type BoolMasterOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBoolMasterOptionContext() *BoolMasterOptionContext {
	var p = new(BoolMasterOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_boolMasterOption
	return p
}

func (*BoolMasterOptionContext) IsBoolMasterOptionContext() {}

func NewBoolMasterOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BoolMasterOptionContext {
	var p = new(BoolMasterOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_boolMasterOption

	return p
}

func (s *BoolMasterOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *BoolMasterOptionContext) MASTER_AUTO_POSITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_AUTO_POSITION, 0)
}

func (s *BoolMasterOptionContext) MASTER_SSL() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL, 0)
}

func (s *BoolMasterOptionContext) MASTER_SSL_VERIFY_SERVER_CERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_VERIFY_SERVER_CERT, 0)
}

func (s *BoolMasterOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BoolMasterOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BoolMasterOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterBoolMasterOption(s)
	}
}

func (s *BoolMasterOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitBoolMasterOption(s)
	}
}

func (p *MySqlParser) BoolMasterOption() (localctx IBoolMasterOptionContext) {
	this := p
	_ = this

	localctx = NewBoolMasterOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, MySqlParserRULE_boolMasterOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4509)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserMASTER_SSL_VERIFY_SERVER_CERT || _la == MySqlParserMASTER_AUTO_POSITION || _la == MySqlParserMASTER_SSL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IChannelOptionContext is an interface to support dynamic dispatch.
type IChannelOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	CHANNEL() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsChannelOptionContext differentiates from other interfaces.
	IsChannelOptionContext()
}

type ChannelOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChannelOptionContext() *ChannelOptionContext {
	var p = new(ChannelOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_channelOption
	return p
}

func (*ChannelOptionContext) IsChannelOptionContext() {}

func NewChannelOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChannelOptionContext {
	var p = new(ChannelOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_channelOption

	return p
}

func (s *ChannelOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ChannelOptionContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *ChannelOptionContext) CHANNEL() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHANNEL, 0)
}

func (s *ChannelOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *ChannelOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChannelOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChannelOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterChannelOption(s)
	}
}

func (s *ChannelOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitChannelOption(s)
	}
}

func (p *MySqlParser) ChannelOption() (localctx IChannelOptionContext) {
	this := p
	_ = this

	localctx = NewChannelOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, MySqlParserRULE_channelOption)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4511)
		p.Match(MySqlParserFOR)
	}
	{
		p.SetState(4512)
		p.Match(MySqlParserCHANNEL)
	}
	{
		p.SetState(4513)
		p.Match(MySqlParserSTRING_LITERAL)
	}

	return localctx
}

// IReplicationFilterContext is an interface to support dynamic dispatch.
type IReplicationFilterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsReplicationFilterContext differentiates from other interfaces.
	IsReplicationFilterContext()
}

type ReplicationFilterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplicationFilterContext() *ReplicationFilterContext {
	var p = new(ReplicationFilterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_replicationFilter
	return p
}

func (*ReplicationFilterContext) IsReplicationFilterContext() {}

func NewReplicationFilterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplicationFilterContext {
	var p = new(ReplicationFilterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_replicationFilter

	return p
}

func (s *ReplicationFilterContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplicationFilterContext) CopyFrom(ctx *ReplicationFilterContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ReplicationFilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplicationFilterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type WildIgnoreTableReplicationContext struct {
	*ReplicationFilterContext
}

func NewWildIgnoreTableReplicationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WildIgnoreTableReplicationContext {
	var p = new(WildIgnoreTableReplicationContext)

	p.ReplicationFilterContext = NewEmptyReplicationFilterContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ReplicationFilterContext))

	return p
}

func (s *WildIgnoreTableReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WildIgnoreTableReplicationContext) REPLICATE_WILD_IGNORE_TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_WILD_IGNORE_TABLE, 0)
}

func (s *WildIgnoreTableReplicationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *WildIgnoreTableReplicationContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *WildIgnoreTableReplicationContext) SimpleStrings() ISimpleStringsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleStringsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleStringsContext)
}

func (s *WildIgnoreTableReplicationContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *WildIgnoreTableReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterWildIgnoreTableReplication(s)
	}
}

func (s *WildIgnoreTableReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitWildIgnoreTableReplication(s)
	}
}

type DoTableReplicationContext struct {
	*ReplicationFilterContext
}

func NewDoTableReplicationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DoTableReplicationContext {
	var p = new(DoTableReplicationContext)

	p.ReplicationFilterContext = NewEmptyReplicationFilterContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ReplicationFilterContext))

	return p
}

func (s *DoTableReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoTableReplicationContext) REPLICATE_DO_TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_DO_TABLE, 0)
}

func (s *DoTableReplicationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *DoTableReplicationContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *DoTableReplicationContext) Tables() ITablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *DoTableReplicationContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *DoTableReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDoTableReplication(s)
	}
}

func (s *DoTableReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDoTableReplication(s)
	}
}

type IgnoreTableReplicationContext struct {
	*ReplicationFilterContext
}

func NewIgnoreTableReplicationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IgnoreTableReplicationContext {
	var p = new(IgnoreTableReplicationContext)

	p.ReplicationFilterContext = NewEmptyReplicationFilterContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ReplicationFilterContext))

	return p
}

func (s *IgnoreTableReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IgnoreTableReplicationContext) REPLICATE_IGNORE_TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_IGNORE_TABLE, 0)
}

func (s *IgnoreTableReplicationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *IgnoreTableReplicationContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *IgnoreTableReplicationContext) Tables() ITablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *IgnoreTableReplicationContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *IgnoreTableReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIgnoreTableReplication(s)
	}
}

func (s *IgnoreTableReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIgnoreTableReplication(s)
	}
}

type RewriteDbReplicationContext struct {
	*ReplicationFilterContext
}

func NewRewriteDbReplicationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RewriteDbReplicationContext {
	var p = new(RewriteDbReplicationContext)

	p.ReplicationFilterContext = NewEmptyReplicationFilterContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ReplicationFilterContext))

	return p
}

func (s *RewriteDbReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RewriteDbReplicationContext) REPLICATE_REWRITE_DB() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_REWRITE_DB, 0)
}

func (s *RewriteDbReplicationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *RewriteDbReplicationContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *RewriteDbReplicationContext) AllTablePair() []ITablePairContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITablePairContext); ok {
			len++
		}
	}

	tst := make([]ITablePairContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITablePairContext); ok {
			tst[i] = t.(ITablePairContext)
			i++
		}
	}

	return tst
}

func (s *RewriteDbReplicationContext) TablePair(i int) ITablePairContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePairContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePairContext)
}

func (s *RewriteDbReplicationContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *RewriteDbReplicationContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *RewriteDbReplicationContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *RewriteDbReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRewriteDbReplication(s)
	}
}

func (s *RewriteDbReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRewriteDbReplication(s)
	}
}

type DoDbReplicationContext struct {
	*ReplicationFilterContext
}

func NewDoDbReplicationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DoDbReplicationContext {
	var p = new(DoDbReplicationContext)

	p.ReplicationFilterContext = NewEmptyReplicationFilterContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ReplicationFilterContext))

	return p
}

func (s *DoDbReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoDbReplicationContext) REPLICATE_DO_DB() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_DO_DB, 0)
}

func (s *DoDbReplicationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *DoDbReplicationContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *DoDbReplicationContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *DoDbReplicationContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *DoDbReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDoDbReplication(s)
	}
}

func (s *DoDbReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDoDbReplication(s)
	}
}

type IgnoreDbReplicationContext struct {
	*ReplicationFilterContext
}

func NewIgnoreDbReplicationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IgnoreDbReplicationContext {
	var p = new(IgnoreDbReplicationContext)

	p.ReplicationFilterContext = NewEmptyReplicationFilterContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ReplicationFilterContext))

	return p
}

func (s *IgnoreDbReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IgnoreDbReplicationContext) REPLICATE_IGNORE_DB() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_IGNORE_DB, 0)
}

func (s *IgnoreDbReplicationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *IgnoreDbReplicationContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *IgnoreDbReplicationContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *IgnoreDbReplicationContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *IgnoreDbReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIgnoreDbReplication(s)
	}
}

func (s *IgnoreDbReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIgnoreDbReplication(s)
	}
}

type WildDoTableReplicationContext struct {
	*ReplicationFilterContext
}

func NewWildDoTableReplicationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WildDoTableReplicationContext {
	var p = new(WildDoTableReplicationContext)

	p.ReplicationFilterContext = NewEmptyReplicationFilterContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ReplicationFilterContext))

	return p
}

func (s *WildDoTableReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WildDoTableReplicationContext) REPLICATE_WILD_DO_TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_WILD_DO_TABLE, 0)
}

func (s *WildDoTableReplicationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *WildDoTableReplicationContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *WildDoTableReplicationContext) SimpleStrings() ISimpleStringsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleStringsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleStringsContext)
}

func (s *WildDoTableReplicationContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *WildDoTableReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterWildDoTableReplication(s)
	}
}

func (s *WildDoTableReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitWildDoTableReplication(s)
	}
}

func (p *MySqlParser) ReplicationFilter() (localctx IReplicationFilterContext) {
	this := p
	_ = this

	localctx = NewReplicationFilterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, MySqlParserRULE_replicationFilter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4564)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserREPLICATE_DO_DB:
		localctx = NewDoDbReplicationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4515)
			p.Match(MySqlParserREPLICATE_DO_DB)
		}
		{
			p.SetState(4516)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}
		{
			p.SetState(4517)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(4518)
			p.UidList()
		}
		{
			p.SetState(4519)
			p.Match(MySqlParserRR_BRACKET)
		}

	case MySqlParserREPLICATE_IGNORE_DB:
		localctx = NewIgnoreDbReplicationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4521)
			p.Match(MySqlParserREPLICATE_IGNORE_DB)
		}
		{
			p.SetState(4522)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}
		{
			p.SetState(4523)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(4524)
			p.UidList()
		}
		{
			p.SetState(4525)
			p.Match(MySqlParserRR_BRACKET)
		}

	case MySqlParserREPLICATE_DO_TABLE:
		localctx = NewDoTableReplicationContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4527)
			p.Match(MySqlParserREPLICATE_DO_TABLE)
		}
		{
			p.SetState(4528)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}
		{
			p.SetState(4529)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(4530)
			p.Tables()
		}
		{
			p.SetState(4531)
			p.Match(MySqlParserRR_BRACKET)
		}

	case MySqlParserREPLICATE_IGNORE_TABLE:
		localctx = NewIgnoreTableReplicationContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4533)
			p.Match(MySqlParserREPLICATE_IGNORE_TABLE)
		}
		{
			p.SetState(4534)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}
		{
			p.SetState(4535)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(4536)
			p.Tables()
		}
		{
			p.SetState(4537)
			p.Match(MySqlParserRR_BRACKET)
		}

	case MySqlParserREPLICATE_WILD_DO_TABLE:
		localctx = NewWildDoTableReplicationContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4539)
			p.Match(MySqlParserREPLICATE_WILD_DO_TABLE)
		}
		{
			p.SetState(4540)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}
		{
			p.SetState(4541)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(4542)
			p.SimpleStrings()
		}
		{
			p.SetState(4543)
			p.Match(MySqlParserRR_BRACKET)
		}

	case MySqlParserREPLICATE_WILD_IGNORE_TABLE:
		localctx = NewWildIgnoreTableReplicationContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4545)
			p.Match(MySqlParserREPLICATE_WILD_IGNORE_TABLE)
		}
		{
			p.SetState(4546)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}
		{
			p.SetState(4547)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(4548)
			p.SimpleStrings()
		}
		{
			p.SetState(4549)
			p.Match(MySqlParserRR_BRACKET)
		}

	case MySqlParserREPLICATE_REWRITE_DB:
		localctx = NewRewriteDbReplicationContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4551)
			p.Match(MySqlParserREPLICATE_REWRITE_DB)
		}
		{
			p.SetState(4552)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}
		{
			p.SetState(4553)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(4554)
			p.TablePair()
		}
		p.SetState(4559)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(4555)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(4556)
				p.TablePair()
			}

			p.SetState(4561)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4562)
			p.Match(MySqlParserRR_BRACKET)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITablePairContext is an interface to support dynamic dispatch.
type ITablePairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFirstTable returns the firstTable rule contexts.
	GetFirstTable() ITableNameContext

	// GetSecondTable returns the secondTable rule contexts.
	GetSecondTable() ITableNameContext

	// SetFirstTable sets the firstTable rule contexts.
	SetFirstTable(ITableNameContext)

	// SetSecondTable sets the secondTable rule contexts.
	SetSecondTable(ITableNameContext)

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	COMMA() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	AllTableName() []ITableNameContext
	TableName(i int) ITableNameContext

	// IsTablePairContext differentiates from other interfaces.
	IsTablePairContext()
}

type TablePairContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	firstTable  ITableNameContext
	secondTable ITableNameContext
}

func NewEmptyTablePairContext() *TablePairContext {
	var p = new(TablePairContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_tablePair
	return p
}

func (*TablePairContext) IsTablePairContext() {}

func NewTablePairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablePairContext {
	var p = new(TablePairContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tablePair

	return p
}

func (s *TablePairContext) GetParser() antlr.Parser { return s.parser }

func (s *TablePairContext) GetFirstTable() ITableNameContext { return s.firstTable }

func (s *TablePairContext) GetSecondTable() ITableNameContext { return s.secondTable }

func (s *TablePairContext) SetFirstTable(v ITableNameContext) { s.firstTable = v }

func (s *TablePairContext) SetSecondTable(v ITableNameContext) { s.secondTable = v }

func (s *TablePairContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *TablePairContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *TablePairContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *TablePairContext) AllTableName() []ITableNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableNameContext); ok {
			len++
		}
	}

	tst := make([]ITableNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableNameContext); ok {
			tst[i] = t.(ITableNameContext)
			i++
		}
	}

	return tst
}

func (s *TablePairContext) TableName(i int) ITableNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TablePairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablePairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablePairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTablePair(s)
	}
}

func (s *TablePairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTablePair(s)
	}
}

func (p *MySqlParser) TablePair() (localctx ITablePairContext) {
	this := p
	_ = this

	localctx = NewTablePairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, MySqlParserRULE_tablePair)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4566)
		p.Match(MySqlParserLR_BRACKET)
	}
	{
		p.SetState(4567)

		var _x = p.TableName()

		localctx.(*TablePairContext).firstTable = _x
	}
	{
		p.SetState(4568)
		p.Match(MySqlParserCOMMA)
	}
	{
		p.SetState(4569)

		var _x = p.TableName()

		localctx.(*TablePairContext).secondTable = _x
	}
	{
		p.SetState(4570)
		p.Match(MySqlParserRR_BRACKET)
	}

	return localctx
}

// IThreadTypeContext is an interface to support dynamic dispatch.
type IThreadTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IO_THREAD() antlr.TerminalNode
	SQL_THREAD() antlr.TerminalNode

	// IsThreadTypeContext differentiates from other interfaces.
	IsThreadTypeContext()
}

type ThreadTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThreadTypeContext() *ThreadTypeContext {
	var p = new(ThreadTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_threadType
	return p
}

func (*ThreadTypeContext) IsThreadTypeContext() {}

func NewThreadTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThreadTypeContext {
	var p = new(ThreadTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_threadType

	return p
}

func (s *ThreadTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ThreadTypeContext) IO_THREAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserIO_THREAD, 0)
}

func (s *ThreadTypeContext) SQL_THREAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_THREAD, 0)
}

func (s *ThreadTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThreadTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThreadTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterThreadType(s)
	}
}

func (s *ThreadTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitThreadType(s)
	}
}

func (p *MySqlParser) ThreadType() (localctx IThreadTypeContext) {
	this := p
	_ = this

	localctx = NewThreadTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, MySqlParserRULE_threadType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4572)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserIO_THREAD || _la == MySqlParserSQL_THREAD) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IUntilOptionContext is an interface to support dynamic dispatch.
type IUntilOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUntilOptionContext differentiates from other interfaces.
	IsUntilOptionContext()
}

type UntilOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUntilOptionContext() *UntilOptionContext {
	var p = new(UntilOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_untilOption
	return p
}

func (*UntilOptionContext) IsUntilOptionContext() {}

func NewUntilOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UntilOptionContext {
	var p = new(UntilOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_untilOption

	return p
}

func (s *UntilOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *UntilOptionContext) CopyFrom(ctx *UntilOptionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *UntilOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UntilOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type GtidsUntilOptionContext struct {
	*UntilOptionContext
	gtids antlr.Token
}

func NewGtidsUntilOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GtidsUntilOptionContext {
	var p = new(GtidsUntilOptionContext)

	p.UntilOptionContext = NewEmptyUntilOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*UntilOptionContext))

	return p
}

func (s *GtidsUntilOptionContext) GetGtids() antlr.Token { return s.gtids }

func (s *GtidsUntilOptionContext) SetGtids(v antlr.Token) { s.gtids = v }

func (s *GtidsUntilOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GtidsUntilOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *GtidsUntilOptionContext) GtuidSet() IGtuidSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGtuidSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGtuidSetContext)
}

func (s *GtidsUntilOptionContext) SQL_BEFORE_GTIDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_BEFORE_GTIDS, 0)
}

func (s *GtidsUntilOptionContext) SQL_AFTER_GTIDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_AFTER_GTIDS, 0)
}

func (s *GtidsUntilOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterGtidsUntilOption(s)
	}
}

func (s *GtidsUntilOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitGtidsUntilOption(s)
	}
}

type SqlGapsUntilOptionContext struct {
	*UntilOptionContext
}

func NewSqlGapsUntilOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SqlGapsUntilOptionContext {
	var p = new(SqlGapsUntilOptionContext)

	p.UntilOptionContext = NewEmptyUntilOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*UntilOptionContext))

	return p
}

func (s *SqlGapsUntilOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqlGapsUntilOptionContext) SQL_AFTER_MTS_GAPS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_AFTER_MTS_GAPS, 0)
}

func (s *SqlGapsUntilOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSqlGapsUntilOption(s)
	}
}

func (s *SqlGapsUntilOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSqlGapsUntilOption(s)
	}
}

type MasterLogUntilOptionContext struct {
	*UntilOptionContext
}

func NewMasterLogUntilOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MasterLogUntilOptionContext {
	var p = new(MasterLogUntilOptionContext)

	p.UntilOptionContext = NewEmptyUntilOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*UntilOptionContext))

	return p
}

func (s *MasterLogUntilOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MasterLogUntilOptionContext) MASTER_LOG_FILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_LOG_FILE, 0)
}

func (s *MasterLogUntilOptionContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *MasterLogUntilOptionContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *MasterLogUntilOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *MasterLogUntilOptionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *MasterLogUntilOptionContext) MASTER_LOG_POS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_LOG_POS, 0)
}

func (s *MasterLogUntilOptionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *MasterLogUntilOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMasterLogUntilOption(s)
	}
}

func (s *MasterLogUntilOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMasterLogUntilOption(s)
	}
}

type RelayLogUntilOptionContext struct {
	*UntilOptionContext
}

func NewRelayLogUntilOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RelayLogUntilOptionContext {
	var p = new(RelayLogUntilOptionContext)

	p.UntilOptionContext = NewEmptyUntilOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*UntilOptionContext))

	return p
}

func (s *RelayLogUntilOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelayLogUntilOptionContext) RELAY_LOG_FILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELAY_LOG_FILE, 0)
}

func (s *RelayLogUntilOptionContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *RelayLogUntilOptionContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *RelayLogUntilOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *RelayLogUntilOptionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *RelayLogUntilOptionContext) RELAY_LOG_POS() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELAY_LOG_POS, 0)
}

func (s *RelayLogUntilOptionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *RelayLogUntilOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRelayLogUntilOption(s)
	}
}

func (s *RelayLogUntilOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRelayLogUntilOption(s)
	}
}

func (p *MySqlParser) UntilOption() (localctx IUntilOptionContext) {
	this := p
	_ = this

	localctx = NewUntilOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, MySqlParserRULE_untilOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4592)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_BEFORE_GTIDS:
		localctx = NewGtidsUntilOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4574)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*GtidsUntilOptionContext).gtids = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserSQL_AFTER_GTIDS || _la == MySqlParserSQL_BEFORE_GTIDS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*GtidsUntilOptionContext).gtids = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4575)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}
		{
			p.SetState(4576)
			p.GtuidSet()
		}

	case MySqlParserMASTER_LOG_FILE:
		localctx = NewMasterLogUntilOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4577)
			p.Match(MySqlParserMASTER_LOG_FILE)
		}
		{
			p.SetState(4578)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}
		{
			p.SetState(4579)
			p.Match(MySqlParserSTRING_LITERAL)
		}
		{
			p.SetState(4580)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(4581)
			p.Match(MySqlParserMASTER_LOG_POS)
		}
		{
			p.SetState(4582)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}
		{
			p.SetState(4583)
			p.DecimalLiteral()
		}

	case MySqlParserRELAY_LOG_FILE:
		localctx = NewRelayLogUntilOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4584)
			p.Match(MySqlParserRELAY_LOG_FILE)
		}
		{
			p.SetState(4585)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}
		{
			p.SetState(4586)
			p.Match(MySqlParserSTRING_LITERAL)
		}
		{
			p.SetState(4587)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(4588)
			p.Match(MySqlParserRELAY_LOG_POS)
		}
		{
			p.SetState(4589)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}
		{
			p.SetState(4590)
			p.DecimalLiteral()
		}

	case MySqlParserSQL_AFTER_MTS_GAPS:
		localctx = NewSqlGapsUntilOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4591)
			p.Match(MySqlParserSQL_AFTER_MTS_GAPS)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IConnectionOptionContext is an interface to support dynamic dispatch.
type IConnectionOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsConnectionOptionContext differentiates from other interfaces.
	IsConnectionOptionContext()
}

type ConnectionOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConnectionOptionContext() *ConnectionOptionContext {
	var p = new(ConnectionOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_connectionOption
	return p
}

func (*ConnectionOptionContext) IsConnectionOptionContext() {}

func NewConnectionOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConnectionOptionContext {
	var p = new(ConnectionOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_connectionOption

	return p
}

func (s *ConnectionOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConnectionOptionContext) CopyFrom(ctx *ConnectionOptionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ConnectionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConnectionOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PluginDirConnectionOptionContext struct {
	*ConnectionOptionContext
	conOptPluginDir antlr.Token
}

func NewPluginDirConnectionOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PluginDirConnectionOptionContext {
	var p = new(PluginDirConnectionOptionContext)

	p.ConnectionOptionContext = NewEmptyConnectionOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ConnectionOptionContext))

	return p
}

func (s *PluginDirConnectionOptionContext) GetConOptPluginDir() antlr.Token { return s.conOptPluginDir }

func (s *PluginDirConnectionOptionContext) SetConOptPluginDir(v antlr.Token) { s.conOptPluginDir = v }

func (s *PluginDirConnectionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PluginDirConnectionOptionContext) PLUGIN_DIR() antlr.TerminalNode {
	return s.GetToken(MySqlParserPLUGIN_DIR, 0)
}

func (s *PluginDirConnectionOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *PluginDirConnectionOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *PluginDirConnectionOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPluginDirConnectionOption(s)
	}
}

func (s *PluginDirConnectionOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPluginDirConnectionOption(s)
	}
}

type UserConnectionOptionContext struct {
	*ConnectionOptionContext
	conOptUser antlr.Token
}

func NewUserConnectionOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UserConnectionOptionContext {
	var p = new(UserConnectionOptionContext)

	p.ConnectionOptionContext = NewEmptyConnectionOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ConnectionOptionContext))

	return p
}

func (s *UserConnectionOptionContext) GetConOptUser() antlr.Token { return s.conOptUser }

func (s *UserConnectionOptionContext) SetConOptUser(v antlr.Token) { s.conOptUser = v }

func (s *UserConnectionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserConnectionOptionContext) USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER, 0)
}

func (s *UserConnectionOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *UserConnectionOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *UserConnectionOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUserConnectionOption(s)
	}
}

func (s *UserConnectionOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUserConnectionOption(s)
	}
}

type DefaultAuthConnectionOptionContext struct {
	*ConnectionOptionContext
	conOptDefAuth antlr.Token
}

func NewDefaultAuthConnectionOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DefaultAuthConnectionOptionContext {
	var p = new(DefaultAuthConnectionOptionContext)

	p.ConnectionOptionContext = NewEmptyConnectionOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ConnectionOptionContext))

	return p
}

func (s *DefaultAuthConnectionOptionContext) GetConOptDefAuth() antlr.Token { return s.conOptDefAuth }

func (s *DefaultAuthConnectionOptionContext) SetConOptDefAuth(v antlr.Token) { s.conOptDefAuth = v }

func (s *DefaultAuthConnectionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultAuthConnectionOptionContext) DEFAULT_AUTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT_AUTH, 0)
}

func (s *DefaultAuthConnectionOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *DefaultAuthConnectionOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *DefaultAuthConnectionOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDefaultAuthConnectionOption(s)
	}
}

func (s *DefaultAuthConnectionOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDefaultAuthConnectionOption(s)
	}
}

type PasswordConnectionOptionContext struct {
	*ConnectionOptionContext
	conOptPassword antlr.Token
}

func NewPasswordConnectionOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PasswordConnectionOptionContext {
	var p = new(PasswordConnectionOptionContext)

	p.ConnectionOptionContext = NewEmptyConnectionOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ConnectionOptionContext))

	return p
}

func (s *PasswordConnectionOptionContext) GetConOptPassword() antlr.Token { return s.conOptPassword }

func (s *PasswordConnectionOptionContext) SetConOptPassword(v antlr.Token) { s.conOptPassword = v }

func (s *PasswordConnectionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PasswordConnectionOptionContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD, 0)
}

func (s *PasswordConnectionOptionContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *PasswordConnectionOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *PasswordConnectionOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPasswordConnectionOption(s)
	}
}

func (s *PasswordConnectionOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPasswordConnectionOption(s)
	}
}

func (p *MySqlParser) ConnectionOption() (localctx IConnectionOptionContext) {
	this := p
	_ = this

	localctx = NewConnectionOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, MySqlParserRULE_connectionOption)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4606)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserUSER:
		localctx = NewUserConnectionOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4594)
			p.Match(MySqlParserUSER)
		}
		{
			p.SetState(4595)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}
		{
			p.SetState(4596)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*UserConnectionOptionContext).conOptUser = _m
		}

	case MySqlParserPASSWORD:
		localctx = NewPasswordConnectionOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4597)
			p.Match(MySqlParserPASSWORD)
		}
		{
			p.SetState(4598)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}
		{
			p.SetState(4599)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*PasswordConnectionOptionContext).conOptPassword = _m
		}

	case MySqlParserDEFAULT_AUTH:
		localctx = NewDefaultAuthConnectionOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4600)
			p.Match(MySqlParserDEFAULT_AUTH)
		}
		{
			p.SetState(4601)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}
		{
			p.SetState(4602)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*DefaultAuthConnectionOptionContext).conOptDefAuth = _m
		}

	case MySqlParserPLUGIN_DIR:
		localctx = NewPluginDirConnectionOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4603)
			p.Match(MySqlParserPLUGIN_DIR)
		}
		{
			p.SetState(4604)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}
		{
			p.SetState(4605)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*PluginDirConnectionOptionContext).conOptPluginDir = _m
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IGtuidSetContext is an interface to support dynamic dispatch.
type IGtuidSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllUuidSet() []IUuidSetContext
	UuidSet(i int) IUuidSetContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsGtuidSetContext differentiates from other interfaces.
	IsGtuidSetContext()
}

type GtuidSetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGtuidSetContext() *GtuidSetContext {
	var p = new(GtuidSetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_gtuidSet
	return p
}

func (*GtuidSetContext) IsGtuidSetContext() {}

func NewGtuidSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GtuidSetContext {
	var p = new(GtuidSetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_gtuidSet

	return p
}

func (s *GtuidSetContext) GetParser() antlr.Parser { return s.parser }

func (s *GtuidSetContext) AllUuidSet() []IUuidSetContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUuidSetContext); ok {
			len++
		}
	}

	tst := make([]IUuidSetContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUuidSetContext); ok {
			tst[i] = t.(IUuidSetContext)
			i++
		}
	}

	return tst
}

func (s *GtuidSetContext) UuidSet(i int) IUuidSetContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUuidSetContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUuidSetContext)
}

func (s *GtuidSetContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *GtuidSetContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *GtuidSetContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *GtuidSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GtuidSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GtuidSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterGtuidSet(s)
	}
}

func (s *GtuidSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitGtuidSet(s)
	}
}

func (p *MySqlParser) GtuidSet() (localctx IGtuidSetContext) {
	this := p
	_ = this

	localctx = NewGtuidSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, MySqlParserRULE_gtuidSet)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4617)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserZERO_DECIMAL, MySqlParserONE_DECIMAL, MySqlParserTWO_DECIMAL, MySqlParserDECIMAL_LITERAL, MySqlParserREAL_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4608)
			p.UuidSet()
		}
		p.SetState(4613)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(4609)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(4610)
				p.UuidSet()
			}

			p.SetState(4615)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case MySqlParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4616)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IXaStartTransactionContext is an interface to support dynamic dispatch.
type IXaStartTransactionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetXaStart returns the xaStart token.
	GetXaStart() antlr.Token

	// GetXaAction returns the xaAction token.
	GetXaAction() antlr.Token

	// SetXaStart sets the xaStart token.
	SetXaStart(antlr.Token)

	// SetXaAction sets the xaAction token.
	SetXaAction(antlr.Token)

	// Getter signatures
	XA() antlr.TerminalNode
	Xid() IXidContext
	START() antlr.TerminalNode
	BEGIN() antlr.TerminalNode
	JOIN() antlr.TerminalNode
	RESUME() antlr.TerminalNode

	// IsXaStartTransactionContext differentiates from other interfaces.
	IsXaStartTransactionContext()
}

type XaStartTransactionContext struct {
	*antlr.BaseParserRuleContext
	parser   antlr.Parser
	xaStart  antlr.Token
	xaAction antlr.Token
}

func NewEmptyXaStartTransactionContext() *XaStartTransactionContext {
	var p = new(XaStartTransactionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_xaStartTransaction
	return p
}

func (*XaStartTransactionContext) IsXaStartTransactionContext() {}

func NewXaStartTransactionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XaStartTransactionContext {
	var p = new(XaStartTransactionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_xaStartTransaction

	return p
}

func (s *XaStartTransactionContext) GetParser() antlr.Parser { return s.parser }

func (s *XaStartTransactionContext) GetXaStart() antlr.Token { return s.xaStart }

func (s *XaStartTransactionContext) GetXaAction() antlr.Token { return s.xaAction }

func (s *XaStartTransactionContext) SetXaStart(v antlr.Token) { s.xaStart = v }

func (s *XaStartTransactionContext) SetXaAction(v antlr.Token) { s.xaAction = v }

func (s *XaStartTransactionContext) XA() antlr.TerminalNode {
	return s.GetToken(MySqlParserXA, 0)
}

func (s *XaStartTransactionContext) Xid() IXidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXidContext)
}

func (s *XaStartTransactionContext) START() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTART, 0)
}

func (s *XaStartTransactionContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBEGIN, 0)
}

func (s *XaStartTransactionContext) JOIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserJOIN, 0)
}

func (s *XaStartTransactionContext) RESUME() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESUME, 0)
}

func (s *XaStartTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XaStartTransactionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XaStartTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterXaStartTransaction(s)
	}
}

func (s *XaStartTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitXaStartTransaction(s)
	}
}

func (p *MySqlParser) XaStartTransaction() (localctx IXaStartTransactionContext) {
	this := p
	_ = this

	localctx = NewXaStartTransactionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, MySqlParserRULE_xaStartTransaction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4619)
		p.Match(MySqlParserXA)
	}
	{
		p.SetState(4620)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*XaStartTransactionContext).xaStart = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserBEGIN || _la == MySqlParserSTART) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*XaStartTransactionContext).xaStart = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4621)
		p.Xid()
	}
	p.SetState(4623)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserJOIN || _la == MySqlParserRESUME {
		{
			p.SetState(4622)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*XaStartTransactionContext).xaAction = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserJOIN || _la == MySqlParserRESUME) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*XaStartTransactionContext).xaAction = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IXaEndTransactionContext is an interface to support dynamic dispatch.
type IXaEndTransactionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	XA() antlr.TerminalNode
	END() antlr.TerminalNode
	Xid() IXidContext
	SUSPEND() antlr.TerminalNode
	FOR() antlr.TerminalNode
	MIGRATE() antlr.TerminalNode

	// IsXaEndTransactionContext differentiates from other interfaces.
	IsXaEndTransactionContext()
}

type XaEndTransactionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXaEndTransactionContext() *XaEndTransactionContext {
	var p = new(XaEndTransactionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_xaEndTransaction
	return p
}

func (*XaEndTransactionContext) IsXaEndTransactionContext() {}

func NewXaEndTransactionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XaEndTransactionContext {
	var p = new(XaEndTransactionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_xaEndTransaction

	return p
}

func (s *XaEndTransactionContext) GetParser() antlr.Parser { return s.parser }

func (s *XaEndTransactionContext) XA() antlr.TerminalNode {
	return s.GetToken(MySqlParserXA, 0)
}

func (s *XaEndTransactionContext) END() antlr.TerminalNode {
	return s.GetToken(MySqlParserEND, 0)
}

func (s *XaEndTransactionContext) Xid() IXidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXidContext)
}

func (s *XaEndTransactionContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUSPEND, 0)
}

func (s *XaEndTransactionContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *XaEndTransactionContext) MIGRATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMIGRATE, 0)
}

func (s *XaEndTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XaEndTransactionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XaEndTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterXaEndTransaction(s)
	}
}

func (s *XaEndTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitXaEndTransaction(s)
	}
}

func (p *MySqlParser) XaEndTransaction() (localctx IXaEndTransactionContext) {
	this := p
	_ = this

	localctx = NewXaEndTransactionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, MySqlParserRULE_xaEndTransaction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4625)
		p.Match(MySqlParserXA)
	}
	{
		p.SetState(4626)
		p.Match(MySqlParserEND)
	}
	{
		p.SetState(4627)
		p.Xid()
	}
	p.SetState(4633)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserSUSPEND {
		{
			p.SetState(4628)
			p.Match(MySqlParserSUSPEND)
		}
		p.SetState(4631)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserFOR {
			{
				p.SetState(4629)
				p.Match(MySqlParserFOR)
			}
			{
				p.SetState(4630)
				p.Match(MySqlParserMIGRATE)
			}

		}

	}

	return localctx
}

// IXaPrepareStatementContext is an interface to support dynamic dispatch.
type IXaPrepareStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	XA() antlr.TerminalNode
	PREPARE() antlr.TerminalNode
	Xid() IXidContext

	// IsXaPrepareStatementContext differentiates from other interfaces.
	IsXaPrepareStatementContext()
}

type XaPrepareStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXaPrepareStatementContext() *XaPrepareStatementContext {
	var p = new(XaPrepareStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_xaPrepareStatement
	return p
}

func (*XaPrepareStatementContext) IsXaPrepareStatementContext() {}

func NewXaPrepareStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XaPrepareStatementContext {
	var p = new(XaPrepareStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_xaPrepareStatement

	return p
}

func (s *XaPrepareStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *XaPrepareStatementContext) XA() antlr.TerminalNode {
	return s.GetToken(MySqlParserXA, 0)
}

func (s *XaPrepareStatementContext) PREPARE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPREPARE, 0)
}

func (s *XaPrepareStatementContext) Xid() IXidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXidContext)
}

func (s *XaPrepareStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XaPrepareStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XaPrepareStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterXaPrepareStatement(s)
	}
}

func (s *XaPrepareStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitXaPrepareStatement(s)
	}
}

func (p *MySqlParser) XaPrepareStatement() (localctx IXaPrepareStatementContext) {
	this := p
	_ = this

	localctx = NewXaPrepareStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, MySqlParserRULE_xaPrepareStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4635)
		p.Match(MySqlParserXA)
	}
	{
		p.SetState(4636)
		p.Match(MySqlParserPREPARE)
	}
	{
		p.SetState(4637)
		p.Xid()
	}

	return localctx
}

// IXaCommitWorkContext is an interface to support dynamic dispatch.
type IXaCommitWorkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	XA() antlr.TerminalNode
	COMMIT() antlr.TerminalNode
	Xid() IXidContext
	ONE() antlr.TerminalNode
	PHASE() antlr.TerminalNode

	// IsXaCommitWorkContext differentiates from other interfaces.
	IsXaCommitWorkContext()
}

type XaCommitWorkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXaCommitWorkContext() *XaCommitWorkContext {
	var p = new(XaCommitWorkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_xaCommitWork
	return p
}

func (*XaCommitWorkContext) IsXaCommitWorkContext() {}

func NewXaCommitWorkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XaCommitWorkContext {
	var p = new(XaCommitWorkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_xaCommitWork

	return p
}

func (s *XaCommitWorkContext) GetParser() antlr.Parser { return s.parser }

func (s *XaCommitWorkContext) XA() antlr.TerminalNode {
	return s.GetToken(MySqlParserXA, 0)
}

func (s *XaCommitWorkContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMIT, 0)
}

func (s *XaCommitWorkContext) Xid() IXidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXidContext)
}

func (s *XaCommitWorkContext) ONE() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE, 0)
}

func (s *XaCommitWorkContext) PHASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPHASE, 0)
}

func (s *XaCommitWorkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XaCommitWorkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XaCommitWorkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterXaCommitWork(s)
	}
}

func (s *XaCommitWorkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitXaCommitWork(s)
	}
}

func (p *MySqlParser) XaCommitWork() (localctx IXaCommitWorkContext) {
	this := p
	_ = this

	localctx = NewXaCommitWorkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, MySqlParserRULE_xaCommitWork)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4639)
		p.Match(MySqlParserXA)
	}
	{
		p.SetState(4640)
		p.Match(MySqlParserCOMMIT)
	}
	{
		p.SetState(4641)
		p.Xid()
	}
	p.SetState(4644)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserONE {
		{
			p.SetState(4642)
			p.Match(MySqlParserONE)
		}
		{
			p.SetState(4643)
			p.Match(MySqlParserPHASE)
		}

	}

	return localctx
}

// IXaRollbackWorkContext is an interface to support dynamic dispatch.
type IXaRollbackWorkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	XA() antlr.TerminalNode
	ROLLBACK() antlr.TerminalNode
	Xid() IXidContext

	// IsXaRollbackWorkContext differentiates from other interfaces.
	IsXaRollbackWorkContext()
}

type XaRollbackWorkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXaRollbackWorkContext() *XaRollbackWorkContext {
	var p = new(XaRollbackWorkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_xaRollbackWork
	return p
}

func (*XaRollbackWorkContext) IsXaRollbackWorkContext() {}

func NewXaRollbackWorkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XaRollbackWorkContext {
	var p = new(XaRollbackWorkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_xaRollbackWork

	return p
}

func (s *XaRollbackWorkContext) GetParser() antlr.Parser { return s.parser }

func (s *XaRollbackWorkContext) XA() antlr.TerminalNode {
	return s.GetToken(MySqlParserXA, 0)
}

func (s *XaRollbackWorkContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLLBACK, 0)
}

func (s *XaRollbackWorkContext) Xid() IXidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXidContext)
}

func (s *XaRollbackWorkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XaRollbackWorkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XaRollbackWorkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterXaRollbackWork(s)
	}
}

func (s *XaRollbackWorkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitXaRollbackWork(s)
	}
}

func (p *MySqlParser) XaRollbackWork() (localctx IXaRollbackWorkContext) {
	this := p
	_ = this

	localctx = NewXaRollbackWorkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, MySqlParserRULE_xaRollbackWork)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4646)
		p.Match(MySqlParserXA)
	}
	{
		p.SetState(4647)
		p.Match(MySqlParserROLLBACK)
	}
	{
		p.SetState(4648)
		p.Xid()
	}

	return localctx
}

// IXaRecoverWorkContext is an interface to support dynamic dispatch.
type IXaRecoverWorkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	XA() antlr.TerminalNode
	RECOVER() antlr.TerminalNode
	CONVERT() antlr.TerminalNode
	Xid() IXidContext

	// IsXaRecoverWorkContext differentiates from other interfaces.
	IsXaRecoverWorkContext()
}

type XaRecoverWorkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXaRecoverWorkContext() *XaRecoverWorkContext {
	var p = new(XaRecoverWorkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_xaRecoverWork
	return p
}

func (*XaRecoverWorkContext) IsXaRecoverWorkContext() {}

func NewXaRecoverWorkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XaRecoverWorkContext {
	var p = new(XaRecoverWorkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_xaRecoverWork

	return p
}

func (s *XaRecoverWorkContext) GetParser() antlr.Parser { return s.parser }

func (s *XaRecoverWorkContext) XA() antlr.TerminalNode {
	return s.GetToken(MySqlParserXA, 0)
}

func (s *XaRecoverWorkContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(MySqlParserRECOVER, 0)
}

func (s *XaRecoverWorkContext) CONVERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONVERT, 0)
}

func (s *XaRecoverWorkContext) Xid() IXidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXidContext)
}

func (s *XaRecoverWorkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XaRecoverWorkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XaRecoverWorkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterXaRecoverWork(s)
	}
}

func (s *XaRecoverWorkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitXaRecoverWork(s)
	}
}

func (p *MySqlParser) XaRecoverWork() (localctx IXaRecoverWorkContext) {
	this := p
	_ = this

	localctx = NewXaRecoverWorkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, MySqlParserRULE_xaRecoverWork)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4650)
		p.Match(MySqlParserXA)
	}
	{
		p.SetState(4651)
		p.Match(MySqlParserRECOVER)
	}
	p.SetState(4654)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserCONVERT {
		{
			p.SetState(4652)
			p.Match(MySqlParserCONVERT)
		}
		{
			p.SetState(4653)
			p.Xid()
		}

	}

	return localctx
}

// IPrepareStatementContext is an interface to support dynamic dispatch.
type IPrepareStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetQuery returns the query token.
	GetQuery() antlr.Token

	// GetVariable returns the variable token.
	GetVariable() antlr.Token

	// SetQuery sets the query token.
	SetQuery(antlr.Token)

	// SetVariable sets the variable token.
	SetVariable(antlr.Token)

	// Getter signatures
	PREPARE() antlr.TerminalNode
	Uid() IUidContext
	FROM() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	LOCAL_ID() antlr.TerminalNode

	// IsPrepareStatementContext differentiates from other interfaces.
	IsPrepareStatementContext()
}

type PrepareStatementContext struct {
	*antlr.BaseParserRuleContext
	parser   antlr.Parser
	query    antlr.Token
	variable antlr.Token
}

func NewEmptyPrepareStatementContext() *PrepareStatementContext {
	var p = new(PrepareStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_prepareStatement
	return p
}

func (*PrepareStatementContext) IsPrepareStatementContext() {}

func NewPrepareStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrepareStatementContext {
	var p = new(PrepareStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_prepareStatement

	return p
}

func (s *PrepareStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PrepareStatementContext) GetQuery() antlr.Token { return s.query }

func (s *PrepareStatementContext) GetVariable() antlr.Token { return s.variable }

func (s *PrepareStatementContext) SetQuery(v antlr.Token) { s.query = v }

func (s *PrepareStatementContext) SetVariable(v antlr.Token) { s.variable = v }

func (s *PrepareStatementContext) PREPARE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPREPARE, 0)
}

func (s *PrepareStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *PrepareStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *PrepareStatementContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *PrepareStatementContext) LOCAL_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL_ID, 0)
}

func (s *PrepareStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrepareStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrepareStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPrepareStatement(s)
	}
}

func (s *PrepareStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPrepareStatement(s)
	}
}

func (p *MySqlParser) PrepareStatement() (localctx IPrepareStatementContext) {
	this := p
	_ = this

	localctx = NewPrepareStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, MySqlParserRULE_prepareStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4656)
		p.Match(MySqlParserPREPARE)
	}
	{
		p.SetState(4657)
		p.Uid()
	}
	{
		p.SetState(4658)
		p.Match(MySqlParserFROM)
	}
	p.SetState(4661)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSTRING_LITERAL:
		{
			p.SetState(4659)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*PrepareStatementContext).query = _m
		}

	case MySqlParserLOCAL_ID:
		{
			p.SetState(4660)

			var _m = p.Match(MySqlParserLOCAL_ID)

			localctx.(*PrepareStatementContext).variable = _m
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExecuteStatementContext is an interface to support dynamic dispatch.
type IExecuteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXECUTE() antlr.TerminalNode
	Uid() IUidContext
	USING() antlr.TerminalNode
	UserVariables() IUserVariablesContext

	// IsExecuteStatementContext differentiates from other interfaces.
	IsExecuteStatementContext()
}

type ExecuteStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecuteStatementContext() *ExecuteStatementContext {
	var p = new(ExecuteStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_executeStatement
	return p
}

func (*ExecuteStatementContext) IsExecuteStatementContext() {}

func NewExecuteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecuteStatementContext {
	var p = new(ExecuteStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_executeStatement

	return p
}

func (s *ExecuteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecuteStatementContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXECUTE, 0)
}

func (s *ExecuteStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ExecuteStatementContext) USING() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSING, 0)
}

func (s *ExecuteStatementContext) UserVariables() IUserVariablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserVariablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserVariablesContext)
}

func (s *ExecuteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecuteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExecuteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterExecuteStatement(s)
	}
}

func (s *ExecuteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitExecuteStatement(s)
	}
}

func (p *MySqlParser) ExecuteStatement() (localctx IExecuteStatementContext) {
	this := p
	_ = this

	localctx = NewExecuteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, MySqlParserRULE_executeStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4663)
		p.Match(MySqlParserEXECUTE)
	}
	{
		p.SetState(4664)
		p.Uid()
	}
	p.SetState(4667)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserUSING {
		{
			p.SetState(4665)
			p.Match(MySqlParserUSING)
		}
		{
			p.SetState(4666)
			p.UserVariables()
		}

	}

	return localctx
}

// IDeallocatePrepareContext is an interface to support dynamic dispatch.
type IDeallocatePrepareContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDropFormat returns the dropFormat token.
	GetDropFormat() antlr.Token

	// SetDropFormat sets the dropFormat token.
	SetDropFormat(antlr.Token)

	// Getter signatures
	PREPARE() antlr.TerminalNode
	Uid() IUidContext
	DEALLOCATE() antlr.TerminalNode
	DROP() antlr.TerminalNode

	// IsDeallocatePrepareContext differentiates from other interfaces.
	IsDeallocatePrepareContext()
}

type DeallocatePrepareContext struct {
	*antlr.BaseParserRuleContext
	parser     antlr.Parser
	dropFormat antlr.Token
}

func NewEmptyDeallocatePrepareContext() *DeallocatePrepareContext {
	var p = new(DeallocatePrepareContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_deallocatePrepare
	return p
}

func (*DeallocatePrepareContext) IsDeallocatePrepareContext() {}

func NewDeallocatePrepareContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeallocatePrepareContext {
	var p = new(DeallocatePrepareContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_deallocatePrepare

	return p
}

func (s *DeallocatePrepareContext) GetParser() antlr.Parser { return s.parser }

func (s *DeallocatePrepareContext) GetDropFormat() antlr.Token { return s.dropFormat }

func (s *DeallocatePrepareContext) SetDropFormat(v antlr.Token) { s.dropFormat = v }

func (s *DeallocatePrepareContext) PREPARE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPREPARE, 0)
}

func (s *DeallocatePrepareContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DeallocatePrepareContext) DEALLOCATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEALLOCATE, 0)
}

func (s *DeallocatePrepareContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DeallocatePrepareContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeallocatePrepareContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeallocatePrepareContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDeallocatePrepare(s)
	}
}

func (s *DeallocatePrepareContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDeallocatePrepare(s)
	}
}

func (p *MySqlParser) DeallocatePrepare() (localctx IDeallocatePrepareContext) {
	this := p
	_ = this

	localctx = NewDeallocatePrepareContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, MySqlParserRULE_deallocatePrepare)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4669)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*DeallocatePrepareContext).dropFormat = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserDROP || _la == MySqlParserDEALLOCATE) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*DeallocatePrepareContext).dropFormat = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4670)
		p.Match(MySqlParserPREPARE)
	}
	{
		p.SetState(4671)
		p.Uid()
	}

	return localctx
}

// IRoutineBodyContext is an interface to support dynamic dispatch.
type IRoutineBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BlockStatement() IBlockStatementContext
	SqlStatement() ISqlStatementContext

	// IsRoutineBodyContext differentiates from other interfaces.
	IsRoutineBodyContext()
}

type RoutineBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoutineBodyContext() *RoutineBodyContext {
	var p = new(RoutineBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_routineBody
	return p
}

func (*RoutineBodyContext) IsRoutineBodyContext() {}

func NewRoutineBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoutineBodyContext {
	var p = new(RoutineBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_routineBody

	return p
}

func (s *RoutineBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *RoutineBodyContext) BlockStatement() IBlockStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *RoutineBodyContext) SqlStatement() ISqlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlStatementContext)
}

func (s *RoutineBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoutineBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRoutineBody(s)
	}
}

func (s *RoutineBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRoutineBody(s)
	}
}

func (p *MySqlParser) RoutineBody() (localctx IRoutineBodyContext) {
	this := p
	_ = this

	localctx = NewRoutineBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, MySqlParserRULE_routineBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4675)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 677, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4673)
			p.BlockStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4674)
			p.SqlStatement()
		}

	}

	return localctx
}

// IBlockStatementContext is an interface to support dynamic dispatch.
type IBlockStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BEGIN() antlr.TerminalNode
	END() antlr.TerminalNode
	AllUid() []IUidContext
	Uid(i int) IUidContext
	COLON_SYMB() antlr.TerminalNode
	AllDeclareVariable() []IDeclareVariableContext
	DeclareVariable(i int) IDeclareVariableContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	AllDeclareCondition() []IDeclareConditionContext
	DeclareCondition(i int) IDeclareConditionContext
	AllDeclareCursor() []IDeclareCursorContext
	DeclareCursor(i int) IDeclareCursorContext
	AllDeclareHandler() []IDeclareHandlerContext
	DeclareHandler(i int) IDeclareHandlerContext
	AllProcedureSqlStatement() []IProcedureSqlStatementContext
	ProcedureSqlStatement(i int) IProcedureSqlStatementContext

	// IsBlockStatementContext differentiates from other interfaces.
	IsBlockStatementContext()
}

type BlockStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockStatementContext() *BlockStatementContext {
	var p = new(BlockStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_blockStatement
	return p
}

func (*BlockStatementContext) IsBlockStatementContext() {}

func NewBlockStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockStatementContext {
	var p = new(BlockStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_blockStatement

	return p
}

func (s *BlockStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockStatementContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBEGIN, 0)
}

func (s *BlockStatementContext) END() antlr.TerminalNode {
	return s.GetToken(MySqlParserEND, 0)
}

func (s *BlockStatementContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *BlockStatementContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *BlockStatementContext) COLON_SYMB() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLON_SYMB, 0)
}

func (s *BlockStatementContext) AllDeclareVariable() []IDeclareVariableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclareVariableContext); ok {
			len++
		}
	}

	tst := make([]IDeclareVariableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclareVariableContext); ok {
			tst[i] = t.(IDeclareVariableContext)
			i++
		}
	}

	return tst
}

func (s *BlockStatementContext) DeclareVariable(i int) IDeclareVariableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclareVariableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclareVariableContext)
}

func (s *BlockStatementContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSEMI)
}

func (s *BlockStatementContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSEMI, i)
}

func (s *BlockStatementContext) AllDeclareCondition() []IDeclareConditionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclareConditionContext); ok {
			len++
		}
	}

	tst := make([]IDeclareConditionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclareConditionContext); ok {
			tst[i] = t.(IDeclareConditionContext)
			i++
		}
	}

	return tst
}

func (s *BlockStatementContext) DeclareCondition(i int) IDeclareConditionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclareConditionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclareConditionContext)
}

func (s *BlockStatementContext) AllDeclareCursor() []IDeclareCursorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclareCursorContext); ok {
			len++
		}
	}

	tst := make([]IDeclareCursorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclareCursorContext); ok {
			tst[i] = t.(IDeclareCursorContext)
			i++
		}
	}

	return tst
}

func (s *BlockStatementContext) DeclareCursor(i int) IDeclareCursorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclareCursorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclareCursorContext)
}

func (s *BlockStatementContext) AllDeclareHandler() []IDeclareHandlerContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclareHandlerContext); ok {
			len++
		}
	}

	tst := make([]IDeclareHandlerContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclareHandlerContext); ok {
			tst[i] = t.(IDeclareHandlerContext)
			i++
		}
	}

	return tst
}

func (s *BlockStatementContext) DeclareHandler(i int) IDeclareHandlerContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclareHandlerContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclareHandlerContext)
}

func (s *BlockStatementContext) AllProcedureSqlStatement() []IProcedureSqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			len++
		}
	}

	tst := make([]IProcedureSqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureSqlStatementContext); ok {
			tst[i] = t.(IProcedureSqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *BlockStatementContext) ProcedureSqlStatement(i int) IProcedureSqlStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureSqlStatementContext)
}

func (s *BlockStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterBlockStatement(s)
	}
}

func (s *BlockStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitBlockStatement(s)
	}
}

func (p *MySqlParser) BlockStatement() (localctx IBlockStatementContext) {
	this := p
	_ = this

	localctx = NewBlockStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, MySqlParserRULE_blockStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4680)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 678, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4677)
			p.Uid()
		}
		{
			p.SetState(4678)
			p.Match(MySqlParserCOLON_SYMB)
		}

	}
	{
		p.SetState(4682)
		p.Match(MySqlParserBEGIN)
	}
	p.SetState(4688)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 679, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4683)
				p.DeclareVariable()
			}
			{
				p.SetState(4684)
				p.Match(MySqlParserSEMI)
			}

		}
		p.SetState(4690)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 679, p.GetParserRuleContext())
	}
	p.SetState(4696)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 680, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4691)
				p.DeclareCondition()
			}
			{
				p.SetState(4692)
				p.Match(MySqlParserSEMI)
			}

		}
		p.SetState(4698)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 680, p.GetParserRuleContext())
	}
	p.SetState(4704)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 681, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4699)
				p.DeclareCursor()
			}
			{
				p.SetState(4700)
				p.Match(MySqlParserSEMI)
			}

		}
		p.SetState(4706)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 681, p.GetParserRuleContext())
	}
	p.SetState(4712)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserDECLARE {
		{
			p.SetState(4707)
			p.DeclareHandler()
		}
		{
			p.SetState(4708)
			p.Match(MySqlParserSEMI)
		}

		p.SetState(4714)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4718)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 683, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4715)
				p.ProcedureSqlStatement()
			}

		}
		p.SetState(4720)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 683, p.GetParserRuleContext())
	}
	{
		p.SetState(4721)
		p.Match(MySqlParserEND)
	}
	p.SetState(4723)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 684, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4722)
			p.Uid()
		}

	}

	return localctx
}

// ICaseStatementContext is an interface to support dynamic dispatch.
type ICaseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCASE() []antlr.TerminalNode
	CASE(i int) antlr.TerminalNode
	END() antlr.TerminalNode
	Uid() IUidContext
	Expression() IExpressionContext
	AllCaseAlternative() []ICaseAlternativeContext
	CaseAlternative(i int) ICaseAlternativeContext
	ELSE() antlr.TerminalNode
	AllProcedureSqlStatement() []IProcedureSqlStatementContext
	ProcedureSqlStatement(i int) IProcedureSqlStatementContext

	// IsCaseStatementContext differentiates from other interfaces.
	IsCaseStatementContext()
}

type CaseStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseStatementContext() *CaseStatementContext {
	var p = new(CaseStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_caseStatement
	return p
}

func (*CaseStatementContext) IsCaseStatementContext() {}

func NewCaseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseStatementContext {
	var p = new(CaseStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_caseStatement

	return p
}

func (s *CaseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseStatementContext) AllCASE() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCASE)
}

func (s *CaseStatementContext) CASE(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCASE, i)
}

func (s *CaseStatementContext) END() antlr.TerminalNode {
	return s.GetToken(MySqlParserEND, 0)
}

func (s *CaseStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CaseStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseStatementContext) AllCaseAlternative() []ICaseAlternativeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseAlternativeContext); ok {
			len++
		}
	}

	tst := make([]ICaseAlternativeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseAlternativeContext); ok {
			tst[i] = t.(ICaseAlternativeContext)
			i++
		}
	}

	return tst
}

func (s *CaseStatementContext) CaseAlternative(i int) ICaseAlternativeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseAlternativeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseAlternativeContext)
}

func (s *CaseStatementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserELSE, 0)
}

func (s *CaseStatementContext) AllProcedureSqlStatement() []IProcedureSqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			len++
		}
	}

	tst := make([]IProcedureSqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureSqlStatementContext); ok {
			tst[i] = t.(IProcedureSqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *CaseStatementContext) ProcedureSqlStatement(i int) IProcedureSqlStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureSqlStatementContext)
}

func (s *CaseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCaseStatement(s)
	}
}

func (s *CaseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCaseStatement(s)
	}
}

func (p *MySqlParser) CaseStatement() (localctx ICaseStatementContext) {
	this := p
	_ = this

	localctx = NewCaseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, MySqlParserRULE_caseStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4725)
		p.Match(MySqlParserCASE)
	}
	p.SetState(4728)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 685, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4726)
			p.Uid()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 685, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(4727)
			p.expression(0)
		}

	}
	p.SetState(4731)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == MySqlParserWHEN {
		{
			p.SetState(4730)
			p.CaseAlternative()
		}

		p.SetState(4733)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4741)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserELSE {
		{
			p.SetState(4735)
			p.Match(MySqlParserELSE)
		}
		p.SetState(4737)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(4736)
					p.ProcedureSqlStatement()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(4739)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 687, p.GetParserRuleContext())
		}

	}
	{
		p.SetState(4743)
		p.Match(MySqlParserEND)
	}
	{
		p.SetState(4744)
		p.Match(MySqlParserCASE)
	}

	return localctx
}

// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_procedureSqlStatement returns the _procedureSqlStatement rule contexts.
	Get_procedureSqlStatement() IProcedureSqlStatementContext

	// Set_procedureSqlStatement sets the _procedureSqlStatement rule contexts.
	Set_procedureSqlStatement(IProcedureSqlStatementContext)

	// GetThenStatements returns the thenStatements rule context list.
	GetThenStatements() []IProcedureSqlStatementContext

	// GetElseStatements returns the elseStatements rule context list.
	GetElseStatements() []IProcedureSqlStatementContext

	// SetThenStatements sets the thenStatements rule context list.
	SetThenStatements([]IProcedureSqlStatementContext)

	// SetElseStatements sets the elseStatements rule context list.
	SetElseStatements([]IProcedureSqlStatementContext)

	// Getter signatures
	AllIF() []antlr.TerminalNode
	IF(i int) antlr.TerminalNode
	Expression() IExpressionContext
	THEN() antlr.TerminalNode
	END() antlr.TerminalNode
	AllElifAlternative() []IElifAlternativeContext
	ElifAlternative(i int) IElifAlternativeContext
	ELSE() antlr.TerminalNode
	AllProcedureSqlStatement() []IProcedureSqlStatementContext
	ProcedureSqlStatement(i int) IProcedureSqlStatementContext

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	*antlr.BaseParserRuleContext
	parser                 antlr.Parser
	_procedureSqlStatement IProcedureSqlStatementContext
	thenStatements         []IProcedureSqlStatementContext
	elseStatements         []IProcedureSqlStatementContext
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_ifStatement
	return p
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) Get_procedureSqlStatement() IProcedureSqlStatementContext {
	return s._procedureSqlStatement
}

func (s *IfStatementContext) Set_procedureSqlStatement(v IProcedureSqlStatementContext) {
	s._procedureSqlStatement = v
}

func (s *IfStatementContext) GetThenStatements() []IProcedureSqlStatementContext {
	return s.thenStatements
}

func (s *IfStatementContext) GetElseStatements() []IProcedureSqlStatementContext {
	return s.elseStatements
}

func (s *IfStatementContext) SetThenStatements(v []IProcedureSqlStatementContext) {
	s.thenStatements = v
}

func (s *IfStatementContext) SetElseStatements(v []IProcedureSqlStatementContext) {
	s.elseStatements = v
}

func (s *IfStatementContext) AllIF() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserIF)
}

func (s *IfStatementContext) IF(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserIF, i)
}

func (s *IfStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfStatementContext) THEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserTHEN, 0)
}

func (s *IfStatementContext) END() antlr.TerminalNode {
	return s.GetToken(MySqlParserEND, 0)
}

func (s *IfStatementContext) AllElifAlternative() []IElifAlternativeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElifAlternativeContext); ok {
			len++
		}
	}

	tst := make([]IElifAlternativeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElifAlternativeContext); ok {
			tst[i] = t.(IElifAlternativeContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) ElifAlternative(i int) IElifAlternativeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElifAlternativeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElifAlternativeContext)
}

func (s *IfStatementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserELSE, 0)
}

func (s *IfStatementContext) AllProcedureSqlStatement() []IProcedureSqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			len++
		}
	}

	tst := make([]IProcedureSqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureSqlStatementContext); ok {
			tst[i] = t.(IProcedureSqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) ProcedureSqlStatement(i int) IProcedureSqlStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureSqlStatementContext)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIfStatement(s)
	}
}

func (s *IfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIfStatement(s)
	}
}

func (p *MySqlParser) IfStatement() (localctx IIfStatementContext) {
	this := p
	_ = this

	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, MySqlParserRULE_ifStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4746)
		p.Match(MySqlParserIF)
	}
	{
		p.SetState(4747)
		p.expression(0)
	}
	{
		p.SetState(4748)
		p.Match(MySqlParserTHEN)
	}
	p.SetState(4750)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4749)

				var _x = p.ProcedureSqlStatement()

				localctx.(*IfStatementContext)._procedureSqlStatement = _x
			}
			localctx.(*IfStatementContext).thenStatements = append(localctx.(*IfStatementContext).thenStatements, localctx.(*IfStatementContext)._procedureSqlStatement)

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4752)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 689, p.GetParserRuleContext())
	}
	p.SetState(4757)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserELSEIF {
		{
			p.SetState(4754)
			p.ElifAlternative()
		}

		p.SetState(4759)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4766)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserELSE {
		{
			p.SetState(4760)
			p.Match(MySqlParserELSE)
		}
		p.SetState(4762)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(4761)

					var _x = p.ProcedureSqlStatement()

					localctx.(*IfStatementContext)._procedureSqlStatement = _x
				}
				localctx.(*IfStatementContext).elseStatements = append(localctx.(*IfStatementContext).elseStatements, localctx.(*IfStatementContext)._procedureSqlStatement)

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(4764)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 691, p.GetParserRuleContext())
		}

	}
	{
		p.SetState(4768)
		p.Match(MySqlParserEND)
	}
	{
		p.SetState(4769)
		p.Match(MySqlParserIF)
	}

	return localctx
}

// IIterateStatementContext is an interface to support dynamic dispatch.
type IIterateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ITERATE() antlr.TerminalNode
	Uid() IUidContext

	// IsIterateStatementContext differentiates from other interfaces.
	IsIterateStatementContext()
}

type IterateStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIterateStatementContext() *IterateStatementContext {
	var p = new(IterateStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_iterateStatement
	return p
}

func (*IterateStatementContext) IsIterateStatementContext() {}

func NewIterateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IterateStatementContext {
	var p = new(IterateStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_iterateStatement

	return p
}

func (s *IterateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IterateStatementContext) ITERATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserITERATE, 0)
}

func (s *IterateStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *IterateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IterateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IterateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIterateStatement(s)
	}
}

func (s *IterateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIterateStatement(s)
	}
}

func (p *MySqlParser) IterateStatement() (localctx IIterateStatementContext) {
	this := p
	_ = this

	localctx = NewIterateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, MySqlParserRULE_iterateStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4771)
		p.Match(MySqlParserITERATE)
	}
	{
		p.SetState(4772)
		p.Uid()
	}

	return localctx
}

// ILeaveStatementContext is an interface to support dynamic dispatch.
type ILeaveStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEAVE() antlr.TerminalNode
	Uid() IUidContext

	// IsLeaveStatementContext differentiates from other interfaces.
	IsLeaveStatementContext()
}

type LeaveStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLeaveStatementContext() *LeaveStatementContext {
	var p = new(LeaveStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_leaveStatement
	return p
}

func (*LeaveStatementContext) IsLeaveStatementContext() {}

func NewLeaveStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LeaveStatementContext {
	var p = new(LeaveStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_leaveStatement

	return p
}

func (s *LeaveStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LeaveStatementContext) LEAVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEAVE, 0)
}

func (s *LeaveStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *LeaveStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LeaveStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LeaveStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLeaveStatement(s)
	}
}

func (s *LeaveStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLeaveStatement(s)
	}
}

func (p *MySqlParser) LeaveStatement() (localctx ILeaveStatementContext) {
	this := p
	_ = this

	localctx = NewLeaveStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, MySqlParserRULE_leaveStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4774)
		p.Match(MySqlParserLEAVE)
	}
	{
		p.SetState(4775)
		p.Uid()
	}

	return localctx
}

// ILoopStatementContext is an interface to support dynamic dispatch.
type ILoopStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLOOP() []antlr.TerminalNode
	LOOP(i int) antlr.TerminalNode
	END() antlr.TerminalNode
	AllUid() []IUidContext
	Uid(i int) IUidContext
	COLON_SYMB() antlr.TerminalNode
	AllProcedureSqlStatement() []IProcedureSqlStatementContext
	ProcedureSqlStatement(i int) IProcedureSqlStatementContext

	// IsLoopStatementContext differentiates from other interfaces.
	IsLoopStatementContext()
}

type LoopStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoopStatementContext() *LoopStatementContext {
	var p = new(LoopStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_loopStatement
	return p
}

func (*LoopStatementContext) IsLoopStatementContext() {}

func NewLoopStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoopStatementContext {
	var p = new(LoopStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_loopStatement

	return p
}

func (s *LoopStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LoopStatementContext) AllLOOP() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLOOP)
}

func (s *LoopStatementContext) LOOP(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLOOP, i)
}

func (s *LoopStatementContext) END() antlr.TerminalNode {
	return s.GetToken(MySqlParserEND, 0)
}

func (s *LoopStatementContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *LoopStatementContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *LoopStatementContext) COLON_SYMB() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLON_SYMB, 0)
}

func (s *LoopStatementContext) AllProcedureSqlStatement() []IProcedureSqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			len++
		}
	}

	tst := make([]IProcedureSqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureSqlStatementContext); ok {
			tst[i] = t.(IProcedureSqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *LoopStatementContext) ProcedureSqlStatement(i int) IProcedureSqlStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureSqlStatementContext)
}

func (s *LoopStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoopStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLoopStatement(s)
	}
}

func (s *LoopStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLoopStatement(s)
	}
}

func (p *MySqlParser) LoopStatement() (localctx ILoopStatementContext) {
	this := p
	_ = this

	localctx = NewLoopStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, MySqlParserRULE_loopStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4780)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&756891332513120256) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&146666055071174737) != 0) || ((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&134349441) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-2882305960540372993) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-4398063288321) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-16325548649218049) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-81064793296864001) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-68719476801) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-11118270170269697) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-33) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-3073) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&144115188075855871) != 0) || ((int64((_la-1121)) & ^0x3f) == 0 && ((int64(1)<<(_la-1121))&25807552513) != 0) {
		{
			p.SetState(4777)
			p.Uid()
		}
		{
			p.SetState(4778)
			p.Match(MySqlParserCOLON_SYMB)
		}

	}
	{
		p.SetState(4782)
		p.Match(MySqlParserLOOP)
	}
	p.SetState(4784)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4783)
				p.ProcedureSqlStatement()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4786)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 694, p.GetParserRuleContext())
	}
	{
		p.SetState(4788)
		p.Match(MySqlParserEND)
	}
	{
		p.SetState(4789)
		p.Match(MySqlParserLOOP)
	}
	p.SetState(4791)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&756891332513120256) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&146666055071174737) != 0) || ((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&134349441) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-2882305960540372993) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-4398063288321) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-16325548649218049) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-81064793296864001) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-68719476801) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-11118270170269697) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-33) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-3073) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&144115188075855871) != 0) || ((int64((_la-1121)) & ^0x3f) == 0 && ((int64(1)<<(_la-1121))&25807552513) != 0) {
		{
			p.SetState(4790)
			p.Uid()
		}

	}

	return localctx
}

// IRepeatStatementContext is an interface to support dynamic dispatch.
type IRepeatStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllREPEAT() []antlr.TerminalNode
	REPEAT(i int) antlr.TerminalNode
	UNTIL() antlr.TerminalNode
	Expression() IExpressionContext
	END() antlr.TerminalNode
	AllUid() []IUidContext
	Uid(i int) IUidContext
	COLON_SYMB() antlr.TerminalNode
	AllProcedureSqlStatement() []IProcedureSqlStatementContext
	ProcedureSqlStatement(i int) IProcedureSqlStatementContext

	// IsRepeatStatementContext differentiates from other interfaces.
	IsRepeatStatementContext()
}

type RepeatStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRepeatStatementContext() *RepeatStatementContext {
	var p = new(RepeatStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_repeatStatement
	return p
}

func (*RepeatStatementContext) IsRepeatStatementContext() {}

func NewRepeatStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RepeatStatementContext {
	var p = new(RepeatStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_repeatStatement

	return p
}

func (s *RepeatStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RepeatStatementContext) AllREPEAT() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserREPEAT)
}

func (s *RepeatStatementContext) REPEAT(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserREPEAT, i)
}

func (s *RepeatStatementContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNTIL, 0)
}

func (s *RepeatStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RepeatStatementContext) END() antlr.TerminalNode {
	return s.GetToken(MySqlParserEND, 0)
}

func (s *RepeatStatementContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *RepeatStatementContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *RepeatStatementContext) COLON_SYMB() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLON_SYMB, 0)
}

func (s *RepeatStatementContext) AllProcedureSqlStatement() []IProcedureSqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			len++
		}
	}

	tst := make([]IProcedureSqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureSqlStatementContext); ok {
			tst[i] = t.(IProcedureSqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *RepeatStatementContext) ProcedureSqlStatement(i int) IProcedureSqlStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureSqlStatementContext)
}

func (s *RepeatStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RepeatStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RepeatStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRepeatStatement(s)
	}
}

func (s *RepeatStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRepeatStatement(s)
	}
}

func (p *MySqlParser) RepeatStatement() (localctx IRepeatStatementContext) {
	this := p
	_ = this

	localctx = NewRepeatStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, MySqlParserRULE_repeatStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4796)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&756891332513120256) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&146666055071174737) != 0) || ((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&134349441) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-2882305960540372993) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-4398063288321) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-16325548649218049) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-81064793296864001) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-68719476801) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-11118270170269697) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-33) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-3073) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&144115188075855871) != 0) || ((int64((_la-1121)) & ^0x3f) == 0 && ((int64(1)<<(_la-1121))&25807552513) != 0) {
		{
			p.SetState(4793)
			p.Uid()
		}
		{
			p.SetState(4794)
			p.Match(MySqlParserCOLON_SYMB)
		}

	}
	{
		p.SetState(4798)
		p.Match(MySqlParserREPEAT)
	}
	p.SetState(4800)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4799)
				p.ProcedureSqlStatement()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4802)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 697, p.GetParserRuleContext())
	}
	{
		p.SetState(4804)
		p.Match(MySqlParserUNTIL)
	}
	{
		p.SetState(4805)
		p.expression(0)
	}
	{
		p.SetState(4806)
		p.Match(MySqlParserEND)
	}
	{
		p.SetState(4807)
		p.Match(MySqlParserREPEAT)
	}
	p.SetState(4809)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&756891332513120256) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&146666055071174737) != 0) || ((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&134349441) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-2882305960540372993) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-4398063288321) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-16325548649218049) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-81064793296864001) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-68719476801) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-11118270170269697) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-33) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-3073) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&144115188075855871) != 0) || ((int64((_la-1121)) & ^0x3f) == 0 && ((int64(1)<<(_la-1121))&25807552513) != 0) {
		{
			p.SetState(4808)
			p.Uid()
		}

	}

	return localctx
}

// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETURN() antlr.TerminalNode
	Expression() IExpressionContext

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_returnStatement
	return p
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) RETURN() antlr.TerminalNode {
	return s.GetToken(MySqlParserRETURN, 0)
}

func (s *ReturnStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterReturnStatement(s)
	}
}

func (s *ReturnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitReturnStatement(s)
	}
}

func (p *MySqlParser) ReturnStatement() (localctx IReturnStatementContext) {
	this := p
	_ = this

	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, MySqlParserRULE_returnStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4811)
		p.Match(MySqlParserRETURN)
	}
	{
		p.SetState(4812)
		p.expression(0)
	}

	return localctx
}

// IWhileStatementContext is an interface to support dynamic dispatch.
type IWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllWHILE() []antlr.TerminalNode
	WHILE(i int) antlr.TerminalNode
	Expression() IExpressionContext
	DO() antlr.TerminalNode
	END() antlr.TerminalNode
	AllUid() []IUidContext
	Uid(i int) IUidContext
	COLON_SYMB() antlr.TerminalNode
	AllProcedureSqlStatement() []IProcedureSqlStatementContext
	ProcedureSqlStatement(i int) IProcedureSqlStatementContext

	// IsWhileStatementContext differentiates from other interfaces.
	IsWhileStatementContext()
}

type WhileStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileStatementContext() *WhileStatementContext {
	var p = new(WhileStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_whileStatement
	return p
}

func (*WhileStatementContext) IsWhileStatementContext() {}

func NewWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStatementContext {
	var p = new(WhileStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_whileStatement

	return p
}

func (s *WhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStatementContext) AllWHILE() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserWHILE)
}

func (s *WhileStatementContext) WHILE(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserWHILE, i)
}

func (s *WhileStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhileStatementContext) DO() antlr.TerminalNode {
	return s.GetToken(MySqlParserDO, 0)
}

func (s *WhileStatementContext) END() antlr.TerminalNode {
	return s.GetToken(MySqlParserEND, 0)
}

func (s *WhileStatementContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *WhileStatementContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *WhileStatementContext) COLON_SYMB() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLON_SYMB, 0)
}

func (s *WhileStatementContext) AllProcedureSqlStatement() []IProcedureSqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			len++
		}
	}

	tst := make([]IProcedureSqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureSqlStatementContext); ok {
			tst[i] = t.(IProcedureSqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *WhileStatementContext) ProcedureSqlStatement(i int) IProcedureSqlStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureSqlStatementContext)
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterWhileStatement(s)
	}
}

func (s *WhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitWhileStatement(s)
	}
}

func (p *MySqlParser) WhileStatement() (localctx IWhileStatementContext) {
	this := p
	_ = this

	localctx = NewWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, MySqlParserRULE_whileStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4817)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&756891332513120256) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&146666055071174737) != 0) || ((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&134349441) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-2882305960540372993) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-4398063288321) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-16325548649218049) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-81064793296864001) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-68719476801) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-11118270170269697) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-33) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-3073) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&144115188075855871) != 0) || ((int64((_la-1121)) & ^0x3f) == 0 && ((int64(1)<<(_la-1121))&25807552513) != 0) {
		{
			p.SetState(4814)
			p.Uid()
		}
		{
			p.SetState(4815)
			p.Match(MySqlParserCOLON_SYMB)
		}

	}
	{
		p.SetState(4819)
		p.Match(MySqlParserWHILE)
	}
	{
		p.SetState(4820)
		p.expression(0)
	}
	{
		p.SetState(4821)
		p.Match(MySqlParserDO)
	}
	p.SetState(4823)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4822)
				p.ProcedureSqlStatement()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4825)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 700, p.GetParserRuleContext())
	}
	{
		p.SetState(4827)
		p.Match(MySqlParserEND)
	}
	{
		p.SetState(4828)
		p.Match(MySqlParserWHILE)
	}
	p.SetState(4830)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&756891332513120256) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&146666055071174737) != 0) || ((int64((_la-141)) & ^0x3f) == 0 && ((int64(1)<<(_la-141))&134349441) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17174494689) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&-1099511627777) != 0) || ((int64((_la-345)) & ^0x3f) == 0 && ((int64(1)<<(_la-345))&-2882305960540372993) != 0) || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&-4398063288321) != 0) || ((int64((_la-473)) & ^0x3f) == 0 && ((int64(1)<<(_la-473))&-16325548649218049) != 0) || ((int64((_la-537)) & ^0x3f) == 0 && ((int64(1)<<(_la-537))&-81064793296864001) != 0) || ((int64((_la-601)) & ^0x3f) == 0 && ((int64(1)<<(_la-601))&-68719476801) != 0) || ((int64((_la-665)) & ^0x3f) == 0 && ((int64(1)<<(_la-665))&-11118270170269697) != 0) || ((int64((_la-729)) & ^0x3f) == 0 && ((int64(1)<<(_la-729))&-33) != 0) || ((int64((_la-793)) & ^0x3f) == 0 && ((int64(1)<<(_la-793))&-3073) != 0) || ((int64((_la-857)) & ^0x3f) == 0 && ((int64(1)<<(_la-857))&-1) != 0) || ((int64((_la-921)) & ^0x3f) == 0 && ((int64(1)<<(_la-921))&-1) != 0) || ((int64((_la-985)) & ^0x3f) == 0 && ((int64(1)<<(_la-985))&-1) != 0) || ((int64((_la-1049)) & ^0x3f) == 0 && ((int64(1)<<(_la-1049))&144115188075855871) != 0) || ((int64((_la-1121)) & ^0x3f) == 0 && ((int64(1)<<(_la-1121))&25807552513) != 0) {
		{
			p.SetState(4829)
			p.Uid()
		}

	}

	return localctx
}

// ICursorStatementContext is an interface to support dynamic dispatch.
type ICursorStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsCursorStatementContext differentiates from other interfaces.
	IsCursorStatementContext()
}

type CursorStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCursorStatementContext() *CursorStatementContext {
	var p = new(CursorStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_cursorStatement
	return p
}

func (*CursorStatementContext) IsCursorStatementContext() {}

func NewCursorStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CursorStatementContext {
	var p = new(CursorStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_cursorStatement

	return p
}

func (s *CursorStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CursorStatementContext) CopyFrom(ctx *CursorStatementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *CursorStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CursorStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CloseCursorContext struct {
	*CursorStatementContext
}

func NewCloseCursorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CloseCursorContext {
	var p = new(CloseCursorContext)

	p.CursorStatementContext = NewEmptyCursorStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*CursorStatementContext))

	return p
}

func (s *CloseCursorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CloseCursorContext) CLOSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCLOSE, 0)
}

func (s *CloseCursorContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CloseCursorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCloseCursor(s)
	}
}

func (s *CloseCursorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCloseCursor(s)
	}
}

type OpenCursorContext struct {
	*CursorStatementContext
}

func NewOpenCursorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *OpenCursorContext {
	var p = new(OpenCursorContext)

	p.CursorStatementContext = NewEmptyCursorStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*CursorStatementContext))

	return p
}

func (s *OpenCursorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OpenCursorContext) OPEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPEN, 0)
}

func (s *OpenCursorContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *OpenCursorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterOpenCursor(s)
	}
}

func (s *OpenCursorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitOpenCursor(s)
	}
}

type FetchCursorContext struct {
	*CursorStatementContext
}

func NewFetchCursorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FetchCursorContext {
	var p = new(FetchCursorContext)

	p.CursorStatementContext = NewEmptyCursorStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*CursorStatementContext))

	return p
}

func (s *FetchCursorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FetchCursorContext) FETCH() antlr.TerminalNode {
	return s.GetToken(MySqlParserFETCH, 0)
}

func (s *FetchCursorContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *FetchCursorContext) INTO() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTO, 0)
}

func (s *FetchCursorContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *FetchCursorContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *FetchCursorContext) NEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNEXT, 0)
}

func (s *FetchCursorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFetchCursor(s)
	}
}

func (s *FetchCursorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFetchCursor(s)
	}
}

func (p *MySqlParser) CursorStatement() (localctx ICursorStatementContext) {
	this := p
	_ = this

	localctx = NewCursorStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, MySqlParserRULE_cursorStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4847)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserCLOSE:
		localctx = NewCloseCursorContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4832)
			p.Match(MySqlParserCLOSE)
		}
		{
			p.SetState(4833)
			p.Uid()
		}

	case MySqlParserFETCH:
		localctx = NewFetchCursorContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4834)
			p.Match(MySqlParserFETCH)
		}
		p.SetState(4839)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 703, p.GetParserRuleContext()) == 1 {
			p.SetState(4836)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserNEXT {
				{
					p.SetState(4835)
					p.Match(MySqlParserNEXT)
				}

			}
			{
				p.SetState(4838)
				p.Match(MySqlParserFROM)
			}

		}
		{
			p.SetState(4841)
			p.Uid()
		}
		{
			p.SetState(4842)
			p.Match(MySqlParserINTO)
		}
		{
			p.SetState(4843)
			p.UidList()
		}

	case MySqlParserOPEN:
		localctx = NewOpenCursorContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4845)
			p.Match(MySqlParserOPEN)
		}
		{
			p.SetState(4846)
			p.Uid()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDeclareVariableContext is an interface to support dynamic dispatch.
type IDeclareVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECLARE() antlr.TerminalNode
	UidList() IUidListContext
	DataType() IDataTypeContext
	DEFAULT() antlr.TerminalNode
	Expression() IExpressionContext

	// IsDeclareVariableContext differentiates from other interfaces.
	IsDeclareVariableContext()
}

type DeclareVariableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclareVariableContext() *DeclareVariableContext {
	var p = new(DeclareVariableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_declareVariable
	return p
}

func (*DeclareVariableContext) IsDeclareVariableContext() {}

func NewDeclareVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclareVariableContext {
	var p = new(DeclareVariableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_declareVariable

	return p
}

func (s *DeclareVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclareVariableContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDECLARE, 0)
}

func (s *DeclareVariableContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *DeclareVariableContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *DeclareVariableContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *DeclareVariableContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DeclareVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclareVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclareVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDeclareVariable(s)
	}
}

func (s *DeclareVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDeclareVariable(s)
	}
}

func (p *MySqlParser) DeclareVariable() (localctx IDeclareVariableContext) {
	this := p
	_ = this

	localctx = NewDeclareVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, MySqlParserRULE_declareVariable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4849)
		p.Match(MySqlParserDECLARE)
	}
	{
		p.SetState(4850)
		p.UidList()
	}
	{
		p.SetState(4851)
		p.DataType()
	}
	p.SetState(4854)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserDEFAULT {
		{
			p.SetState(4852)
			p.Match(MySqlParserDEFAULT)
		}
		{
			p.SetState(4853)
			p.expression(0)
		}

	}

	return localctx
}

// IDeclareConditionContext is an interface to support dynamic dispatch.
type IDeclareConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECLARE() antlr.TerminalNode
	Uid() IUidContext
	CONDITION() antlr.TerminalNode
	FOR() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	SQLSTATE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	VALUE() antlr.TerminalNode

	// IsDeclareConditionContext differentiates from other interfaces.
	IsDeclareConditionContext()
}

type DeclareConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclareConditionContext() *DeclareConditionContext {
	var p = new(DeclareConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_declareCondition
	return p
}

func (*DeclareConditionContext) IsDeclareConditionContext() {}

func NewDeclareConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclareConditionContext {
	var p = new(DeclareConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_declareCondition

	return p
}

func (s *DeclareConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclareConditionContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDECLARE, 0)
}

func (s *DeclareConditionContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DeclareConditionContext) CONDITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONDITION, 0)
}

func (s *DeclareConditionContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *DeclareConditionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *DeclareConditionContext) SQLSTATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQLSTATE, 0)
}

func (s *DeclareConditionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *DeclareConditionContext) VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUE, 0)
}

func (s *DeclareConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclareConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclareConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDeclareCondition(s)
	}
}

func (s *DeclareConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDeclareCondition(s)
	}
}

func (p *MySqlParser) DeclareCondition() (localctx IDeclareConditionContext) {
	this := p
	_ = this

	localctx = NewDeclareConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, MySqlParserRULE_declareCondition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4856)
		p.Match(MySqlParserDECLARE)
	}
	{
		p.SetState(4857)
		p.Uid()
	}
	{
		p.SetState(4858)
		p.Match(MySqlParserCONDITION)
	}
	{
		p.SetState(4859)
		p.Match(MySqlParserFOR)
	}
	p.SetState(4866)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserZERO_DECIMAL, MySqlParserONE_DECIMAL, MySqlParserTWO_DECIMAL, MySqlParserDECIMAL_LITERAL, MySqlParserREAL_LITERAL:
		{
			p.SetState(4860)
			p.DecimalLiteral()
		}

	case MySqlParserSQLSTATE:
		{
			p.SetState(4861)
			p.Match(MySqlParserSQLSTATE)
		}
		p.SetState(4863)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserVALUE {
			{
				p.SetState(4862)
				p.Match(MySqlParserVALUE)
			}

		}
		{
			p.SetState(4865)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDeclareCursorContext is an interface to support dynamic dispatch.
type IDeclareCursorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECLARE() antlr.TerminalNode
	Uid() IUidContext
	CURSOR() antlr.TerminalNode
	FOR() antlr.TerminalNode
	SelectStatement() ISelectStatementContext

	// IsDeclareCursorContext differentiates from other interfaces.
	IsDeclareCursorContext()
}

type DeclareCursorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclareCursorContext() *DeclareCursorContext {
	var p = new(DeclareCursorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_declareCursor
	return p
}

func (*DeclareCursorContext) IsDeclareCursorContext() {}

func NewDeclareCursorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclareCursorContext {
	var p = new(DeclareCursorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_declareCursor

	return p
}

func (s *DeclareCursorContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclareCursorContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDECLARE, 0)
}

func (s *DeclareCursorContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DeclareCursorContext) CURSOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURSOR, 0)
}

func (s *DeclareCursorContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *DeclareCursorContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *DeclareCursorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclareCursorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclareCursorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDeclareCursor(s)
	}
}

func (s *DeclareCursorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDeclareCursor(s)
	}
}

func (p *MySqlParser) DeclareCursor() (localctx IDeclareCursorContext) {
	this := p
	_ = this

	localctx = NewDeclareCursorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, MySqlParserRULE_declareCursor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4868)
		p.Match(MySqlParserDECLARE)
	}
	{
		p.SetState(4869)
		p.Uid()
	}
	{
		p.SetState(4870)
		p.Match(MySqlParserCURSOR)
	}
	{
		p.SetState(4871)
		p.Match(MySqlParserFOR)
	}
	{
		p.SetState(4872)
		p.SelectStatement()
	}

	return localctx
}

// IDeclareHandlerContext is an interface to support dynamic dispatch.
type IDeclareHandlerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetHandlerAction returns the handlerAction token.
	GetHandlerAction() antlr.Token

	// SetHandlerAction sets the handlerAction token.
	SetHandlerAction(antlr.Token)

	// Getter signatures
	DECLARE() antlr.TerminalNode
	HANDLER() antlr.TerminalNode
	FOR() antlr.TerminalNode
	AllHandlerConditionValue() []IHandlerConditionValueContext
	HandlerConditionValue(i int) IHandlerConditionValueContext
	RoutineBody() IRoutineBodyContext
	CONTINUE() antlr.TerminalNode
	EXIT() antlr.TerminalNode
	UNDO() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDeclareHandlerContext differentiates from other interfaces.
	IsDeclareHandlerContext()
}

type DeclareHandlerContext struct {
	*antlr.BaseParserRuleContext
	parser        antlr.Parser
	handlerAction antlr.Token
}

func NewEmptyDeclareHandlerContext() *DeclareHandlerContext {
	var p = new(DeclareHandlerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_declareHandler
	return p
}

func (*DeclareHandlerContext) IsDeclareHandlerContext() {}

func NewDeclareHandlerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclareHandlerContext {
	var p = new(DeclareHandlerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_declareHandler

	return p
}

func (s *DeclareHandlerContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclareHandlerContext) GetHandlerAction() antlr.Token { return s.handlerAction }

func (s *DeclareHandlerContext) SetHandlerAction(v antlr.Token) { s.handlerAction = v }

func (s *DeclareHandlerContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDECLARE, 0)
}

func (s *DeclareHandlerContext) HANDLER() antlr.TerminalNode {
	return s.GetToken(MySqlParserHANDLER, 0)
}

func (s *DeclareHandlerContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *DeclareHandlerContext) AllHandlerConditionValue() []IHandlerConditionValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHandlerConditionValueContext); ok {
			len++
		}
	}

	tst := make([]IHandlerConditionValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHandlerConditionValueContext); ok {
			tst[i] = t.(IHandlerConditionValueContext)
			i++
		}
	}

	return tst
}

func (s *DeclareHandlerContext) HandlerConditionValue(i int) IHandlerConditionValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHandlerConditionValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHandlerConditionValueContext)
}

func (s *DeclareHandlerContext) RoutineBody() IRoutineBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineBodyContext)
}

func (s *DeclareHandlerContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONTINUE, 0)
}

func (s *DeclareHandlerContext) EXIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXIT, 0)
}

func (s *DeclareHandlerContext) UNDO() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNDO, 0)
}

func (s *DeclareHandlerContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *DeclareHandlerContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *DeclareHandlerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclareHandlerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclareHandlerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDeclareHandler(s)
	}
}

func (s *DeclareHandlerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDeclareHandler(s)
	}
}

func (p *MySqlParser) DeclareHandler() (localctx IDeclareHandlerContext) {
	this := p
	_ = this

	localctx = NewDeclareHandlerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, MySqlParserRULE_declareHandler)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4874)
		p.Match(MySqlParserDECLARE)
	}
	{
		p.SetState(4875)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*DeclareHandlerContext).handlerAction = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserCONTINUE || _la == MySqlParserEXIT || _la == MySqlParserUNDO) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*DeclareHandlerContext).handlerAction = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4876)
		p.Match(MySqlParserHANDLER)
	}
	{
		p.SetState(4877)
		p.Match(MySqlParserFOR)
	}
	{
		p.SetState(4878)
		p.HandlerConditionValue()
	}
	p.SetState(4883)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(4879)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(4880)
			p.HandlerConditionValue()
		}

		p.SetState(4885)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4886)
		p.RoutineBody()
	}

	return localctx
}

// IHandlerConditionValueContext is an interface to support dynamic dispatch.
type IHandlerConditionValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsHandlerConditionValueContext differentiates from other interfaces.
	IsHandlerConditionValueContext()
}

type HandlerConditionValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHandlerConditionValueContext() *HandlerConditionValueContext {
	var p = new(HandlerConditionValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_handlerConditionValue
	return p
}

func (*HandlerConditionValueContext) IsHandlerConditionValueContext() {}

func NewHandlerConditionValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HandlerConditionValueContext {
	var p = new(HandlerConditionValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_handlerConditionValue

	return p
}

func (s *HandlerConditionValueContext) GetParser() antlr.Parser { return s.parser }

func (s *HandlerConditionValueContext) CopyFrom(ctx *HandlerConditionValueContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *HandlerConditionValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerConditionValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type HandlerConditionWarningContext struct {
	*HandlerConditionValueContext
}

func NewHandlerConditionWarningContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *HandlerConditionWarningContext {
	var p = new(HandlerConditionWarningContext)

	p.HandlerConditionValueContext = NewEmptyHandlerConditionValueContext()
	p.parser = parser
	p.CopyFrom(ctx.(*HandlerConditionValueContext))

	return p
}

func (s *HandlerConditionWarningContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerConditionWarningContext) SQLWARNING() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQLWARNING, 0)
}

func (s *HandlerConditionWarningContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHandlerConditionWarning(s)
	}
}

func (s *HandlerConditionWarningContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHandlerConditionWarning(s)
	}
}

type HandlerConditionCodeContext struct {
	*HandlerConditionValueContext
}

func NewHandlerConditionCodeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *HandlerConditionCodeContext {
	var p = new(HandlerConditionCodeContext)

	p.HandlerConditionValueContext = NewEmptyHandlerConditionValueContext()
	p.parser = parser
	p.CopyFrom(ctx.(*HandlerConditionValueContext))

	return p
}

func (s *HandlerConditionCodeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerConditionCodeContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *HandlerConditionCodeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHandlerConditionCode(s)
	}
}

func (s *HandlerConditionCodeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHandlerConditionCode(s)
	}
}

type HandlerConditionNotfoundContext struct {
	*HandlerConditionValueContext
}

func NewHandlerConditionNotfoundContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *HandlerConditionNotfoundContext {
	var p = new(HandlerConditionNotfoundContext)

	p.HandlerConditionValueContext = NewEmptyHandlerConditionValueContext()
	p.parser = parser
	p.CopyFrom(ctx.(*HandlerConditionValueContext))

	return p
}

func (s *HandlerConditionNotfoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerConditionNotfoundContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *HandlerConditionNotfoundContext) FOUND() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOUND, 0)
}

func (s *HandlerConditionNotfoundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHandlerConditionNotfound(s)
	}
}

func (s *HandlerConditionNotfoundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHandlerConditionNotfound(s)
	}
}

type HandlerConditionStateContext struct {
	*HandlerConditionValueContext
}

func NewHandlerConditionStateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *HandlerConditionStateContext {
	var p = new(HandlerConditionStateContext)

	p.HandlerConditionValueContext = NewEmptyHandlerConditionValueContext()
	p.parser = parser
	p.CopyFrom(ctx.(*HandlerConditionValueContext))

	return p
}

func (s *HandlerConditionStateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerConditionStateContext) SQLSTATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQLSTATE, 0)
}

func (s *HandlerConditionStateContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *HandlerConditionStateContext) VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUE, 0)
}

func (s *HandlerConditionStateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHandlerConditionState(s)
	}
}

func (s *HandlerConditionStateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHandlerConditionState(s)
	}
}

type HandlerConditionExceptionContext struct {
	*HandlerConditionValueContext
}

func NewHandlerConditionExceptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *HandlerConditionExceptionContext {
	var p = new(HandlerConditionExceptionContext)

	p.HandlerConditionValueContext = NewEmptyHandlerConditionValueContext()
	p.parser = parser
	p.CopyFrom(ctx.(*HandlerConditionValueContext))

	return p
}

func (s *HandlerConditionExceptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerConditionExceptionContext) SQLEXCEPTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQLEXCEPTION, 0)
}

func (s *HandlerConditionExceptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHandlerConditionException(s)
	}
}

func (s *HandlerConditionExceptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHandlerConditionException(s)
	}
}

type HandlerConditionNameContext struct {
	*HandlerConditionValueContext
}

func NewHandlerConditionNameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *HandlerConditionNameContext {
	var p = new(HandlerConditionNameContext)

	p.HandlerConditionValueContext = NewEmptyHandlerConditionValueContext()
	p.parser = parser
	p.CopyFrom(ctx.(*HandlerConditionValueContext))

	return p
}

func (s *HandlerConditionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerConditionNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *HandlerConditionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHandlerConditionName(s)
	}
}

func (s *HandlerConditionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHandlerConditionName(s)
	}
}

func (p *MySqlParser) HandlerConditionValue() (localctx IHandlerConditionValueContext) {
	this := p
	_ = this

	localctx = NewHandlerConditionValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, MySqlParserRULE_handlerConditionValue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4899)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserZERO_DECIMAL, MySqlParserONE_DECIMAL, MySqlParserTWO_DECIMAL, MySqlParserDECIMAL_LITERAL, MySqlParserREAL_LITERAL:
		localctx = NewHandlerConditionCodeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4888)
			p.DecimalLiteral()
		}

	case MySqlParserSQLSTATE:
		localctx = NewHandlerConditionStateContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4889)
			p.Match(MySqlParserSQLSTATE)
		}
		p.SetState(4891)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserVALUE {
			{
				p.SetState(4890)
				p.Match(MySqlParserVALUE)
			}

		}
		{
			p.SetState(4893)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	case MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID, MySqlParserREVERSE_QUOTE_ID:
		localctx = NewHandlerConditionNameContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4894)
			p.Uid()
		}

	case MySqlParserSQLWARNING:
		localctx = NewHandlerConditionWarningContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4895)
			p.Match(MySqlParserSQLWARNING)
		}

	case MySqlParserNOT:
		localctx = NewHandlerConditionNotfoundContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4896)
			p.Match(MySqlParserNOT)
		}
		{
			p.SetState(4897)
			p.Match(MySqlParserFOUND)
		}

	case MySqlParserSQLEXCEPTION:
		localctx = NewHandlerConditionExceptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4898)
			p.Match(MySqlParserSQLEXCEPTION)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IProcedureSqlStatementContext is an interface to support dynamic dispatch.
type IProcedureSqlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEMI() antlr.TerminalNode
	CompoundStatement() ICompoundStatementContext
	SqlStatement() ISqlStatementContext

	// IsProcedureSqlStatementContext differentiates from other interfaces.
	IsProcedureSqlStatementContext()
}

type ProcedureSqlStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureSqlStatementContext() *ProcedureSqlStatementContext {
	var p = new(ProcedureSqlStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_procedureSqlStatement
	return p
}

func (*ProcedureSqlStatementContext) IsProcedureSqlStatementContext() {}

func NewProcedureSqlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureSqlStatementContext {
	var p = new(ProcedureSqlStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_procedureSqlStatement

	return p
}

func (s *ProcedureSqlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureSqlStatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(MySqlParserSEMI, 0)
}

func (s *ProcedureSqlStatementContext) CompoundStatement() ICompoundStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *ProcedureSqlStatementContext) SqlStatement() ISqlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlStatementContext)
}

func (s *ProcedureSqlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureSqlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureSqlStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterProcedureSqlStatement(s)
	}
}

func (s *ProcedureSqlStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitProcedureSqlStatement(s)
	}
}

func (p *MySqlParser) ProcedureSqlStatement() (localctx IProcedureSqlStatementContext) {
	this := p
	_ = this

	localctx = NewProcedureSqlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, MySqlParserRULE_procedureSqlStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4903)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 711, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4901)
			p.CompoundStatement()
		}

	case 2:
		{
			p.SetState(4902)
			p.SqlStatement()
		}

	}
	{
		p.SetState(4905)
		p.Match(MySqlParserSEMI)
	}

	return localctx
}

// ICaseAlternativeContext is an interface to support dynamic dispatch.
type ICaseAlternativeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHEN() antlr.TerminalNode
	THEN() antlr.TerminalNode
	Constant() IConstantContext
	Expression() IExpressionContext
	AllProcedureSqlStatement() []IProcedureSqlStatementContext
	ProcedureSqlStatement(i int) IProcedureSqlStatementContext

	// IsCaseAlternativeContext differentiates from other interfaces.
	IsCaseAlternativeContext()
}

type CaseAlternativeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseAlternativeContext() *CaseAlternativeContext {
	var p = new(CaseAlternativeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_caseAlternative
	return p
}

func (*CaseAlternativeContext) IsCaseAlternativeContext() {}

func NewCaseAlternativeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseAlternativeContext {
	var p = new(CaseAlternativeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_caseAlternative

	return p
}

func (s *CaseAlternativeContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseAlternativeContext) WHEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserWHEN, 0)
}

func (s *CaseAlternativeContext) THEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserTHEN, 0)
}

func (s *CaseAlternativeContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *CaseAlternativeContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseAlternativeContext) AllProcedureSqlStatement() []IProcedureSqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			len++
		}
	}

	tst := make([]IProcedureSqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureSqlStatementContext); ok {
			tst[i] = t.(IProcedureSqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *CaseAlternativeContext) ProcedureSqlStatement(i int) IProcedureSqlStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureSqlStatementContext)
}

func (s *CaseAlternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseAlternativeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseAlternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCaseAlternative(s)
	}
}

func (s *CaseAlternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCaseAlternative(s)
	}
}

func (p *MySqlParser) CaseAlternative() (localctx ICaseAlternativeContext) {
	this := p
	_ = this

	localctx = NewCaseAlternativeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, MySqlParserRULE_caseAlternative)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4907)
		p.Match(MySqlParserWHEN)
	}
	p.SetState(4910)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 712, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4908)
			p.Constant()
		}

	case 2:
		{
			p.SetState(4909)
			p.expression(0)
		}

	}
	{
		p.SetState(4912)
		p.Match(MySqlParserTHEN)
	}
	p.SetState(4914)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4913)
				p.ProcedureSqlStatement()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4916)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 713, p.GetParserRuleContext())
	}

	return localctx
}

// IElifAlternativeContext is an interface to support dynamic dispatch.
type IElifAlternativeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ELSEIF() antlr.TerminalNode
	Expression() IExpressionContext
	THEN() antlr.TerminalNode
	AllProcedureSqlStatement() []IProcedureSqlStatementContext
	ProcedureSqlStatement(i int) IProcedureSqlStatementContext

	// IsElifAlternativeContext differentiates from other interfaces.
	IsElifAlternativeContext()
}

type ElifAlternativeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElifAlternativeContext() *ElifAlternativeContext {
	var p = new(ElifAlternativeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_elifAlternative
	return p
}

func (*ElifAlternativeContext) IsElifAlternativeContext() {}

func NewElifAlternativeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElifAlternativeContext {
	var p = new(ElifAlternativeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_elifAlternative

	return p
}

func (s *ElifAlternativeContext) GetParser() antlr.Parser { return s.parser }

func (s *ElifAlternativeContext) ELSEIF() antlr.TerminalNode {
	return s.GetToken(MySqlParserELSEIF, 0)
}

func (s *ElifAlternativeContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ElifAlternativeContext) THEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserTHEN, 0)
}

func (s *ElifAlternativeContext) AllProcedureSqlStatement() []IProcedureSqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			len++
		}
	}

	tst := make([]IProcedureSqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureSqlStatementContext); ok {
			tst[i] = t.(IProcedureSqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *ElifAlternativeContext) ProcedureSqlStatement(i int) IProcedureSqlStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureSqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureSqlStatementContext)
}

func (s *ElifAlternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElifAlternativeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElifAlternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterElifAlternative(s)
	}
}

func (s *ElifAlternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitElifAlternative(s)
	}
}

func (p *MySqlParser) ElifAlternative() (localctx IElifAlternativeContext) {
	this := p
	_ = this

	localctx = NewElifAlternativeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, MySqlParserRULE_elifAlternative)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4918)
		p.Match(MySqlParserELSEIF)
	}
	{
		p.SetState(4919)
		p.expression(0)
	}
	{
		p.SetState(4920)
		p.Match(MySqlParserTHEN)
	}
	p.SetState(4922)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4921)
				p.ProcedureSqlStatement()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4924)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 714, p.GetParserRuleContext())
	}

	return localctx
}

// IAlterUserContext is an interface to support dynamic dispatch.
type IAlterUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAlterUserContext differentiates from other interfaces.
	IsAlterUserContext()
}

type AlterUserContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterUserContext() *AlterUserContext {
	var p = new(AlterUserContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_alterUser
	return p
}

func (*AlterUserContext) IsAlterUserContext() {}

func NewAlterUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterUserContext {
	var p = new(AlterUserContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_alterUser

	return p
}

func (s *AlterUserContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterUserContext) CopyFrom(ctx *AlterUserContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *AlterUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AlterUserMysqlV80Context struct {
	*AlterUserContext
	tlsNone antlr.Token
}

func NewAlterUserMysqlV80Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterUserMysqlV80Context {
	var p = new(AlterUserMysqlV80Context)

	p.AlterUserContext = NewEmptyAlterUserContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterUserContext))

	return p
}

func (s *AlterUserMysqlV80Context) GetTlsNone() antlr.Token { return s.tlsNone }

func (s *AlterUserMysqlV80Context) SetTlsNone(v antlr.Token) { s.tlsNone = v }

func (s *AlterUserMysqlV80Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterUserMysqlV80Context) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterUserMysqlV80Context) USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER, 0)
}

func (s *AlterUserMysqlV80Context) AllUserAuthOption() []IUserAuthOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserAuthOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserAuthOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserAuthOptionContext); ok {
			tst[i] = t.(IUserAuthOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterUserMysqlV80Context) UserAuthOption(i int) IUserAuthOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserAuthOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserAuthOptionContext)
}

func (s *AlterUserMysqlV80Context) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *AlterUserMysqlV80Context) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AlterUserMysqlV80Context) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *AlterUserMysqlV80Context) REQUIRE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREQUIRE, 0)
}

func (s *AlterUserMysqlV80Context) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *AlterUserMysqlV80Context) AllUserPasswordOption() []IUserPasswordOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserPasswordOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserPasswordOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserPasswordOptionContext); ok {
			tst[i] = t.(IUserPasswordOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterUserMysqlV80Context) UserPasswordOption(i int) IUserPasswordOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserPasswordOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserPasswordOptionContext)
}

func (s *AlterUserMysqlV80Context) AllUserLockOption() []IUserLockOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserLockOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserLockOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserLockOptionContext); ok {
			tst[i] = t.(IUserLockOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterUserMysqlV80Context) UserLockOption(i int) IUserLockOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserLockOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserLockOptionContext)
}

func (s *AlterUserMysqlV80Context) COMMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT, 0)
}

func (s *AlterUserMysqlV80Context) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *AlterUserMysqlV80Context) ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserATTRIBUTE, 0)
}

func (s *AlterUserMysqlV80Context) AllTlsOption() []ITlsOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITlsOptionContext); ok {
			len++
		}
	}

	tst := make([]ITlsOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITlsOptionContext); ok {
			tst[i] = t.(ITlsOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterUserMysqlV80Context) TlsOption(i int) ITlsOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITlsOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITlsOptionContext)
}

func (s *AlterUserMysqlV80Context) NONE() antlr.TerminalNode {
	return s.GetToken(MySqlParserNONE, 0)
}

func (s *AlterUserMysqlV80Context) AllUserResourceOption() []IUserResourceOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserResourceOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserResourceOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserResourceOptionContext); ok {
			tst[i] = t.(IUserResourceOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterUserMysqlV80Context) UserResourceOption(i int) IUserResourceOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserResourceOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserResourceOptionContext)
}

func (s *AlterUserMysqlV80Context) AllAND() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserAND)
}

func (s *AlterUserMysqlV80Context) AND(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserAND, i)
}

func (s *AlterUserMysqlV80Context) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *AlterUserMysqlV80Context) ROLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLE, 0)
}

func (s *AlterUserMysqlV80Context) RoleOption() IRoleOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleOptionContext)
}

func (s *AlterUserMysqlV80Context) UserName() IUserNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *AlterUserMysqlV80Context) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AlterUserMysqlV80Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterUserMysqlV80(s)
	}
}

func (s *AlterUserMysqlV80Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterUserMysqlV80(s)
	}
}

type AlterUserMysqlV56Context struct {
	*AlterUserContext
}

func NewAlterUserMysqlV56Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterUserMysqlV56Context {
	var p = new(AlterUserMysqlV56Context)

	p.AlterUserContext = NewEmptyAlterUserContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AlterUserContext))

	return p
}

func (s *AlterUserMysqlV56Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterUserMysqlV56Context) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *AlterUserMysqlV56Context) USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER, 0)
}

func (s *AlterUserMysqlV56Context) AllUserSpecification() []IUserSpecificationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserSpecificationContext); ok {
			len++
		}
	}

	tst := make([]IUserSpecificationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserSpecificationContext); ok {
			tst[i] = t.(IUserSpecificationContext)
			i++
		}
	}

	return tst
}

func (s *AlterUserMysqlV56Context) UserSpecification(i int) IUserSpecificationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserSpecificationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserSpecificationContext)
}

func (s *AlterUserMysqlV56Context) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AlterUserMysqlV56Context) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *AlterUserMysqlV56Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAlterUserMysqlV56(s)
	}
}

func (s *AlterUserMysqlV56Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAlterUserMysqlV56(s)
	}
}

func (p *MySqlParser) AlterUser() (localctx IAlterUserContext) {
	this := p
	_ = this

	localctx = NewAlterUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, MySqlParserRULE_alterUser)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4999)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 729, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAlterUserMysqlV56Context(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4926)
			p.Match(MySqlParserALTER)
		}
		{
			p.SetState(4927)
			p.Match(MySqlParserUSER)
		}
		{
			p.SetState(4928)
			p.UserSpecification()
		}
		p.SetState(4933)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(4929)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(4930)
				p.UserSpecification()
			}

			p.SetState(4935)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewAlterUserMysqlV80Context(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4936)
			p.Match(MySqlParserALTER)
		}
		{
			p.SetState(4937)
			p.Match(MySqlParserUSER)
		}
		p.SetState(4939)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserIF {
			{
				p.SetState(4938)
				p.IfExists()
			}

		}
		{
			p.SetState(4941)
			p.UserAuthOption()
		}
		p.SetState(4946)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(4942)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(4943)
				p.UserAuthOption()
			}

			p.SetState(4948)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(4963)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserREQUIRE {
			{
				p.SetState(4949)
				p.Match(MySqlParserREQUIRE)
			}
			p.SetState(4961)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case MySqlParserNONE:
				{
					p.SetState(4950)

					var _m = p.Match(MySqlParserNONE)

					localctx.(*AlterUserMysqlV80Context).tlsNone = _m
				}

			case MySqlParserSSL, MySqlParserCIPHER, MySqlParserISSUER, MySqlParserSUBJECT, MySqlParserX509:
				{
					p.SetState(4951)
					p.TlsOption()
				}
				p.SetState(4958)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == MySqlParserAND || _la == MySqlParserSSL || _la == MySqlParserCIPHER || _la == MySqlParserISSUER || _la == MySqlParserSUBJECT || _la == MySqlParserX509 {
					p.SetState(4953)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)

					if _la == MySqlParserAND {
						{
							p.SetState(4952)
							p.Match(MySqlParserAND)
						}

					}
					{
						p.SetState(4955)
						p.TlsOption()
					}

					p.SetState(4960)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(4971)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 723, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4965)
				p.Match(MySqlParserWITH)
			}
			p.SetState(4967)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = ((int64((_la-498)) & ^0x3f) == 0 && ((int64(1)<<(_la-498))&51) != 0) {
				{
					p.SetState(4966)
					p.UserResourceOption()
				}

				p.SetState(4969)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(4977)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserACCOUNT || _la == MySqlParserFAILED_LOGIN_ATTEMPTS || _la == MySqlParserPASSWORD || _la == MySqlParserPASSWORD_LOCK_TIME {
			p.SetState(4975)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME:
				{
					p.SetState(4973)
					p.UserPasswordOption()
				}

			case MySqlParserACCOUNT:
				{
					p.SetState(4974)
					p.UserLockOption()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(4979)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(4984)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserCOMMENT:
			{
				p.SetState(4980)
				p.Match(MySqlParserCOMMENT)
			}
			{
				p.SetState(4981)
				p.Match(MySqlParserSTRING_LITERAL)
			}

		case MySqlParserATTRIBUTE:
			{
				p.SetState(4982)
				p.Match(MySqlParserATTRIBUTE)
			}
			{
				p.SetState(4983)
				p.Match(MySqlParserSTRING_LITERAL)
			}

		case MySqlParserEOF, MySqlParserALTER, MySqlParserANALYZE, MySqlParserCALL, MySqlParserCHANGE, MySqlParserCHECK, MySqlParserCREATE, MySqlParserDELETE, MySqlParserDESC, MySqlParserDESCRIBE, MySqlParserDROP, MySqlParserEXPLAIN, MySqlParserGET, MySqlParserGRANT, MySqlParserINSERT, MySqlParserKILL, MySqlParserLOAD, MySqlParserLOCK, MySqlParserOPTIMIZE, MySqlParserPURGE, MySqlParserRELEASE, MySqlParserRENAME, MySqlParserREPLACE, MySqlParserRESIGNAL, MySqlParserREVOKE, MySqlParserSELECT, MySqlParserSET, MySqlParserSHOW, MySqlParserSIGNAL, MySqlParserUNLOCK, MySqlParserUPDATE, MySqlParserUSE, MySqlParserVALUES, MySqlParserWITH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserCACHE, MySqlParserCHECKSUM, MySqlParserCOMMIT, MySqlParserDEALLOCATE, MySqlParserDO, MySqlParserFLUSH, MySqlParserHANDLER, MySqlParserHELP, MySqlParserINSTALL, MySqlParserPREPARE, MySqlParserREPAIR, MySqlParserRESET, MySqlParserROLLBACK, MySqlParserSAVEPOINT, MySqlParserSTART, MySqlParserSTOP, MySqlParserTRUNCATE, MySqlParserUNINSTALL, MySqlParserXA, MySqlParserEXECUTE, MySqlParserSHUTDOWN, MySqlParserMINUS, MySqlParserLR_BRACKET, MySqlParserSEMI:

		default:
		}

	case 3:
		localctx = NewAlterUserMysqlV80Context(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4986)
			p.Match(MySqlParserALTER)
		}
		{
			p.SetState(4987)
			p.Match(MySqlParserUSER)
		}
		p.SetState(4989)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 727, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4988)
				p.IfExists()
			}

		}
		p.SetState(4993)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 728, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(4991)
				p.UserName()
			}

		case 2:
			{
				p.SetState(4992)
				p.Uid()
			}

		}
		{
			p.SetState(4995)
			p.Match(MySqlParserDEFAULT)
		}
		{
			p.SetState(4996)
			p.Match(MySqlParserROLE)
		}
		{
			p.SetState(4997)
			p.RoleOption()
		}

	}

	return localctx
}

// ICreateUserContext is an interface to support dynamic dispatch.
type ICreateUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsCreateUserContext differentiates from other interfaces.
	IsCreateUserContext()
}

type CreateUserContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateUserContext() *CreateUserContext {
	var p = new(CreateUserContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_createUser
	return p
}

func (*CreateUserContext) IsCreateUserContext() {}

func NewCreateUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateUserContext {
	var p = new(CreateUserContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createUser

	return p
}

func (s *CreateUserContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateUserContext) CopyFrom(ctx *CreateUserContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *CreateUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CreateUserMysqlV56Context struct {
	*CreateUserContext
}

func NewCreateUserMysqlV56Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateUserMysqlV56Context {
	var p = new(CreateUserMysqlV56Context)

	p.CreateUserContext = NewEmptyCreateUserContext()
	p.parser = parser
	p.CopyFrom(ctx.(*CreateUserContext))

	return p
}

func (s *CreateUserMysqlV56Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUserMysqlV56Context) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateUserMysqlV56Context) USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER, 0)
}

func (s *CreateUserMysqlV56Context) AllUserAuthOption() []IUserAuthOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserAuthOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserAuthOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserAuthOptionContext); ok {
			tst[i] = t.(IUserAuthOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateUserMysqlV56Context) UserAuthOption(i int) IUserAuthOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserAuthOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserAuthOptionContext)
}

func (s *CreateUserMysqlV56Context) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *CreateUserMysqlV56Context) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *CreateUserMysqlV56Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateUserMysqlV56(s)
	}
}

func (s *CreateUserMysqlV56Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateUserMysqlV56(s)
	}
}

type CreateUserMysqlV80Context struct {
	*CreateUserContext
	tlsNone antlr.Token
}

func NewCreateUserMysqlV80Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateUserMysqlV80Context {
	var p = new(CreateUserMysqlV80Context)

	p.CreateUserContext = NewEmptyCreateUserContext()
	p.parser = parser
	p.CopyFrom(ctx.(*CreateUserContext))

	return p
}

func (s *CreateUserMysqlV80Context) GetTlsNone() antlr.Token { return s.tlsNone }

func (s *CreateUserMysqlV80Context) SetTlsNone(v antlr.Token) { s.tlsNone = v }

func (s *CreateUserMysqlV80Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUserMysqlV80Context) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateUserMysqlV80Context) USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER, 0)
}

func (s *CreateUserMysqlV80Context) AllUserAuthOption() []IUserAuthOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserAuthOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserAuthOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserAuthOptionContext); ok {
			tst[i] = t.(IUserAuthOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateUserMysqlV80Context) UserAuthOption(i int) IUserAuthOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserAuthOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserAuthOptionContext)
}

func (s *CreateUserMysqlV80Context) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateUserMysqlV80Context) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *CreateUserMysqlV80Context) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *CreateUserMysqlV80Context) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *CreateUserMysqlV80Context) ROLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLE, 0)
}

func (s *CreateUserMysqlV80Context) RoleOption() IRoleOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleOptionContext)
}

func (s *CreateUserMysqlV80Context) REQUIRE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREQUIRE, 0)
}

func (s *CreateUserMysqlV80Context) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *CreateUserMysqlV80Context) AllUserPasswordOption() []IUserPasswordOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserPasswordOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserPasswordOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserPasswordOptionContext); ok {
			tst[i] = t.(IUserPasswordOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateUserMysqlV80Context) UserPasswordOption(i int) IUserPasswordOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserPasswordOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserPasswordOptionContext)
}

func (s *CreateUserMysqlV80Context) AllUserLockOption() []IUserLockOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserLockOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserLockOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserLockOptionContext); ok {
			tst[i] = t.(IUserLockOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateUserMysqlV80Context) UserLockOption(i int) IUserLockOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserLockOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserLockOptionContext)
}

func (s *CreateUserMysqlV80Context) COMMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT, 0)
}

func (s *CreateUserMysqlV80Context) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *CreateUserMysqlV80Context) ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserATTRIBUTE, 0)
}

func (s *CreateUserMysqlV80Context) AllTlsOption() []ITlsOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITlsOptionContext); ok {
			len++
		}
	}

	tst := make([]ITlsOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITlsOptionContext); ok {
			tst[i] = t.(ITlsOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateUserMysqlV80Context) TlsOption(i int) ITlsOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITlsOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITlsOptionContext)
}

func (s *CreateUserMysqlV80Context) NONE() antlr.TerminalNode {
	return s.GetToken(MySqlParserNONE, 0)
}

func (s *CreateUserMysqlV80Context) AllUserResourceOption() []IUserResourceOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserResourceOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserResourceOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserResourceOptionContext); ok {
			tst[i] = t.(IUserResourceOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateUserMysqlV80Context) UserResourceOption(i int) IUserResourceOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserResourceOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserResourceOptionContext)
}

func (s *CreateUserMysqlV80Context) AllAND() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserAND)
}

func (s *CreateUserMysqlV80Context) AND(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserAND, i)
}

func (s *CreateUserMysqlV80Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateUserMysqlV80(s)
	}
}

func (s *CreateUserMysqlV80Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateUserMysqlV80(s)
	}
}

func (p *MySqlParser) CreateUser() (localctx ICreateUserContext) {
	this := p
	_ = this

	localctx = NewCreateUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, MySqlParserRULE_createUser)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5066)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 743, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCreateUserMysqlV56Context(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5001)
			p.Match(MySqlParserCREATE)
		}
		{
			p.SetState(5002)
			p.Match(MySqlParserUSER)
		}
		{
			p.SetState(5003)
			p.UserAuthOption()
		}
		p.SetState(5008)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(5004)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(5005)
				p.UserAuthOption()
			}

			p.SetState(5010)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewCreateUserMysqlV80Context(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5011)
			p.Match(MySqlParserCREATE)
		}
		{
			p.SetState(5012)
			p.Match(MySqlParserUSER)
		}
		p.SetState(5014)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserIF {
			{
				p.SetState(5013)
				p.IfNotExists()
			}

		}
		{
			p.SetState(5016)
			p.UserAuthOption()
		}
		p.SetState(5021)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(5017)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(5018)
				p.UserAuthOption()
			}

			p.SetState(5023)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5027)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserDEFAULT {
			{
				p.SetState(5024)
				p.Match(MySqlParserDEFAULT)
			}
			{
				p.SetState(5025)
				p.Match(MySqlParserROLE)
			}
			{
				p.SetState(5026)
				p.RoleOption()
			}

		}
		p.SetState(5043)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserREQUIRE {
			{
				p.SetState(5029)
				p.Match(MySqlParserREQUIRE)
			}
			p.SetState(5041)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case MySqlParserNONE:
				{
					p.SetState(5030)

					var _m = p.Match(MySqlParserNONE)

					localctx.(*CreateUserMysqlV80Context).tlsNone = _m
				}

			case MySqlParserSSL, MySqlParserCIPHER, MySqlParserISSUER, MySqlParserSUBJECT, MySqlParserX509:
				{
					p.SetState(5031)
					p.TlsOption()
				}
				p.SetState(5038)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == MySqlParserAND || _la == MySqlParserSSL || _la == MySqlParserCIPHER || _la == MySqlParserISSUER || _la == MySqlParserSUBJECT || _la == MySqlParserX509 {
					p.SetState(5033)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)

					if _la == MySqlParserAND {
						{
							p.SetState(5032)
							p.Match(MySqlParserAND)
						}

					}
					{
						p.SetState(5035)
						p.TlsOption()
					}

					p.SetState(5040)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(5051)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 739, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5045)
				p.Match(MySqlParserWITH)
			}
			p.SetState(5047)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = ((int64((_la-498)) & ^0x3f) == 0 && ((int64(1)<<(_la-498))&51) != 0) {
				{
					p.SetState(5046)
					p.UserResourceOption()
				}

				p.SetState(5049)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(5057)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserACCOUNT || _la == MySqlParserFAILED_LOGIN_ATTEMPTS || _la == MySqlParserPASSWORD || _la == MySqlParserPASSWORD_LOCK_TIME {
			p.SetState(5055)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME:
				{
					p.SetState(5053)
					p.UserPasswordOption()
				}

			case MySqlParserACCOUNT:
				{
					p.SetState(5054)
					p.UserLockOption()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(5059)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5064)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserCOMMENT:
			{
				p.SetState(5060)
				p.Match(MySqlParserCOMMENT)
			}
			{
				p.SetState(5061)
				p.Match(MySqlParserSTRING_LITERAL)
			}

		case MySqlParserATTRIBUTE:
			{
				p.SetState(5062)
				p.Match(MySqlParserATTRIBUTE)
			}
			{
				p.SetState(5063)
				p.Match(MySqlParserSTRING_LITERAL)
			}

		case MySqlParserEOF, MySqlParserALTER, MySqlParserANALYZE, MySqlParserCALL, MySqlParserCHANGE, MySqlParserCHECK, MySqlParserCREATE, MySqlParserDELETE, MySqlParserDESC, MySqlParserDESCRIBE, MySqlParserDROP, MySqlParserEXPLAIN, MySqlParserGET, MySqlParserGRANT, MySqlParserINSERT, MySqlParserKILL, MySqlParserLOAD, MySqlParserLOCK, MySqlParserOPTIMIZE, MySqlParserPURGE, MySqlParserRELEASE, MySqlParserRENAME, MySqlParserREPLACE, MySqlParserRESIGNAL, MySqlParserREVOKE, MySqlParserSELECT, MySqlParserSET, MySqlParserSHOW, MySqlParserSIGNAL, MySqlParserUNLOCK, MySqlParserUPDATE, MySqlParserUSE, MySqlParserVALUES, MySqlParserWITH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserCACHE, MySqlParserCHECKSUM, MySqlParserCOMMIT, MySqlParserDEALLOCATE, MySqlParserDO, MySqlParserFLUSH, MySqlParserHANDLER, MySqlParserHELP, MySqlParserINSTALL, MySqlParserPREPARE, MySqlParserREPAIR, MySqlParserRESET, MySqlParserROLLBACK, MySqlParserSAVEPOINT, MySqlParserSTART, MySqlParserSTOP, MySqlParserTRUNCATE, MySqlParserUNINSTALL, MySqlParserXA, MySqlParserEXECUTE, MySqlParserSHUTDOWN, MySqlParserMINUS, MySqlParserLR_BRACKET, MySqlParserSEMI:

		default:
		}

	}

	return localctx
}

// IDropUserContext is an interface to support dynamic dispatch.
type IDropUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	USER() antlr.TerminalNode
	AllUserName() []IUserNameContext
	UserName(i int) IUserNameContext
	IfExists() IIfExistsContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDropUserContext differentiates from other interfaces.
	IsDropUserContext()
}

type DropUserContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropUserContext() *DropUserContext {
	var p = new(DropUserContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_dropUser
	return p
}

func (*DropUserContext) IsDropUserContext() {}

func NewDropUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropUserContext {
	var p = new(DropUserContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dropUser

	return p
}

func (s *DropUserContext) GetParser() antlr.Parser { return s.parser }

func (s *DropUserContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *DropUserContext) USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER, 0)
}

func (s *DropUserContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *DropUserContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *DropUserContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropUserContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *DropUserContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *DropUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDropUser(s)
	}
}

func (s *DropUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDropUser(s)
	}
}

func (p *MySqlParser) DropUser() (localctx IDropUserContext) {
	this := p
	_ = this

	localctx = NewDropUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, MySqlParserRULE_dropUser)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5068)
		p.Match(MySqlParserDROP)
	}
	{
		p.SetState(5069)
		p.Match(MySqlParserUSER)
	}
	p.SetState(5071)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserIF {
		{
			p.SetState(5070)
			p.IfExists()
		}

	}
	{
		p.SetState(5073)
		p.UserName()
	}
	p.SetState(5078)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(5074)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(5075)
			p.UserName()
		}

		p.SetState(5080)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IGrantStatementContext is an interface to support dynamic dispatch.
type IGrantStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPrivilegeObject returns the privilegeObject token.
	GetPrivilegeObject() antlr.Token

	// GetTlsNone returns the tlsNone token.
	GetTlsNone() antlr.Token

	// SetPrivilegeObject sets the privilegeObject token.
	SetPrivilegeObject(antlr.Token)

	// SetTlsNone sets the tlsNone token.
	SetTlsNone(antlr.Token)

	// Getter signatures
	AllGRANT() []antlr.TerminalNode
	GRANT(i int) antlr.TerminalNode
	AllPrivelegeClause() []IPrivelegeClauseContext
	PrivelegeClause(i int) IPrivelegeClauseContext
	ON() antlr.TerminalNode
	PrivilegeLevel() IPrivilegeLevelContext
	TO() antlr.TerminalNode
	AllUserAuthOption() []IUserAuthOptionContext
	UserAuthOption(i int) IUserAuthOptionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	REQUIRE() antlr.TerminalNode
	AllWITH() []antlr.TerminalNode
	WITH(i int) antlr.TerminalNode
	AS() antlr.TerminalNode
	AllUserName() []IUserNameContext
	UserName(i int) IUserNameContext
	ROLE() antlr.TerminalNode
	RoleOption() IRoleOptionContext
	TABLE() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	PROCEDURE() antlr.TerminalNode
	AllTlsOption() []ITlsOptionContext
	TlsOption(i int) ITlsOptionContext
	NONE() antlr.TerminalNode
	AllOPTION() []antlr.TerminalNode
	OPTION(i int) antlr.TerminalNode
	AllUserResourceOption() []IUserResourceOptionContext
	UserResourceOption(i int) IUserResourceOptionContext
	AllAND() []antlr.TerminalNode
	AND(i int) antlr.TerminalNode
	AllUid() []IUidContext
	Uid(i int) IUidContext
	ADMIN() antlr.TerminalNode

	// IsGrantStatementContext differentiates from other interfaces.
	IsGrantStatementContext()
}

type GrantStatementContext struct {
	*antlr.BaseParserRuleContext
	parser          antlr.Parser
	privilegeObject antlr.Token
	tlsNone         antlr.Token
}

func NewEmptyGrantStatementContext() *GrantStatementContext {
	var p = new(GrantStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_grantStatement
	return p
}

func (*GrantStatementContext) IsGrantStatementContext() {}

func NewGrantStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantStatementContext {
	var p = new(GrantStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_grantStatement

	return p
}

func (s *GrantStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantStatementContext) GetPrivilegeObject() antlr.Token { return s.privilegeObject }

func (s *GrantStatementContext) GetTlsNone() antlr.Token { return s.tlsNone }

func (s *GrantStatementContext) SetPrivilegeObject(v antlr.Token) { s.privilegeObject = v }

func (s *GrantStatementContext) SetTlsNone(v antlr.Token) { s.tlsNone = v }

func (s *GrantStatementContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserGRANT)
}

func (s *GrantStatementContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserGRANT, i)
}

func (s *GrantStatementContext) AllPrivelegeClause() []IPrivelegeClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrivelegeClauseContext); ok {
			len++
		}
	}

	tst := make([]IPrivelegeClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrivelegeClauseContext); ok {
			tst[i] = t.(IPrivelegeClauseContext)
			i++
		}
	}

	return tst
}

func (s *GrantStatementContext) PrivelegeClause(i int) IPrivelegeClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivelegeClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivelegeClauseContext)
}

func (s *GrantStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *GrantStatementContext) PrivilegeLevel() IPrivilegeLevelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeLevelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeLevelContext)
}

func (s *GrantStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *GrantStatementContext) AllUserAuthOption() []IUserAuthOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserAuthOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserAuthOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserAuthOptionContext); ok {
			tst[i] = t.(IUserAuthOptionContext)
			i++
		}
	}

	return tst
}

func (s *GrantStatementContext) UserAuthOption(i int) IUserAuthOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserAuthOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserAuthOptionContext)
}

func (s *GrantStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *GrantStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *GrantStatementContext) REQUIRE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREQUIRE, 0)
}

func (s *GrantStatementContext) AllWITH() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserWITH)
}

func (s *GrantStatementContext) WITH(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, i)
}

func (s *GrantStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *GrantStatementContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *GrantStatementContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *GrantStatementContext) ROLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLE, 0)
}

func (s *GrantStatementContext) RoleOption() IRoleOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleOptionContext)
}

func (s *GrantStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *GrantStatementContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserFUNCTION, 0)
}

func (s *GrantStatementContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROCEDURE, 0)
}

func (s *GrantStatementContext) AllTlsOption() []ITlsOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITlsOptionContext); ok {
			len++
		}
	}

	tst := make([]ITlsOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITlsOptionContext); ok {
			tst[i] = t.(ITlsOptionContext)
			i++
		}
	}

	return tst
}

func (s *GrantStatementContext) TlsOption(i int) ITlsOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITlsOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITlsOptionContext)
}

func (s *GrantStatementContext) NONE() antlr.TerminalNode {
	return s.GetToken(MySqlParserNONE, 0)
}

func (s *GrantStatementContext) AllOPTION() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserOPTION)
}

func (s *GrantStatementContext) OPTION(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTION, i)
}

func (s *GrantStatementContext) AllUserResourceOption() []IUserResourceOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserResourceOptionContext); ok {
			len++
		}
	}

	tst := make([]IUserResourceOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserResourceOptionContext); ok {
			tst[i] = t.(IUserResourceOptionContext)
			i++
		}
	}

	return tst
}

func (s *GrantStatementContext) UserResourceOption(i int) IUserResourceOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserResourceOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserResourceOptionContext)
}

func (s *GrantStatementContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserAND)
}

func (s *GrantStatementContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserAND, i)
}

func (s *GrantStatementContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *GrantStatementContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *GrantStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserADMIN, 0)
}

func (s *GrantStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GrantStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterGrantStatement(s)
	}
}

func (s *GrantStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitGrantStatement(s)
	}
}

func (p *MySqlParser) GrantStatement() (localctx IGrantStatementContext) {
	this := p
	_ = this

	localctx = NewGrantStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, MySqlParserRULE_grantStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(5174)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 764, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5081)
			p.Match(MySqlParserGRANT)
		}
		{
			p.SetState(5082)
			p.PrivelegeClause()
		}
		p.SetState(5087)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(5083)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(5084)
				p.PrivelegeClause()
			}

			p.SetState(5089)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5090)
			p.Match(MySqlParserON)
		}
		p.SetState(5092)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 747, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5091)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*GrantStatementContext).privilegeObject = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserPROCEDURE || _la == MySqlParserTABLE || _la == MySqlParserFUNCTION) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*GrantStatementContext).privilegeObject = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(5094)
			p.PrivilegeLevel()
		}
		{
			p.SetState(5095)
			p.Match(MySqlParserTO)
		}
		{
			p.SetState(5096)
			p.UserAuthOption()
		}
		p.SetState(5101)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(5097)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(5098)
				p.UserAuthOption()
			}

			p.SetState(5103)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5118)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserREQUIRE {
			{
				p.SetState(5104)
				p.Match(MySqlParserREQUIRE)
			}
			p.SetState(5116)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case MySqlParserNONE:
				{
					p.SetState(5105)

					var _m = p.Match(MySqlParserNONE)

					localctx.(*GrantStatementContext).tlsNone = _m
				}

			case MySqlParserSSL, MySqlParserCIPHER, MySqlParserISSUER, MySqlParserSUBJECT, MySqlParserX509:
				{
					p.SetState(5106)
					p.TlsOption()
				}
				p.SetState(5113)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == MySqlParserAND || _la == MySqlParserSSL || _la == MySqlParserCIPHER || _la == MySqlParserISSUER || _la == MySqlParserSUBJECT || _la == MySqlParserX509 {
					p.SetState(5108)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)

					if _la == MySqlParserAND {
						{
							p.SetState(5107)
							p.Match(MySqlParserAND)
						}

					}
					{
						p.SetState(5110)
						p.TlsOption()
					}

					p.SetState(5115)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(5129)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 755, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5120)
				p.Match(MySqlParserWITH)
			}
			p.SetState(5126)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 754, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					p.SetState(5124)
					p.GetErrorHandler().Sync(p)

					switch p.GetTokenStream().LA(1) {
					case MySqlParserGRANT:
						{
							p.SetState(5121)
							p.Match(MySqlParserGRANT)
						}
						{
							p.SetState(5122)
							p.Match(MySqlParserOPTION)
						}

					case MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS:
						{
							p.SetState(5123)
							p.UserResourceOption()
						}

					default:
						panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					}

				}
				p.SetState(5128)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 754, p.GetParserRuleContext())
			}

		}
		p.SetState(5137)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserAS {
			{
				p.SetState(5131)
				p.Match(MySqlParserAS)
			}
			{
				p.SetState(5132)
				p.UserName()
			}
			{
				p.SetState(5133)
				p.Match(MySqlParserWITH)
			}
			{
				p.SetState(5134)
				p.Match(MySqlParserROLE)
			}
			{
				p.SetState(5135)
				p.RoleOption()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5139)
			p.Match(MySqlParserGRANT)
		}
		p.SetState(5142)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 757, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5140)
				p.UserName()
			}

		case 2:
			{
				p.SetState(5141)
				p.Uid()
			}

		}
		p.SetState(5151)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(5144)
				p.Match(MySqlParserCOMMA)
			}
			p.SetState(5147)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 758, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(5145)
					p.UserName()
				}

			case 2:
				{
					p.SetState(5146)
					p.Uid()
				}

			}

			p.SetState(5153)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5154)
			p.Match(MySqlParserTO)
		}
		p.SetState(5157)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 760, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5155)
				p.UserName()
			}

		case 2:
			{
				p.SetState(5156)
				p.Uid()
			}

		}
		p.SetState(5166)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(5159)
				p.Match(MySqlParserCOMMA)
			}
			p.SetState(5162)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 761, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(5160)
					p.UserName()
				}

			case 2:
				{
					p.SetState(5161)
					p.Uid()
				}

			}

			p.SetState(5168)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5172)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 763, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5169)
				p.Match(MySqlParserWITH)
			}
			{
				p.SetState(5170)
				p.Match(MySqlParserADMIN)
			}
			{
				p.SetState(5171)
				p.Match(MySqlParserOPTION)
			}

		}

	}

	return localctx
}

// IRoleOptionContext is an interface to support dynamic dispatch.
type IRoleOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFAULT() antlr.TerminalNode
	NONE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	EXCEPT() antlr.TerminalNode
	AllUserName() []IUserNameContext
	UserName(i int) IUserNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRoleOptionContext differentiates from other interfaces.
	IsRoleOptionContext()
}

type RoleOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoleOptionContext() *RoleOptionContext {
	var p = new(RoleOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_roleOption
	return p
}

func (*RoleOptionContext) IsRoleOptionContext() {}

func NewRoleOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleOptionContext {
	var p = new(RoleOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_roleOption

	return p
}

func (s *RoleOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleOptionContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *RoleOptionContext) NONE() antlr.TerminalNode {
	return s.GetToken(MySqlParserNONE, 0)
}

func (s *RoleOptionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *RoleOptionContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCEPT, 0)
}

func (s *RoleOptionContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *RoleOptionContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *RoleOptionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *RoleOptionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *RoleOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRoleOption(s)
	}
}

func (s *RoleOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRoleOption(s)
	}
}

func (p *MySqlParser) RoleOption() (localctx IRoleOptionContext) {
	this := p
	_ = this

	localctx = NewRoleOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, MySqlParserRULE_roleOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5198)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 768, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5176)
			p.Match(MySqlParserDEFAULT)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5177)
			p.Match(MySqlParserNONE)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5178)
			p.Match(MySqlParserALL)
		}
		p.SetState(5188)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserEXCEPT {
			{
				p.SetState(5179)
				p.Match(MySqlParserEXCEPT)
			}
			{
				p.SetState(5180)
				p.UserName()
			}
			p.SetState(5185)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == MySqlParserCOMMA {
				{
					p.SetState(5181)
					p.Match(MySqlParserCOMMA)
				}
				{
					p.SetState(5182)
					p.UserName()
				}

				p.SetState(5187)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5190)
			p.UserName()
		}
		p.SetState(5195)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(5191)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(5192)
				p.UserName()
			}

			p.SetState(5197)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IGrantProxyContext is an interface to support dynamic dispatch.
type IGrantProxyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFromFirst returns the fromFirst rule contexts.
	GetFromFirst() IUserNameContext

	// GetToFirst returns the toFirst rule contexts.
	GetToFirst() IUserNameContext

	// Get_userName returns the _userName rule contexts.
	Get_userName() IUserNameContext

	// SetFromFirst sets the fromFirst rule contexts.
	SetFromFirst(IUserNameContext)

	// SetToFirst sets the toFirst rule contexts.
	SetToFirst(IUserNameContext)

	// Set_userName sets the _userName rule contexts.
	Set_userName(IUserNameContext)

	// GetToOther returns the toOther rule context list.
	GetToOther() []IUserNameContext

	// SetToOther sets the toOther rule context list.
	SetToOther([]IUserNameContext)

	// Getter signatures
	AllGRANT() []antlr.TerminalNode
	GRANT(i int) antlr.TerminalNode
	PROXY() antlr.TerminalNode
	ON() antlr.TerminalNode
	TO() antlr.TerminalNode
	AllUserName() []IUserNameContext
	UserName(i int) IUserNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	WITH() antlr.TerminalNode
	OPTION() antlr.TerminalNode

	// IsGrantProxyContext differentiates from other interfaces.
	IsGrantProxyContext()
}

type GrantProxyContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	fromFirst IUserNameContext
	toFirst   IUserNameContext
	_userName IUserNameContext
	toOther   []IUserNameContext
}

func NewEmptyGrantProxyContext() *GrantProxyContext {
	var p = new(GrantProxyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_grantProxy
	return p
}

func (*GrantProxyContext) IsGrantProxyContext() {}

func NewGrantProxyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantProxyContext {
	var p = new(GrantProxyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_grantProxy

	return p
}

func (s *GrantProxyContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantProxyContext) GetFromFirst() IUserNameContext { return s.fromFirst }

func (s *GrantProxyContext) GetToFirst() IUserNameContext { return s.toFirst }

func (s *GrantProxyContext) Get_userName() IUserNameContext { return s._userName }

func (s *GrantProxyContext) SetFromFirst(v IUserNameContext) { s.fromFirst = v }

func (s *GrantProxyContext) SetToFirst(v IUserNameContext) { s.toFirst = v }

func (s *GrantProxyContext) Set_userName(v IUserNameContext) { s._userName = v }

func (s *GrantProxyContext) GetToOther() []IUserNameContext { return s.toOther }

func (s *GrantProxyContext) SetToOther(v []IUserNameContext) { s.toOther = v }

func (s *GrantProxyContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserGRANT)
}

func (s *GrantProxyContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserGRANT, i)
}

func (s *GrantProxyContext) PROXY() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROXY, 0)
}

func (s *GrantProxyContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *GrantProxyContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *GrantProxyContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *GrantProxyContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *GrantProxyContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *GrantProxyContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *GrantProxyContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *GrantProxyContext) OPTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTION, 0)
}

func (s *GrantProxyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantProxyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GrantProxyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterGrantProxy(s)
	}
}

func (s *GrantProxyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitGrantProxy(s)
	}
}

func (p *MySqlParser) GrantProxy() (localctx IGrantProxyContext) {
	this := p
	_ = this

	localctx = NewGrantProxyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, MySqlParserRULE_grantProxy)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5200)
		p.Match(MySqlParserGRANT)
	}
	{
		p.SetState(5201)
		p.Match(MySqlParserPROXY)
	}
	{
		p.SetState(5202)
		p.Match(MySqlParserON)
	}
	{
		p.SetState(5203)

		var _x = p.UserName()

		localctx.(*GrantProxyContext).fromFirst = _x
	}
	{
		p.SetState(5204)
		p.Match(MySqlParserTO)
	}
	{
		p.SetState(5205)

		var _x = p.UserName()

		localctx.(*GrantProxyContext).toFirst = _x
	}
	p.SetState(5210)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(5206)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(5207)

			var _x = p.UserName()

			localctx.(*GrantProxyContext)._userName = _x
		}
		localctx.(*GrantProxyContext).toOther = append(localctx.(*GrantProxyContext).toOther, localctx.(*GrantProxyContext)._userName)

		p.SetState(5212)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(5216)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 770, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5213)
			p.Match(MySqlParserWITH)
		}
		{
			p.SetState(5214)
			p.Match(MySqlParserGRANT)
		}
		{
			p.SetState(5215)
			p.Match(MySqlParserOPTION)
		}

	}

	return localctx
}

// IRenameUserContext is an interface to support dynamic dispatch.
type IRenameUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RENAME() antlr.TerminalNode
	USER() antlr.TerminalNode
	AllRenameUserClause() []IRenameUserClauseContext
	RenameUserClause(i int) IRenameUserClauseContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRenameUserContext differentiates from other interfaces.
	IsRenameUserContext()
}

type RenameUserContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRenameUserContext() *RenameUserContext {
	var p = new(RenameUserContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_renameUser
	return p
}

func (*RenameUserContext) IsRenameUserContext() {}

func NewRenameUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RenameUserContext {
	var p = new(RenameUserContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_renameUser

	return p
}

func (s *RenameUserContext) GetParser() antlr.Parser { return s.parser }

func (s *RenameUserContext) RENAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserRENAME, 0)
}

func (s *RenameUserContext) USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER, 0)
}

func (s *RenameUserContext) AllRenameUserClause() []IRenameUserClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRenameUserClauseContext); ok {
			len++
		}
	}

	tst := make([]IRenameUserClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRenameUserClauseContext); ok {
			tst[i] = t.(IRenameUserClauseContext)
			i++
		}
	}

	return tst
}

func (s *RenameUserContext) RenameUserClause(i int) IRenameUserClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRenameUserClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRenameUserClauseContext)
}

func (s *RenameUserContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *RenameUserContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *RenameUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RenameUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRenameUser(s)
	}
}

func (s *RenameUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRenameUser(s)
	}
}

func (p *MySqlParser) RenameUser() (localctx IRenameUserContext) {
	this := p
	_ = this

	localctx = NewRenameUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, MySqlParserRULE_renameUser)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5218)
		p.Match(MySqlParserRENAME)
	}
	{
		p.SetState(5219)
		p.Match(MySqlParserUSER)
	}
	{
		p.SetState(5220)
		p.RenameUserClause()
	}
	p.SetState(5225)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(5221)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(5222)
			p.RenameUserClause()
		}

		p.SetState(5227)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IRevokeStatementContext is an interface to support dynamic dispatch.
type IRevokeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRevokeStatementContext differentiates from other interfaces.
	IsRevokeStatementContext()
}

type RevokeStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRevokeStatementContext() *RevokeStatementContext {
	var p = new(RevokeStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_revokeStatement
	return p
}

func (*RevokeStatementContext) IsRevokeStatementContext() {}

func NewRevokeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RevokeStatementContext {
	var p = new(RevokeStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_revokeStatement

	return p
}

func (s *RevokeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RevokeStatementContext) CopyFrom(ctx *RevokeStatementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *RevokeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DetailRevokeContext struct {
	*RevokeStatementContext
	privilegeObject antlr.Token
}

func NewDetailRevokeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DetailRevokeContext {
	var p = new(DetailRevokeContext)

	p.RevokeStatementContext = NewEmptyRevokeStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RevokeStatementContext))

	return p
}

func (s *DetailRevokeContext) GetPrivilegeObject() antlr.Token { return s.privilegeObject }

func (s *DetailRevokeContext) SetPrivilegeObject(v antlr.Token) { s.privilegeObject = v }

func (s *DetailRevokeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DetailRevokeContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREVOKE, 0)
}

func (s *DetailRevokeContext) AllPrivelegeClause() []IPrivelegeClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrivelegeClauseContext); ok {
			len++
		}
	}

	tst := make([]IPrivelegeClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrivelegeClauseContext); ok {
			tst[i] = t.(IPrivelegeClauseContext)
			i++
		}
	}

	return tst
}

func (s *DetailRevokeContext) PrivelegeClause(i int) IPrivelegeClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivelegeClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivelegeClauseContext)
}

func (s *DetailRevokeContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *DetailRevokeContext) PrivilegeLevel() IPrivilegeLevelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeLevelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeLevelContext)
}

func (s *DetailRevokeContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *DetailRevokeContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *DetailRevokeContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *DetailRevokeContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *DetailRevokeContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *DetailRevokeContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *DetailRevokeContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserFUNCTION, 0)
}

func (s *DetailRevokeContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROCEDURE, 0)
}

func (s *DetailRevokeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDetailRevoke(s)
	}
}

func (s *DetailRevokeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDetailRevoke(s)
	}
}

type RoleRevokeContext struct {
	*RevokeStatementContext
}

func NewRoleRevokeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RoleRevokeContext {
	var p = new(RoleRevokeContext)

	p.RevokeStatementContext = NewEmptyRevokeStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RevokeStatementContext))

	return p
}

func (s *RoleRevokeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleRevokeContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREVOKE, 0)
}

func (s *RoleRevokeContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *RoleRevokeContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *RoleRevokeContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *RoleRevokeContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *RoleRevokeContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *RoleRevokeContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *RoleRevokeContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *RoleRevokeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRoleRevoke(s)
	}
}

func (s *RoleRevokeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRoleRevoke(s)
	}
}

type ShortRevokeContext struct {
	*RevokeStatementContext
}

func NewShortRevokeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShortRevokeContext {
	var p = new(ShortRevokeContext)

	p.RevokeStatementContext = NewEmptyRevokeStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RevokeStatementContext))

	return p
}

func (s *ShortRevokeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShortRevokeContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREVOKE, 0)
}

func (s *ShortRevokeContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *ShortRevokeContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *ShortRevokeContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *ShortRevokeContext) GRANT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGRANT, 0)
}

func (s *ShortRevokeContext) OPTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTION, 0)
}

func (s *ShortRevokeContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *ShortRevokeContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *ShortRevokeContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *ShortRevokeContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRIVILEGES, 0)
}

func (s *ShortRevokeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShortRevoke(s)
	}
}

func (s *ShortRevokeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShortRevoke(s)
	}
}

func (p *MySqlParser) RevokeStatement() (localctx IRevokeStatementContext) {
	this := p
	_ = this

	localctx = NewRevokeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, MySqlParserRULE_revokeStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5298)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 783, p.GetParserRuleContext()) {
	case 1:
		localctx = NewDetailRevokeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5228)
			p.Match(MySqlParserREVOKE)
		}
		{
			p.SetState(5229)
			p.PrivelegeClause()
		}
		p.SetState(5234)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(5230)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(5231)
				p.PrivelegeClause()
			}

			p.SetState(5236)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5237)
			p.Match(MySqlParserON)
		}
		p.SetState(5239)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 773, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5238)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*DetailRevokeContext).privilegeObject = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserPROCEDURE || _la == MySqlParserTABLE || _la == MySqlParserFUNCTION) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*DetailRevokeContext).privilegeObject = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(5241)
			p.PrivilegeLevel()
		}
		{
			p.SetState(5242)
			p.Match(MySqlParserFROM)
		}
		{
			p.SetState(5243)
			p.UserName()
		}
		p.SetState(5248)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(5244)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(5245)
				p.UserName()
			}

			p.SetState(5250)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewShortRevokeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5251)
			p.Match(MySqlParserREVOKE)
		}
		{
			p.SetState(5252)
			p.Match(MySqlParserALL)
		}
		p.SetState(5254)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserPRIVILEGES {
			{
				p.SetState(5253)
				p.Match(MySqlParserPRIVILEGES)
			}

		}
		{
			p.SetState(5256)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(5257)
			p.Match(MySqlParserGRANT)
		}
		{
			p.SetState(5258)
			p.Match(MySqlParserOPTION)
		}
		{
			p.SetState(5259)
			p.Match(MySqlParserFROM)
		}
		{
			p.SetState(5260)
			p.UserName()
		}
		p.SetState(5265)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(5261)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(5262)
				p.UserName()
			}

			p.SetState(5267)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		localctx = NewRoleRevokeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5268)
			p.Match(MySqlParserREVOKE)
		}
		p.SetState(5271)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 777, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5269)
				p.UserName()
			}

		case 2:
			{
				p.SetState(5270)
				p.Uid()
			}

		}
		p.SetState(5280)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(5273)
				p.Match(MySqlParserCOMMA)
			}
			p.SetState(5276)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 778, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(5274)
					p.UserName()
				}

			case 2:
				{
					p.SetState(5275)
					p.Uid()
				}

			}

			p.SetState(5282)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5283)
			p.Match(MySqlParserFROM)
		}
		p.SetState(5286)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 780, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5284)
				p.UserName()
			}

		case 2:
			{
				p.SetState(5285)
				p.Uid()
			}

		}
		p.SetState(5295)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(5288)
				p.Match(MySqlParserCOMMA)
			}
			p.SetState(5291)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 781, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(5289)
					p.UserName()
				}

			case 2:
				{
					p.SetState(5290)
					p.Uid()
				}

			}

			p.SetState(5297)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IRevokeProxyContext is an interface to support dynamic dispatch.
type IRevokeProxyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOnUser returns the onUser rule contexts.
	GetOnUser() IUserNameContext

	// GetFromFirst returns the fromFirst rule contexts.
	GetFromFirst() IUserNameContext

	// Get_userName returns the _userName rule contexts.
	Get_userName() IUserNameContext

	// SetOnUser sets the onUser rule contexts.
	SetOnUser(IUserNameContext)

	// SetFromFirst sets the fromFirst rule contexts.
	SetFromFirst(IUserNameContext)

	// Set_userName sets the _userName rule contexts.
	Set_userName(IUserNameContext)

	// GetFromOther returns the fromOther rule context list.
	GetFromOther() []IUserNameContext

	// SetFromOther sets the fromOther rule context list.
	SetFromOther([]IUserNameContext)

	// Getter signatures
	REVOKE() antlr.TerminalNode
	PROXY() antlr.TerminalNode
	ON() antlr.TerminalNode
	FROM() antlr.TerminalNode
	AllUserName() []IUserNameContext
	UserName(i int) IUserNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRevokeProxyContext differentiates from other interfaces.
	IsRevokeProxyContext()
}

type RevokeProxyContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	onUser    IUserNameContext
	fromFirst IUserNameContext
	_userName IUserNameContext
	fromOther []IUserNameContext
}

func NewEmptyRevokeProxyContext() *RevokeProxyContext {
	var p = new(RevokeProxyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_revokeProxy
	return p
}

func (*RevokeProxyContext) IsRevokeProxyContext() {}

func NewRevokeProxyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RevokeProxyContext {
	var p = new(RevokeProxyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_revokeProxy

	return p
}

func (s *RevokeProxyContext) GetParser() antlr.Parser { return s.parser }

func (s *RevokeProxyContext) GetOnUser() IUserNameContext { return s.onUser }

func (s *RevokeProxyContext) GetFromFirst() IUserNameContext { return s.fromFirst }

func (s *RevokeProxyContext) Get_userName() IUserNameContext { return s._userName }

func (s *RevokeProxyContext) SetOnUser(v IUserNameContext) { s.onUser = v }

func (s *RevokeProxyContext) SetFromFirst(v IUserNameContext) { s.fromFirst = v }

func (s *RevokeProxyContext) Set_userName(v IUserNameContext) { s._userName = v }

func (s *RevokeProxyContext) GetFromOther() []IUserNameContext { return s.fromOther }

func (s *RevokeProxyContext) SetFromOther(v []IUserNameContext) { s.fromOther = v }

func (s *RevokeProxyContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREVOKE, 0)
}

func (s *RevokeProxyContext) PROXY() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROXY, 0)
}

func (s *RevokeProxyContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *RevokeProxyContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *RevokeProxyContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *RevokeProxyContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *RevokeProxyContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *RevokeProxyContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *RevokeProxyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeProxyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RevokeProxyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRevokeProxy(s)
	}
}

func (s *RevokeProxyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRevokeProxy(s)
	}
}

func (p *MySqlParser) RevokeProxy() (localctx IRevokeProxyContext) {
	this := p
	_ = this

	localctx = NewRevokeProxyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, MySqlParserRULE_revokeProxy)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5300)
		p.Match(MySqlParserREVOKE)
	}
	{
		p.SetState(5301)
		p.Match(MySqlParserPROXY)
	}
	{
		p.SetState(5302)
		p.Match(MySqlParserON)
	}
	{
		p.SetState(5303)

		var _x = p.UserName()

		localctx.(*RevokeProxyContext).onUser = _x
	}
	{
		p.SetState(5304)
		p.Match(MySqlParserFROM)
	}
	{
		p.SetState(5305)

		var _x = p.UserName()

		localctx.(*RevokeProxyContext).fromFirst = _x
	}
	p.SetState(5310)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(5306)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(5307)

			var _x = p.UserName()

			localctx.(*RevokeProxyContext)._userName = _x
		}
		localctx.(*RevokeProxyContext).fromOther = append(localctx.(*RevokeProxyContext).fromOther, localctx.(*RevokeProxyContext)._userName)

		p.SetState(5312)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISetPasswordStatementContext is an interface to support dynamic dispatch.
type ISetPasswordStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	EQUAL_SYMBOL() antlr.TerminalNode
	PasswordFunctionClause() IPasswordFunctionClauseContext
	STRING_LITERAL() antlr.TerminalNode
	FOR() antlr.TerminalNode
	UserName() IUserNameContext

	// IsSetPasswordStatementContext differentiates from other interfaces.
	IsSetPasswordStatementContext()
}

type SetPasswordStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetPasswordStatementContext() *SetPasswordStatementContext {
	var p = new(SetPasswordStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_setPasswordStatement
	return p
}

func (*SetPasswordStatementContext) IsSetPasswordStatementContext() {}

func NewSetPasswordStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetPasswordStatementContext {
	var p = new(SetPasswordStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_setPasswordStatement

	return p
}

func (s *SetPasswordStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetPasswordStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *SetPasswordStatementContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD, 0)
}

func (s *SetPasswordStatementContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *SetPasswordStatementContext) PasswordFunctionClause() IPasswordFunctionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPasswordFunctionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPasswordFunctionClauseContext)
}

func (s *SetPasswordStatementContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *SetPasswordStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *SetPasswordStatementContext) UserName() IUserNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *SetPasswordStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetPasswordStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetPasswordStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSetPasswordStatement(s)
	}
}

func (s *SetPasswordStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSetPasswordStatement(s)
	}
}

func (p *MySqlParser) SetPasswordStatement() (localctx ISetPasswordStatementContext) {
	this := p
	_ = this

	localctx = NewSetPasswordStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, MySqlParserRULE_setPasswordStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5313)
		p.Match(MySqlParserSET)
	}
	{
		p.SetState(5314)
		p.Match(MySqlParserPASSWORD)
	}
	p.SetState(5317)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserFOR {
		{
			p.SetState(5315)
			p.Match(MySqlParserFOR)
		}
		{
			p.SetState(5316)
			p.UserName()
		}

	}
	{
		p.SetState(5319)
		p.Match(MySqlParserEQUAL_SYMBOL)
	}
	p.SetState(5322)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserOLD_PASSWORD, MySqlParserPASSWORD:
		{
			p.SetState(5320)
			p.PasswordFunctionClause()
		}

	case MySqlParserSTRING_LITERAL:
		{
			p.SetState(5321)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUserSpecificationContext is an interface to support dynamic dispatch.
type IUserSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UserName() IUserNameContext
	UserPasswordOption() IUserPasswordOptionContext

	// IsUserSpecificationContext differentiates from other interfaces.
	IsUserSpecificationContext()
}

type UserSpecificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserSpecificationContext() *UserSpecificationContext {
	var p = new(UserSpecificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_userSpecification
	return p
}

func (*UserSpecificationContext) IsUserSpecificationContext() {}

func NewUserSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserSpecificationContext {
	var p = new(UserSpecificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_userSpecification

	return p
}

func (s *UserSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *UserSpecificationContext) UserName() IUserNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *UserSpecificationContext) UserPasswordOption() IUserPasswordOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserPasswordOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserPasswordOptionContext)
}

func (s *UserSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUserSpecification(s)
	}
}

func (s *UserSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUserSpecification(s)
	}
}

func (p *MySqlParser) UserSpecification() (localctx IUserSpecificationContext) {
	this := p
	_ = this

	localctx = NewUserSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, MySqlParserRULE_userSpecification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5324)
		p.UserName()
	}
	{
		p.SetState(5325)
		p.UserPasswordOption()
	}

	return localctx
}

// IUserAuthOptionContext is an interface to support dynamic dispatch.
type IUserAuthOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUserAuthOptionContext differentiates from other interfaces.
	IsUserAuthOptionContext()
}

type UserAuthOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserAuthOptionContext() *UserAuthOptionContext {
	var p = new(UserAuthOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_userAuthOption
	return p
}

func (*UserAuthOptionContext) IsUserAuthOptionContext() {}

func NewUserAuthOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserAuthOptionContext {
	var p = new(UserAuthOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_userAuthOption

	return p
}

func (s *UserAuthOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *UserAuthOptionContext) CopyFrom(ctx *UserAuthOptionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *UserAuthOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserAuthOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SimpleAuthOptionContext struct {
	*UserAuthOptionContext
}

func NewSimpleAuthOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleAuthOptionContext {
	var p = new(SimpleAuthOptionContext)

	p.UserAuthOptionContext = NewEmptyUserAuthOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*UserAuthOptionContext))

	return p
}

func (s *SimpleAuthOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleAuthOptionContext) UserName() IUserNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *SimpleAuthOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSimpleAuthOption(s)
	}
}

func (s *SimpleAuthOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSimpleAuthOption(s)
	}
}

type ModuleAuthOptionContext struct {
	*UserAuthOptionContext
}

func NewModuleAuthOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModuleAuthOptionContext {
	var p = new(ModuleAuthOptionContext)

	p.UserAuthOptionContext = NewEmptyUserAuthOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*UserAuthOptionContext))

	return p
}

func (s *ModuleAuthOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleAuthOptionContext) UserName() IUserNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *ModuleAuthOptionContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(MySqlParserIDENTIFIED, 0)
}

func (s *ModuleAuthOptionContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *ModuleAuthOptionContext) AuthenticationRule() IAuthenticationRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAuthenticationRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAuthenticationRuleContext)
}

func (s *ModuleAuthOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterModuleAuthOption(s)
	}
}

func (s *ModuleAuthOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitModuleAuthOption(s)
	}
}

type StringAuthOptionContext struct {
	*UserAuthOptionContext
}

func NewStringAuthOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringAuthOptionContext {
	var p = new(StringAuthOptionContext)

	p.UserAuthOptionContext = NewEmptyUserAuthOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*UserAuthOptionContext))

	return p
}

func (s *StringAuthOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringAuthOptionContext) UserName() IUserNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *StringAuthOptionContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(MySqlParserIDENTIFIED, 0)
}

func (s *StringAuthOptionContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *StringAuthOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *StringAuthOptionContext) RETAIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserRETAIN, 0)
}

func (s *StringAuthOptionContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT, 0)
}

func (s *StringAuthOptionContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD, 0)
}

func (s *StringAuthOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterStringAuthOption(s)
	}
}

func (s *StringAuthOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitStringAuthOption(s)
	}
}

type HashAuthOptionContext struct {
	*UserAuthOptionContext
	hashed antlr.Token
}

func NewHashAuthOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *HashAuthOptionContext {
	var p = new(HashAuthOptionContext)

	p.UserAuthOptionContext = NewEmptyUserAuthOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*UserAuthOptionContext))

	return p
}

func (s *HashAuthOptionContext) GetHashed() antlr.Token { return s.hashed }

func (s *HashAuthOptionContext) SetHashed(v antlr.Token) { s.hashed = v }

func (s *HashAuthOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HashAuthOptionContext) UserName() IUserNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *HashAuthOptionContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(MySqlParserIDENTIFIED, 0)
}

func (s *HashAuthOptionContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *HashAuthOptionContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD, 0)
}

func (s *HashAuthOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *HashAuthOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHashAuthOption(s)
	}
}

func (s *HashAuthOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHashAuthOption(s)
	}
}

func (p *MySqlParser) UserAuthOption() (localctx IUserAuthOptionContext) {
	this := p
	_ = this

	localctx = NewUserAuthOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, MySqlParserRULE_userAuthOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5348)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 788, p.GetParserRuleContext()) {
	case 1:
		localctx = NewHashAuthOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5327)
			p.UserName()
		}
		{
			p.SetState(5328)
			p.Match(MySqlParserIDENTIFIED)
		}
		{
			p.SetState(5329)
			p.Match(MySqlParserBY)
		}
		{
			p.SetState(5330)
			p.Match(MySqlParserPASSWORD)
		}
		{
			p.SetState(5331)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*HashAuthOptionContext).hashed = _m
		}

	case 2:
		localctx = NewStringAuthOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5333)
			p.UserName()
		}
		{
			p.SetState(5334)
			p.Match(MySqlParserIDENTIFIED)
		}
		{
			p.SetState(5335)
			p.Match(MySqlParserBY)
		}
		{
			p.SetState(5336)
			p.Match(MySqlParserSTRING_LITERAL)
		}
		p.SetState(5340)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserRETAIN {
			{
				p.SetState(5337)
				p.Match(MySqlParserRETAIN)
			}
			{
				p.SetState(5338)
				p.Match(MySqlParserCURRENT)
			}
			{
				p.SetState(5339)
				p.Match(MySqlParserPASSWORD)
			}

		}

	case 3:
		localctx = NewModuleAuthOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5342)
			p.UserName()
		}
		{
			p.SetState(5343)
			p.Match(MySqlParserIDENTIFIED)
		}
		{
			p.SetState(5344)
			p.Match(MySqlParserWITH)
		}
		{
			p.SetState(5345)
			p.AuthenticationRule()
		}

	case 4:
		localctx = NewSimpleAuthOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5347)
			p.UserName()
		}

	}

	return localctx
}

// IAuthenticationRuleContext is an interface to support dynamic dispatch.
type IAuthenticationRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAuthenticationRuleContext differentiates from other interfaces.
	IsAuthenticationRuleContext()
}

type AuthenticationRuleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAuthenticationRuleContext() *AuthenticationRuleContext {
	var p = new(AuthenticationRuleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_authenticationRule
	return p
}

func (*AuthenticationRuleContext) IsAuthenticationRuleContext() {}

func NewAuthenticationRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AuthenticationRuleContext {
	var p = new(AuthenticationRuleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_authenticationRule

	return p
}

func (s *AuthenticationRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *AuthenticationRuleContext) CopyFrom(ctx *AuthenticationRuleContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *AuthenticationRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AuthenticationRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PasswordModuleOptionContext struct {
	*AuthenticationRuleContext
}

func NewPasswordModuleOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PasswordModuleOptionContext {
	var p = new(PasswordModuleOptionContext)

	p.AuthenticationRuleContext = NewEmptyAuthenticationRuleContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AuthenticationRuleContext))

	return p
}

func (s *PasswordModuleOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PasswordModuleOptionContext) AuthPlugin() IAuthPluginContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAuthPluginContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAuthPluginContext)
}

func (s *PasswordModuleOptionContext) USING() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSING, 0)
}

func (s *PasswordModuleOptionContext) PasswordFunctionClause() IPasswordFunctionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPasswordFunctionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPasswordFunctionClauseContext)
}

func (s *PasswordModuleOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPasswordModuleOption(s)
	}
}

func (s *PasswordModuleOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPasswordModuleOption(s)
	}
}

type ModuleContext struct {
	*AuthenticationRuleContext
}

func NewModuleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModuleContext {
	var p = new(ModuleContext)

	p.AuthenticationRuleContext = NewEmptyAuthenticationRuleContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AuthenticationRuleContext))

	return p
}

func (s *ModuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleContext) AuthPlugin() IAuthPluginContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAuthPluginContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAuthPluginContext)
}

func (s *ModuleContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *ModuleContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *ModuleContext) USING() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSING, 0)
}

func (s *ModuleContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *ModuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterModule(s)
	}
}

func (s *ModuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitModule(s)
	}
}

func (p *MySqlParser) AuthenticationRule() (localctx IAuthenticationRuleContext) {
	this := p
	_ = this

	localctx = NewAuthenticationRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, MySqlParserRULE_authenticationRule)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5359)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 790, p.GetParserRuleContext()) {
	case 1:
		localctx = NewModuleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5350)
			p.AuthPlugin()
		}
		p.SetState(5353)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 789, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5351)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserAS || _la == MySqlParserBY || _la == MySqlParserUSING) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(5352)
				p.Match(MySqlParserSTRING_LITERAL)
			}

		}

	case 2:
		localctx = NewPasswordModuleOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5355)
			p.AuthPlugin()
		}
		{
			p.SetState(5356)
			p.Match(MySqlParserUSING)
		}
		{
			p.SetState(5357)
			p.PasswordFunctionClause()
		}

	}

	return localctx
}

// ITlsOptionContext is an interface to support dynamic dispatch.
type ITlsOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SSL() antlr.TerminalNode
	X509() antlr.TerminalNode
	CIPHER() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	ISSUER() antlr.TerminalNode
	SUBJECT() antlr.TerminalNode

	// IsTlsOptionContext differentiates from other interfaces.
	IsTlsOptionContext()
}

type TlsOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTlsOptionContext() *TlsOptionContext {
	var p = new(TlsOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_tlsOption
	return p
}

func (*TlsOptionContext) IsTlsOptionContext() {}

func NewTlsOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TlsOptionContext {
	var p = new(TlsOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tlsOption

	return p
}

func (s *TlsOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *TlsOptionContext) SSL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSSL, 0)
}

func (s *TlsOptionContext) X509() antlr.TerminalNode {
	return s.GetToken(MySqlParserX509, 0)
}

func (s *TlsOptionContext) CIPHER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCIPHER, 0)
}

func (s *TlsOptionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *TlsOptionContext) ISSUER() antlr.TerminalNode {
	return s.GetToken(MySqlParserISSUER, 0)
}

func (s *TlsOptionContext) SUBJECT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBJECT, 0)
}

func (s *TlsOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TlsOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TlsOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTlsOption(s)
	}
}

func (s *TlsOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTlsOption(s)
	}
}

func (p *MySqlParser) TlsOption() (localctx ITlsOptionContext) {
	this := p
	_ = this

	localctx = NewTlsOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, MySqlParserRULE_tlsOption)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5369)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSSL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5361)
			p.Match(MySqlParserSSL)
		}

	case MySqlParserX509:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5362)
			p.Match(MySqlParserX509)
		}

	case MySqlParserCIPHER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5363)
			p.Match(MySqlParserCIPHER)
		}
		{
			p.SetState(5364)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	case MySqlParserISSUER:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5365)
			p.Match(MySqlParserISSUER)
		}
		{
			p.SetState(5366)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	case MySqlParserSUBJECT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5367)
			p.Match(MySqlParserSUBJECT)
		}
		{
			p.SetState(5368)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUserResourceOptionContext is an interface to support dynamic dispatch.
type IUserResourceOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MAX_QUERIES_PER_HOUR() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	MAX_UPDATES_PER_HOUR() antlr.TerminalNode
	MAX_CONNECTIONS_PER_HOUR() antlr.TerminalNode
	MAX_USER_CONNECTIONS() antlr.TerminalNode

	// IsUserResourceOptionContext differentiates from other interfaces.
	IsUserResourceOptionContext()
}

type UserResourceOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserResourceOptionContext() *UserResourceOptionContext {
	var p = new(UserResourceOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_userResourceOption
	return p
}

func (*UserResourceOptionContext) IsUserResourceOptionContext() {}

func NewUserResourceOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserResourceOptionContext {
	var p = new(UserResourceOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_userResourceOption

	return p
}

func (s *UserResourceOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *UserResourceOptionContext) MAX_QUERIES_PER_HOUR() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_QUERIES_PER_HOUR, 0)
}

func (s *UserResourceOptionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *UserResourceOptionContext) MAX_UPDATES_PER_HOUR() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_UPDATES_PER_HOUR, 0)
}

func (s *UserResourceOptionContext) MAX_CONNECTIONS_PER_HOUR() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_CONNECTIONS_PER_HOUR, 0)
}

func (s *UserResourceOptionContext) MAX_USER_CONNECTIONS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_USER_CONNECTIONS, 0)
}

func (s *UserResourceOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserResourceOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserResourceOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUserResourceOption(s)
	}
}

func (s *UserResourceOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUserResourceOption(s)
	}
}

func (p *MySqlParser) UserResourceOption() (localctx IUserResourceOptionContext) {
	this := p
	_ = this

	localctx = NewUserResourceOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 448, MySqlParserRULE_userResourceOption)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5379)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserMAX_QUERIES_PER_HOUR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5371)
			p.Match(MySqlParserMAX_QUERIES_PER_HOUR)
		}
		{
			p.SetState(5372)
			p.DecimalLiteral()
		}

	case MySqlParserMAX_UPDATES_PER_HOUR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5373)
			p.Match(MySqlParserMAX_UPDATES_PER_HOUR)
		}
		{
			p.SetState(5374)
			p.DecimalLiteral()
		}

	case MySqlParserMAX_CONNECTIONS_PER_HOUR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5375)
			p.Match(MySqlParserMAX_CONNECTIONS_PER_HOUR)
		}
		{
			p.SetState(5376)
			p.DecimalLiteral()
		}

	case MySqlParserMAX_USER_CONNECTIONS:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5377)
			p.Match(MySqlParserMAX_USER_CONNECTIONS)
		}
		{
			p.SetState(5378)
			p.DecimalLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUserPasswordOptionContext is an interface to support dynamic dispatch.
type IUserPasswordOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetExpireType returns the expireType token.
	GetExpireType() antlr.Token

	// SetExpireType sets the expireType token.
	SetExpireType(antlr.Token)

	// Getter signatures
	PASSWORD() antlr.TerminalNode
	EXPIRE() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	DAY() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	NEVER() antlr.TerminalNode
	INTERVAL() antlr.TerminalNode
	HISTORY() antlr.TerminalNode
	REUSE() antlr.TerminalNode
	REQUIRE() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	OPTIONAL() antlr.TerminalNode
	FAILED_LOGIN_ATTEMPTS() antlr.TerminalNode
	PASSWORD_LOCK_TIME() antlr.TerminalNode
	UNBOUNDED() antlr.TerminalNode

	// IsUserPasswordOptionContext differentiates from other interfaces.
	IsUserPasswordOptionContext()
}

type UserPasswordOptionContext struct {
	*antlr.BaseParserRuleContext
	parser     antlr.Parser
	expireType antlr.Token
}

func NewEmptyUserPasswordOptionContext() *UserPasswordOptionContext {
	var p = new(UserPasswordOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_userPasswordOption
	return p
}

func (*UserPasswordOptionContext) IsUserPasswordOptionContext() {}

func NewUserPasswordOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserPasswordOptionContext {
	var p = new(UserPasswordOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_userPasswordOption

	return p
}

func (s *UserPasswordOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *UserPasswordOptionContext) GetExpireType() antlr.Token { return s.expireType }

func (s *UserPasswordOptionContext) SetExpireType(v antlr.Token) { s.expireType = v }

func (s *UserPasswordOptionContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD, 0)
}

func (s *UserPasswordOptionContext) EXPIRE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXPIRE, 0)
}

func (s *UserPasswordOptionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *UserPasswordOptionContext) DAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAY, 0)
}

func (s *UserPasswordOptionContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *UserPasswordOptionContext) NEVER() antlr.TerminalNode {
	return s.GetToken(MySqlParserNEVER, 0)
}

func (s *UserPasswordOptionContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTERVAL, 0)
}

func (s *UserPasswordOptionContext) HISTORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserHISTORY, 0)
}

func (s *UserPasswordOptionContext) REUSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREUSE, 0)
}

func (s *UserPasswordOptionContext) REQUIRE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREQUIRE, 0)
}

func (s *UserPasswordOptionContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT, 0)
}

func (s *UserPasswordOptionContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTIONAL, 0)
}

func (s *UserPasswordOptionContext) FAILED_LOGIN_ATTEMPTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFAILED_LOGIN_ATTEMPTS, 0)
}

func (s *UserPasswordOptionContext) PASSWORD_LOCK_TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD_LOCK_TIME, 0)
}

func (s *UserPasswordOptionContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNBOUNDED, 0)
}

func (s *UserPasswordOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserPasswordOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserPasswordOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUserPasswordOption(s)
	}
}

func (s *UserPasswordOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUserPasswordOption(s)
	}
}

func (p *MySqlParser) UserPasswordOption() (localctx IUserPasswordOptionContext) {
	this := p
	_ = this

	localctx = NewUserPasswordOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 450, MySqlParserRULE_userPasswordOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5419)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 798, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5381)
			p.Match(MySqlParserPASSWORD)
		}
		{
			p.SetState(5382)
			p.Match(MySqlParserEXPIRE)
		}
		p.SetState(5389)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserDEFAULT:
			{
				p.SetState(5383)

				var _m = p.Match(MySqlParserDEFAULT)

				localctx.(*UserPasswordOptionContext).expireType = _m
			}

		case MySqlParserNEVER:
			{
				p.SetState(5384)

				var _m = p.Match(MySqlParserNEVER)

				localctx.(*UserPasswordOptionContext).expireType = _m
			}

		case MySqlParserINTERVAL:
			{
				p.SetState(5385)

				var _m = p.Match(MySqlParserINTERVAL)

				localctx.(*UserPasswordOptionContext).expireType = _m
			}
			{
				p.SetState(5386)
				p.DecimalLiteral()
			}
			{
				p.SetState(5387)
				p.Match(MySqlParserDAY)
			}

		case MySqlParserEOF, MySqlParserALTER, MySqlParserANALYZE, MySqlParserATTRIBUTE, MySqlParserCALL, MySqlParserCHANGE, MySqlParserCHECK, MySqlParserCREATE, MySqlParserDELETE, MySqlParserDESC, MySqlParserDESCRIBE, MySqlParserDROP, MySqlParserEXPLAIN, MySqlParserGET, MySqlParserGRANT, MySqlParserINSERT, MySqlParserKILL, MySqlParserLOAD, MySqlParserLOCK, MySqlParserOPTIMIZE, MySqlParserPURGE, MySqlParserRELEASE, MySqlParserRENAME, MySqlParserREPLACE, MySqlParserRESIGNAL, MySqlParserREVOKE, MySqlParserSELECT, MySqlParserSET, MySqlParserSHOW, MySqlParserSIGNAL, MySqlParserUNLOCK, MySqlParserUPDATE, MySqlParserUSE, MySqlParserVALUES, MySqlParserWITH, MySqlParserACCOUNT, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserCACHE, MySqlParserCHECKSUM, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserDEALLOCATE, MySqlParserDO, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFLUSH, MySqlParserHANDLER, MySqlParserHELP, MySqlParserINSTALL, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPREPARE, MySqlParserREPAIR, MySqlParserRESET, MySqlParserROLLBACK, MySqlParserSAVEPOINT, MySqlParserSTART, MySqlParserSTOP, MySqlParserTRUNCATE, MySqlParserUNINSTALL, MySqlParserXA, MySqlParserEXECUTE, MySqlParserSHUTDOWN, MySqlParserMINUS, MySqlParserLR_BRACKET, MySqlParserCOMMA, MySqlParserSEMI:

		default:
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5391)
			p.Match(MySqlParserPASSWORD)
		}
		{
			p.SetState(5392)
			p.Match(MySqlParserHISTORY)
		}
		p.SetState(5395)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserDEFAULT:
			{
				p.SetState(5393)
				p.Match(MySqlParserDEFAULT)
			}

		case MySqlParserZERO_DECIMAL, MySqlParserONE_DECIMAL, MySqlParserTWO_DECIMAL, MySqlParserDECIMAL_LITERAL, MySqlParserREAL_LITERAL:
			{
				p.SetState(5394)
				p.DecimalLiteral()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5397)
			p.Match(MySqlParserPASSWORD)
		}
		{
			p.SetState(5398)
			p.Match(MySqlParserREUSE)
		}
		{
			p.SetState(5399)
			p.Match(MySqlParserINTERVAL)
		}
		p.SetState(5404)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserDEFAULT:
			{
				p.SetState(5400)
				p.Match(MySqlParserDEFAULT)
			}

		case MySqlParserZERO_DECIMAL, MySqlParserONE_DECIMAL, MySqlParserTWO_DECIMAL, MySqlParserDECIMAL_LITERAL, MySqlParserREAL_LITERAL:
			{
				p.SetState(5401)
				p.DecimalLiteral()
			}
			{
				p.SetState(5402)
				p.Match(MySqlParserDAY)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5406)
			p.Match(MySqlParserPASSWORD)
		}
		{
			p.SetState(5407)
			p.Match(MySqlParserREQUIRE)
		}
		{
			p.SetState(5408)
			p.Match(MySqlParserCURRENT)
		}
		p.SetState(5410)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserDEFAULT || _la == MySqlParserOPTIONAL {
			{
				p.SetState(5409)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserDEFAULT || _la == MySqlParserOPTIONAL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5412)
			p.Match(MySqlParserFAILED_LOGIN_ATTEMPTS)
		}
		{
			p.SetState(5413)
			p.DecimalLiteral()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5414)
			p.Match(MySqlParserPASSWORD_LOCK_TIME)
		}
		p.SetState(5417)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserZERO_DECIMAL, MySqlParserONE_DECIMAL, MySqlParserTWO_DECIMAL, MySqlParserDECIMAL_LITERAL, MySqlParserREAL_LITERAL:
			{
				p.SetState(5415)
				p.DecimalLiteral()
			}

		case MySqlParserUNBOUNDED:
			{
				p.SetState(5416)
				p.Match(MySqlParserUNBOUNDED)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}

	return localctx
}

// IUserLockOptionContext is an interface to support dynamic dispatch.
type IUserLockOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLockType returns the lockType token.
	GetLockType() antlr.Token

	// SetLockType sets the lockType token.
	SetLockType(antlr.Token)

	// Getter signatures
	ACCOUNT() antlr.TerminalNode
	LOCK() antlr.TerminalNode
	UNLOCK() antlr.TerminalNode

	// IsUserLockOptionContext differentiates from other interfaces.
	IsUserLockOptionContext()
}

type UserLockOptionContext struct {
	*antlr.BaseParserRuleContext
	parser   antlr.Parser
	lockType antlr.Token
}

func NewEmptyUserLockOptionContext() *UserLockOptionContext {
	var p = new(UserLockOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_userLockOption
	return p
}

func (*UserLockOptionContext) IsUserLockOptionContext() {}

func NewUserLockOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserLockOptionContext {
	var p = new(UserLockOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_userLockOption

	return p
}

func (s *UserLockOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *UserLockOptionContext) GetLockType() antlr.Token { return s.lockType }

func (s *UserLockOptionContext) SetLockType(v antlr.Token) { s.lockType = v }

func (s *UserLockOptionContext) ACCOUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserACCOUNT, 0)
}

func (s *UserLockOptionContext) LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCK, 0)
}

func (s *UserLockOptionContext) UNLOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNLOCK, 0)
}

func (s *UserLockOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserLockOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserLockOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUserLockOption(s)
	}
}

func (s *UserLockOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUserLockOption(s)
	}
}

func (p *MySqlParser) UserLockOption() (localctx IUserLockOptionContext) {
	this := p
	_ = this

	localctx = NewUserLockOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 452, MySqlParserRULE_userLockOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5421)
		p.Match(MySqlParserACCOUNT)
	}
	{
		p.SetState(5422)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*UserLockOptionContext).lockType = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserLOCK || _la == MySqlParserUNLOCK) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*UserLockOptionContext).lockType = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPrivelegeClauseContext is an interface to support dynamic dispatch.
type IPrivelegeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Privilege() IPrivilegeContext
	LR_BRACKET() antlr.TerminalNode
	UidList() IUidListContext
	RR_BRACKET() antlr.TerminalNode

	// IsPrivelegeClauseContext differentiates from other interfaces.
	IsPrivelegeClauseContext()
}

type PrivelegeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivelegeClauseContext() *PrivelegeClauseContext {
	var p = new(PrivelegeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_privelegeClause
	return p
}

func (*PrivelegeClauseContext) IsPrivelegeClauseContext() {}

func NewPrivelegeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivelegeClauseContext {
	var p = new(PrivelegeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_privelegeClause

	return p
}

func (s *PrivelegeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivelegeClauseContext) Privilege() IPrivilegeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeContext)
}

func (s *PrivelegeClauseContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *PrivelegeClauseContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *PrivelegeClauseContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *PrivelegeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivelegeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivelegeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPrivelegeClause(s)
	}
}

func (s *PrivelegeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPrivelegeClause(s)
	}
}

func (p *MySqlParser) PrivelegeClause() (localctx IPrivelegeClauseContext) {
	this := p
	_ = this

	localctx = NewPrivelegeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 454, MySqlParserRULE_privelegeClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5424)
		p.Privilege()
	}
	p.SetState(5429)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserLR_BRACKET {
		{
			p.SetState(5425)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(5426)
			p.UidList()
		}
		{
			p.SetState(5427)
			p.Match(MySqlParserRR_BRACKET)
		}

	}

	return localctx
}

// IPrivilegeContext is an interface to support dynamic dispatch.
type IPrivilegeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode
	ALTER() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	USER() antlr.TerminalNode
	TABLESPACE() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	DROP() antlr.TerminalNode
	EVENT() antlr.TerminalNode
	EXECUTE() antlr.TerminalNode
	FILE() antlr.TerminalNode
	GRANT() antlr.TerminalNode
	OPTION() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	INSERT() antlr.TerminalNode
	LOCK() antlr.TerminalNode
	PROCESS() antlr.TerminalNode
	PROXY() antlr.TerminalNode
	REFERENCES() antlr.TerminalNode
	RELOAD() antlr.TerminalNode
	REPLICATION() antlr.TerminalNode
	CLIENT() antlr.TerminalNode
	SLAVE() antlr.TerminalNode
	SELECT() antlr.TerminalNode
	SHOW() antlr.TerminalNode
	DATABASES() antlr.TerminalNode
	SHUTDOWN() antlr.TerminalNode
	SUPER() antlr.TerminalNode
	TRIGGER() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	USAGE() antlr.TerminalNode
	APPLICATION_PASSWORD_ADMIN() antlr.TerminalNode
	AUDIT_ABORT_EXEMPT() antlr.TerminalNode
	AUDIT_ADMIN() antlr.TerminalNode
	BACKUP_ADMIN() antlr.TerminalNode
	BINLOG_ADMIN() antlr.TerminalNode
	BINLOG_ENCRYPTION_ADMIN() antlr.TerminalNode
	CLONE_ADMIN() antlr.TerminalNode
	CONNECTION_ADMIN() antlr.TerminalNode
	ENCRYPTION_KEY_ADMIN() antlr.TerminalNode
	FIREWALL_ADMIN() antlr.TerminalNode
	FIREWALL_EXEMPT() antlr.TerminalNode
	FIREWALL_USER() antlr.TerminalNode
	FLUSH_OPTIMIZER_COSTS() antlr.TerminalNode
	FLUSH_STATUS() antlr.TerminalNode
	FLUSH_TABLES() antlr.TerminalNode
	FLUSH_USER_RESOURCES() antlr.TerminalNode
	GROUP_REPLICATION_ADMIN() antlr.TerminalNode
	INNODB_REDO_LOG_ARCHIVE() antlr.TerminalNode
	INNODB_REDO_LOG_ENABLE() antlr.TerminalNode
	NDB_STORED_USER() antlr.TerminalNode
	PASSWORDLESS_USER_ADMIN() antlr.TerminalNode
	PERSIST_RO_VARIABLES_ADMIN() antlr.TerminalNode
	REPLICATION_APPLIER() antlr.TerminalNode
	REPLICATION_SLAVE_ADMIN() antlr.TerminalNode
	RESOURCE_GROUP_ADMIN() antlr.TerminalNode
	RESOURCE_GROUP_USER() antlr.TerminalNode
	ROLE_ADMIN() antlr.TerminalNode
	SERVICE_CONNECTION_ADMIN() antlr.TerminalNode
	SESSION_VARIABLES_ADMIN() antlr.TerminalNode
	SET_USER_ID() antlr.TerminalNode
	SKIP_QUERY_REWRITE() antlr.TerminalNode
	SHOW_ROUTINE() antlr.TerminalNode
	SYSTEM_USER() antlr.TerminalNode
	SYSTEM_VARIABLES_ADMIN() antlr.TerminalNode
	TABLE_ENCRYPTION_ADMIN() antlr.TerminalNode
	TP_CONNECTION_ADMIN() antlr.TerminalNode
	VERSION_TOKEN_ADMIN() antlr.TerminalNode
	XA_RECOVER_ADMIN() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	FROM() antlr.TerminalNode
	S3() antlr.TerminalNode
	INTO() antlr.TerminalNode
	INVOKE() antlr.TerminalNode
	LAMBDA() antlr.TerminalNode

	// IsPrivilegeContext differentiates from other interfaces.
	IsPrivilegeContext()
}

type PrivilegeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegeContext() *PrivilegeContext {
	var p = new(PrivilegeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_privilege
	return p
}

func (*PrivilegeContext) IsPrivilegeContext() {}

func NewPrivilegeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeContext {
	var p = new(PrivilegeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_privilege

	return p
}

func (s *PrivilegeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *PrivilegeContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRIVILEGES, 0)
}

func (s *PrivilegeContext) ALTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserALTER, 0)
}

func (s *PrivilegeContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROUTINE, 0)
}

func (s *PrivilegeContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *PrivilegeContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserTEMPORARY, 0)
}

func (s *PrivilegeContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLES, 0)
}

func (s *PrivilegeContext) VIEW() antlr.TerminalNode {
	return s.GetToken(MySqlParserVIEW, 0)
}

func (s *PrivilegeContext) USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER, 0)
}

func (s *PrivilegeContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLESPACE, 0)
}

func (s *PrivilegeContext) ROLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLE, 0)
}

func (s *PrivilegeContext) DELETE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDELETE, 0)
}

func (s *PrivilegeContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *PrivilegeContext) EVENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVENT, 0)
}

func (s *PrivilegeContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXECUTE, 0)
}

func (s *PrivilegeContext) FILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFILE, 0)
}

func (s *PrivilegeContext) GRANT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGRANT, 0)
}

func (s *PrivilegeContext) OPTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTION, 0)
}

func (s *PrivilegeContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *PrivilegeContext) INSERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSERT, 0)
}

func (s *PrivilegeContext) LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCK, 0)
}

func (s *PrivilegeContext) PROCESS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROCESS, 0)
}

func (s *PrivilegeContext) PROXY() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROXY, 0)
}

func (s *PrivilegeContext) REFERENCES() antlr.TerminalNode {
	return s.GetToken(MySqlParserREFERENCES, 0)
}

func (s *PrivilegeContext) RELOAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELOAD, 0)
}

func (s *PrivilegeContext) REPLICATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATION, 0)
}

func (s *PrivilegeContext) CLIENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCLIENT, 0)
}

func (s *PrivilegeContext) SLAVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSLAVE, 0)
}

func (s *PrivilegeContext) SELECT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSELECT, 0)
}

func (s *PrivilegeContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *PrivilegeContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATABASES, 0)
}

func (s *PrivilegeContext) SHUTDOWN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHUTDOWN, 0)
}

func (s *PrivilegeContext) SUPER() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUPER, 0)
}

func (s *PrivilegeContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRIGGER, 0)
}

func (s *PrivilegeContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPDATE, 0)
}

func (s *PrivilegeContext) USAGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSAGE, 0)
}

func (s *PrivilegeContext) APPLICATION_PASSWORD_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserAPPLICATION_PASSWORD_ADMIN, 0)
}

func (s *PrivilegeContext) AUDIT_ABORT_EXEMPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUDIT_ABORT_EXEMPT, 0)
}

func (s *PrivilegeContext) AUDIT_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUDIT_ADMIN, 0)
}

func (s *PrivilegeContext) BACKUP_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBACKUP_ADMIN, 0)
}

func (s *PrivilegeContext) BINLOG_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINLOG_ADMIN, 0)
}

func (s *PrivilegeContext) BINLOG_ENCRYPTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINLOG_ENCRYPTION_ADMIN, 0)
}

func (s *PrivilegeContext) CLONE_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCLONE_ADMIN, 0)
}

func (s *PrivilegeContext) CONNECTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONNECTION_ADMIN, 0)
}

func (s *PrivilegeContext) ENCRYPTION_KEY_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserENCRYPTION_KEY_ADMIN, 0)
}

func (s *PrivilegeContext) FIREWALL_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIREWALL_ADMIN, 0)
}

func (s *PrivilegeContext) FIREWALL_EXEMPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIREWALL_EXEMPT, 0)
}

func (s *PrivilegeContext) FIREWALL_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIREWALL_USER, 0)
}

func (s *PrivilegeContext) FLUSH_OPTIMIZER_COSTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFLUSH_OPTIMIZER_COSTS, 0)
}

func (s *PrivilegeContext) FLUSH_STATUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFLUSH_STATUS, 0)
}

func (s *PrivilegeContext) FLUSH_TABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserFLUSH_TABLES, 0)
}

func (s *PrivilegeContext) FLUSH_USER_RESOURCES() antlr.TerminalNode {
	return s.GetToken(MySqlParserFLUSH_USER_RESOURCES, 0)
}

func (s *PrivilegeContext) GROUP_REPLICATION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP_REPLICATION_ADMIN, 0)
}

func (s *PrivilegeContext) INNODB_REDO_LOG_ARCHIVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINNODB_REDO_LOG_ARCHIVE, 0)
}

func (s *PrivilegeContext) INNODB_REDO_LOG_ENABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINNODB_REDO_LOG_ENABLE, 0)
}

func (s *PrivilegeContext) NDB_STORED_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserNDB_STORED_USER, 0)
}

func (s *PrivilegeContext) PASSWORDLESS_USER_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORDLESS_USER_ADMIN, 0)
}

func (s *PrivilegeContext) PERSIST_RO_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserPERSIST_RO_VARIABLES_ADMIN, 0)
}

func (s *PrivilegeContext) REPLICATION_APPLIER() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATION_APPLIER, 0)
}

func (s *PrivilegeContext) REPLICATION_SLAVE_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATION_SLAVE_ADMIN, 0)
}

func (s *PrivilegeContext) RESOURCE_GROUP_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESOURCE_GROUP_ADMIN, 0)
}

func (s *PrivilegeContext) RESOURCE_GROUP_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESOURCE_GROUP_USER, 0)
}

func (s *PrivilegeContext) ROLE_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLE_ADMIN, 0)
}

func (s *PrivilegeContext) SERVICE_CONNECTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSERVICE_CONNECTION_ADMIN, 0)
}

func (s *PrivilegeContext) SESSION_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSESSION_VARIABLES_ADMIN, 0)
}

func (s *PrivilegeContext) SET_USER_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET_USER_ID, 0)
}

func (s *PrivilegeContext) SKIP_QUERY_REWRITE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSKIP_QUERY_REWRITE, 0)
}

func (s *PrivilegeContext) SHOW_ROUTINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW_ROUTINE, 0)
}

func (s *PrivilegeContext) SYSTEM_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserSYSTEM_USER, 0)
}

func (s *PrivilegeContext) SYSTEM_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSYSTEM_VARIABLES_ADMIN, 0)
}

func (s *PrivilegeContext) TABLE_ENCRYPTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE_ENCRYPTION_ADMIN, 0)
}

func (s *PrivilegeContext) TP_CONNECTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserTP_CONNECTION_ADMIN, 0)
}

func (s *PrivilegeContext) VERSION_TOKEN_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserVERSION_TOKEN_ADMIN, 0)
}

func (s *PrivilegeContext) XA_RECOVER_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserXA_RECOVER_ADMIN, 0)
}

func (s *PrivilegeContext) LOAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOAD, 0)
}

func (s *PrivilegeContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *PrivilegeContext) S3() antlr.TerminalNode {
	return s.GetToken(MySqlParserS3, 0)
}

func (s *PrivilegeContext) INTO() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTO, 0)
}

func (s *PrivilegeContext) INVOKE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINVOKE, 0)
}

func (s *PrivilegeContext) LAMBDA() antlr.TerminalNode {
	return s.GetToken(MySqlParserLAMBDA, 0)
}

func (s *PrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPrivilege(s)
	}
}

func (s *PrivilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPrivilege(s)
	}
}

func (p *MySqlParser) Privilege() (localctx IPrivilegeContext) {
	this := p
	_ = this

	localctx = NewPrivilegeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 456, MySqlParserRULE_privilege)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5523)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 804, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5431)
			p.Match(MySqlParserALL)
		}
		p.SetState(5433)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserPRIVILEGES {
			{
				p.SetState(5432)
				p.Match(MySqlParserPRIVILEGES)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5435)
			p.Match(MySqlParserALTER)
		}
		p.SetState(5437)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserROUTINE {
			{
				p.SetState(5436)
				p.Match(MySqlParserROUTINE)
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5439)
			p.Match(MySqlParserCREATE)
		}
		p.SetState(5447)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserTEMPORARY:
			{
				p.SetState(5440)
				p.Match(MySqlParserTEMPORARY)
			}
			{
				p.SetState(5441)
				p.Match(MySqlParserTABLES)
			}

		case MySqlParserROUTINE:
			{
				p.SetState(5442)
				p.Match(MySqlParserROUTINE)
			}

		case MySqlParserVIEW:
			{
				p.SetState(5443)
				p.Match(MySqlParserVIEW)
			}

		case MySqlParserUSER:
			{
				p.SetState(5444)
				p.Match(MySqlParserUSER)
			}

		case MySqlParserTABLESPACE:
			{
				p.SetState(5445)
				p.Match(MySqlParserTABLESPACE)
			}

		case MySqlParserROLE:
			{
				p.SetState(5446)
				p.Match(MySqlParserROLE)
			}

		case MySqlParserON, MySqlParserLR_BRACKET, MySqlParserCOMMA:

		default:
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5449)
			p.Match(MySqlParserDELETE)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5450)
			p.Match(MySqlParserDROP)
		}
		p.SetState(5452)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserROLE {
			{
				p.SetState(5451)
				p.Match(MySqlParserROLE)
			}

		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5454)
			p.Match(MySqlParserEVENT)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5455)
			p.Match(MySqlParserEXECUTE)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5456)
			p.Match(MySqlParserFILE)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5457)
			p.Match(MySqlParserGRANT)
		}
		{
			p.SetState(5458)
			p.Match(MySqlParserOPTION)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(5459)
			p.Match(MySqlParserINDEX)
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(5460)
			p.Match(MySqlParserINSERT)
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(5461)
			p.Match(MySqlParserLOCK)
		}
		{
			p.SetState(5462)
			p.Match(MySqlParserTABLES)
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(5463)
			p.Match(MySqlParserPROCESS)
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(5464)
			p.Match(MySqlParserPROXY)
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(5465)
			p.Match(MySqlParserREFERENCES)
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(5466)
			p.Match(MySqlParserRELOAD)
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(5467)
			p.Match(MySqlParserREPLICATION)
		}
		{
			p.SetState(5468)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCLIENT || _la == MySqlParserSLAVE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(5469)
			p.Match(MySqlParserSELECT)
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(5470)
			p.Match(MySqlParserSHOW)
		}
		{
			p.SetState(5471)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDATABASES || _la == MySqlParserVIEW) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(5472)
			p.Match(MySqlParserSHUTDOWN)
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(5473)
			p.Match(MySqlParserSUPER)
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(5474)
			p.Match(MySqlParserTRIGGER)
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(5475)
			p.Match(MySqlParserUPDATE)
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(5476)
			p.Match(MySqlParserUSAGE)
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(5477)
			p.Match(MySqlParserAPPLICATION_PASSWORD_ADMIN)
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(5478)
			p.Match(MySqlParserAUDIT_ABORT_EXEMPT)
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(5479)
			p.Match(MySqlParserAUDIT_ADMIN)
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(5480)
			p.Match(MySqlParserBACKUP_ADMIN)
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(5481)
			p.Match(MySqlParserBINLOG_ADMIN)
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(5482)
			p.Match(MySqlParserBINLOG_ENCRYPTION_ADMIN)
		}

	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(5483)
			p.Match(MySqlParserCLONE_ADMIN)
		}

	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(5484)
			p.Match(MySqlParserCONNECTION_ADMIN)
		}

	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(5485)
			p.Match(MySqlParserENCRYPTION_KEY_ADMIN)
		}

	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(5486)
			p.Match(MySqlParserFIREWALL_ADMIN)
		}

	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(5487)
			p.Match(MySqlParserFIREWALL_EXEMPT)
		}

	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(5488)
			p.Match(MySqlParserFIREWALL_USER)
		}

	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(5489)
			p.Match(MySqlParserFLUSH_OPTIMIZER_COSTS)
		}

	case 38:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(5490)
			p.Match(MySqlParserFLUSH_STATUS)
		}

	case 39:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(5491)
			p.Match(MySqlParserFLUSH_TABLES)
		}

	case 40:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(5492)
			p.Match(MySqlParserFLUSH_USER_RESOURCES)
		}

	case 41:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(5493)
			p.Match(MySqlParserGROUP_REPLICATION_ADMIN)
		}

	case 42:
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(5494)
			p.Match(MySqlParserINNODB_REDO_LOG_ARCHIVE)
		}

	case 43:
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(5495)
			p.Match(MySqlParserINNODB_REDO_LOG_ENABLE)
		}

	case 44:
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(5496)
			p.Match(MySqlParserNDB_STORED_USER)
		}

	case 45:
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(5497)
			p.Match(MySqlParserPASSWORDLESS_USER_ADMIN)
		}

	case 46:
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(5498)
			p.Match(MySqlParserPERSIST_RO_VARIABLES_ADMIN)
		}

	case 47:
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(5499)
			p.Match(MySqlParserREPLICATION_APPLIER)
		}

	case 48:
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(5500)
			p.Match(MySqlParserREPLICATION_SLAVE_ADMIN)
		}

	case 49:
		p.EnterOuterAlt(localctx, 49)
		{
			p.SetState(5501)
			p.Match(MySqlParserRESOURCE_GROUP_ADMIN)
		}

	case 50:
		p.EnterOuterAlt(localctx, 50)
		{
			p.SetState(5502)
			p.Match(MySqlParserRESOURCE_GROUP_USER)
		}

	case 51:
		p.EnterOuterAlt(localctx, 51)
		{
			p.SetState(5503)
			p.Match(MySqlParserROLE_ADMIN)
		}

	case 52:
		p.EnterOuterAlt(localctx, 52)
		{
			p.SetState(5504)
			p.Match(MySqlParserSERVICE_CONNECTION_ADMIN)
		}

	case 53:
		p.EnterOuterAlt(localctx, 53)
		{
			p.SetState(5505)
			p.Match(MySqlParserSESSION_VARIABLES_ADMIN)
		}

	case 54:
		p.EnterOuterAlt(localctx, 54)
		{
			p.SetState(5506)
			p.Match(MySqlParserSET_USER_ID)
		}

	case 55:
		p.EnterOuterAlt(localctx, 55)
		{
			p.SetState(5507)
			p.Match(MySqlParserSKIP_QUERY_REWRITE)
		}

	case 56:
		p.EnterOuterAlt(localctx, 56)
		{
			p.SetState(5508)
			p.Match(MySqlParserSHOW_ROUTINE)
		}

	case 57:
		p.EnterOuterAlt(localctx, 57)
		{
			p.SetState(5509)
			p.Match(MySqlParserSYSTEM_USER)
		}

	case 58:
		p.EnterOuterAlt(localctx, 58)
		{
			p.SetState(5510)
			p.Match(MySqlParserSYSTEM_VARIABLES_ADMIN)
		}

	case 59:
		p.EnterOuterAlt(localctx, 59)
		{
			p.SetState(5511)
			p.Match(MySqlParserTABLE_ENCRYPTION_ADMIN)
		}

	case 60:
		p.EnterOuterAlt(localctx, 60)
		{
			p.SetState(5512)
			p.Match(MySqlParserTP_CONNECTION_ADMIN)
		}

	case 61:
		p.EnterOuterAlt(localctx, 61)
		{
			p.SetState(5513)
			p.Match(MySqlParserVERSION_TOKEN_ADMIN)
		}

	case 62:
		p.EnterOuterAlt(localctx, 62)
		{
			p.SetState(5514)
			p.Match(MySqlParserXA_RECOVER_ADMIN)
		}

	case 63:
		p.EnterOuterAlt(localctx, 63)
		{
			p.SetState(5515)
			p.Match(MySqlParserLOAD)
		}
		{
			p.SetState(5516)
			p.Match(MySqlParserFROM)
		}
		{
			p.SetState(5517)
			p.Match(MySqlParserS3)
		}

	case 64:
		p.EnterOuterAlt(localctx, 64)
		{
			p.SetState(5518)
			p.Match(MySqlParserSELECT)
		}
		{
			p.SetState(5519)
			p.Match(MySqlParserINTO)
		}
		{
			p.SetState(5520)
			p.Match(MySqlParserS3)
		}

	case 65:
		p.EnterOuterAlt(localctx, 65)
		{
			p.SetState(5521)
			p.Match(MySqlParserINVOKE)
		}
		{
			p.SetState(5522)
			p.Match(MySqlParserLAMBDA)
		}

	}

	return localctx
}

// IPrivilegeLevelContext is an interface to support dynamic dispatch.
type IPrivilegeLevelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPrivilegeLevelContext differentiates from other interfaces.
	IsPrivilegeLevelContext()
}

type PrivilegeLevelContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegeLevelContext() *PrivilegeLevelContext {
	var p = new(PrivilegeLevelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_privilegeLevel
	return p
}

func (*PrivilegeLevelContext) IsPrivilegeLevelContext() {}

func NewPrivilegeLevelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeLevelContext {
	var p = new(PrivilegeLevelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_privilegeLevel

	return p
}

func (s *PrivilegeLevelContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeLevelContext) CopyFrom(ctx *PrivilegeLevelContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *PrivilegeLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeLevelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DefiniteSchemaPrivLevelContext struct {
	*PrivilegeLevelContext
}

func NewDefiniteSchemaPrivLevelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DefiniteSchemaPrivLevelContext {
	var p = new(DefiniteSchemaPrivLevelContext)

	p.PrivilegeLevelContext = NewEmptyPrivilegeLevelContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrivilegeLevelContext))

	return p
}

func (s *DefiniteSchemaPrivLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefiniteSchemaPrivLevelContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DefiniteSchemaPrivLevelContext) DOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT, 0)
}

func (s *DefiniteSchemaPrivLevelContext) STAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTAR, 0)
}

func (s *DefiniteSchemaPrivLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDefiniteSchemaPrivLevel(s)
	}
}

func (s *DefiniteSchemaPrivLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDefiniteSchemaPrivLevel(s)
	}
}

type DefiniteFullTablePrivLevel2Context struct {
	*PrivilegeLevelContext
}

func NewDefiniteFullTablePrivLevel2Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *DefiniteFullTablePrivLevel2Context {
	var p = new(DefiniteFullTablePrivLevel2Context)

	p.PrivilegeLevelContext = NewEmptyPrivilegeLevelContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrivilegeLevelContext))

	return p
}

func (s *DefiniteFullTablePrivLevel2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefiniteFullTablePrivLevel2Context) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DefiniteFullTablePrivLevel2Context) DottedId() IDottedIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDottedIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDottedIdContext)
}

func (s *DefiniteFullTablePrivLevel2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDefiniteFullTablePrivLevel2(s)
	}
}

func (s *DefiniteFullTablePrivLevel2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDefiniteFullTablePrivLevel2(s)
	}
}

type DefiniteFullTablePrivLevelContext struct {
	*PrivilegeLevelContext
}

func NewDefiniteFullTablePrivLevelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DefiniteFullTablePrivLevelContext {
	var p = new(DefiniteFullTablePrivLevelContext)

	p.PrivilegeLevelContext = NewEmptyPrivilegeLevelContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrivilegeLevelContext))

	return p
}

func (s *DefiniteFullTablePrivLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefiniteFullTablePrivLevelContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *DefiniteFullTablePrivLevelContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DefiniteFullTablePrivLevelContext) DOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT, 0)
}

func (s *DefiniteFullTablePrivLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDefiniteFullTablePrivLevel(s)
	}
}

func (s *DefiniteFullTablePrivLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDefiniteFullTablePrivLevel(s)
	}
}

type GlobalPrivLevelContext struct {
	*PrivilegeLevelContext
}

func NewGlobalPrivLevelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GlobalPrivLevelContext {
	var p = new(GlobalPrivLevelContext)

	p.PrivilegeLevelContext = NewEmptyPrivilegeLevelContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrivilegeLevelContext))

	return p
}

func (s *GlobalPrivLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GlobalPrivLevelContext) AllSTAR() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSTAR)
}

func (s *GlobalPrivLevelContext) STAR(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSTAR, i)
}

func (s *GlobalPrivLevelContext) DOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT, 0)
}

func (s *GlobalPrivLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterGlobalPrivLevel(s)
	}
}

func (s *GlobalPrivLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitGlobalPrivLevel(s)
	}
}

type DefiniteTablePrivLevelContext struct {
	*PrivilegeLevelContext
}

func NewDefiniteTablePrivLevelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DefiniteTablePrivLevelContext {
	var p = new(DefiniteTablePrivLevelContext)

	p.PrivilegeLevelContext = NewEmptyPrivilegeLevelContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrivilegeLevelContext))

	return p
}

func (s *DefiniteTablePrivLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefiniteTablePrivLevelContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DefiniteTablePrivLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDefiniteTablePrivLevel(s)
	}
}

func (s *DefiniteTablePrivLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDefiniteTablePrivLevel(s)
	}
}

type CurrentSchemaPriviLevelContext struct {
	*PrivilegeLevelContext
}

func NewCurrentSchemaPriviLevelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentSchemaPriviLevelContext {
	var p = new(CurrentSchemaPriviLevelContext)

	p.PrivilegeLevelContext = NewEmptyPrivilegeLevelContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrivilegeLevelContext))

	return p
}

func (s *CurrentSchemaPriviLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentSchemaPriviLevelContext) STAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTAR, 0)
}

func (s *CurrentSchemaPriviLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCurrentSchemaPriviLevel(s)
	}
}

func (s *CurrentSchemaPriviLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCurrentSchemaPriviLevel(s)
	}
}

func (p *MySqlParser) PrivilegeLevel() (localctx IPrivilegeLevelContext) {
	this := p
	_ = this

	localctx = NewPrivilegeLevelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 458, MySqlParserRULE_privilegeLevel)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5541)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 805, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCurrentSchemaPriviLevelContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5525)
			p.Match(MySqlParserSTAR)
		}

	case 2:
		localctx = NewGlobalPrivLevelContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5526)
			p.Match(MySqlParserSTAR)
		}
		{
			p.SetState(5527)
			p.Match(MySqlParserDOT)
		}
		{
			p.SetState(5528)
			p.Match(MySqlParserSTAR)
		}

	case 3:
		localctx = NewDefiniteSchemaPrivLevelContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5529)
			p.Uid()
		}
		{
			p.SetState(5530)
			p.Match(MySqlParserDOT)
		}
		{
			p.SetState(5531)
			p.Match(MySqlParserSTAR)
		}

	case 4:
		localctx = NewDefiniteFullTablePrivLevelContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5533)
			p.Uid()
		}
		{
			p.SetState(5534)
			p.Match(MySqlParserDOT)
		}
		{
			p.SetState(5535)
			p.Uid()
		}

	case 5:
		localctx = NewDefiniteFullTablePrivLevel2Context(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5537)
			p.Uid()
		}
		{
			p.SetState(5538)
			p.DottedId()
		}

	case 6:
		localctx = NewDefiniteTablePrivLevelContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5540)
			p.Uid()
		}

	}

	return localctx
}

// IRenameUserClauseContext is an interface to support dynamic dispatch.
type IRenameUserClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFromFirst returns the fromFirst rule contexts.
	GetFromFirst() IUserNameContext

	// GetToFirst returns the toFirst rule contexts.
	GetToFirst() IUserNameContext

	// SetFromFirst sets the fromFirst rule contexts.
	SetFromFirst(IUserNameContext)

	// SetToFirst sets the toFirst rule contexts.
	SetToFirst(IUserNameContext)

	// Getter signatures
	TO() antlr.TerminalNode
	AllUserName() []IUserNameContext
	UserName(i int) IUserNameContext

	// IsRenameUserClauseContext differentiates from other interfaces.
	IsRenameUserClauseContext()
}

type RenameUserClauseContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	fromFirst IUserNameContext
	toFirst   IUserNameContext
}

func NewEmptyRenameUserClauseContext() *RenameUserClauseContext {
	var p = new(RenameUserClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_renameUserClause
	return p
}

func (*RenameUserClauseContext) IsRenameUserClauseContext() {}

func NewRenameUserClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RenameUserClauseContext {
	var p = new(RenameUserClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_renameUserClause

	return p
}

func (s *RenameUserClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RenameUserClauseContext) GetFromFirst() IUserNameContext { return s.fromFirst }

func (s *RenameUserClauseContext) GetToFirst() IUserNameContext { return s.toFirst }

func (s *RenameUserClauseContext) SetFromFirst(v IUserNameContext) { s.fromFirst = v }

func (s *RenameUserClauseContext) SetToFirst(v IUserNameContext) { s.toFirst = v }

func (s *RenameUserClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO, 0)
}

func (s *RenameUserClauseContext) AllUserName() []IUserNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserNameContext); ok {
			len++
		}
	}

	tst := make([]IUserNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserNameContext); ok {
			tst[i] = t.(IUserNameContext)
			i++
		}
	}

	return tst
}

func (s *RenameUserClauseContext) UserName(i int) IUserNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *RenameUserClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameUserClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RenameUserClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRenameUserClause(s)
	}
}

func (s *RenameUserClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRenameUserClause(s)
	}
}

func (p *MySqlParser) RenameUserClause() (localctx IRenameUserClauseContext) {
	this := p
	_ = this

	localctx = NewRenameUserClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 460, MySqlParserRULE_renameUserClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5543)

		var _x = p.UserName()

		localctx.(*RenameUserClauseContext).fromFirst = _x
	}
	{
		p.SetState(5544)
		p.Match(MySqlParserTO)
	}
	{
		p.SetState(5545)

		var _x = p.UserName()

		localctx.(*RenameUserClauseContext).toFirst = _x
	}

	return localctx
}

// IAnalyzeTableContext is an interface to support dynamic dispatch.
type IAnalyzeTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetActionOption returns the actionOption token.
	GetActionOption() antlr.Token

	// SetActionOption sets the actionOption token.
	SetActionOption(antlr.Token)

	// Getter signatures
	ANALYZE() antlr.TerminalNode
	Tables() ITablesContext
	TABLE() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	AllHISTOGRAM() []antlr.TerminalNode
	HISTOGRAM(i int) antlr.TerminalNode
	AllON() []antlr.TerminalNode
	ON(i int) antlr.TerminalNode
	AllFullColumnName() []IFullColumnNameContext
	FullColumnName(i int) IFullColumnNameContext
	DROP() antlr.TerminalNode
	NO_WRITE_TO_BINLOG() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	WITH() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	BUCKETS() antlr.TerminalNode

	// IsAnalyzeTableContext differentiates from other interfaces.
	IsAnalyzeTableContext()
}

type AnalyzeTableContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	actionOption antlr.Token
}

func NewEmptyAnalyzeTableContext() *AnalyzeTableContext {
	var p = new(AnalyzeTableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_analyzeTable
	return p
}

func (*AnalyzeTableContext) IsAnalyzeTableContext() {}

func NewAnalyzeTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnalyzeTableContext {
	var p = new(AnalyzeTableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_analyzeTable

	return p
}

func (s *AnalyzeTableContext) GetParser() antlr.Parser { return s.parser }

func (s *AnalyzeTableContext) GetActionOption() antlr.Token { return s.actionOption }

func (s *AnalyzeTableContext) SetActionOption(v antlr.Token) { s.actionOption = v }

func (s *AnalyzeTableContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserANALYZE, 0)
}

func (s *AnalyzeTableContext) Tables() ITablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *AnalyzeTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *AnalyzeTableContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLES, 0)
}

func (s *AnalyzeTableContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPDATE, 0)
}

func (s *AnalyzeTableContext) AllHISTOGRAM() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserHISTOGRAM)
}

func (s *AnalyzeTableContext) HISTOGRAM(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserHISTOGRAM, i)
}

func (s *AnalyzeTableContext) AllON() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserON)
}

func (s *AnalyzeTableContext) ON(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserON, i)
}

func (s *AnalyzeTableContext) AllFullColumnName() []IFullColumnNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			len++
		}
	}

	tst := make([]IFullColumnNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFullColumnNameContext); ok {
			tst[i] = t.(IFullColumnNameContext)
			i++
		}
	}

	return tst
}

func (s *AnalyzeTableContext) FullColumnName(i int) IFullColumnNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *AnalyzeTableContext) DROP() antlr.TerminalNode {
	return s.GetToken(MySqlParserDROP, 0)
}

func (s *AnalyzeTableContext) NO_WRITE_TO_BINLOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserNO_WRITE_TO_BINLOG, 0)
}

func (s *AnalyzeTableContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL, 0)
}

func (s *AnalyzeTableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AnalyzeTableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *AnalyzeTableContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *AnalyzeTableContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *AnalyzeTableContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(MySqlParserBUCKETS, 0)
}

func (s *AnalyzeTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalyzeTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnalyzeTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAnalyzeTable(s)
	}
}

func (s *AnalyzeTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAnalyzeTable(s)
	}
}

func (p *MySqlParser) AnalyzeTable() (localctx IAnalyzeTableContext) {
	this := p
	_ = this

	localctx = NewAnalyzeTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 462, MySqlParserRULE_analyzeTable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5547)
		p.Match(MySqlParserANALYZE)
	}
	p.SetState(5549)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserNO_WRITE_TO_BINLOG || _la == MySqlParserLOCAL {
		{
			p.SetState(5548)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AnalyzeTableContext).actionOption = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserNO_WRITE_TO_BINLOG || _la == MySqlParserLOCAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AnalyzeTableContext).actionOption = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(5551)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserTABLE || _la == MySqlParserTABLES) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5552)
		p.Tables()
	}
	p.SetState(5570)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 809, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5553)
			p.Match(MySqlParserUPDATE)
		}
		{
			p.SetState(5554)
			p.Match(MySqlParserHISTOGRAM)
		}
		{
			p.SetState(5555)
			p.Match(MySqlParserON)
		}
		{
			p.SetState(5556)
			p.FullColumnName()
		}
		p.SetState(5561)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(5557)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(5558)
				p.FullColumnName()
			}

			p.SetState(5563)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5568)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 808, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5564)
				p.Match(MySqlParserWITH)
			}
			{
				p.SetState(5565)
				p.DecimalLiteral()
			}
			{
				p.SetState(5566)
				p.Match(MySqlParserBUCKETS)
			}

		}

	}
	p.SetState(5583)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 811, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5572)
			p.Match(MySqlParserDROP)
		}
		{
			p.SetState(5573)
			p.Match(MySqlParserHISTOGRAM)
		}
		{
			p.SetState(5574)
			p.Match(MySqlParserON)
		}
		{
			p.SetState(5575)
			p.FullColumnName()
		}
		p.SetState(5580)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(5576)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(5577)
				p.FullColumnName()
			}

			p.SetState(5582)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// ICheckTableContext is an interface to support dynamic dispatch.
type ICheckTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHECK() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	Tables() ITablesContext
	AllCheckTableOption() []ICheckTableOptionContext
	CheckTableOption(i int) ICheckTableOptionContext

	// IsCheckTableContext differentiates from other interfaces.
	IsCheckTableContext()
}

type CheckTableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCheckTableContext() *CheckTableContext {
	var p = new(CheckTableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_checkTable
	return p
}

func (*CheckTableContext) IsCheckTableContext() {}

func NewCheckTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CheckTableContext {
	var p = new(CheckTableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_checkTable

	return p
}

func (s *CheckTableContext) GetParser() antlr.Parser { return s.parser }

func (s *CheckTableContext) CHECK() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHECK, 0)
}

func (s *CheckTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *CheckTableContext) Tables() ITablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *CheckTableContext) AllCheckTableOption() []ICheckTableOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICheckTableOptionContext); ok {
			len++
		}
	}

	tst := make([]ICheckTableOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICheckTableOptionContext); ok {
			tst[i] = t.(ICheckTableOptionContext)
			i++
		}
	}

	return tst
}

func (s *CheckTableContext) CheckTableOption(i int) ICheckTableOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICheckTableOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICheckTableOptionContext)
}

func (s *CheckTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CheckTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCheckTable(s)
	}
}

func (s *CheckTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCheckTable(s)
	}
}

func (p *MySqlParser) CheckTable() (localctx ICheckTableContext) {
	this := p
	_ = this

	localctx = NewCheckTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 464, MySqlParserRULE_checkTable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5585)
		p.Match(MySqlParserCHECK)
	}
	{
		p.SetState(5586)
		p.Match(MySqlParserTABLE)
	}
	{
		p.SetState(5587)
		p.Tables()
	}
	p.SetState(5591)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserFOR || _la == MySqlParserCHANGED || _la == MySqlParserEXTENDED || _la == MySqlParserFAST || _la == MySqlParserMEDIUM || _la == MySqlParserQUICK {
		{
			p.SetState(5588)
			p.CheckTableOption()
		}

		p.SetState(5593)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IChecksumTableContext is an interface to support dynamic dispatch.
type IChecksumTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetActionOption returns the actionOption token.
	GetActionOption() antlr.Token

	// SetActionOption sets the actionOption token.
	SetActionOption(antlr.Token)

	// Getter signatures
	CHECKSUM() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	Tables() ITablesContext
	QUICK() antlr.TerminalNode
	EXTENDED() antlr.TerminalNode

	// IsChecksumTableContext differentiates from other interfaces.
	IsChecksumTableContext()
}

type ChecksumTableContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	actionOption antlr.Token
}

func NewEmptyChecksumTableContext() *ChecksumTableContext {
	var p = new(ChecksumTableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_checksumTable
	return p
}

func (*ChecksumTableContext) IsChecksumTableContext() {}

func NewChecksumTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChecksumTableContext {
	var p = new(ChecksumTableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_checksumTable

	return p
}

func (s *ChecksumTableContext) GetParser() antlr.Parser { return s.parser }

func (s *ChecksumTableContext) GetActionOption() antlr.Token { return s.actionOption }

func (s *ChecksumTableContext) SetActionOption(v antlr.Token) { s.actionOption = v }

func (s *ChecksumTableContext) CHECKSUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHECKSUM, 0)
}

func (s *ChecksumTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *ChecksumTableContext) Tables() ITablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *ChecksumTableContext) QUICK() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUICK, 0)
}

func (s *ChecksumTableContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXTENDED, 0)
}

func (s *ChecksumTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChecksumTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChecksumTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterChecksumTable(s)
	}
}

func (s *ChecksumTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitChecksumTable(s)
	}
}

func (p *MySqlParser) ChecksumTable() (localctx IChecksumTableContext) {
	this := p
	_ = this

	localctx = NewChecksumTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 466, MySqlParserRULE_checksumTable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5594)
		p.Match(MySqlParserCHECKSUM)
	}
	{
		p.SetState(5595)
		p.Match(MySqlParserTABLE)
	}
	{
		p.SetState(5596)
		p.Tables()
	}
	p.SetState(5598)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserEXTENDED || _la == MySqlParserQUICK {
		{
			p.SetState(5597)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ChecksumTableContext).actionOption = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserEXTENDED || _la == MySqlParserQUICK) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ChecksumTableContext).actionOption = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IOptimizeTableContext is an interface to support dynamic dispatch.
type IOptimizeTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetActionOption returns the actionOption token.
	GetActionOption() antlr.Token

	// SetActionOption sets the actionOption token.
	SetActionOption(antlr.Token)

	// Getter signatures
	OPTIMIZE() antlr.TerminalNode
	Tables() ITablesContext
	TABLE() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	NO_WRITE_TO_BINLOG() antlr.TerminalNode
	LOCAL() antlr.TerminalNode

	// IsOptimizeTableContext differentiates from other interfaces.
	IsOptimizeTableContext()
}

type OptimizeTableContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	actionOption antlr.Token
}

func NewEmptyOptimizeTableContext() *OptimizeTableContext {
	var p = new(OptimizeTableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_optimizeTable
	return p
}

func (*OptimizeTableContext) IsOptimizeTableContext() {}

func NewOptimizeTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptimizeTableContext {
	var p = new(OptimizeTableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_optimizeTable

	return p
}

func (s *OptimizeTableContext) GetParser() antlr.Parser { return s.parser }

func (s *OptimizeTableContext) GetActionOption() antlr.Token { return s.actionOption }

func (s *OptimizeTableContext) SetActionOption(v antlr.Token) { s.actionOption = v }

func (s *OptimizeTableContext) OPTIMIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTIMIZE, 0)
}

func (s *OptimizeTableContext) Tables() ITablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *OptimizeTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *OptimizeTableContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLES, 0)
}

func (s *OptimizeTableContext) NO_WRITE_TO_BINLOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserNO_WRITE_TO_BINLOG, 0)
}

func (s *OptimizeTableContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL, 0)
}

func (s *OptimizeTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptimizeTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptimizeTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterOptimizeTable(s)
	}
}

func (s *OptimizeTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitOptimizeTable(s)
	}
}

func (p *MySqlParser) OptimizeTable() (localctx IOptimizeTableContext) {
	this := p
	_ = this

	localctx = NewOptimizeTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 468, MySqlParserRULE_optimizeTable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5600)
		p.Match(MySqlParserOPTIMIZE)
	}
	p.SetState(5602)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserNO_WRITE_TO_BINLOG || _la == MySqlParserLOCAL {
		{
			p.SetState(5601)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*OptimizeTableContext).actionOption = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserNO_WRITE_TO_BINLOG || _la == MySqlParserLOCAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*OptimizeTableContext).actionOption = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(5604)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserTABLE || _la == MySqlParserTABLES) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5605)
		p.Tables()
	}

	return localctx
}

// IRepairTableContext is an interface to support dynamic dispatch.
type IRepairTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetActionOption returns the actionOption token.
	GetActionOption() antlr.Token

	// SetActionOption sets the actionOption token.
	SetActionOption(antlr.Token)

	// Getter signatures
	REPAIR() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	Tables() ITablesContext
	QUICK() antlr.TerminalNode
	EXTENDED() antlr.TerminalNode
	USE_FRM() antlr.TerminalNode
	NO_WRITE_TO_BINLOG() antlr.TerminalNode
	LOCAL() antlr.TerminalNode

	// IsRepairTableContext differentiates from other interfaces.
	IsRepairTableContext()
}

type RepairTableContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	actionOption antlr.Token
}

func NewEmptyRepairTableContext() *RepairTableContext {
	var p = new(RepairTableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_repairTable
	return p
}

func (*RepairTableContext) IsRepairTableContext() {}

func NewRepairTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RepairTableContext {
	var p = new(RepairTableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_repairTable

	return p
}

func (s *RepairTableContext) GetParser() antlr.Parser { return s.parser }

func (s *RepairTableContext) GetActionOption() antlr.Token { return s.actionOption }

func (s *RepairTableContext) SetActionOption(v antlr.Token) { s.actionOption = v }

func (s *RepairTableContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPAIR, 0)
}

func (s *RepairTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *RepairTableContext) Tables() ITablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *RepairTableContext) QUICK() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUICK, 0)
}

func (s *RepairTableContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXTENDED, 0)
}

func (s *RepairTableContext) USE_FRM() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSE_FRM, 0)
}

func (s *RepairTableContext) NO_WRITE_TO_BINLOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserNO_WRITE_TO_BINLOG, 0)
}

func (s *RepairTableContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL, 0)
}

func (s *RepairTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RepairTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RepairTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRepairTable(s)
	}
}

func (s *RepairTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRepairTable(s)
	}
}

func (p *MySqlParser) RepairTable() (localctx IRepairTableContext) {
	this := p
	_ = this

	localctx = NewRepairTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 470, MySqlParserRULE_repairTable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5607)
		p.Match(MySqlParserREPAIR)
	}
	p.SetState(5609)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserNO_WRITE_TO_BINLOG || _la == MySqlParserLOCAL {
		{
			p.SetState(5608)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*RepairTableContext).actionOption = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserNO_WRITE_TO_BINLOG || _la == MySqlParserLOCAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*RepairTableContext).actionOption = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(5611)
		p.Match(MySqlParserTABLE)
	}
	{
		p.SetState(5612)
		p.Tables()
	}
	p.SetState(5614)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserQUICK {
		{
			p.SetState(5613)
			p.Match(MySqlParserQUICK)
		}

	}
	p.SetState(5617)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserEXTENDED {
		{
			p.SetState(5616)
			p.Match(MySqlParserEXTENDED)
		}

	}
	p.SetState(5620)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserUSE_FRM {
		{
			p.SetState(5619)
			p.Match(MySqlParserUSE_FRM)
		}

	}

	return localctx
}

// ICheckTableOptionContext is an interface to support dynamic dispatch.
type ICheckTableOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	UPGRADE() antlr.TerminalNode
	QUICK() antlr.TerminalNode
	FAST() antlr.TerminalNode
	MEDIUM() antlr.TerminalNode
	EXTENDED() antlr.TerminalNode
	CHANGED() antlr.TerminalNode

	// IsCheckTableOptionContext differentiates from other interfaces.
	IsCheckTableOptionContext()
}

type CheckTableOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCheckTableOptionContext() *CheckTableOptionContext {
	var p = new(CheckTableOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_checkTableOption
	return p
}

func (*CheckTableOptionContext) IsCheckTableOptionContext() {}

func NewCheckTableOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CheckTableOptionContext {
	var p = new(CheckTableOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_checkTableOption

	return p
}

func (s *CheckTableOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *CheckTableOptionContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *CheckTableOptionContext) UPGRADE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPGRADE, 0)
}

func (s *CheckTableOptionContext) QUICK() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUICK, 0)
}

func (s *CheckTableOptionContext) FAST() antlr.TerminalNode {
	return s.GetToken(MySqlParserFAST, 0)
}

func (s *CheckTableOptionContext) MEDIUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEDIUM, 0)
}

func (s *CheckTableOptionContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXTENDED, 0)
}

func (s *CheckTableOptionContext) CHANGED() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHANGED, 0)
}

func (s *CheckTableOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckTableOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CheckTableOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCheckTableOption(s)
	}
}

func (s *CheckTableOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCheckTableOption(s)
	}
}

func (p *MySqlParser) CheckTableOption() (localctx ICheckTableOptionContext) {
	this := p
	_ = this

	localctx = NewCheckTableOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 472, MySqlParserRULE_checkTableOption)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5629)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserFOR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5622)
			p.Match(MySqlParserFOR)
		}
		{
			p.SetState(5623)
			p.Match(MySqlParserUPGRADE)
		}

	case MySqlParserQUICK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5624)
			p.Match(MySqlParserQUICK)
		}

	case MySqlParserFAST:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5625)
			p.Match(MySqlParserFAST)
		}

	case MySqlParserMEDIUM:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5626)
			p.Match(MySqlParserMEDIUM)
		}

	case MySqlParserEXTENDED:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5627)
			p.Match(MySqlParserEXTENDED)
		}

	case MySqlParserCHANGED:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5628)
			p.Match(MySqlParserCHANGED)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICreateUdfunctionContext is an interface to support dynamic dispatch.
type ICreateUdfunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetReturnType returns the returnType token.
	GetReturnType() antlr.Token

	// SetReturnType sets the returnType token.
	SetReturnType(antlr.Token)

	// Getter signatures
	CREATE() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	Uid() IUidContext
	RETURNS() antlr.TerminalNode
	SONAME() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	STRING() antlr.TerminalNode
	INTEGER() antlr.TerminalNode
	REAL() antlr.TerminalNode
	DECIMAL() antlr.TerminalNode
	AGGREGATE() antlr.TerminalNode
	IfNotExists() IIfNotExistsContext

	// IsCreateUdfunctionContext differentiates from other interfaces.
	IsCreateUdfunctionContext()
}

type CreateUdfunctionContext struct {
	*antlr.BaseParserRuleContext
	parser     antlr.Parser
	returnType antlr.Token
}

func NewEmptyCreateUdfunctionContext() *CreateUdfunctionContext {
	var p = new(CreateUdfunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_createUdfunction
	return p
}

func (*CreateUdfunctionContext) IsCreateUdfunctionContext() {}

func NewCreateUdfunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateUdfunctionContext {
	var p = new(CreateUdfunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_createUdfunction

	return p
}

func (s *CreateUdfunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateUdfunctionContext) GetReturnType() antlr.Token { return s.returnType }

func (s *CreateUdfunctionContext) SetReturnType(v antlr.Token) { s.returnType = v }

func (s *CreateUdfunctionContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *CreateUdfunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserFUNCTION, 0)
}

func (s *CreateUdfunctionContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CreateUdfunctionContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(MySqlParserRETURNS, 0)
}

func (s *CreateUdfunctionContext) SONAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSONAME, 0)
}

func (s *CreateUdfunctionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *CreateUdfunctionContext) STRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING, 0)
}

func (s *CreateUdfunctionContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTEGER, 0)
}

func (s *CreateUdfunctionContext) REAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAL, 0)
}

func (s *CreateUdfunctionContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserDECIMAL, 0)
}

func (s *CreateUdfunctionContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserAGGREGATE, 0)
}

func (s *CreateUdfunctionContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateUdfunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUdfunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateUdfunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCreateUdfunction(s)
	}
}

func (s *CreateUdfunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCreateUdfunction(s)
	}
}

func (p *MySqlParser) CreateUdfunction() (localctx ICreateUdfunctionContext) {
	this := p
	_ = this

	localctx = NewCreateUdfunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 474, MySqlParserRULE_createUdfunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5631)
		p.Match(MySqlParserCREATE)
	}
	p.SetState(5633)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserAGGREGATE {
		{
			p.SetState(5632)
			p.Match(MySqlParserAGGREGATE)
		}

	}
	{
		p.SetState(5635)
		p.Match(MySqlParserFUNCTION)
	}
	p.SetState(5637)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 821, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5636)
			p.IfNotExists()
		}

	}
	{
		p.SetState(5639)
		p.Uid()
	}
	{
		p.SetState(5640)
		p.Match(MySqlParserRETURNS)
	}
	{
		p.SetState(5641)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*CreateUdfunctionContext).returnType = _lt

		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-206)) & ^0x3f) == 0 && ((int64(1)<<(_la-206))&261) != 0) || _la == MySqlParserSTRING) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*CreateUdfunctionContext).returnType = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5642)
		p.Match(MySqlParserSONAME)
	}
	{
		p.SetState(5643)
		p.Match(MySqlParserSTRING_LITERAL)
	}

	return localctx
}

// IInstallPluginContext is an interface to support dynamic dispatch.
type IInstallPluginContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INSTALL() antlr.TerminalNode
	PLUGIN() antlr.TerminalNode
	Uid() IUidContext
	SONAME() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsInstallPluginContext differentiates from other interfaces.
	IsInstallPluginContext()
}

type InstallPluginContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstallPluginContext() *InstallPluginContext {
	var p = new(InstallPluginContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_installPlugin
	return p
}

func (*InstallPluginContext) IsInstallPluginContext() {}

func NewInstallPluginContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstallPluginContext {
	var p = new(InstallPluginContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_installPlugin

	return p
}

func (s *InstallPluginContext) GetParser() antlr.Parser { return s.parser }

func (s *InstallPluginContext) INSTALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSTALL, 0)
}

func (s *InstallPluginContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserPLUGIN, 0)
}

func (s *InstallPluginContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *InstallPluginContext) SONAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSONAME, 0)
}

func (s *InstallPluginContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *InstallPluginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstallPluginContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstallPluginContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterInstallPlugin(s)
	}
}

func (s *InstallPluginContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitInstallPlugin(s)
	}
}

func (p *MySqlParser) InstallPlugin() (localctx IInstallPluginContext) {
	this := p
	_ = this

	localctx = NewInstallPluginContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 476, MySqlParserRULE_installPlugin)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5645)
		p.Match(MySqlParserINSTALL)
	}
	{
		p.SetState(5646)
		p.Match(MySqlParserPLUGIN)
	}
	{
		p.SetState(5647)
		p.Uid()
	}
	{
		p.SetState(5648)
		p.Match(MySqlParserSONAME)
	}
	{
		p.SetState(5649)
		p.Match(MySqlParserSTRING_LITERAL)
	}

	return localctx
}

// IUninstallPluginContext is an interface to support dynamic dispatch.
type IUninstallPluginContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNINSTALL() antlr.TerminalNode
	PLUGIN() antlr.TerminalNode
	Uid() IUidContext

	// IsUninstallPluginContext differentiates from other interfaces.
	IsUninstallPluginContext()
}

type UninstallPluginContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUninstallPluginContext() *UninstallPluginContext {
	var p = new(UninstallPluginContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_uninstallPlugin
	return p
}

func (*UninstallPluginContext) IsUninstallPluginContext() {}

func NewUninstallPluginContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UninstallPluginContext {
	var p = new(UninstallPluginContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_uninstallPlugin

	return p
}

func (s *UninstallPluginContext) GetParser() antlr.Parser { return s.parser }

func (s *UninstallPluginContext) UNINSTALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNINSTALL, 0)
}

func (s *UninstallPluginContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserPLUGIN, 0)
}

func (s *UninstallPluginContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *UninstallPluginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UninstallPluginContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UninstallPluginContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUninstallPlugin(s)
	}
}

func (s *UninstallPluginContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUninstallPlugin(s)
	}
}

func (p *MySqlParser) UninstallPlugin() (localctx IUninstallPluginContext) {
	this := p
	_ = this

	localctx = NewUninstallPluginContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 478, MySqlParserRULE_uninstallPlugin)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5651)
		p.Match(MySqlParserUNINSTALL)
	}
	{
		p.SetState(5652)
		p.Match(MySqlParserPLUGIN)
	}
	{
		p.SetState(5653)
		p.Uid()
	}

	return localctx
}

// ISetStatementContext is an interface to support dynamic dispatch.
type ISetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSetStatementContext differentiates from other interfaces.
	IsSetStatementContext()
}

type SetStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetStatementContext() *SetStatementContext {
	var p = new(SetStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_setStatement
	return p
}

func (*SetStatementContext) IsSetStatementContext() {}

func NewSetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetStatementContext {
	var p = new(SetStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_setStatement

	return p
}

func (s *SetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetStatementContext) CopyFrom(ctx *SetStatementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *SetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SetTransactionContext struct {
	*SetStatementContext
}

func NewSetTransactionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetTransactionContext {
	var p = new(SetTransactionContext)

	p.SetStatementContext = NewEmptySetStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SetStatementContext))

	return p
}

func (s *SetTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetTransactionContext) SetTransactionStatement() ISetTransactionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetTransactionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetTransactionStatementContext)
}

func (s *SetTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSetTransaction(s)
	}
}

func (s *SetTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSetTransaction(s)
	}
}

type SetCharsetContext struct {
	*SetStatementContext
}

func NewSetCharsetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetCharsetContext {
	var p = new(SetCharsetContext)

	p.SetStatementContext = NewEmptySetStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SetStatementContext))

	return p
}

func (s *SetCharsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetCharsetContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *SetCharsetContext) CharSet() ICharSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharSetContext)
}

func (s *SetCharsetContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *SetCharsetContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *SetCharsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSetCharset(s)
	}
}

func (s *SetCharsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSetCharset(s)
	}
}

type SetNamesContext struct {
	*SetStatementContext
}

func NewSetNamesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetNamesContext {
	var p = new(SetNamesContext)

	p.SetStatementContext = NewEmptySetStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SetStatementContext))

	return p
}

func (s *SetNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetNamesContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *SetNamesContext) NAMES() antlr.TerminalNode {
	return s.GetToken(MySqlParserNAMES, 0)
}

func (s *SetNamesContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *SetNamesContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *SetNamesContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATE, 0)
}

func (s *SetNamesContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *SetNamesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSetNames(s)
	}
}

func (s *SetNamesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSetNames(s)
	}
}

type SetPasswordContext struct {
	*SetStatementContext
}

func NewSetPasswordContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetPasswordContext {
	var p = new(SetPasswordContext)

	p.SetStatementContext = NewEmptySetStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SetStatementContext))

	return p
}

func (s *SetPasswordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetPasswordContext) SetPasswordStatement() ISetPasswordStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetPasswordStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetPasswordStatementContext)
}

func (s *SetPasswordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSetPassword(s)
	}
}

func (s *SetPasswordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSetPassword(s)
	}
}

type SetAutocommitContext struct {
	*SetStatementContext
}

func NewSetAutocommitContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetAutocommitContext {
	var p = new(SetAutocommitContext)

	p.SetStatementContext = NewEmptySetStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SetStatementContext))

	return p
}

func (s *SetAutocommitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetAutocommitContext) SetAutocommitStatement() ISetAutocommitStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetAutocommitStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetAutocommitStatementContext)
}

func (s *SetAutocommitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSetAutocommit(s)
	}
}

func (s *SetAutocommitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSetAutocommit(s)
	}
}

type SetNewValueInsideTriggerContext struct {
	*SetStatementContext
}

func NewSetNewValueInsideTriggerContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetNewValueInsideTriggerContext {
	var p = new(SetNewValueInsideTriggerContext)

	p.SetStatementContext = NewEmptySetStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SetStatementContext))

	return p
}

func (s *SetNewValueInsideTriggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetNewValueInsideTriggerContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *SetNewValueInsideTriggerContext) AllFullId() []IFullIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFullIdContext); ok {
			len++
		}
	}

	tst := make([]IFullIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFullIdContext); ok {
			tst[i] = t.(IFullIdContext)
			i++
		}
	}

	return tst
}

func (s *SetNewValueInsideTriggerContext) FullId(i int) IFullIdContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *SetNewValueInsideTriggerContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SetNewValueInsideTriggerContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetNewValueInsideTriggerContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *SetNewValueInsideTriggerContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *SetNewValueInsideTriggerContext) AllVAR_ASSIGN() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserVAR_ASSIGN)
}

func (s *SetNewValueInsideTriggerContext) VAR_ASSIGN(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserVAR_ASSIGN, i)
}

func (s *SetNewValueInsideTriggerContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *SetNewValueInsideTriggerContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *SetNewValueInsideTriggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSetNewValueInsideTrigger(s)
	}
}

func (s *SetNewValueInsideTriggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSetNewValueInsideTrigger(s)
	}
}

type SetVariableContext struct {
	*SetStatementContext
}

func NewSetVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetVariableContext {
	var p = new(SetVariableContext)

	p.SetStatementContext = NewEmptySetStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SetStatementContext))

	return p
}

func (s *SetVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetVariableContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *SetVariableContext) AllVariableClause() []IVariableClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableClauseContext); ok {
			len++
		}
	}

	tst := make([]IVariableClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableClauseContext); ok {
			tst[i] = t.(IVariableClauseContext)
			i++
		}
	}

	return tst
}

func (s *SetVariableContext) VariableClause(i int) IVariableClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableClauseContext)
}

func (s *SetVariableContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *SetVariableContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *SetVariableContext) AllVAR_ASSIGN() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserVAR_ASSIGN)
}

func (s *SetVariableContext) VAR_ASSIGN(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserVAR_ASSIGN, i)
}

func (s *SetVariableContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SetVariableContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetVariableContext) AllON() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserON)
}

func (s *SetVariableContext) ON(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserON, i)
}

func (s *SetVariableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *SetVariableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *SetVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSetVariable(s)
	}
}

func (s *SetVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSetVariable(s)
	}
}

func (p *MySqlParser) SetStatement() (localctx ISetStatementContext) {
	this := p
	_ = this

	localctx = NewSetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 480, MySqlParserRULE_setStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5707)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 829, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSetVariableContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5655)
			p.Match(MySqlParserSET)
		}
		{
			p.SetState(5656)
			p.VariableClause()
		}
		{
			p.SetState(5657)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserVAR_ASSIGN || _la == MySqlParserEQUAL_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(5660)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 822, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5658)
				p.expression(0)
			}

		case 2:
			{
				p.SetState(5659)
				p.Match(MySqlParserON)
			}

		}
		p.SetState(5671)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(5662)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(5663)
				p.VariableClause()
			}
			{
				p.SetState(5664)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserVAR_ASSIGN || _la == MySqlParserEQUAL_SYMBOL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			p.SetState(5667)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 823, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(5665)
					p.expression(0)
				}

			case 2:
				{
					p.SetState(5666)
					p.Match(MySqlParserON)
				}

			}

			p.SetState(5673)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewSetCharsetContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5674)
			p.Match(MySqlParserSET)
		}
		{
			p.SetState(5675)
			p.CharSet()
		}
		p.SetState(5678)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserBINARY, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL:
			{
				p.SetState(5676)
				p.CharsetName()
			}

		case MySqlParserDEFAULT:
			{
				p.SetState(5677)
				p.Match(MySqlParserDEFAULT)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 3:
		localctx = NewSetNamesContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5680)
			p.Match(MySqlParserSET)
		}
		{
			p.SetState(5681)
			p.Match(MySqlParserNAMES)
		}
		p.SetState(5688)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserBINARY, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL:
			{
				p.SetState(5682)
				p.CharsetName()
			}
			p.SetState(5685)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserCOLLATE {
				{
					p.SetState(5683)
					p.Match(MySqlParserCOLLATE)
				}
				{
					p.SetState(5684)
					p.CollationName()
				}

			}

		case MySqlParserDEFAULT:
			{
				p.SetState(5687)
				p.Match(MySqlParserDEFAULT)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 4:
		localctx = NewSetPasswordContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5690)
			p.SetPasswordStatement()
		}

	case 5:
		localctx = NewSetTransactionContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5691)
			p.SetTransactionStatement()
		}

	case 6:
		localctx = NewSetAutocommitContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5692)
			p.SetAutocommitStatement()
		}

	case 7:
		localctx = NewSetNewValueInsideTriggerContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5693)
			p.Match(MySqlParserSET)
		}
		{
			p.SetState(5694)
			p.FullId()
		}
		{
			p.SetState(5695)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserVAR_ASSIGN || _la == MySqlParserEQUAL_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5696)
			p.expression(0)
		}
		p.SetState(5704)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(5697)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(5698)
				p.FullId()
			}
			{
				p.SetState(5699)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserVAR_ASSIGN || _la == MySqlParserEQUAL_SYMBOL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(5700)
				p.expression(0)
			}

			p.SetState(5706)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IShowStatementContext is an interface to support dynamic dispatch.
type IShowStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsShowStatementContext differentiates from other interfaces.
	IsShowStatementContext()
}

type ShowStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowStatementContext() *ShowStatementContext {
	var p = new(ShowStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_showStatement
	return p
}

func (*ShowStatementContext) IsShowStatementContext() {}

func NewShowStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowStatementContext {
	var p = new(ShowStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_showStatement

	return p
}

func (s *ShowStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowStatementContext) CopyFrom(ctx *ShowStatementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ShowStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ShowOpenTablesContext struct {
	*ShowStatementContext
	schemaFormat antlr.Token
}

func NewShowOpenTablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowOpenTablesContext {
	var p = new(ShowOpenTablesContext)

	p.ShowStatementContext = NewEmptyShowStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowOpenTablesContext) GetSchemaFormat() antlr.Token { return s.schemaFormat }

func (s *ShowOpenTablesContext) SetSchemaFormat(v antlr.Token) { s.schemaFormat = v }

func (s *ShowOpenTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowOpenTablesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowOpenTablesContext) OPEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPEN, 0)
}

func (s *ShowOpenTablesContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLES, 0)
}

func (s *ShowOpenTablesContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ShowOpenTablesContext) ShowFilter() IShowFilterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowFilterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowFilterContext)
}

func (s *ShowOpenTablesContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *ShowOpenTablesContext) IN() antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, 0)
}

func (s *ShowOpenTablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowOpenTables(s)
	}
}

func (s *ShowOpenTablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowOpenTables(s)
	}
}

type ShowGlobalInfoContext struct {
	*ShowStatementContext
}

func NewShowGlobalInfoContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowGlobalInfoContext {
	var p = new(ShowGlobalInfoContext)

	p.ShowStatementContext = NewEmptyShowStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowGlobalInfoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowGlobalInfoContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowGlobalInfoContext) ShowGlobalInfoClause() IShowGlobalInfoClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowGlobalInfoClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowGlobalInfoClauseContext)
}

func (s *ShowGlobalInfoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowGlobalInfo(s)
	}
}

func (s *ShowGlobalInfoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowGlobalInfo(s)
	}
}

type ShowCreateFullIdObjectContext struct {
	*ShowStatementContext
	namedEntity antlr.Token
}

func NewShowCreateFullIdObjectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateFullIdObjectContext {
	var p = new(ShowCreateFullIdObjectContext)

	p.ShowStatementContext = NewEmptyShowStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowCreateFullIdObjectContext) GetNamedEntity() antlr.Token { return s.namedEntity }

func (s *ShowCreateFullIdObjectContext) SetNamedEntity(v antlr.Token) { s.namedEntity = v }

func (s *ShowCreateFullIdObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateFullIdObjectContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowCreateFullIdObjectContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *ShowCreateFullIdObjectContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *ShowCreateFullIdObjectContext) EVENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVENT, 0)
}

func (s *ShowCreateFullIdObjectContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserFUNCTION, 0)
}

func (s *ShowCreateFullIdObjectContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROCEDURE, 0)
}

func (s *ShowCreateFullIdObjectContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *ShowCreateFullIdObjectContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRIGGER, 0)
}

func (s *ShowCreateFullIdObjectContext) VIEW() antlr.TerminalNode {
	return s.GetToken(MySqlParserVIEW, 0)
}

func (s *ShowCreateFullIdObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowCreateFullIdObject(s)
	}
}

func (s *ShowCreateFullIdObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowCreateFullIdObject(s)
	}
}

type ShowCreateUserContext struct {
	*ShowStatementContext
}

func NewShowCreateUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateUserContext {
	var p = new(ShowCreateUserContext)

	p.ShowStatementContext = NewEmptyShowStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowCreateUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateUserContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowCreateUserContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *ShowCreateUserContext) USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER, 0)
}

func (s *ShowCreateUserContext) UserName() IUserNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *ShowCreateUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowCreateUser(s)
	}
}

func (s *ShowCreateUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowCreateUser(s)
	}
}

type ShowErrorsContext struct {
	*ShowStatementContext
	errorFormat antlr.Token
	offset      IDecimalLiteralContext
	rowCount    IDecimalLiteralContext
}

func NewShowErrorsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowErrorsContext {
	var p = new(ShowErrorsContext)

	p.ShowStatementContext = NewEmptyShowStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowErrorsContext) GetErrorFormat() antlr.Token { return s.errorFormat }

func (s *ShowErrorsContext) SetErrorFormat(v antlr.Token) { s.errorFormat = v }

func (s *ShowErrorsContext) GetOffset() IDecimalLiteralContext { return s.offset }

func (s *ShowErrorsContext) GetRowCount() IDecimalLiteralContext { return s.rowCount }

func (s *ShowErrorsContext) SetOffset(v IDecimalLiteralContext) { s.offset = v }

func (s *ShowErrorsContext) SetRowCount(v IDecimalLiteralContext) { s.rowCount = v }

func (s *ShowErrorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowErrorsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowErrorsContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(MySqlParserERRORS, 0)
}

func (s *ShowErrorsContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(MySqlParserWARNINGS, 0)
}

func (s *ShowErrorsContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIMIT, 0)
}

func (s *ShowErrorsContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *ShowErrorsContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *ShowErrorsContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *ShowErrorsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowErrors(s)
	}
}

func (s *ShowErrorsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowErrors(s)
	}
}

type ShowCountErrorsContext struct {
	*ShowStatementContext
	errorFormat antlr.Token
}

func NewShowCountErrorsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCountErrorsContext {
	var p = new(ShowCountErrorsContext)

	p.ShowStatementContext = NewEmptyShowStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowCountErrorsContext) GetErrorFormat() antlr.Token { return s.errorFormat }

func (s *ShowCountErrorsContext) SetErrorFormat(v antlr.Token) { s.errorFormat = v }

func (s *ShowCountErrorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCountErrorsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowCountErrorsContext) COUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOUNT, 0)
}

func (s *ShowCountErrorsContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *ShowCountErrorsContext) STAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTAR, 0)
}

func (s *ShowCountErrorsContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *ShowCountErrorsContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(MySqlParserERRORS, 0)
}

func (s *ShowCountErrorsContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(MySqlParserWARNINGS, 0)
}

func (s *ShowCountErrorsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowCountErrors(s)
	}
}

func (s *ShowCountErrorsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowCountErrors(s)
	}
}

type ShowObjectFilterContext struct {
	*ShowStatementContext
}

func NewShowObjectFilterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowObjectFilterContext {
	var p = new(ShowObjectFilterContext)

	p.ShowStatementContext = NewEmptyShowStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowObjectFilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowObjectFilterContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowObjectFilterContext) ShowCommonEntity() IShowCommonEntityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCommonEntityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCommonEntityContext)
}

func (s *ShowObjectFilterContext) ShowFilter() IShowFilterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowFilterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowFilterContext)
}

func (s *ShowObjectFilterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowObjectFilter(s)
	}
}

func (s *ShowObjectFilterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowObjectFilter(s)
	}
}

type ShowCreateDbContext struct {
	*ShowStatementContext
	schemaFormat antlr.Token
}

func NewShowCreateDbContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateDbContext {
	var p = new(ShowCreateDbContext)

	p.ShowStatementContext = NewEmptyShowStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowCreateDbContext) GetSchemaFormat() antlr.Token { return s.schemaFormat }

func (s *ShowCreateDbContext) SetSchemaFormat(v antlr.Token) { s.schemaFormat = v }

func (s *ShowCreateDbContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateDbContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowCreateDbContext) CREATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE, 0)
}

func (s *ShowCreateDbContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ShowCreateDbContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATABASE, 0)
}

func (s *ShowCreateDbContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEMA, 0)
}

func (s *ShowCreateDbContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *ShowCreateDbContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowCreateDb(s)
	}
}

func (s *ShowCreateDbContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowCreateDb(s)
	}
}

type ShowEngineContext struct {
	*ShowStatementContext
	engineOption antlr.Token
}

func NewShowEngineContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowEngineContext {
	var p = new(ShowEngineContext)

	p.ShowStatementContext = NewEmptyShowStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowEngineContext) GetEngineOption() antlr.Token { return s.engineOption }

func (s *ShowEngineContext) SetEngineOption(v antlr.Token) { s.engineOption = v }

func (s *ShowEngineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowEngineContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowEngineContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE, 0)
}

func (s *ShowEngineContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *ShowEngineContext) STATUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATUS, 0)
}

func (s *ShowEngineContext) MUTEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserMUTEX, 0)
}

func (s *ShowEngineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowEngine(s)
	}
}

func (s *ShowEngineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowEngine(s)
	}
}

type ShowSchemaFilterContext struct {
	*ShowStatementContext
	schemaFormat antlr.Token
}

func NewShowSchemaFilterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowSchemaFilterContext {
	var p = new(ShowSchemaFilterContext)

	p.ShowStatementContext = NewEmptyShowStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowSchemaFilterContext) GetSchemaFormat() antlr.Token { return s.schemaFormat }

func (s *ShowSchemaFilterContext) SetSchemaFormat(v antlr.Token) { s.schemaFormat = v }

func (s *ShowSchemaFilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSchemaFilterContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowSchemaFilterContext) ShowSchemaEntity() IShowSchemaEntityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowSchemaEntityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowSchemaEntityContext)
}

func (s *ShowSchemaFilterContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ShowSchemaFilterContext) ShowFilter() IShowFilterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowFilterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowFilterContext)
}

func (s *ShowSchemaFilterContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *ShowSchemaFilterContext) IN() antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, 0)
}

func (s *ShowSchemaFilterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowSchemaFilter(s)
	}
}

func (s *ShowSchemaFilterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowSchemaFilter(s)
	}
}

type ShowIndexesContext struct {
	*ShowStatementContext
	indexFormat  antlr.Token
	tableFormat  antlr.Token
	schemaFormat antlr.Token
}

func NewShowIndexesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowIndexesContext {
	var p = new(ShowIndexesContext)

	p.ShowStatementContext = NewEmptyShowStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowIndexesContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *ShowIndexesContext) GetTableFormat() antlr.Token { return s.tableFormat }

func (s *ShowIndexesContext) GetSchemaFormat() antlr.Token { return s.schemaFormat }

func (s *ShowIndexesContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *ShowIndexesContext) SetTableFormat(v antlr.Token) { s.tableFormat = v }

func (s *ShowIndexesContext) SetSchemaFormat(v antlr.Token) { s.schemaFormat = v }

func (s *ShowIndexesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowIndexesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowIndexesContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *ShowIndexesContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *ShowIndexesContext) INDEXES() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEXES, 0)
}

func (s *ShowIndexesContext) KEYS() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEYS, 0)
}

func (s *ShowIndexesContext) AllFROM() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserFROM)
}

func (s *ShowIndexesContext) FROM(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, i)
}

func (s *ShowIndexesContext) AllIN() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserIN)
}

func (s *ShowIndexesContext) IN(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, i)
}

func (s *ShowIndexesContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ShowIndexesContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWHERE, 0)
}

func (s *ShowIndexesContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowIndexesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowIndexes(s)
	}
}

func (s *ShowIndexesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowIndexes(s)
	}
}

type ShowLogEventsContext struct {
	*ShowStatementContext
	logFormat    antlr.Token
	filename     antlr.Token
	fromPosition IDecimalLiteralContext
	offset       IDecimalLiteralContext
	rowCount     IDecimalLiteralContext
}

func NewShowLogEventsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowLogEventsContext {
	var p = new(ShowLogEventsContext)

	p.ShowStatementContext = NewEmptyShowStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowLogEventsContext) GetLogFormat() antlr.Token { return s.logFormat }

func (s *ShowLogEventsContext) GetFilename() antlr.Token { return s.filename }

func (s *ShowLogEventsContext) SetLogFormat(v antlr.Token) { s.logFormat = v }

func (s *ShowLogEventsContext) SetFilename(v antlr.Token) { s.filename = v }

func (s *ShowLogEventsContext) GetFromPosition() IDecimalLiteralContext { return s.fromPosition }

func (s *ShowLogEventsContext) GetOffset() IDecimalLiteralContext { return s.offset }

func (s *ShowLogEventsContext) GetRowCount() IDecimalLiteralContext { return s.rowCount }

func (s *ShowLogEventsContext) SetFromPosition(v IDecimalLiteralContext) { s.fromPosition = v }

func (s *ShowLogEventsContext) SetOffset(v IDecimalLiteralContext) { s.offset = v }

func (s *ShowLogEventsContext) SetRowCount(v IDecimalLiteralContext) { s.rowCount = v }

func (s *ShowLogEventsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowLogEventsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowLogEventsContext) EVENTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVENTS, 0)
}

func (s *ShowLogEventsContext) BINLOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINLOG, 0)
}

func (s *ShowLogEventsContext) RELAYLOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELAYLOG, 0)
}

func (s *ShowLogEventsContext) IN() antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, 0)
}

func (s *ShowLogEventsContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *ShowLogEventsContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIMIT, 0)
}

func (s *ShowLogEventsContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *ShowLogEventsContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *ShowLogEventsContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *ShowLogEventsContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *ShowLogEventsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowLogEvents(s)
	}
}

func (s *ShowLogEventsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowLogEvents(s)
	}
}

type ShowMasterLogsContext struct {
	*ShowStatementContext
	logFormat antlr.Token
}

func NewShowMasterLogsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowMasterLogsContext {
	var p = new(ShowMasterLogsContext)

	p.ShowStatementContext = NewEmptyShowStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowMasterLogsContext) GetLogFormat() antlr.Token { return s.logFormat }

func (s *ShowMasterLogsContext) SetLogFormat(v antlr.Token) { s.logFormat = v }

func (s *ShowMasterLogsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowMasterLogsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowMasterLogsContext) LOGS() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOGS, 0)
}

func (s *ShowMasterLogsContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *ShowMasterLogsContext) MASTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER, 0)
}

func (s *ShowMasterLogsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowMasterLogs(s)
	}
}

func (s *ShowMasterLogsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowMasterLogs(s)
	}
}

type ShowGrantsContext struct {
	*ShowStatementContext
}

func NewShowGrantsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowGrantsContext {
	var p = new(ShowGrantsContext)

	p.ShowStatementContext = NewEmptyShowStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowGrantsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowGrantsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowGrantsContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserGRANTS, 0)
}

func (s *ShowGrantsContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *ShowGrantsContext) UserName() IUserNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *ShowGrantsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowGrants(s)
	}
}

func (s *ShowGrantsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowGrants(s)
	}
}

type ShowSlaveStatusContext struct {
	*ShowStatementContext
}

func NewShowSlaveStatusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowSlaveStatusContext {
	var p = new(ShowSlaveStatusContext)

	p.ShowStatementContext = NewEmptyShowStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowSlaveStatusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSlaveStatusContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowSlaveStatusContext) SLAVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSLAVE, 0)
}

func (s *ShowSlaveStatusContext) STATUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATUS, 0)
}

func (s *ShowSlaveStatusContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *ShowSlaveStatusContext) CHANNEL() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHANNEL, 0)
}

func (s *ShowSlaveStatusContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *ShowSlaveStatusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowSlaveStatus(s)
	}
}

func (s *ShowSlaveStatusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowSlaveStatus(s)
	}
}

type ShowRoutineContext struct {
	*ShowStatementContext
	routine antlr.Token
}

func NewShowRoutineContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowRoutineContext {
	var p = new(ShowRoutineContext)

	p.ShowStatementContext = NewEmptyShowStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowRoutineContext) GetRoutine() antlr.Token { return s.routine }

func (s *ShowRoutineContext) SetRoutine(v antlr.Token) { s.routine = v }

func (s *ShowRoutineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRoutineContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowRoutineContext) CODE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCODE, 0)
}

func (s *ShowRoutineContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *ShowRoutineContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserFUNCTION, 0)
}

func (s *ShowRoutineContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROCEDURE, 0)
}

func (s *ShowRoutineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowRoutine(s)
	}
}

func (s *ShowRoutineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowRoutine(s)
	}
}

type ShowProfileContext struct {
	*ShowStatementContext
	queryCount IDecimalLiteralContext
	offset     IDecimalLiteralContext
	rowCount   IDecimalLiteralContext
}

func NewShowProfileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowProfileContext {
	var p = new(ShowProfileContext)

	p.ShowStatementContext = NewEmptyShowStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowProfileContext) GetQueryCount() IDecimalLiteralContext { return s.queryCount }

func (s *ShowProfileContext) GetOffset() IDecimalLiteralContext { return s.offset }

func (s *ShowProfileContext) GetRowCount() IDecimalLiteralContext { return s.rowCount }

func (s *ShowProfileContext) SetQueryCount(v IDecimalLiteralContext) { s.queryCount = v }

func (s *ShowProfileContext) SetOffset(v IDecimalLiteralContext) { s.offset = v }

func (s *ShowProfileContext) SetRowCount(v IDecimalLiteralContext) { s.rowCount = v }

func (s *ShowProfileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowProfileContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowProfileContext) PROFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROFILE, 0)
}

func (s *ShowProfileContext) AllShowProfileType() []IShowProfileTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IShowProfileTypeContext); ok {
			len++
		}
	}

	tst := make([]IShowProfileTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IShowProfileTypeContext); ok {
			tst[i] = t.(IShowProfileTypeContext)
			i++
		}
	}

	return tst
}

func (s *ShowProfileContext) ShowProfileType(i int) IShowProfileTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowProfileTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowProfileTypeContext)
}

func (s *ShowProfileContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIMIT, 0)
}

func (s *ShowProfileContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *ShowProfileContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *ShowProfileContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *ShowProfileContext) QUERY() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUERY, 0)
}

func (s *ShowProfileContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *ShowProfileContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *ShowProfileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowProfile(s)
	}
}

func (s *ShowProfileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowProfile(s)
	}
}

type ShowColumnsContext struct {
	*ShowStatementContext
	columnsFormat antlr.Token
	tableFormat   antlr.Token
	schemaFormat  antlr.Token
}

func NewShowColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowColumnsContext {
	var p = new(ShowColumnsContext)

	p.ShowStatementContext = NewEmptyShowStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ShowStatementContext))

	return p
}

func (s *ShowColumnsContext) GetColumnsFormat() antlr.Token { return s.columnsFormat }

func (s *ShowColumnsContext) GetTableFormat() antlr.Token { return s.tableFormat }

func (s *ShowColumnsContext) GetSchemaFormat() antlr.Token { return s.schemaFormat }

func (s *ShowColumnsContext) SetColumnsFormat(v antlr.Token) { s.columnsFormat = v }

func (s *ShowColumnsContext) SetTableFormat(v antlr.Token) { s.tableFormat = v }

func (s *ShowColumnsContext) SetSchemaFormat(v antlr.Token) { s.schemaFormat = v }

func (s *ShowColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowColumnsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW, 0)
}

func (s *ShowColumnsContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *ShowColumnsContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMNS, 0)
}

func (s *ShowColumnsContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIELDS, 0)
}

func (s *ShowColumnsContext) AllFROM() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserFROM)
}

func (s *ShowColumnsContext) FROM(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, i)
}

func (s *ShowColumnsContext) AllIN() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserIN)
}

func (s *ShowColumnsContext) IN(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, i)
}

func (s *ShowColumnsContext) FULL() antlr.TerminalNode {
	return s.GetToken(MySqlParserFULL, 0)
}

func (s *ShowColumnsContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *ShowColumnsContext) ShowFilter() IShowFilterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowFilterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowFilterContext)
}

func (s *ShowColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowColumns(s)
	}
}

func (s *ShowColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowColumns(s)
	}
}

func (p *MySqlParser) ShowStatement() (localctx IShowStatementContext) {
	this := p
	_ = this

	localctx = NewShowStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 482, MySqlParserRULE_showStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5862)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 852, p.GetParserRuleContext()) {
	case 1:
		localctx = NewShowMasterLogsContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5709)
			p.Match(MySqlParserSHOW)
		}
		{
			p.SetState(5710)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowMasterLogsContext).logFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserBINARY || _la == MySqlParserMASTER) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowMasterLogsContext).logFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5711)
			p.Match(MySqlParserLOGS)
		}

	case 2:
		localctx = NewShowLogEventsContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5712)
			p.Match(MySqlParserSHOW)
		}
		{
			p.SetState(5713)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowLogEventsContext).logFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserBINLOG || _la == MySqlParserRELAYLOG) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowLogEventsContext).logFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5714)
			p.Match(MySqlParserEVENTS)
		}
		p.SetState(5717)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserIN {
			{
				p.SetState(5715)
				p.Match(MySqlParserIN)
			}
			{
				p.SetState(5716)

				var _m = p.Match(MySqlParserSTRING_LITERAL)

				localctx.(*ShowLogEventsContext).filename = _m
			}

		}
		p.SetState(5721)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserFROM {
			{
				p.SetState(5719)
				p.Match(MySqlParserFROM)
			}
			{
				p.SetState(5720)

				var _x = p.DecimalLiteral()

				localctx.(*ShowLogEventsContext).fromPosition = _x
			}

		}
		p.SetState(5730)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLIMIT {
			{
				p.SetState(5723)
				p.Match(MySqlParserLIMIT)
			}
			p.SetState(5727)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 832, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(5724)

					var _x = p.DecimalLiteral()

					localctx.(*ShowLogEventsContext).offset = _x
				}
				{
					p.SetState(5725)
					p.Match(MySqlParserCOMMA)
				}

			}
			{
				p.SetState(5729)

				var _x = p.DecimalLiteral()

				localctx.(*ShowLogEventsContext).rowCount = _x
			}

		}

	case 3:
		localctx = NewShowObjectFilterContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5732)
			p.Match(MySqlParserSHOW)
		}
		{
			p.SetState(5733)
			p.ShowCommonEntity()
		}
		p.SetState(5735)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLIKE || _la == MySqlParserWHERE {
			{
				p.SetState(5734)
				p.ShowFilter()
			}

		}

	case 4:
		localctx = NewShowColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5737)
			p.Match(MySqlParserSHOW)
		}
		p.SetState(5739)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserFULL {
			{
				p.SetState(5738)
				p.Match(MySqlParserFULL)
			}

		}
		{
			p.SetState(5741)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowColumnsContext).columnsFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCOLUMNS || _la == MySqlParserFIELDS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowColumnsContext).columnsFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5742)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowColumnsContext).tableFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFROM || _la == MySqlParserIN) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowColumnsContext).tableFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5743)
			p.TableName()
		}
		p.SetState(5746)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserFROM || _la == MySqlParserIN {
			{
				p.SetState(5744)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*ShowColumnsContext).schemaFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserFROM || _la == MySqlParserIN) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*ShowColumnsContext).schemaFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(5745)
				p.Uid()
			}

		}
		p.SetState(5749)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLIKE || _la == MySqlParserWHERE {
			{
				p.SetState(5748)
				p.ShowFilter()
			}

		}

	case 5:
		localctx = NewShowCreateDbContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5751)
			p.Match(MySqlParserSHOW)
		}
		{
			p.SetState(5752)
			p.Match(MySqlParserCREATE)
		}
		{
			p.SetState(5753)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowCreateDbContext).schemaFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserDATABASE || _la == MySqlParserSCHEMA) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowCreateDbContext).schemaFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(5755)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 838, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5754)
				p.IfNotExists()
			}

		}
		{
			p.SetState(5757)
			p.Uid()
		}

	case 6:
		localctx = NewShowCreateFullIdObjectContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5758)
			p.Match(MySqlParserSHOW)
		}
		{
			p.SetState(5759)
			p.Match(MySqlParserCREATE)
		}
		{
			p.SetState(5760)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowCreateFullIdObjectContext).namedEntity = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la-131)) & ^0x3f) == 0 && ((int64(1)<<(_la-131))&72567767433217) != 0) || _la == MySqlParserEVENT || _la == MySqlParserFUNCTION || _la == MySqlParserVIEW) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowCreateFullIdObjectContext).namedEntity = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5761)
			p.FullId()
		}

	case 7:
		localctx = NewShowCreateUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5762)
			p.Match(MySqlParserSHOW)
		}
		{
			p.SetState(5763)
			p.Match(MySqlParserCREATE)
		}
		{
			p.SetState(5764)
			p.Match(MySqlParserUSER)
		}
		{
			p.SetState(5765)
			p.UserName()
		}

	case 8:
		localctx = NewShowEngineContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5766)
			p.Match(MySqlParserSHOW)
		}
		{
			p.SetState(5767)
			p.Match(MySqlParserENGINE)
		}
		{
			p.SetState(5768)
			p.EngineName()
		}
		{
			p.SetState(5769)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowEngineContext).engineOption = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserMUTEX || _la == MySqlParserSTATUS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowEngineContext).engineOption = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 9:
		localctx = NewShowGlobalInfoContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5771)
			p.Match(MySqlParserSHOW)
		}
		{
			p.SetState(5772)
			p.ShowGlobalInfoClause()
		}

	case 10:
		localctx = NewShowErrorsContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(5773)
			p.Match(MySqlParserSHOW)
		}
		{
			p.SetState(5774)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowErrorsContext).errorFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserERRORS || _la == MySqlParserWARNINGS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowErrorsContext).errorFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(5782)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLIMIT {
			{
				p.SetState(5775)
				p.Match(MySqlParserLIMIT)
			}
			p.SetState(5779)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 839, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(5776)

					var _x = p.DecimalLiteral()

					localctx.(*ShowErrorsContext).offset = _x
				}
				{
					p.SetState(5777)
					p.Match(MySqlParserCOMMA)
				}

			}
			{
				p.SetState(5781)

				var _x = p.DecimalLiteral()

				localctx.(*ShowErrorsContext).rowCount = _x
			}

		}

	case 11:
		localctx = NewShowCountErrorsContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(5784)
			p.Match(MySqlParserSHOW)
		}
		{
			p.SetState(5785)
			p.Match(MySqlParserCOUNT)
		}
		{
			p.SetState(5786)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(5787)
			p.Match(MySqlParserSTAR)
		}
		{
			p.SetState(5788)
			p.Match(MySqlParserRR_BRACKET)
		}
		{
			p.SetState(5789)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowCountErrorsContext).errorFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserERRORS || _la == MySqlParserWARNINGS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowCountErrorsContext).errorFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 12:
		localctx = NewShowSchemaFilterContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(5790)
			p.Match(MySqlParserSHOW)
		}
		{
			p.SetState(5791)
			p.ShowSchemaEntity()
		}
		p.SetState(5794)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserFROM || _la == MySqlParserIN {
			{
				p.SetState(5792)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*ShowSchemaFilterContext).schemaFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserFROM || _la == MySqlParserIN) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*ShowSchemaFilterContext).schemaFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(5793)
				p.Uid()
			}

		}
		p.SetState(5797)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLIKE || _la == MySqlParserWHERE {
			{
				p.SetState(5796)
				p.ShowFilter()
			}

		}

	case 13:
		localctx = NewShowRoutineContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(5799)
			p.Match(MySqlParserSHOW)
		}
		{
			p.SetState(5800)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowRoutineContext).routine = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserPROCEDURE || _la == MySqlParserFUNCTION) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowRoutineContext).routine = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5801)
			p.Match(MySqlParserCODE)
		}
		{
			p.SetState(5802)
			p.FullId()
		}

	case 14:
		localctx = NewShowGrantsContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(5803)
			p.Match(MySqlParserSHOW)
		}
		{
			p.SetState(5804)
			p.Match(MySqlParserGRANTS)
		}
		p.SetState(5807)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserFOR {
			{
				p.SetState(5805)
				p.Match(MySqlParserFOR)
			}
			{
				p.SetState(5806)
				p.UserName()
			}

		}

	case 15:
		localctx = NewShowIndexesContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(5809)
			p.Match(MySqlParserSHOW)
		}
		{
			p.SetState(5810)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowIndexesContext).indexFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserINDEX || _la == MySqlParserKEYS || _la == MySqlParserINDEXES) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowIndexesContext).indexFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5811)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowIndexesContext).tableFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFROM || _la == MySqlParserIN) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowIndexesContext).tableFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5812)
			p.TableName()
		}
		p.SetState(5815)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserFROM || _la == MySqlParserIN {
			{
				p.SetState(5813)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*ShowIndexesContext).schemaFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserFROM || _la == MySqlParserIN) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*ShowIndexesContext).schemaFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(5814)
				p.Uid()
			}

		}
		p.SetState(5819)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserWHERE {
			{
				p.SetState(5817)
				p.Match(MySqlParserWHERE)
			}
			{
				p.SetState(5818)
				p.expression(0)
			}

		}

	case 16:
		localctx = NewShowOpenTablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(5821)
			p.Match(MySqlParserSHOW)
		}
		{
			p.SetState(5822)
			p.Match(MySqlParserOPEN)
		}
		{
			p.SetState(5823)
			p.Match(MySqlParserTABLES)
		}
		p.SetState(5826)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserFROM || _la == MySqlParserIN {
			{
				p.SetState(5824)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*ShowOpenTablesContext).schemaFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserFROM || _la == MySqlParserIN) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*ShowOpenTablesContext).schemaFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(5825)
				p.Uid()
			}

		}
		p.SetState(5829)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLIKE || _la == MySqlParserWHERE {
			{
				p.SetState(5828)
				p.ShowFilter()
			}

		}

	case 17:
		localctx = NewShowProfileContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(5831)
			p.Match(MySqlParserSHOW)
		}
		{
			p.SetState(5832)
			p.Match(MySqlParserPROFILE)
		}
		{
			p.SetState(5833)
			p.ShowProfileType()
		}
		p.SetState(5838)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(5834)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(5835)
				p.ShowProfileType()
			}

			p.SetState(5840)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5844)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserFOR {
			{
				p.SetState(5841)
				p.Match(MySqlParserFOR)
			}
			{
				p.SetState(5842)
				p.Match(MySqlParserQUERY)
			}
			{
				p.SetState(5843)

				var _x = p.DecimalLiteral()

				localctx.(*ShowProfileContext).queryCount = _x
			}

		}

		{
			p.SetState(5846)
			p.Match(MySqlParserLIMIT)
		}
		p.SetState(5850)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 850, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5847)

				var _x = p.DecimalLiteral()

				localctx.(*ShowProfileContext).offset = _x
			}
			{
				p.SetState(5848)
				p.Match(MySqlParserCOMMA)
			}

		}
		{
			p.SetState(5852)

			var _x = p.DecimalLiteral()

			localctx.(*ShowProfileContext).rowCount = _x
		}

	case 18:
		localctx = NewShowSlaveStatusContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(5854)
			p.Match(MySqlParserSHOW)
		}
		{
			p.SetState(5855)
			p.Match(MySqlParserSLAVE)
		}
		{
			p.SetState(5856)
			p.Match(MySqlParserSTATUS)
		}
		p.SetState(5860)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserFOR {
			{
				p.SetState(5857)
				p.Match(MySqlParserFOR)
			}
			{
				p.SetState(5858)
				p.Match(MySqlParserCHANNEL)
			}
			{
				p.SetState(5859)
				p.Match(MySqlParserSTRING_LITERAL)
			}

		}

	}

	return localctx
}

// IVariableClauseContext is an interface to support dynamic dispatch.
type IVariableClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCAL_ID() antlr.TerminalNode
	GLOBAL_ID() antlr.TerminalNode
	Uid() IUidContext
	GLOBAL() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	AllAT_SIGN() []antlr.TerminalNode
	AT_SIGN(i int) antlr.TerminalNode

	// IsVariableClauseContext differentiates from other interfaces.
	IsVariableClauseContext()
}

type VariableClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableClauseContext() *VariableClauseContext {
	var p = new(VariableClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_variableClause
	return p
}

func (*VariableClauseContext) IsVariableClauseContext() {}

func NewVariableClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableClauseContext {
	var p = new(VariableClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_variableClause

	return p
}

func (s *VariableClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableClauseContext) LOCAL_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL_ID, 0)
}

func (s *VariableClauseContext) GLOBAL_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserGLOBAL_ID, 0)
}

func (s *VariableClauseContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *VariableClauseContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserGLOBAL, 0)
}

func (s *VariableClauseContext) SESSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserSESSION, 0)
}

func (s *VariableClauseContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL, 0)
}

func (s *VariableClauseContext) AllAT_SIGN() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserAT_SIGN)
}

func (s *VariableClauseContext) AT_SIGN(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserAT_SIGN, i)
}

func (s *VariableClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterVariableClause(s)
	}
}

func (s *VariableClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitVariableClause(s)
	}
}

func (p *MySqlParser) VariableClause() (localctx IVariableClauseContext) {
	this := p
	_ = this

	localctx = NewVariableClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 484, MySqlParserRULE_variableClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5874)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserLOCAL_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5864)
			p.Match(MySqlParserLOCAL_ID)
		}

	case MySqlParserGLOBAL_ID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5865)
			p.Match(MySqlParserGLOBAL_ID)
		}

	case MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserAT_SIGN, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID, MySqlParserREVERSE_QUOTE_ID:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(5871)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 854, p.GetParserRuleContext()) == 1 {
			p.SetState(5868)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserAT_SIGN {
				{
					p.SetState(5866)
					p.Match(MySqlParserAT_SIGN)
				}
				{
					p.SetState(5867)
					p.Match(MySqlParserAT_SIGN)
				}

			}
			{
				p.SetState(5870)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserGLOBAL || _la == MySqlParserLOCAL || _la == MySqlParserSESSION) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(5873)
			p.Uid()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IShowCommonEntityContext is an interface to support dynamic dispatch.
type IShowCommonEntityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHARACTER() antlr.TerminalNode
	SET() antlr.TerminalNode
	COLLATION() antlr.TerminalNode
	DATABASES() antlr.TerminalNode
	SCHEMAS() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	PROCEDURE() antlr.TerminalNode
	VARIABLES() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	SESSION() antlr.TerminalNode

	// IsShowCommonEntityContext differentiates from other interfaces.
	IsShowCommonEntityContext()
}

type ShowCommonEntityContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowCommonEntityContext() *ShowCommonEntityContext {
	var p = new(ShowCommonEntityContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_showCommonEntity
	return p
}

func (*ShowCommonEntityContext) IsShowCommonEntityContext() {}

func NewShowCommonEntityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCommonEntityContext {
	var p = new(ShowCommonEntityContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_showCommonEntity

	return p
}

func (s *ShowCommonEntityContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCommonEntityContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER, 0)
}

func (s *ShowCommonEntityContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *ShowCommonEntityContext) COLLATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATION, 0)
}

func (s *ShowCommonEntityContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATABASES, 0)
}

func (s *ShowCommonEntityContext) SCHEMAS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEMAS, 0)
}

func (s *ShowCommonEntityContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserFUNCTION, 0)
}

func (s *ShowCommonEntityContext) STATUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATUS, 0)
}

func (s *ShowCommonEntityContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROCEDURE, 0)
}

func (s *ShowCommonEntityContext) VARIABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARIABLES, 0)
}

func (s *ShowCommonEntityContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserGLOBAL, 0)
}

func (s *ShowCommonEntityContext) SESSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserSESSION, 0)
}

func (s *ShowCommonEntityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCommonEntityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCommonEntityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowCommonEntity(s)
	}
}

func (s *ShowCommonEntityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowCommonEntity(s)
	}
}

func (p *MySqlParser) ShowCommonEntity() (localctx IShowCommonEntityContext) {
	this := p
	_ = this

	localctx = NewShowCommonEntityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 486, MySqlParserRULE_showCommonEntity)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5889)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserCHARACTER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5876)
			p.Match(MySqlParserCHARACTER)
		}
		{
			p.SetState(5877)
			p.Match(MySqlParserSET)
		}

	case MySqlParserCOLLATION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5878)
			p.Match(MySqlParserCOLLATION)
		}

	case MySqlParserDATABASES:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5879)
			p.Match(MySqlParserDATABASES)
		}

	case MySqlParserSCHEMAS:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5880)
			p.Match(MySqlParserSCHEMAS)
		}

	case MySqlParserFUNCTION:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5881)
			p.Match(MySqlParserFUNCTION)
		}
		{
			p.SetState(5882)
			p.Match(MySqlParserSTATUS)
		}

	case MySqlParserPROCEDURE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5883)
			p.Match(MySqlParserPROCEDURE)
		}
		{
			p.SetState(5884)
			p.Match(MySqlParserSTATUS)
		}

	case MySqlParserGLOBAL, MySqlParserSESSION, MySqlParserSTATUS, MySqlParserVARIABLES:
		p.EnterOuterAlt(localctx, 7)
		p.SetState(5886)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserGLOBAL || _la == MySqlParserSESSION {
			{
				p.SetState(5885)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserGLOBAL || _la == MySqlParserSESSION) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(5888)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserSTATUS || _la == MySqlParserVARIABLES) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IShowFilterContext is an interface to support dynamic dispatch.
type IShowFilterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIKE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsShowFilterContext differentiates from other interfaces.
	IsShowFilterContext()
}

type ShowFilterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowFilterContext() *ShowFilterContext {
	var p = new(ShowFilterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_showFilter
	return p
}

func (*ShowFilterContext) IsShowFilterContext() {}

func NewShowFilterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowFilterContext {
	var p = new(ShowFilterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_showFilter

	return p
}

func (s *ShowFilterContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowFilterContext) LIKE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIKE, 0)
}

func (s *ShowFilterContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *ShowFilterContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWHERE, 0)
}

func (s *ShowFilterContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowFilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowFilterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowFilterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowFilter(s)
	}
}

func (s *ShowFilterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowFilter(s)
	}
}

func (p *MySqlParser) ShowFilter() (localctx IShowFilterContext) {
	this := p
	_ = this

	localctx = NewShowFilterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 488, MySqlParserRULE_showFilter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5895)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserLIKE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5891)
			p.Match(MySqlParserLIKE)
		}
		{
			p.SetState(5892)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	case MySqlParserWHERE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5893)
			p.Match(MySqlParserWHERE)
		}
		{
			p.SetState(5894)
			p.expression(0)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IShowGlobalInfoClauseContext is an interface to support dynamic dispatch.
type IShowGlobalInfoClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ENGINES() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	MASTER() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	PLUGINS() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode
	PROCESSLIST() antlr.TerminalNode
	FULL() antlr.TerminalNode
	PROFILES() antlr.TerminalNode
	SLAVE() antlr.TerminalNode
	HOSTS() antlr.TerminalNode
	AUTHORS() antlr.TerminalNode
	CONTRIBUTORS() antlr.TerminalNode

	// IsShowGlobalInfoClauseContext differentiates from other interfaces.
	IsShowGlobalInfoClauseContext()
}

type ShowGlobalInfoClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowGlobalInfoClauseContext() *ShowGlobalInfoClauseContext {
	var p = new(ShowGlobalInfoClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_showGlobalInfoClause
	return p
}

func (*ShowGlobalInfoClauseContext) IsShowGlobalInfoClauseContext() {}

func NewShowGlobalInfoClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowGlobalInfoClauseContext {
	var p = new(ShowGlobalInfoClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_showGlobalInfoClause

	return p
}

func (s *ShowGlobalInfoClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowGlobalInfoClauseContext) ENGINES() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINES, 0)
}

func (s *ShowGlobalInfoClauseContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTORAGE, 0)
}

func (s *ShowGlobalInfoClauseContext) MASTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER, 0)
}

func (s *ShowGlobalInfoClauseContext) STATUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATUS, 0)
}

func (s *ShowGlobalInfoClauseContext) PLUGINS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPLUGINS, 0)
}

func (s *ShowGlobalInfoClauseContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRIVILEGES, 0)
}

func (s *ShowGlobalInfoClauseContext) PROCESSLIST() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROCESSLIST, 0)
}

func (s *ShowGlobalInfoClauseContext) FULL() antlr.TerminalNode {
	return s.GetToken(MySqlParserFULL, 0)
}

func (s *ShowGlobalInfoClauseContext) PROFILES() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROFILES, 0)
}

func (s *ShowGlobalInfoClauseContext) SLAVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSLAVE, 0)
}

func (s *ShowGlobalInfoClauseContext) HOSTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOSTS, 0)
}

func (s *ShowGlobalInfoClauseContext) AUTHORS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUTHORS, 0)
}

func (s *ShowGlobalInfoClauseContext) CONTRIBUTORS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONTRIBUTORS, 0)
}

func (s *ShowGlobalInfoClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowGlobalInfoClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowGlobalInfoClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowGlobalInfoClause(s)
	}
}

func (s *ShowGlobalInfoClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowGlobalInfoClause(s)
	}
}

func (p *MySqlParser) ShowGlobalInfoClause() (localctx IShowGlobalInfoClauseContext) {
	this := p
	_ = this

	localctx = NewShowGlobalInfoClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 490, MySqlParserRULE_showGlobalInfoClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5914)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserENGINES, MySqlParserSTORAGE:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(5898)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserSTORAGE {
			{
				p.SetState(5897)
				p.Match(MySqlParserSTORAGE)
			}

		}
		{
			p.SetState(5900)
			p.Match(MySqlParserENGINES)
		}

	case MySqlParserMASTER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5901)
			p.Match(MySqlParserMASTER)
		}
		{
			p.SetState(5902)
			p.Match(MySqlParserSTATUS)
		}

	case MySqlParserPLUGINS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5903)
			p.Match(MySqlParserPLUGINS)
		}

	case MySqlParserPRIVILEGES:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5904)
			p.Match(MySqlParserPRIVILEGES)
		}

	case MySqlParserFULL, MySqlParserPROCESSLIST:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(5906)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserFULL {
			{
				p.SetState(5905)
				p.Match(MySqlParserFULL)
			}

		}
		{
			p.SetState(5908)
			p.Match(MySqlParserPROCESSLIST)
		}

	case MySqlParserPROFILES:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5909)
			p.Match(MySqlParserPROFILES)
		}

	case MySqlParserSLAVE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5910)
			p.Match(MySqlParserSLAVE)
		}
		{
			p.SetState(5911)
			p.Match(MySqlParserHOSTS)
		}

	case MySqlParserAUTHORS:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5912)
			p.Match(MySqlParserAUTHORS)
		}

	case MySqlParserCONTRIBUTORS:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5913)
			p.Match(MySqlParserCONTRIBUTORS)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IShowSchemaEntityContext is an interface to support dynamic dispatch.
type IShowSchemaEntityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EVENTS() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	FULL() antlr.TerminalNode
	TRIGGERS() antlr.TerminalNode

	// IsShowSchemaEntityContext differentiates from other interfaces.
	IsShowSchemaEntityContext()
}

type ShowSchemaEntityContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowSchemaEntityContext() *ShowSchemaEntityContext {
	var p = new(ShowSchemaEntityContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_showSchemaEntity
	return p
}

func (*ShowSchemaEntityContext) IsShowSchemaEntityContext() {}

func NewShowSchemaEntityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowSchemaEntityContext {
	var p = new(ShowSchemaEntityContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_showSchemaEntity

	return p
}

func (s *ShowSchemaEntityContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowSchemaEntityContext) EVENTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVENTS, 0)
}

func (s *ShowSchemaEntityContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *ShowSchemaEntityContext) STATUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATUS, 0)
}

func (s *ShowSchemaEntityContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLES, 0)
}

func (s *ShowSchemaEntityContext) FULL() antlr.TerminalNode {
	return s.GetToken(MySqlParserFULL, 0)
}

func (s *ShowSchemaEntityContext) TRIGGERS() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRIGGERS, 0)
}

func (s *ShowSchemaEntityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSchemaEntityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowSchemaEntityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowSchemaEntity(s)
	}
}

func (s *ShowSchemaEntityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowSchemaEntity(s)
	}
}

func (p *MySqlParser) ShowSchemaEntity() (localctx IShowSchemaEntityContext) {
	this := p
	_ = this

	localctx = NewShowSchemaEntityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 492, MySqlParserRULE_showSchemaEntity)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5924)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserEVENTS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5916)
			p.Match(MySqlParserEVENTS)
		}

	case MySqlParserTABLE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5917)
			p.Match(MySqlParserTABLE)
		}
		{
			p.SetState(5918)
			p.Match(MySqlParserSTATUS)
		}

	case MySqlParserFULL, MySqlParserTABLES:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(5920)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserFULL {
			{
				p.SetState(5919)
				p.Match(MySqlParserFULL)
			}

		}
		{
			p.SetState(5922)
			p.Match(MySqlParserTABLES)
		}

	case MySqlParserTRIGGERS:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5923)
			p.Match(MySqlParserTRIGGERS)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IShowProfileTypeContext is an interface to support dynamic dispatch.
type IShowProfileTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL() antlr.TerminalNode
	BLOCK() antlr.TerminalNode
	IO() antlr.TerminalNode
	CONTEXT() antlr.TerminalNode
	SWITCHES() antlr.TerminalNode
	CPU() antlr.TerminalNode
	IPC() antlr.TerminalNode
	MEMORY() antlr.TerminalNode
	PAGE() antlr.TerminalNode
	FAULTS() antlr.TerminalNode
	SOURCE() antlr.TerminalNode
	SWAPS() antlr.TerminalNode

	// IsShowProfileTypeContext differentiates from other interfaces.
	IsShowProfileTypeContext()
}

type ShowProfileTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowProfileTypeContext() *ShowProfileTypeContext {
	var p = new(ShowProfileTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_showProfileType
	return p
}

func (*ShowProfileTypeContext) IsShowProfileTypeContext() {}

func NewShowProfileTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowProfileTypeContext {
	var p = new(ShowProfileTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_showProfileType

	return p
}

func (s *ShowProfileTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowProfileTypeContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *ShowProfileTypeContext) BLOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserBLOCK, 0)
}

func (s *ShowProfileTypeContext) IO() antlr.TerminalNode {
	return s.GetToken(MySqlParserIO, 0)
}

func (s *ShowProfileTypeContext) CONTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONTEXT, 0)
}

func (s *ShowProfileTypeContext) SWITCHES() antlr.TerminalNode {
	return s.GetToken(MySqlParserSWITCHES, 0)
}

func (s *ShowProfileTypeContext) CPU() antlr.TerminalNode {
	return s.GetToken(MySqlParserCPU, 0)
}

func (s *ShowProfileTypeContext) IPC() antlr.TerminalNode {
	return s.GetToken(MySqlParserIPC, 0)
}

func (s *ShowProfileTypeContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEMORY, 0)
}

func (s *ShowProfileTypeContext) PAGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPAGE, 0)
}

func (s *ShowProfileTypeContext) FAULTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFAULTS, 0)
}

func (s *ShowProfileTypeContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSOURCE, 0)
}

func (s *ShowProfileTypeContext) SWAPS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSWAPS, 0)
}

func (s *ShowProfileTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowProfileTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowProfileTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShowProfileType(s)
	}
}

func (s *ShowProfileTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShowProfileType(s)
	}
}

func (p *MySqlParser) ShowProfileType() (localctx IShowProfileTypeContext) {
	this := p
	_ = this

	localctx = NewShowProfileTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 494, MySqlParserRULE_showProfileType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5938)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserALL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5926)
			p.Match(MySqlParserALL)
		}

	case MySqlParserBLOCK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5927)
			p.Match(MySqlParserBLOCK)
		}
		{
			p.SetState(5928)
			p.Match(MySqlParserIO)
		}

	case MySqlParserCONTEXT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5929)
			p.Match(MySqlParserCONTEXT)
		}
		{
			p.SetState(5930)
			p.Match(MySqlParserSWITCHES)
		}

	case MySqlParserCPU:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5931)
			p.Match(MySqlParserCPU)
		}

	case MySqlParserIPC:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5932)
			p.Match(MySqlParserIPC)
		}

	case MySqlParserMEMORY:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5933)
			p.Match(MySqlParserMEMORY)
		}

	case MySqlParserPAGE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5934)
			p.Match(MySqlParserPAGE)
		}
		{
			p.SetState(5935)
			p.Match(MySqlParserFAULTS)
		}

	case MySqlParserSOURCE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5936)
			p.Match(MySqlParserSOURCE)
		}

	case MySqlParserSWAPS:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5937)
			p.Match(MySqlParserSWAPS)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBinlogStatementContext is an interface to support dynamic dispatch.
type IBinlogStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BINLOG() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsBinlogStatementContext differentiates from other interfaces.
	IsBinlogStatementContext()
}

type BinlogStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinlogStatementContext() *BinlogStatementContext {
	var p = new(BinlogStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_binlogStatement
	return p
}

func (*BinlogStatementContext) IsBinlogStatementContext() {}

func NewBinlogStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BinlogStatementContext {
	var p = new(BinlogStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_binlogStatement

	return p
}

func (s *BinlogStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BinlogStatementContext) BINLOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINLOG, 0)
}

func (s *BinlogStatementContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *BinlogStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinlogStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BinlogStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterBinlogStatement(s)
	}
}

func (s *BinlogStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitBinlogStatement(s)
	}
}

func (p *MySqlParser) BinlogStatement() (localctx IBinlogStatementContext) {
	this := p
	_ = this

	localctx = NewBinlogStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 496, MySqlParserRULE_binlogStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5940)
		p.Match(MySqlParserBINLOG)
	}
	{
		p.SetState(5941)
		p.Match(MySqlParserSTRING_LITERAL)
	}

	return localctx
}

// ICacheIndexStatementContext is an interface to support dynamic dispatch.
type ICacheIndexStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSchema returns the schema rule contexts.
	GetSchema() IUidContext

	// SetSchema sets the schema rule contexts.
	SetSchema(IUidContext)

	// Getter signatures
	CACHE() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	AllTableIndexes() []ITableIndexesContext
	TableIndexes(i int) ITableIndexesContext
	IN() antlr.TerminalNode
	Uid() IUidContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	UidList() IUidListContext
	ALL() antlr.TerminalNode

	// IsCacheIndexStatementContext differentiates from other interfaces.
	IsCacheIndexStatementContext()
}

type CacheIndexStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	schema IUidContext
}

func NewEmptyCacheIndexStatementContext() *CacheIndexStatementContext {
	var p = new(CacheIndexStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_cacheIndexStatement
	return p
}

func (*CacheIndexStatementContext) IsCacheIndexStatementContext() {}

func NewCacheIndexStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CacheIndexStatementContext {
	var p = new(CacheIndexStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_cacheIndexStatement

	return p
}

func (s *CacheIndexStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CacheIndexStatementContext) GetSchema() IUidContext { return s.schema }

func (s *CacheIndexStatementContext) SetSchema(v IUidContext) { s.schema = v }

func (s *CacheIndexStatementContext) CACHE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCACHE, 0)
}

func (s *CacheIndexStatementContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *CacheIndexStatementContext) AllTableIndexes() []ITableIndexesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableIndexesContext); ok {
			len++
		}
	}

	tst := make([]ITableIndexesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableIndexesContext); ok {
			tst[i] = t.(ITableIndexesContext)
			i++
		}
	}

	return tst
}

func (s *CacheIndexStatementContext) TableIndexes(i int) ITableIndexesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIndexesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIndexesContext)
}

func (s *CacheIndexStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, 0)
}

func (s *CacheIndexStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CacheIndexStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *CacheIndexStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *CacheIndexStatementContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *CacheIndexStatementContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CacheIndexStatementContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CacheIndexStatementContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *CacheIndexStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *CacheIndexStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CacheIndexStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CacheIndexStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCacheIndexStatement(s)
	}
}

func (s *CacheIndexStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCacheIndexStatement(s)
	}
}

func (p *MySqlParser) CacheIndexStatement() (localctx ICacheIndexStatementContext) {
	this := p
	_ = this

	localctx = NewCacheIndexStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 498, MySqlParserRULE_cacheIndexStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5943)
		p.Match(MySqlParserCACHE)
	}
	{
		p.SetState(5944)
		p.Match(MySqlParserINDEX)
	}
	{
		p.SetState(5945)
		p.TableIndexes()
	}
	p.SetState(5950)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(5946)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(5947)
			p.TableIndexes()
		}

		p.SetState(5952)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(5960)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserPARTITION {
		{
			p.SetState(5953)
			p.Match(MySqlParserPARTITION)
		}
		{
			p.SetState(5954)
			p.Match(MySqlParserLR_BRACKET)
		}
		p.SetState(5957)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID, MySqlParserREVERSE_QUOTE_ID:
			{
				p.SetState(5955)
				p.UidList()
			}

		case MySqlParserALL:
			{
				p.SetState(5956)
				p.Match(MySqlParserALL)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(5959)
			p.Match(MySqlParserRR_BRACKET)
		}

	}
	{
		p.SetState(5962)
		p.Match(MySqlParserIN)
	}
	{
		p.SetState(5963)

		var _x = p.Uid()

		localctx.(*CacheIndexStatementContext).schema = _x
	}

	return localctx
}

// IFlushStatementContext is an interface to support dynamic dispatch.
type IFlushStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFlushFormat returns the flushFormat token.
	GetFlushFormat() antlr.Token

	// SetFlushFormat sets the flushFormat token.
	SetFlushFormat(antlr.Token)

	// Getter signatures
	FLUSH() antlr.TerminalNode
	AllFlushOption() []IFlushOptionContext
	FlushOption(i int) IFlushOptionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	NO_WRITE_TO_BINLOG() antlr.TerminalNode
	LOCAL() antlr.TerminalNode

	// IsFlushStatementContext differentiates from other interfaces.
	IsFlushStatementContext()
}

type FlushStatementContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	flushFormat antlr.Token
}

func NewEmptyFlushStatementContext() *FlushStatementContext {
	var p = new(FlushStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_flushStatement
	return p
}

func (*FlushStatementContext) IsFlushStatementContext() {}

func NewFlushStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FlushStatementContext {
	var p = new(FlushStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_flushStatement

	return p
}

func (s *FlushStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *FlushStatementContext) GetFlushFormat() antlr.Token { return s.flushFormat }

func (s *FlushStatementContext) SetFlushFormat(v antlr.Token) { s.flushFormat = v }

func (s *FlushStatementContext) FLUSH() antlr.TerminalNode {
	return s.GetToken(MySqlParserFLUSH, 0)
}

func (s *FlushStatementContext) AllFlushOption() []IFlushOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFlushOptionContext); ok {
			len++
		}
	}

	tst := make([]IFlushOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFlushOptionContext); ok {
			tst[i] = t.(IFlushOptionContext)
			i++
		}
	}

	return tst
}

func (s *FlushStatementContext) FlushOption(i int) IFlushOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFlushOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFlushOptionContext)
}

func (s *FlushStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *FlushStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *FlushStatementContext) NO_WRITE_TO_BINLOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserNO_WRITE_TO_BINLOG, 0)
}

func (s *FlushStatementContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL, 0)
}

func (s *FlushStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FlushStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FlushStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFlushStatement(s)
	}
}

func (s *FlushStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFlushStatement(s)
	}
}

func (p *MySqlParser) FlushStatement() (localctx IFlushStatementContext) {
	this := p
	_ = this

	localctx = NewFlushStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 500, MySqlParserRULE_flushStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5965)
		p.Match(MySqlParserFLUSH)
	}
	p.SetState(5967)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserNO_WRITE_TO_BINLOG || _la == MySqlParserLOCAL {
		{
			p.SetState(5966)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*FlushStatementContext).flushFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserNO_WRITE_TO_BINLOG || _la == MySqlParserLOCAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*FlushStatementContext).flushFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(5969)
		p.FlushOption()
	}
	p.SetState(5974)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(5970)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(5971)
			p.FlushOption()
		}

		p.SetState(5976)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IKillStatementContext is an interface to support dynamic dispatch.
type IKillStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetConnectionFormat returns the connectionFormat token.
	GetConnectionFormat() antlr.Token

	// SetConnectionFormat sets the connectionFormat token.
	SetConnectionFormat(antlr.Token)

	// Getter signatures
	KILL() antlr.TerminalNode
	Expression() IExpressionContext
	CONNECTION() antlr.TerminalNode
	QUERY() antlr.TerminalNode

	// IsKillStatementContext differentiates from other interfaces.
	IsKillStatementContext()
}

type KillStatementContext struct {
	*antlr.BaseParserRuleContext
	parser           antlr.Parser
	connectionFormat antlr.Token
}

func NewEmptyKillStatementContext() *KillStatementContext {
	var p = new(KillStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_killStatement
	return p
}

func (*KillStatementContext) IsKillStatementContext() {}

func NewKillStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KillStatementContext {
	var p = new(KillStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_killStatement

	return p
}

func (s *KillStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *KillStatementContext) GetConnectionFormat() antlr.Token { return s.connectionFormat }

func (s *KillStatementContext) SetConnectionFormat(v antlr.Token) { s.connectionFormat = v }

func (s *KillStatementContext) KILL() antlr.TerminalNode {
	return s.GetToken(MySqlParserKILL, 0)
}

func (s *KillStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *KillStatementContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONNECTION, 0)
}

func (s *KillStatementContext) QUERY() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUERY, 0)
}

func (s *KillStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KillStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KillStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterKillStatement(s)
	}
}

func (s *KillStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitKillStatement(s)
	}
}

func (p *MySqlParser) KillStatement() (localctx IKillStatementContext) {
	this := p
	_ = this

	localctx = NewKillStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 502, MySqlParserRULE_killStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5977)
		p.Match(MySqlParserKILL)
	}
	p.SetState(5979)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 870, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5978)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*KillStatementContext).connectionFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCONNECTION || _la == MySqlParserQUERY) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*KillStatementContext).connectionFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(5981)
		p.expression(0)
	}

	return localctx
}

// ILoadIndexIntoCacheContext is an interface to support dynamic dispatch.
type ILoadIndexIntoCacheContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOAD() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	INTO() antlr.TerminalNode
	CACHE() antlr.TerminalNode
	AllLoadedTableIndexes() []ILoadedTableIndexesContext
	LoadedTableIndexes(i int) ILoadedTableIndexesContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsLoadIndexIntoCacheContext differentiates from other interfaces.
	IsLoadIndexIntoCacheContext()
}

type LoadIndexIntoCacheContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoadIndexIntoCacheContext() *LoadIndexIntoCacheContext {
	var p = new(LoadIndexIntoCacheContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_loadIndexIntoCache
	return p
}

func (*LoadIndexIntoCacheContext) IsLoadIndexIntoCacheContext() {}

func NewLoadIndexIntoCacheContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoadIndexIntoCacheContext {
	var p = new(LoadIndexIntoCacheContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_loadIndexIntoCache

	return p
}

func (s *LoadIndexIntoCacheContext) GetParser() antlr.Parser { return s.parser }

func (s *LoadIndexIntoCacheContext) LOAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOAD, 0)
}

func (s *LoadIndexIntoCacheContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *LoadIndexIntoCacheContext) INTO() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTO, 0)
}

func (s *LoadIndexIntoCacheContext) CACHE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCACHE, 0)
}

func (s *LoadIndexIntoCacheContext) AllLoadedTableIndexes() []ILoadedTableIndexesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILoadedTableIndexesContext); ok {
			len++
		}
	}

	tst := make([]ILoadedTableIndexesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILoadedTableIndexesContext); ok {
			tst[i] = t.(ILoadedTableIndexesContext)
			i++
		}
	}

	return tst
}

func (s *LoadIndexIntoCacheContext) LoadedTableIndexes(i int) ILoadedTableIndexesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadedTableIndexesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadedTableIndexesContext)
}

func (s *LoadIndexIntoCacheContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *LoadIndexIntoCacheContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *LoadIndexIntoCacheContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadIndexIntoCacheContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoadIndexIntoCacheContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLoadIndexIntoCache(s)
	}
}

func (s *LoadIndexIntoCacheContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLoadIndexIntoCache(s)
	}
}

func (p *MySqlParser) LoadIndexIntoCache() (localctx ILoadIndexIntoCacheContext) {
	this := p
	_ = this

	localctx = NewLoadIndexIntoCacheContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 504, MySqlParserRULE_loadIndexIntoCache)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5983)
		p.Match(MySqlParserLOAD)
	}
	{
		p.SetState(5984)
		p.Match(MySqlParserINDEX)
	}
	{
		p.SetState(5985)
		p.Match(MySqlParserINTO)
	}
	{
		p.SetState(5986)
		p.Match(MySqlParserCACHE)
	}
	{
		p.SetState(5987)
		p.LoadedTableIndexes()
	}
	p.SetState(5992)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(5988)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(5989)
			p.LoadedTableIndexes()
		}

		p.SetState(5994)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IResetStatementContext is an interface to support dynamic dispatch.
type IResetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESET() antlr.TerminalNode
	QUERY() antlr.TerminalNode
	CACHE() antlr.TerminalNode

	// IsResetStatementContext differentiates from other interfaces.
	IsResetStatementContext()
}

type ResetStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResetStatementContext() *ResetStatementContext {
	var p = new(ResetStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_resetStatement
	return p
}

func (*ResetStatementContext) IsResetStatementContext() {}

func NewResetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResetStatementContext {
	var p = new(ResetStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_resetStatement

	return p
}

func (s *ResetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ResetStatementContext) RESET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESET, 0)
}

func (s *ResetStatementContext) QUERY() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUERY, 0)
}

func (s *ResetStatementContext) CACHE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCACHE, 0)
}

func (s *ResetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResetStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterResetStatement(s)
	}
}

func (s *ResetStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitResetStatement(s)
	}
}

func (p *MySqlParser) ResetStatement() (localctx IResetStatementContext) {
	this := p
	_ = this

	localctx = NewResetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 506, MySqlParserRULE_resetStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5995)
		p.Match(MySqlParserRESET)
	}
	{
		p.SetState(5996)
		p.Match(MySqlParserQUERY)
	}
	{
		p.SetState(5997)
		p.Match(MySqlParserCACHE)
	}

	return localctx
}

// IShutdownStatementContext is an interface to support dynamic dispatch.
type IShutdownStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHUTDOWN() antlr.TerminalNode

	// IsShutdownStatementContext differentiates from other interfaces.
	IsShutdownStatementContext()
}

type ShutdownStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShutdownStatementContext() *ShutdownStatementContext {
	var p = new(ShutdownStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_shutdownStatement
	return p
}

func (*ShutdownStatementContext) IsShutdownStatementContext() {}

func NewShutdownStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShutdownStatementContext {
	var p = new(ShutdownStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_shutdownStatement

	return p
}

func (s *ShutdownStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShutdownStatementContext) SHUTDOWN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHUTDOWN, 0)
}

func (s *ShutdownStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShutdownStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShutdownStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterShutdownStatement(s)
	}
}

func (s *ShutdownStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitShutdownStatement(s)
	}
}

func (p *MySqlParser) ShutdownStatement() (localctx IShutdownStatementContext) {
	this := p
	_ = this

	localctx = NewShutdownStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 508, MySqlParserRULE_shutdownStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5999)
		p.Match(MySqlParserSHUTDOWN)
	}

	return localctx
}

// ITableIndexesContext is an interface to support dynamic dispatch.
type ITableIndexesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndexFormat returns the indexFormat token.
	GetIndexFormat() antlr.Token

	// SetIndexFormat sets the indexFormat token.
	SetIndexFormat(antlr.Token)

	// Getter signatures
	TableName() ITableNameContext
	LR_BRACKET() antlr.TerminalNode
	UidList() IUidListContext
	RR_BRACKET() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	KEY() antlr.TerminalNode

	// IsTableIndexesContext differentiates from other interfaces.
	IsTableIndexesContext()
}

type TableIndexesContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	indexFormat antlr.Token
}

func NewEmptyTableIndexesContext() *TableIndexesContext {
	var p = new(TableIndexesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_tableIndexes
	return p
}

func (*TableIndexesContext) IsTableIndexesContext() {}

func NewTableIndexesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableIndexesContext {
	var p = new(TableIndexesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tableIndexes

	return p
}

func (s *TableIndexesContext) GetParser() antlr.Parser { return s.parser }

func (s *TableIndexesContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *TableIndexesContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *TableIndexesContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TableIndexesContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *TableIndexesContext) UidList() IUidListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *TableIndexesContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *TableIndexesContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *TableIndexesContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *TableIndexesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableIndexesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableIndexesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableIndexes(s)
	}
}

func (s *TableIndexesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableIndexes(s)
	}
}

func (p *MySqlParser) TableIndexes() (localctx ITableIndexesContext) {
	this := p
	_ = this

	localctx = NewTableIndexesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 510, MySqlParserRULE_tableIndexes)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6001)
		p.TableName()
	}
	p.SetState(6009)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserINDEX || _la == MySqlParserKEY || _la == MySqlParserLR_BRACKET {
		p.SetState(6003)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserINDEX || _la == MySqlParserKEY {
			{
				p.SetState(6002)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*TableIndexesContext).indexFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserINDEX || _la == MySqlParserKEY) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*TableIndexesContext).indexFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(6005)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(6006)
			p.UidList()
		}
		{
			p.SetState(6007)
			p.Match(MySqlParserRR_BRACKET)
		}

	}

	return localctx
}

// IFlushOptionContext is an interface to support dynamic dispatch.
type IFlushOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsFlushOptionContext differentiates from other interfaces.
	IsFlushOptionContext()
}

type FlushOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlushOptionContext() *FlushOptionContext {
	var p = new(FlushOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_flushOption
	return p
}

func (*FlushOptionContext) IsFlushOptionContext() {}

func NewFlushOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FlushOptionContext {
	var p = new(FlushOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_flushOption

	return p
}

func (s *FlushOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *FlushOptionContext) CopyFrom(ctx *FlushOptionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *FlushOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FlushOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TableFlushOptionContext struct {
	*FlushOptionContext
}

func NewTableFlushOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableFlushOptionContext {
	var p = new(TableFlushOptionContext)

	p.FlushOptionContext = NewEmptyFlushOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*FlushOptionContext))

	return p
}

func (s *TableFlushOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableFlushOptionContext) TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE, 0)
}

func (s *TableFlushOptionContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLES, 0)
}

func (s *TableFlushOptionContext) Tables() ITablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablesContext)
}

func (s *TableFlushOptionContext) FlushTableOption() IFlushTableOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFlushTableOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFlushTableOptionContext)
}

func (s *TableFlushOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableFlushOption(s)
	}
}

func (s *TableFlushOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableFlushOption(s)
	}
}

type ChannelFlushOptionContext struct {
	*FlushOptionContext
}

func NewChannelFlushOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ChannelFlushOptionContext {
	var p = new(ChannelFlushOptionContext)

	p.FlushOptionContext = NewEmptyFlushOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*FlushOptionContext))

	return p
}

func (s *ChannelFlushOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChannelFlushOptionContext) RELAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELAY, 0)
}

func (s *ChannelFlushOptionContext) LOGS() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOGS, 0)
}

func (s *ChannelFlushOptionContext) ChannelOption() IChannelOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChannelOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChannelOptionContext)
}

func (s *ChannelFlushOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterChannelFlushOption(s)
	}
}

func (s *ChannelFlushOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitChannelFlushOption(s)
	}
}

type SimpleFlushOptionContext struct {
	*FlushOptionContext
}

func NewSimpleFlushOptionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleFlushOptionContext {
	var p = new(SimpleFlushOptionContext)

	p.FlushOptionContext = NewEmptyFlushOptionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*FlushOptionContext))

	return p
}

func (s *SimpleFlushOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleFlushOptionContext) DES_KEY_FILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDES_KEY_FILE, 0)
}

func (s *SimpleFlushOptionContext) HOSTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOSTS, 0)
}

func (s *SimpleFlushOptionContext) LOGS() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOGS, 0)
}

func (s *SimpleFlushOptionContext) OPTIMIZER_COSTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTIMIZER_COSTS, 0)
}

func (s *SimpleFlushOptionContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRIVILEGES, 0)
}

func (s *SimpleFlushOptionContext) QUERY() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUERY, 0)
}

func (s *SimpleFlushOptionContext) CACHE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCACHE, 0)
}

func (s *SimpleFlushOptionContext) STATUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATUS, 0)
}

func (s *SimpleFlushOptionContext) USER_RESOURCES() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER_RESOURCES, 0)
}

func (s *SimpleFlushOptionContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLES, 0)
}

func (s *SimpleFlushOptionContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *SimpleFlushOptionContext) READ() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAD, 0)
}

func (s *SimpleFlushOptionContext) LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCK, 0)
}

func (s *SimpleFlushOptionContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *SimpleFlushOptionContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE, 0)
}

func (s *SimpleFlushOptionContext) ERROR() antlr.TerminalNode {
	return s.GetToken(MySqlParserERROR, 0)
}

func (s *SimpleFlushOptionContext) GENERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserGENERAL, 0)
}

func (s *SimpleFlushOptionContext) RELAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELAY, 0)
}

func (s *SimpleFlushOptionContext) SLOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSLOW, 0)
}

func (s *SimpleFlushOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSimpleFlushOption(s)
	}
}

func (s *SimpleFlushOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSimpleFlushOption(s)
	}
}

func (p *MySqlParser) FlushOption() (localctx IFlushOptionContext) {
	this := p
	_ = this

	localctx = NewFlushOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 512, MySqlParserRULE_flushOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6043)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 880, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSimpleFlushOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6029)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserDES_KEY_FILE:
			{
				p.SetState(6011)
				p.Match(MySqlParserDES_KEY_FILE)
			}

		case MySqlParserHOSTS:
			{
				p.SetState(6012)
				p.Match(MySqlParserHOSTS)
			}

		case MySqlParserBINARY, MySqlParserENGINE, MySqlParserERROR, MySqlParserGENERAL, MySqlParserLOGS, MySqlParserRELAY, MySqlParserSLOW:
			p.SetState(6014)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserBINARY || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&536870917) != 0) || _la == MySqlParserRELAY || _la == MySqlParserSLOW {
				{
					p.SetState(6013)
					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserBINARY || ((int64((_la-409)) & ^0x3f) == 0 && ((int64(1)<<(_la-409))&536870917) != 0) || _la == MySqlParserRELAY || _la == MySqlParserSLOW) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(6016)
				p.Match(MySqlParserLOGS)
			}

		case MySqlParserOPTIMIZER_COSTS:
			{
				p.SetState(6017)
				p.Match(MySqlParserOPTIMIZER_COSTS)
			}

		case MySqlParserPRIVILEGES:
			{
				p.SetState(6018)
				p.Match(MySqlParserPRIVILEGES)
			}

		case MySqlParserQUERY:
			{
				p.SetState(6019)
				p.Match(MySqlParserQUERY)
			}
			{
				p.SetState(6020)
				p.Match(MySqlParserCACHE)
			}

		case MySqlParserSTATUS:
			{
				p.SetState(6021)
				p.Match(MySqlParserSTATUS)
			}

		case MySqlParserUSER_RESOURCES:
			{
				p.SetState(6022)
				p.Match(MySqlParserUSER_RESOURCES)
			}

		case MySqlParserTABLES:
			{
				p.SetState(6023)
				p.Match(MySqlParserTABLES)
			}
			p.SetState(6027)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 875, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(6024)
					p.Match(MySqlParserWITH)
				}
				{
					p.SetState(6025)
					p.Match(MySqlParserREAD)
				}
				{
					p.SetState(6026)
					p.Match(MySqlParserLOCK)
				}

			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 2:
		localctx = NewChannelFlushOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6031)
			p.Match(MySqlParserRELAY)
		}
		{
			p.SetState(6032)
			p.Match(MySqlParserLOGS)
		}
		p.SetState(6034)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserFOR {
			{
				p.SetState(6033)
				p.ChannelOption()
			}

		}

	case 3:
		localctx = NewTableFlushOptionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6036)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserTABLE || _la == MySqlParserTABLES) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6038)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 878, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6037)
				p.Tables()
			}

		}
		p.SetState(6041)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 879, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6040)
				p.FlushTableOption()
			}

		}

	}

	return localctx
}

// IFlushTableOptionContext is an interface to support dynamic dispatch.
type IFlushTableOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	READ() antlr.TerminalNode
	LOCK() antlr.TerminalNode
	FOR() antlr.TerminalNode
	EXPORT() antlr.TerminalNode

	// IsFlushTableOptionContext differentiates from other interfaces.
	IsFlushTableOptionContext()
}

type FlushTableOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlushTableOptionContext() *FlushTableOptionContext {
	var p = new(FlushTableOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_flushTableOption
	return p
}

func (*FlushTableOptionContext) IsFlushTableOptionContext() {}

func NewFlushTableOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FlushTableOptionContext {
	var p = new(FlushTableOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_flushTableOption

	return p
}

func (s *FlushTableOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *FlushTableOptionContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *FlushTableOptionContext) READ() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAD, 0)
}

func (s *FlushTableOptionContext) LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCK, 0)
}

func (s *FlushTableOptionContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *FlushTableOptionContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXPORT, 0)
}

func (s *FlushTableOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FlushTableOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FlushTableOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFlushTableOption(s)
	}
}

func (s *FlushTableOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFlushTableOption(s)
	}
}

func (p *MySqlParser) FlushTableOption() (localctx IFlushTableOptionContext) {
	this := p
	_ = this

	localctx = NewFlushTableOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 514, MySqlParserRULE_flushTableOption)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6050)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserWITH:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6045)
			p.Match(MySqlParserWITH)
		}
		{
			p.SetState(6046)
			p.Match(MySqlParserREAD)
		}
		{
			p.SetState(6047)
			p.Match(MySqlParserLOCK)
		}

	case MySqlParserFOR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6048)
			p.Match(MySqlParserFOR)
		}
		{
			p.SetState(6049)
			p.Match(MySqlParserEXPORT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILoadedTableIndexesContext is an interface to support dynamic dispatch.
type ILoadedTableIndexesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndexFormat returns the indexFormat token.
	GetIndexFormat() antlr.Token

	// SetIndexFormat sets the indexFormat token.
	SetIndexFormat(antlr.Token)

	// GetPartitionList returns the partitionList rule contexts.
	GetPartitionList() IUidListContext

	// GetIndexList returns the indexList rule contexts.
	GetIndexList() IUidListContext

	// SetPartitionList sets the partitionList rule contexts.
	SetPartitionList(IUidListContext)

	// SetIndexList sets the indexList rule contexts.
	SetIndexList(IUidListContext)

	// Getter signatures
	TableName() ITableNameContext
	PARTITION() antlr.TerminalNode
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	IGNORE() antlr.TerminalNode
	LEAVES() antlr.TerminalNode
	AllUidList() []IUidListContext
	UidList(i int) IUidListContext
	ALL() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	KEY() antlr.TerminalNode

	// IsLoadedTableIndexesContext differentiates from other interfaces.
	IsLoadedTableIndexesContext()
}

type LoadedTableIndexesContext struct {
	*antlr.BaseParserRuleContext
	parser        antlr.Parser
	partitionList IUidListContext
	indexFormat   antlr.Token
	indexList     IUidListContext
}

func NewEmptyLoadedTableIndexesContext() *LoadedTableIndexesContext {
	var p = new(LoadedTableIndexesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_loadedTableIndexes
	return p
}

func (*LoadedTableIndexesContext) IsLoadedTableIndexesContext() {}

func NewLoadedTableIndexesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoadedTableIndexesContext {
	var p = new(LoadedTableIndexesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_loadedTableIndexes

	return p
}

func (s *LoadedTableIndexesContext) GetParser() antlr.Parser { return s.parser }

func (s *LoadedTableIndexesContext) GetIndexFormat() antlr.Token { return s.indexFormat }

func (s *LoadedTableIndexesContext) SetIndexFormat(v antlr.Token) { s.indexFormat = v }

func (s *LoadedTableIndexesContext) GetPartitionList() IUidListContext { return s.partitionList }

func (s *LoadedTableIndexesContext) GetIndexList() IUidListContext { return s.indexList }

func (s *LoadedTableIndexesContext) SetPartitionList(v IUidListContext) { s.partitionList = v }

func (s *LoadedTableIndexesContext) SetIndexList(v IUidListContext) { s.indexList = v }

func (s *LoadedTableIndexesContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *LoadedTableIndexesContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *LoadedTableIndexesContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *LoadedTableIndexesContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *LoadedTableIndexesContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *LoadedTableIndexesContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *LoadedTableIndexesContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE, 0)
}

func (s *LoadedTableIndexesContext) LEAVES() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEAVES, 0)
}

func (s *LoadedTableIndexesContext) AllUidList() []IUidListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidListContext); ok {
			len++
		}
	}

	tst := make([]IUidListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidListContext); ok {
			tst[i] = t.(IUidListContext)
			i++
		}
	}

	return tst
}

func (s *LoadedTableIndexesContext) UidList(i int) IUidListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *LoadedTableIndexesContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *LoadedTableIndexesContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *LoadedTableIndexesContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *LoadedTableIndexesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadedTableIndexesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoadedTableIndexesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLoadedTableIndexes(s)
	}
}

func (s *LoadedTableIndexesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLoadedTableIndexes(s)
	}
}

func (p *MySqlParser) LoadedTableIndexes() (localctx ILoadedTableIndexesContext) {
	this := p
	_ = this

	localctx = NewLoadedTableIndexesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 516, MySqlParserRULE_loadedTableIndexes)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6052)
		p.TableName()
	}
	p.SetState(6060)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserPARTITION {
		{
			p.SetState(6053)
			p.Match(MySqlParserPARTITION)
		}
		{
			p.SetState(6054)
			p.Match(MySqlParserLR_BRACKET)
		}
		p.SetState(6057)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID, MySqlParserREVERSE_QUOTE_ID:
			{
				p.SetState(6055)

				var _x = p.UidList()

				localctx.(*LoadedTableIndexesContext).partitionList = _x
			}

		case MySqlParserALL:
			{
				p.SetState(6056)
				p.Match(MySqlParserALL)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(6059)
			p.Match(MySqlParserRR_BRACKET)
		}

	}
	p.SetState(6069)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 885, p.GetParserRuleContext()) == 1 {
		p.SetState(6063)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserINDEX || _la == MySqlParserKEY {
			{
				p.SetState(6062)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*LoadedTableIndexesContext).indexFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserINDEX || _la == MySqlParserKEY) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*LoadedTableIndexesContext).indexFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(6065)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(6066)

			var _x = p.UidList()

			localctx.(*LoadedTableIndexesContext).indexList = _x
		}
		{
			p.SetState(6067)
			p.Match(MySqlParserRR_BRACKET)
		}

	}
	p.SetState(6073)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserIGNORE {
		{
			p.SetState(6071)
			p.Match(MySqlParserIGNORE)
		}
		{
			p.SetState(6072)
			p.Match(MySqlParserLEAVES)
		}

	}

	return localctx
}

// ISimpleDescribeStatementContext is an interface to support dynamic dispatch.
type ISimpleDescribeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCommand returns the command token.
	GetCommand() antlr.Token

	// GetPattern returns the pattern token.
	GetPattern() antlr.Token

	// SetCommand sets the command token.
	SetCommand(antlr.Token)

	// SetPattern sets the pattern token.
	SetPattern(antlr.Token)

	// GetColumn returns the column rule contexts.
	GetColumn() IUidContext

	// SetColumn sets the column rule contexts.
	SetColumn(IUidContext)

	// Getter signatures
	TableName() ITableNameContext
	EXPLAIN() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode
	DESC() antlr.TerminalNode
	Uid() IUidContext
	STRING_LITERAL() antlr.TerminalNode

	// IsSimpleDescribeStatementContext differentiates from other interfaces.
	IsSimpleDescribeStatementContext()
}

type SimpleDescribeStatementContext struct {
	*antlr.BaseParserRuleContext
	parser  antlr.Parser
	command antlr.Token
	column  IUidContext
	pattern antlr.Token
}

func NewEmptySimpleDescribeStatementContext() *SimpleDescribeStatementContext {
	var p = new(SimpleDescribeStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_simpleDescribeStatement
	return p
}

func (*SimpleDescribeStatementContext) IsSimpleDescribeStatementContext() {}

func NewSimpleDescribeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleDescribeStatementContext {
	var p = new(SimpleDescribeStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_simpleDescribeStatement

	return p
}

func (s *SimpleDescribeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleDescribeStatementContext) GetCommand() antlr.Token { return s.command }

func (s *SimpleDescribeStatementContext) GetPattern() antlr.Token { return s.pattern }

func (s *SimpleDescribeStatementContext) SetCommand(v antlr.Token) { s.command = v }

func (s *SimpleDescribeStatementContext) SetPattern(v antlr.Token) { s.pattern = v }

func (s *SimpleDescribeStatementContext) GetColumn() IUidContext { return s.column }

func (s *SimpleDescribeStatementContext) SetColumn(v IUidContext) { s.column = v }

func (s *SimpleDescribeStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *SimpleDescribeStatementContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXPLAIN, 0)
}

func (s *SimpleDescribeStatementContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDESCRIBE, 0)
}

func (s *SimpleDescribeStatementContext) DESC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDESC, 0)
}

func (s *SimpleDescribeStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SimpleDescribeStatementContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *SimpleDescribeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleDescribeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleDescribeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSimpleDescribeStatement(s)
	}
}

func (s *SimpleDescribeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSimpleDescribeStatement(s)
	}
}

func (p *MySqlParser) SimpleDescribeStatement() (localctx ISimpleDescribeStatementContext) {
	this := p
	_ = this

	localctx = NewSimpleDescribeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 518, MySqlParserRULE_simpleDescribeStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6075)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*SimpleDescribeStatementContext).command = _lt

		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4611791571543654400) != 0) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*SimpleDescribeStatementContext).command = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(6076)
		p.TableName()
	}
	p.SetState(6079)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 887, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6077)

			var _x = p.Uid()

			localctx.(*SimpleDescribeStatementContext).column = _x
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 887, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(6078)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*SimpleDescribeStatementContext).pattern = _m
		}

	}

	return localctx
}

// IFullDescribeStatementContext is an interface to support dynamic dispatch.
type IFullDescribeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCommand returns the command token.
	GetCommand() antlr.Token

	// GetFormatType returns the formatType token.
	GetFormatType() antlr.Token

	// GetFormatValue returns the formatValue token.
	GetFormatValue() antlr.Token

	// SetCommand sets the command token.
	SetCommand(antlr.Token)

	// SetFormatType sets the formatType token.
	SetFormatType(antlr.Token)

	// SetFormatValue sets the formatValue token.
	SetFormatValue(antlr.Token)

	// Getter signatures
	DescribeObjectClause() IDescribeObjectClauseContext
	EXPLAIN() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode
	DESC() antlr.TerminalNode
	EQUAL_SYMBOL() antlr.TerminalNode
	EXTENDED() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	TRADITIONAL() antlr.TerminalNode
	JSON() antlr.TerminalNode

	// IsFullDescribeStatementContext differentiates from other interfaces.
	IsFullDescribeStatementContext()
}

type FullDescribeStatementContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	command     antlr.Token
	formatType  antlr.Token
	formatValue antlr.Token
}

func NewEmptyFullDescribeStatementContext() *FullDescribeStatementContext {
	var p = new(FullDescribeStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_fullDescribeStatement
	return p
}

func (*FullDescribeStatementContext) IsFullDescribeStatementContext() {}

func NewFullDescribeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullDescribeStatementContext {
	var p = new(FullDescribeStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_fullDescribeStatement

	return p
}

func (s *FullDescribeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *FullDescribeStatementContext) GetCommand() antlr.Token { return s.command }

func (s *FullDescribeStatementContext) GetFormatType() antlr.Token { return s.formatType }

func (s *FullDescribeStatementContext) GetFormatValue() antlr.Token { return s.formatValue }

func (s *FullDescribeStatementContext) SetCommand(v antlr.Token) { s.command = v }

func (s *FullDescribeStatementContext) SetFormatType(v antlr.Token) { s.formatType = v }

func (s *FullDescribeStatementContext) SetFormatValue(v antlr.Token) { s.formatValue = v }

func (s *FullDescribeStatementContext) DescribeObjectClause() IDescribeObjectClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescribeObjectClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescribeObjectClauseContext)
}

func (s *FullDescribeStatementContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXPLAIN, 0)
}

func (s *FullDescribeStatementContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDESCRIBE, 0)
}

func (s *FullDescribeStatementContext) DESC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDESC, 0)
}

func (s *FullDescribeStatementContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *FullDescribeStatementContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXTENDED, 0)
}

func (s *FullDescribeStatementContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITIONS, 0)
}

func (s *FullDescribeStatementContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserFORMAT, 0)
}

func (s *FullDescribeStatementContext) TRADITIONAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRADITIONAL, 0)
}

func (s *FullDescribeStatementContext) JSON() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON, 0)
}

func (s *FullDescribeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullDescribeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FullDescribeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFullDescribeStatement(s)
	}
}

func (s *FullDescribeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFullDescribeStatement(s)
	}
}

func (p *MySqlParser) FullDescribeStatement() (localctx IFullDescribeStatementContext) {
	this := p
	_ = this

	localctx = NewFullDescribeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 520, MySqlParserRULE_fullDescribeStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6081)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*FullDescribeStatementContext).command = _lt

		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4611791571543654400) != 0) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*FullDescribeStatementContext).command = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(6085)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserEXTENDED || _la == MySqlParserPARTITIONS || _la == MySqlParserFORMAT {
		{
			p.SetState(6082)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*FullDescribeStatementContext).formatType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserEXTENDED || _la == MySqlParserPARTITIONS || _la == MySqlParserFORMAT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*FullDescribeStatementContext).formatType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6083)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}
		{
			p.SetState(6084)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*FullDescribeStatementContext).formatValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserJSON || _la == MySqlParserTRADITIONAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*FullDescribeStatementContext).formatValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(6087)
		p.DescribeObjectClause()
	}

	return localctx
}

// IHelpStatementContext is an interface to support dynamic dispatch.
type IHelpStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HELP() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsHelpStatementContext differentiates from other interfaces.
	IsHelpStatementContext()
}

type HelpStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHelpStatementContext() *HelpStatementContext {
	var p = new(HelpStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_helpStatement
	return p
}

func (*HelpStatementContext) IsHelpStatementContext() {}

func NewHelpStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HelpStatementContext {
	var p = new(HelpStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_helpStatement

	return p
}

func (s *HelpStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HelpStatementContext) HELP() antlr.TerminalNode {
	return s.GetToken(MySqlParserHELP, 0)
}

func (s *HelpStatementContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *HelpStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HelpStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HelpStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHelpStatement(s)
	}
}

func (s *HelpStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHelpStatement(s)
	}
}

func (p *MySqlParser) HelpStatement() (localctx IHelpStatementContext) {
	this := p
	_ = this

	localctx = NewHelpStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 522, MySqlParserRULE_helpStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6089)
		p.Match(MySqlParserHELP)
	}
	{
		p.SetState(6090)
		p.Match(MySqlParserSTRING_LITERAL)
	}

	return localctx
}

// IUseStatementContext is an interface to support dynamic dispatch.
type IUseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USE() antlr.TerminalNode
	Uid() IUidContext

	// IsUseStatementContext differentiates from other interfaces.
	IsUseStatementContext()
}

type UseStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseStatementContext() *UseStatementContext {
	var p = new(UseStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_useStatement
	return p
}

func (*UseStatementContext) IsUseStatementContext() {}

func NewUseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseStatementContext {
	var p = new(UseStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_useStatement

	return p
}

func (s *UseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UseStatementContext) USE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSE, 0)
}

func (s *UseStatementContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *UseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUseStatement(s)
	}
}

func (s *UseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUseStatement(s)
	}
}

func (p *MySqlParser) UseStatement() (localctx IUseStatementContext) {
	this := p
	_ = this

	localctx = NewUseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 524, MySqlParserRULE_useStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6092)
		p.Match(MySqlParserUSE)
	}
	{
		p.SetState(6093)
		p.Uid()
	}

	return localctx
}

// ISignalStatementContext is an interface to support dynamic dispatch.
type ISignalStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SIGNAL() antlr.TerminalNode
	ID() antlr.TerminalNode
	REVERSE_QUOTE_ID() antlr.TerminalNode
	SET() antlr.TerminalNode
	AllSignalConditionInformation() []ISignalConditionInformationContext
	SignalConditionInformation(i int) ISignalConditionInformationContext
	SQLSTATE() antlr.TerminalNode
	StringLiteral() IStringLiteralContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	VALUE() antlr.TerminalNode

	// IsSignalStatementContext differentiates from other interfaces.
	IsSignalStatementContext()
}

type SignalStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignalStatementContext() *SignalStatementContext {
	var p = new(SignalStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_signalStatement
	return p
}

func (*SignalStatementContext) IsSignalStatementContext() {}

func NewSignalStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignalStatementContext {
	var p = new(SignalStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_signalStatement

	return p
}

func (s *SignalStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SignalStatementContext) SIGNAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSIGNAL, 0)
}

func (s *SignalStatementContext) ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserID, 0)
}

func (s *SignalStatementContext) REVERSE_QUOTE_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserREVERSE_QUOTE_ID, 0)
}

func (s *SignalStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *SignalStatementContext) AllSignalConditionInformation() []ISignalConditionInformationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISignalConditionInformationContext); ok {
			len++
		}
	}

	tst := make([]ISignalConditionInformationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISignalConditionInformationContext); ok {
			tst[i] = t.(ISignalConditionInformationContext)
			i++
		}
	}

	return tst
}

func (s *SignalStatementContext) SignalConditionInformation(i int) ISignalConditionInformationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignalConditionInformationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignalConditionInformationContext)
}

func (s *SignalStatementContext) SQLSTATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQLSTATE, 0)
}

func (s *SignalStatementContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *SignalStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *SignalStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *SignalStatementContext) VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUE, 0)
}

func (s *SignalStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignalStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SignalStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSignalStatement(s)
	}
}

func (s *SignalStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSignalStatement(s)
	}
}

func (p *MySqlParser) SignalStatement() (localctx ISignalStatementContext) {
	this := p
	_ = this

	localctx = NewSignalStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 526, MySqlParserRULE_signalStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6095)
		p.Match(MySqlParserSIGNAL)
	}
	p.SetState(6103)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSQLSTATE:
		{
			p.SetState(6096)
			p.Match(MySqlParserSQLSTATE)
		}
		p.SetState(6098)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserVALUE {
			{
				p.SetState(6097)
				p.Match(MySqlParserVALUE)
			}

		}
		{
			p.SetState(6100)
			p.StringLiteral()
		}

	case MySqlParserID:
		{
			p.SetState(6101)
			p.Match(MySqlParserID)
		}

	case MySqlParserREVERSE_QUOTE_ID:
		{
			p.SetState(6102)
			p.Match(MySqlParserREVERSE_QUOTE_ID)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(6114)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 892, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6105)
			p.Match(MySqlParserSET)
		}
		{
			p.SetState(6106)
			p.SignalConditionInformation()
		}
		p.SetState(6111)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(6107)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(6108)
				p.SignalConditionInformation()
			}

			p.SetState(6113)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IResignalStatementContext is an interface to support dynamic dispatch.
type IResignalStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESIGNAL() antlr.TerminalNode
	ID() antlr.TerminalNode
	REVERSE_QUOTE_ID() antlr.TerminalNode
	SET() antlr.TerminalNode
	AllSignalConditionInformation() []ISignalConditionInformationContext
	SignalConditionInformation(i int) ISignalConditionInformationContext
	SQLSTATE() antlr.TerminalNode
	StringLiteral() IStringLiteralContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	VALUE() antlr.TerminalNode

	// IsResignalStatementContext differentiates from other interfaces.
	IsResignalStatementContext()
}

type ResignalStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResignalStatementContext() *ResignalStatementContext {
	var p = new(ResignalStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_resignalStatement
	return p
}

func (*ResignalStatementContext) IsResignalStatementContext() {}

func NewResignalStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResignalStatementContext {
	var p = new(ResignalStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_resignalStatement

	return p
}

func (s *ResignalStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ResignalStatementContext) RESIGNAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESIGNAL, 0)
}

func (s *ResignalStatementContext) ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserID, 0)
}

func (s *ResignalStatementContext) REVERSE_QUOTE_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserREVERSE_QUOTE_ID, 0)
}

func (s *ResignalStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *ResignalStatementContext) AllSignalConditionInformation() []ISignalConditionInformationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISignalConditionInformationContext); ok {
			len++
		}
	}

	tst := make([]ISignalConditionInformationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISignalConditionInformationContext); ok {
			tst[i] = t.(ISignalConditionInformationContext)
			i++
		}
	}

	return tst
}

func (s *ResignalStatementContext) SignalConditionInformation(i int) ISignalConditionInformationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignalConditionInformationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignalConditionInformationContext)
}

func (s *ResignalStatementContext) SQLSTATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQLSTATE, 0)
}

func (s *ResignalStatementContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ResignalStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *ResignalStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *ResignalStatementContext) VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUE, 0)
}

func (s *ResignalStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResignalStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResignalStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterResignalStatement(s)
	}
}

func (s *ResignalStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitResignalStatement(s)
	}
}

func (p *MySqlParser) ResignalStatement() (localctx IResignalStatementContext) {
	this := p
	_ = this

	localctx = NewResignalStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 528, MySqlParserRULE_resignalStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6116)
		p.Match(MySqlParserRESIGNAL)
	}
	p.SetState(6124)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSQLSTATE:
		{
			p.SetState(6117)
			p.Match(MySqlParserSQLSTATE)
		}
		p.SetState(6119)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserVALUE {
			{
				p.SetState(6118)
				p.Match(MySqlParserVALUE)
			}

		}
		{
			p.SetState(6121)
			p.StringLiteral()
		}

	case MySqlParserID:
		{
			p.SetState(6122)
			p.Match(MySqlParserID)
		}

	case MySqlParserREVERSE_QUOTE_ID:
		{
			p.SetState(6123)
			p.Match(MySqlParserREVERSE_QUOTE_ID)
		}

	case MySqlParserEOF, MySqlParserALTER, MySqlParserANALYZE, MySqlParserCALL, MySqlParserCHANGE, MySqlParserCHECK, MySqlParserCREATE, MySqlParserDELETE, MySqlParserDESC, MySqlParserDESCRIBE, MySqlParserDROP, MySqlParserEXPLAIN, MySqlParserGET, MySqlParserGRANT, MySqlParserINSERT, MySqlParserKILL, MySqlParserLOAD, MySqlParserLOCK, MySqlParserOPTIMIZE, MySqlParserPURGE, MySqlParserRELEASE, MySqlParserRENAME, MySqlParserREPLACE, MySqlParserRESIGNAL, MySqlParserREVOKE, MySqlParserSELECT, MySqlParserSET, MySqlParserSHOW, MySqlParserSIGNAL, MySqlParserUNLOCK, MySqlParserUPDATE, MySqlParserUSE, MySqlParserVALUES, MySqlParserWITH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserCACHE, MySqlParserCHECKSUM, MySqlParserCOMMIT, MySqlParserDEALLOCATE, MySqlParserDO, MySqlParserFLUSH, MySqlParserHANDLER, MySqlParserHELP, MySqlParserINSTALL, MySqlParserPREPARE, MySqlParserREPAIR, MySqlParserRESET, MySqlParserROLLBACK, MySqlParserSAVEPOINT, MySqlParserSTART, MySqlParserSTOP, MySqlParserTRUNCATE, MySqlParserUNINSTALL, MySqlParserXA, MySqlParserEXECUTE, MySqlParserSHUTDOWN, MySqlParserMINUS, MySqlParserLR_BRACKET, MySqlParserSEMI:

	default:
	}
	p.SetState(6135)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 896, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6126)
			p.Match(MySqlParserSET)
		}
		{
			p.SetState(6127)
			p.SignalConditionInformation()
		}
		p.SetState(6132)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(6128)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(6129)
				p.SignalConditionInformation()
			}

			p.SetState(6134)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// ISignalConditionInformationContext is an interface to support dynamic dispatch.
type ISignalConditionInformationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUAL_SYMBOL() antlr.TerminalNode
	CLASS_ORIGIN() antlr.TerminalNode
	SUBCLASS_ORIGIN() antlr.TerminalNode
	MESSAGE_TEXT() antlr.TerminalNode
	MYSQL_ERRNO() antlr.TerminalNode
	CONSTRAINT_CATALOG() antlr.TerminalNode
	CONSTRAINT_SCHEMA() antlr.TerminalNode
	CONSTRAINT_NAME() antlr.TerminalNode
	CATALOG_NAME() antlr.TerminalNode
	SCHEMA_NAME() antlr.TerminalNode
	TABLE_NAME() antlr.TerminalNode
	COLUMN_NAME() antlr.TerminalNode
	CURSOR_NAME() antlr.TerminalNode
	StringLiteral() IStringLiteralContext
	DECIMAL_LITERAL() antlr.TerminalNode
	MysqlVariable() IMysqlVariableContext
	SimpleId() ISimpleIdContext

	// IsSignalConditionInformationContext differentiates from other interfaces.
	IsSignalConditionInformationContext()
}

type SignalConditionInformationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignalConditionInformationContext() *SignalConditionInformationContext {
	var p = new(SignalConditionInformationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_signalConditionInformation
	return p
}

func (*SignalConditionInformationContext) IsSignalConditionInformationContext() {}

func NewSignalConditionInformationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignalConditionInformationContext {
	var p = new(SignalConditionInformationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_signalConditionInformation

	return p
}

func (s *SignalConditionInformationContext) GetParser() antlr.Parser { return s.parser }

func (s *SignalConditionInformationContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *SignalConditionInformationContext) CLASS_ORIGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCLASS_ORIGIN, 0)
}

func (s *SignalConditionInformationContext) SUBCLASS_ORIGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBCLASS_ORIGIN, 0)
}

func (s *SignalConditionInformationContext) MESSAGE_TEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMESSAGE_TEXT, 0)
}

func (s *SignalConditionInformationContext) MYSQL_ERRNO() antlr.TerminalNode {
	return s.GetToken(MySqlParserMYSQL_ERRNO, 0)
}

func (s *SignalConditionInformationContext) CONSTRAINT_CATALOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT_CATALOG, 0)
}

func (s *SignalConditionInformationContext) CONSTRAINT_SCHEMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT_SCHEMA, 0)
}

func (s *SignalConditionInformationContext) CONSTRAINT_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT_NAME, 0)
}

func (s *SignalConditionInformationContext) CATALOG_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCATALOG_NAME, 0)
}

func (s *SignalConditionInformationContext) SCHEMA_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEMA_NAME, 0)
}

func (s *SignalConditionInformationContext) TABLE_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE_NAME, 0)
}

func (s *SignalConditionInformationContext) COLUMN_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN_NAME, 0)
}

func (s *SignalConditionInformationContext) CURSOR_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURSOR_NAME, 0)
}

func (s *SignalConditionInformationContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *SignalConditionInformationContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserDECIMAL_LITERAL, 0)
}

func (s *SignalConditionInformationContext) MysqlVariable() IMysqlVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMysqlVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMysqlVariableContext)
}

func (s *SignalConditionInformationContext) SimpleId() ISimpleIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdContext)
}

func (s *SignalConditionInformationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignalConditionInformationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SignalConditionInformationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSignalConditionInformation(s)
	}
}

func (s *SignalConditionInformationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSignalConditionInformation(s)
	}
}

func (p *MySqlParser) SignalConditionInformation() (localctx ISignalConditionInformationContext) {
	this := p
	_ = this

	localctx = NewSignalConditionInformationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 530, MySqlParserRULE_signalConditionInformation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6137)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-359)) & ^0x3f) == 0 && ((int64(1)<<(_la-359))&272105729) != 0) || _la == MySqlParserMESSAGE_TEXT || _la == MySqlParserMYSQL_ERRNO || _la == MySqlParserSUBCLASS_ORIGIN || _la == MySqlParserTABLE_NAME || _la == MySqlParserCATALOG_NAME || _la == MySqlParserSCHEMA_NAME) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(6138)
		p.Match(MySqlParserEQUAL_SYMBOL)
	}
	p.SetState(6143)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 897, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(6139)
			p.StringLiteral()
		}

	case 2:
		{
			p.SetState(6140)
			p.Match(MySqlParserDECIMAL_LITERAL)
		}

	case 3:
		{
			p.SetState(6141)
			p.MysqlVariable()
		}

	case 4:
		{
			p.SetState(6142)
			p.SimpleId()
		}

	}

	return localctx
}

// IWithStatementContext is an interface to support dynamic dispatch.
type IWithStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	AllCommonTableExpressions() []ICommonTableExpressionsContext
	CommonTableExpressions(i int) ICommonTableExpressionsContext
	RECURSIVE() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWithStatementContext differentiates from other interfaces.
	IsWithStatementContext()
}

type WithStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithStatementContext() *WithStatementContext {
	var p = new(WithStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_withStatement
	return p
}

func (*WithStatementContext) IsWithStatementContext() {}

func NewWithStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithStatementContext {
	var p = new(WithStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_withStatement

	return p
}

func (s *WithStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WithStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *WithStatementContext) AllCommonTableExpressions() []ICommonTableExpressionsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICommonTableExpressionsContext); ok {
			len++
		}
	}

	tst := make([]ICommonTableExpressionsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICommonTableExpressionsContext); ok {
			tst[i] = t.(ICommonTableExpressionsContext)
			i++
		}
	}

	return tst
}

func (s *WithStatementContext) CommonTableExpressions(i int) ICommonTableExpressionsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommonTableExpressionsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommonTableExpressionsContext)
}

func (s *WithStatementContext) RECURSIVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRECURSIVE, 0)
}

func (s *WithStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *WithStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *WithStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterWithStatement(s)
	}
}

func (s *WithStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitWithStatement(s)
	}
}

func (p *MySqlParser) WithStatement() (localctx IWithStatementContext) {
	this := p
	_ = this

	localctx = NewWithStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 532, MySqlParserRULE_withStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6145)
		p.Match(MySqlParserWITH)
	}
	p.SetState(6147)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 898, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6146)
			p.Match(MySqlParserRECURSIVE)
		}

	}
	{
		p.SetState(6149)
		p.CommonTableExpressions()
	}
	p.SetState(6154)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(6150)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(6151)
			p.CommonTableExpressions()
		}

		p.SetState(6156)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDiagnosticsStatementContext is an interface to support dynamic dispatch.
type IDiagnosticsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GET() antlr.TerminalNode
	DIAGNOSTICS() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	STACKED() antlr.TerminalNode
	AllVariableClause() []IVariableClauseContext
	VariableClause(i int) IVariableClauseContext
	AllEQUAL_SYMBOL() []antlr.TerminalNode
	EQUAL_SYMBOL(i int) antlr.TerminalNode
	CONDITION() antlr.TerminalNode
	AllDiagnosticsConditionInformationName() []IDiagnosticsConditionInformationNameContext
	DiagnosticsConditionInformationName(i int) IDiagnosticsConditionInformationNameContext
	AllNUMBER() []antlr.TerminalNode
	NUMBER(i int) antlr.TerminalNode
	AllROW_COUNT() []antlr.TerminalNode
	ROW_COUNT(i int) antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDiagnosticsStatementContext differentiates from other interfaces.
	IsDiagnosticsStatementContext()
}

type DiagnosticsStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDiagnosticsStatementContext() *DiagnosticsStatementContext {
	var p = new(DiagnosticsStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_diagnosticsStatement
	return p
}

func (*DiagnosticsStatementContext) IsDiagnosticsStatementContext() {}

func NewDiagnosticsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DiagnosticsStatementContext {
	var p = new(DiagnosticsStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_diagnosticsStatement

	return p
}

func (s *DiagnosticsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DiagnosticsStatementContext) GET() antlr.TerminalNode {
	return s.GetToken(MySqlParserGET, 0)
}

func (s *DiagnosticsStatementContext) DIAGNOSTICS() antlr.TerminalNode {
	return s.GetToken(MySqlParserDIAGNOSTICS, 0)
}

func (s *DiagnosticsStatementContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT, 0)
}

func (s *DiagnosticsStatementContext) STACKED() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTACKED, 0)
}

func (s *DiagnosticsStatementContext) AllVariableClause() []IVariableClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableClauseContext); ok {
			len++
		}
	}

	tst := make([]IVariableClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableClauseContext); ok {
			tst[i] = t.(IVariableClauseContext)
			i++
		}
	}

	return tst
}

func (s *DiagnosticsStatementContext) VariableClause(i int) IVariableClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableClauseContext)
}

func (s *DiagnosticsStatementContext) AllEQUAL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserEQUAL_SYMBOL)
}

func (s *DiagnosticsStatementContext) EQUAL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, i)
}

func (s *DiagnosticsStatementContext) CONDITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONDITION, 0)
}

func (s *DiagnosticsStatementContext) AllDiagnosticsConditionInformationName() []IDiagnosticsConditionInformationNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDiagnosticsConditionInformationNameContext); ok {
			len++
		}
	}

	tst := make([]IDiagnosticsConditionInformationNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDiagnosticsConditionInformationNameContext); ok {
			tst[i] = t.(IDiagnosticsConditionInformationNameContext)
			i++
		}
	}

	return tst
}

func (s *DiagnosticsStatementContext) DiagnosticsConditionInformationName(i int) IDiagnosticsConditionInformationNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDiagnosticsConditionInformationNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDiagnosticsConditionInformationNameContext)
}

func (s *DiagnosticsStatementContext) AllNUMBER() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserNUMBER)
}

func (s *DiagnosticsStatementContext) NUMBER(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserNUMBER, i)
}

func (s *DiagnosticsStatementContext) AllROW_COUNT() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserROW_COUNT)
}

func (s *DiagnosticsStatementContext) ROW_COUNT(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserROW_COUNT, i)
}

func (s *DiagnosticsStatementContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *DiagnosticsStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *DiagnosticsStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *DiagnosticsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DiagnosticsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DiagnosticsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDiagnosticsStatement(s)
	}
}

func (s *DiagnosticsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDiagnosticsStatement(s)
	}
}

func (p *MySqlParser) DiagnosticsStatement() (localctx IDiagnosticsStatementContext) {
	this := p
	_ = this

	localctx = NewDiagnosticsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 534, MySqlParserRULE_diagnosticsStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6157)
		p.Match(MySqlParserGET)
	}
	p.SetState(6159)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserCURRENT || _la == MySqlParserSTACKED {
		{
			p.SetState(6158)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCURRENT || _la == MySqlParserSTACKED) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(6161)
		p.Match(MySqlParserDIAGNOSTICS)
	}
	p.SetState(6193)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 904, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(6162)
			p.VariableClause()
		}
		{
			p.SetState(6163)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}
		{
			p.SetState(6164)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserNUMBER || _la == MySqlParserROW_COUNT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6172)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(6165)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(6166)
				p.VariableClause()
			}
			{
				p.SetState(6167)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}
			{
				p.SetState(6168)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserNUMBER || _la == MySqlParserROW_COUNT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

			p.SetState(6174)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		{
			p.SetState(6175)
			p.Match(MySqlParserCONDITION)
		}
		p.SetState(6178)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserZERO_DECIMAL, MySqlParserONE_DECIMAL, MySqlParserTWO_DECIMAL, MySqlParserDECIMAL_LITERAL, MySqlParserREAL_LITERAL:
			{
				p.SetState(6176)
				p.DecimalLiteral()
			}

		case MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserAT_SIGN, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID, MySqlParserREVERSE_QUOTE_ID, MySqlParserLOCAL_ID, MySqlParserGLOBAL_ID:
			{
				p.SetState(6177)
				p.VariableClause()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(6180)
			p.VariableClause()
		}
		{
			p.SetState(6181)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}
		{
			p.SetState(6182)
			p.DiagnosticsConditionInformationName()
		}
		p.SetState(6190)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(6183)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(6184)
				p.VariableClause()
			}
			{
				p.SetState(6185)
				p.Match(MySqlParserEQUAL_SYMBOL)
			}
			{
				p.SetState(6186)
				p.DiagnosticsConditionInformationName()
			}

			p.SetState(6192)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IDiagnosticsConditionInformationNameContext is an interface to support dynamic dispatch.
type IDiagnosticsConditionInformationNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLASS_ORIGIN() antlr.TerminalNode
	SUBCLASS_ORIGIN() antlr.TerminalNode
	RETURNED_SQLSTATE() antlr.TerminalNode
	MESSAGE_TEXT() antlr.TerminalNode
	MYSQL_ERRNO() antlr.TerminalNode
	CONSTRAINT_CATALOG() antlr.TerminalNode
	CONSTRAINT_SCHEMA() antlr.TerminalNode
	CONSTRAINT_NAME() antlr.TerminalNode
	CATALOG_NAME() antlr.TerminalNode
	SCHEMA_NAME() antlr.TerminalNode
	TABLE_NAME() antlr.TerminalNode
	COLUMN_NAME() antlr.TerminalNode
	CURSOR_NAME() antlr.TerminalNode

	// IsDiagnosticsConditionInformationNameContext differentiates from other interfaces.
	IsDiagnosticsConditionInformationNameContext()
}

type DiagnosticsConditionInformationNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDiagnosticsConditionInformationNameContext() *DiagnosticsConditionInformationNameContext {
	var p = new(DiagnosticsConditionInformationNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_diagnosticsConditionInformationName
	return p
}

func (*DiagnosticsConditionInformationNameContext) IsDiagnosticsConditionInformationNameContext() {}

func NewDiagnosticsConditionInformationNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DiagnosticsConditionInformationNameContext {
	var p = new(DiagnosticsConditionInformationNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_diagnosticsConditionInformationName

	return p
}

func (s *DiagnosticsConditionInformationNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DiagnosticsConditionInformationNameContext) CLASS_ORIGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCLASS_ORIGIN, 0)
}

func (s *DiagnosticsConditionInformationNameContext) SUBCLASS_ORIGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBCLASS_ORIGIN, 0)
}

func (s *DiagnosticsConditionInformationNameContext) RETURNED_SQLSTATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRETURNED_SQLSTATE, 0)
}

func (s *DiagnosticsConditionInformationNameContext) MESSAGE_TEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMESSAGE_TEXT, 0)
}

func (s *DiagnosticsConditionInformationNameContext) MYSQL_ERRNO() antlr.TerminalNode {
	return s.GetToken(MySqlParserMYSQL_ERRNO, 0)
}

func (s *DiagnosticsConditionInformationNameContext) CONSTRAINT_CATALOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT_CATALOG, 0)
}

func (s *DiagnosticsConditionInformationNameContext) CONSTRAINT_SCHEMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT_SCHEMA, 0)
}

func (s *DiagnosticsConditionInformationNameContext) CONSTRAINT_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT_NAME, 0)
}

func (s *DiagnosticsConditionInformationNameContext) CATALOG_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCATALOG_NAME, 0)
}

func (s *DiagnosticsConditionInformationNameContext) SCHEMA_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEMA_NAME, 0)
}

func (s *DiagnosticsConditionInformationNameContext) TABLE_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE_NAME, 0)
}

func (s *DiagnosticsConditionInformationNameContext) COLUMN_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN_NAME, 0)
}

func (s *DiagnosticsConditionInformationNameContext) CURSOR_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURSOR_NAME, 0)
}

func (s *DiagnosticsConditionInformationNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DiagnosticsConditionInformationNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DiagnosticsConditionInformationNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDiagnosticsConditionInformationName(s)
	}
}

func (s *DiagnosticsConditionInformationNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDiagnosticsConditionInformationName(s)
	}
}

func (p *MySqlParser) DiagnosticsConditionInformationName() (localctx IDiagnosticsConditionInformationNameContext) {
	this := p
	_ = this

	localctx = NewDiagnosticsConditionInformationNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 536, MySqlParserRULE_diagnosticsConditionInformationName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6195)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-359)) & ^0x3f) == 0 && ((int64(1)<<(_la-359))&272105729) != 0) || _la == MySqlParserMESSAGE_TEXT || _la == MySqlParserMYSQL_ERRNO || ((int64((_la-592)) & ^0x3f) == 0 && ((int64(1)<<(_la-592))&18155135997837313) != 0) || _la == MySqlParserCATALOG_NAME || _la == MySqlParserSCHEMA_NAME) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDescribeObjectClauseContext is an interface to support dynamic dispatch.
type IDescribeObjectClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsDescribeObjectClauseContext differentiates from other interfaces.
	IsDescribeObjectClauseContext()
}

type DescribeObjectClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescribeObjectClauseContext() *DescribeObjectClauseContext {
	var p = new(DescribeObjectClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_describeObjectClause
	return p
}

func (*DescribeObjectClauseContext) IsDescribeObjectClauseContext() {}

func NewDescribeObjectClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescribeObjectClauseContext {
	var p = new(DescribeObjectClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_describeObjectClause

	return p
}

func (s *DescribeObjectClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DescribeObjectClauseContext) CopyFrom(ctx *DescribeObjectClauseContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *DescribeObjectClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeObjectClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DescribeStatementsContext struct {
	*DescribeObjectClauseContext
}

func NewDescribeStatementsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeStatementsContext {
	var p = new(DescribeStatementsContext)

	p.DescribeObjectClauseContext = NewEmptyDescribeObjectClauseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*DescribeObjectClauseContext))

	return p
}

func (s *DescribeStatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeStatementsContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *DescribeStatementsContext) DeleteStatement() IDeleteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeleteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeleteStatementContext)
}

func (s *DescribeStatementsContext) InsertStatement() IInsertStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertStatementContext)
}

func (s *DescribeStatementsContext) ReplaceStatement() IReplaceStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplaceStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplaceStatementContext)
}

func (s *DescribeStatementsContext) UpdateStatement() IUpdateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateStatementContext)
}

func (s *DescribeStatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDescribeStatements(s)
	}
}

func (s *DescribeStatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDescribeStatements(s)
	}
}

type DescribeConnectionContext struct {
	*DescribeObjectClauseContext
}

func NewDescribeConnectionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeConnectionContext {
	var p = new(DescribeConnectionContext)

	p.DescribeObjectClauseContext = NewEmptyDescribeObjectClauseContext()
	p.parser = parser
	p.CopyFrom(ctx.(*DescribeObjectClauseContext))

	return p
}

func (s *DescribeConnectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeConnectionContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *DescribeConnectionContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONNECTION, 0)
}

func (s *DescribeConnectionContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DescribeConnectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDescribeConnection(s)
	}
}

func (s *DescribeConnectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDescribeConnection(s)
	}
}

func (p *MySqlParser) DescribeObjectClause() (localctx IDescribeObjectClauseContext) {
	this := p
	_ = this

	localctx = NewDescribeObjectClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 538, MySqlParserRULE_describeObjectClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6207)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserDELETE, MySqlParserINSERT, MySqlParserREPLACE, MySqlParserSELECT, MySqlParserUPDATE, MySqlParserLR_BRACKET:
		localctx = NewDescribeStatementsContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6202)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserSELECT, MySqlParserLR_BRACKET:
			{
				p.SetState(6197)
				p.SelectStatement()
			}

		case MySqlParserDELETE:
			{
				p.SetState(6198)
				p.DeleteStatement()
			}

		case MySqlParserINSERT:
			{
				p.SetState(6199)
				p.InsertStatement()
			}

		case MySqlParserREPLACE:
			{
				p.SetState(6200)
				p.ReplaceStatement()
			}

		case MySqlParserUPDATE:
			{
				p.SetState(6201)
				p.UpdateStatement()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case MySqlParserFOR:
		localctx = NewDescribeConnectionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6204)
			p.Match(MySqlParserFOR)
		}
		{
			p.SetState(6205)
			p.Match(MySqlParserCONNECTION)
		}
		{
			p.SetState(6206)
			p.Uid()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFullIdContext is an interface to support dynamic dispatch.
type IFullIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllUid() []IUidContext
	Uid(i int) IUidContext
	DOT_ID() antlr.TerminalNode
	DOT() antlr.TerminalNode

	// IsFullIdContext differentiates from other interfaces.
	IsFullIdContext()
}

type FullIdContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullIdContext() *FullIdContext {
	var p = new(FullIdContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_fullId
	return p
}

func (*FullIdContext) IsFullIdContext() {}

func NewFullIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullIdContext {
	var p = new(FullIdContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_fullId

	return p
}

func (s *FullIdContext) GetParser() antlr.Parser { return s.parser }

func (s *FullIdContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *FullIdContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *FullIdContext) DOT_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT_ID, 0)
}

func (s *FullIdContext) DOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT, 0)
}

func (s *FullIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FullIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFullId(s)
	}
}

func (s *FullIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFullId(s)
	}
}

func (p *MySqlParser) FullId() (localctx IFullIdContext) {
	this := p
	_ = this

	localctx = NewFullIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 540, MySqlParserRULE_fullId)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6209)
		p.Uid()
	}
	p.SetState(6213)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 907, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6210)
			p.Match(MySqlParserDOT_ID)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 907, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(6211)
			p.Match(MySqlParserDOT)
		}
		{
			p.SetState(6212)
			p.Uid()
		}

	}

	return localctx
}

// ITableNameContext is an interface to support dynamic dispatch.
type ITableNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FullId() IFullIdContext

	// IsTableNameContext differentiates from other interfaces.
	IsTableNameContext()
}

type TableNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableNameContext() *TableNameContext {
	var p = new(TableNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_tableName
	return p
}

func (*TableNameContext) IsTableNameContext() {}

func NewTableNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableNameContext {
	var p = new(TableNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tableName

	return p
}

func (s *TableNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TableNameContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *TableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableName(s)
	}
}

func (s *TableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableName(s)
	}
}

func (p *MySqlParser) TableName() (localctx ITableNameContext) {
	this := p
	_ = this

	localctx = NewTableNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 542, MySqlParserRULE_tableName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6215)
		p.FullId()
	}

	return localctx
}

// IRoleNameContext is an interface to support dynamic dispatch.
type IRoleNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UserName() IUserNameContext
	Uid() IUidContext

	// IsRoleNameContext differentiates from other interfaces.
	IsRoleNameContext()
}

type RoleNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoleNameContext() *RoleNameContext {
	var p = new(RoleNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_roleName
	return p
}

func (*RoleNameContext) IsRoleNameContext() {}

func NewRoleNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleNameContext {
	var p = new(RoleNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_roleName

	return p
}

func (s *RoleNameContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleNameContext) UserName() IUserNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserNameContext)
}

func (s *RoleNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *RoleNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRoleName(s)
	}
}

func (s *RoleNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRoleName(s)
	}
}

func (p *MySqlParser) RoleName() (localctx IRoleNameContext) {
	this := p
	_ = this

	localctx = NewRoleNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 544, MySqlParserRULE_roleName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6219)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 908, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6217)
			p.UserName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6218)
			p.Uid()
		}

	}

	return localctx
}

// IFullColumnNameContext is an interface to support dynamic dispatch.
type IFullColumnNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext
	AllDottedId() []IDottedIdContext
	DottedId(i int) IDottedIdContext

	// IsFullColumnNameContext differentiates from other interfaces.
	IsFullColumnNameContext()
}

type FullColumnNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullColumnNameContext() *FullColumnNameContext {
	var p = new(FullColumnNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_fullColumnName
	return p
}

func (*FullColumnNameContext) IsFullColumnNameContext() {}

func NewFullColumnNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullColumnNameContext {
	var p = new(FullColumnNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_fullColumnName

	return p
}

func (s *FullColumnNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FullColumnNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *FullColumnNameContext) AllDottedId() []IDottedIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDottedIdContext); ok {
			len++
		}
	}

	tst := make([]IDottedIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDottedIdContext); ok {
			tst[i] = t.(IDottedIdContext)
			i++
		}
	}

	return tst
}

func (s *FullColumnNameContext) DottedId(i int) IDottedIdContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDottedIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDottedIdContext)
}

func (s *FullColumnNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullColumnNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FullColumnNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFullColumnName(s)
	}
}

func (s *FullColumnNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFullColumnName(s)
	}
}

func (p *MySqlParser) FullColumnName() (localctx IFullColumnNameContext) {
	this := p
	_ = this

	localctx = NewFullColumnNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 546, MySqlParserRULE_fullColumnName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6235)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 913, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6221)
			p.Uid()
		}
		p.SetState(6226)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 910, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6222)
				p.DottedId()
			}
			p.SetState(6224)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 909, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(6223)
					p.DottedId()
				}

			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(6229)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 911, p.GetParserRuleContext()) == 1 {
			p.SetState(6228)
			p.MatchWildcard()

		}
		{
			p.SetState(6231)
			p.DottedId()
		}
		p.SetState(6233)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 912, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6232)
				p.DottedId()
			}

		}

	}

	return localctx
}

// IIndexColumnNameContext is an interface to support dynamic dispatch.
type IIndexColumnNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSortType returns the sortType token.
	GetSortType() antlr.Token

	// SetSortType sets the sortType token.
	SetSortType(antlr.Token)

	// Getter signatures
	Expression() IExpressionContext
	Uid() IUidContext
	STRING_LITERAL() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	RR_BRACKET() antlr.TerminalNode
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode

	// IsIndexColumnNameContext differentiates from other interfaces.
	IsIndexColumnNameContext()
}

type IndexColumnNameContext struct {
	*antlr.BaseParserRuleContext
	parser   antlr.Parser
	sortType antlr.Token
}

func NewEmptyIndexColumnNameContext() *IndexColumnNameContext {
	var p = new(IndexColumnNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_indexColumnName
	return p
}

func (*IndexColumnNameContext) IsIndexColumnNameContext() {}

func NewIndexColumnNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexColumnNameContext {
	var p = new(IndexColumnNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_indexColumnName

	return p
}

func (s *IndexColumnNameContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexColumnNameContext) GetSortType() antlr.Token { return s.sortType }

func (s *IndexColumnNameContext) SetSortType(v antlr.Token) { s.sortType = v }

func (s *IndexColumnNameContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IndexColumnNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *IndexColumnNameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *IndexColumnNameContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *IndexColumnNameContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *IndexColumnNameContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *IndexColumnNameContext) ASC() antlr.TerminalNode {
	return s.GetToken(MySqlParserASC, 0)
}

func (s *IndexColumnNameContext) DESC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDESC, 0)
}

func (s *IndexColumnNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexColumnNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexColumnNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIndexColumnName(s)
	}
}

func (s *IndexColumnNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIndexColumnName(s)
	}
}

func (p *MySqlParser) IndexColumnName() (localctx IIndexColumnNameContext) {
	this := p
	_ = this

	localctx = NewIndexColumnNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 548, MySqlParserRULE_indexColumnName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6248)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 916, p.GetParserRuleContext()) {
	case 1:
		p.SetState(6239)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 914, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(6237)
				p.Uid()
			}

		case 2:
			{
				p.SetState(6238)
				p.Match(MySqlParserSTRING_LITERAL)
			}

		}
		p.SetState(6245)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(6241)
				p.Match(MySqlParserLR_BRACKET)
			}
			{
				p.SetState(6242)
				p.DecimalLiteral()
			}
			{
				p.SetState(6243)
				p.Match(MySqlParserRR_BRACKET)
			}

		}

	case 2:
		{
			p.SetState(6247)
			p.expression(0)
		}

	}
	p.SetState(6251)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserASC || _la == MySqlParserDESC {
		{
			p.SetState(6250)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*IndexColumnNameContext).sortType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserASC || _la == MySqlParserDESC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*IndexColumnNameContext).sortType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IUserNameContext is an interface to support dynamic dispatch.
type IUserNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING_USER_NAME() antlr.TerminalNode
	ID() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	ADMIN() antlr.TerminalNode
	KeywordsCanBeId() IKeywordsCanBeIdContext

	// IsUserNameContext differentiates from other interfaces.
	IsUserNameContext()
}

type UserNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserNameContext() *UserNameContext {
	var p = new(UserNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_userName
	return p
}

func (*UserNameContext) IsUserNameContext() {}

func NewUserNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserNameContext {
	var p = new(UserNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_userName

	return p
}

func (s *UserNameContext) GetParser() antlr.Parser { return s.parser }

func (s *UserNameContext) STRING_USER_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_USER_NAME, 0)
}

func (s *UserNameContext) ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserID, 0)
}

func (s *UserNameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *UserNameContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserADMIN, 0)
}

func (s *UserNameContext) KeywordsCanBeId() IKeywordsCanBeIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordsCanBeIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordsCanBeIdContext)
}

func (s *UserNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUserName(s)
	}
}

func (s *UserNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUserName(s)
	}
}

func (p *MySqlParser) UserName() (localctx IUserNameContext) {
	this := p
	_ = this

	localctx = NewUserNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 550, MySqlParserRULE_userName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6258)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 918, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6253)
			p.Match(MySqlParserSTRING_USER_NAME)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6254)
			p.Match(MySqlParserID)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6255)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6256)
			p.Match(MySqlParserADMIN)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6257)
			p.KeywordsCanBeId()
		}

	}

	return localctx
}

// IMysqlVariableContext is an interface to support dynamic dispatch.
type IMysqlVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCAL_ID() antlr.TerminalNode
	GLOBAL_ID() antlr.TerminalNode

	// IsMysqlVariableContext differentiates from other interfaces.
	IsMysqlVariableContext()
}

type MysqlVariableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMysqlVariableContext() *MysqlVariableContext {
	var p = new(MysqlVariableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_mysqlVariable
	return p
}

func (*MysqlVariableContext) IsMysqlVariableContext() {}

func NewMysqlVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MysqlVariableContext {
	var p = new(MysqlVariableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_mysqlVariable

	return p
}

func (s *MysqlVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *MysqlVariableContext) LOCAL_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL_ID, 0)
}

func (s *MysqlVariableContext) GLOBAL_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserGLOBAL_ID, 0)
}

func (s *MysqlVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MysqlVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MysqlVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMysqlVariable(s)
	}
}

func (s *MysqlVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMysqlVariable(s)
	}
}

func (p *MySqlParser) MysqlVariable() (localctx IMysqlVariableContext) {
	this := p
	_ = this

	localctx = NewMysqlVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 552, MySqlParserRULE_mysqlVariable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6260)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserLOCAL_ID || _la == MySqlParserGLOBAL_ID) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ICharsetNameContext is an interface to support dynamic dispatch.
type ICharsetNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BINARY() antlr.TerminalNode
	CharsetNameBase() ICharsetNameBaseContext
	STRING_LITERAL() antlr.TerminalNode
	CHARSET_REVERSE_QOUTE_STRING() antlr.TerminalNode

	// IsCharsetNameContext differentiates from other interfaces.
	IsCharsetNameContext()
}

type CharsetNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharsetNameContext() *CharsetNameContext {
	var p = new(CharsetNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_charsetName
	return p
}

func (*CharsetNameContext) IsCharsetNameContext() {}

func NewCharsetNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharsetNameContext {
	var p = new(CharsetNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_charsetName

	return p
}

func (s *CharsetNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CharsetNameContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *CharsetNameContext) CharsetNameBase() ICharsetNameBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameBaseContext)
}

func (s *CharsetNameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *CharsetNameContext) CHARSET_REVERSE_QOUTE_STRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARSET_REVERSE_QOUTE_STRING, 0)
}

func (s *CharsetNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharsetNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharsetNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCharsetName(s)
	}
}

func (s *CharsetNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCharsetName(s)
	}
}

func (p *MySqlParser) CharsetName() (localctx ICharsetNameContext) {
	this := p
	_ = this

	localctx = NewCharsetNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 554, MySqlParserRULE_charsetName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6266)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 919, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6262)
			p.Match(MySqlParserBINARY)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6263)
			p.CharsetNameBase()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6264)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6265)
			p.Match(MySqlParserCHARSET_REVERSE_QOUTE_STRING)
		}

	}

	return localctx
}

// ICollationNameContext is an interface to support dynamic dispatch.
type ICollationNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext
	STRING_LITERAL() antlr.TerminalNode

	// IsCollationNameContext differentiates from other interfaces.
	IsCollationNameContext()
}

type CollationNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollationNameContext() *CollationNameContext {
	var p = new(CollationNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_collationName
	return p
}

func (*CollationNameContext) IsCollationNameContext() {}

func NewCollationNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollationNameContext {
	var p = new(CollationNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_collationName

	return p
}

func (s *CollationNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CollationNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CollationNameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *CollationNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollationNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollationNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCollationName(s)
	}
}

func (s *CollationNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCollationName(s)
	}
}

func (p *MySqlParser) CollationName() (localctx ICollationNameContext) {
	this := p
	_ = this

	localctx = NewCollationNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 556, MySqlParserRULE_collationName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6270)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 920, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6268)
			p.Uid()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6269)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	}

	return localctx
}

// IEngineNameContext is an interface to support dynamic dispatch.
type IEngineNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARCHIVE() antlr.TerminalNode
	BLACKHOLE() antlr.TerminalNode
	CSV() antlr.TerminalNode
	FEDERATED() antlr.TerminalNode
	INNODB() antlr.TerminalNode
	MEMORY() antlr.TerminalNode
	MRG_MYISAM() antlr.TerminalNode
	MYISAM() antlr.TerminalNode
	NDB() antlr.TerminalNode
	NDBCLUSTER() antlr.TerminalNode
	PERFORMANCE_SCHEMA() antlr.TerminalNode
	TOKUDB() antlr.TerminalNode
	ID() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	REVERSE_QUOTE_ID() antlr.TerminalNode
	CONNECT() antlr.TerminalNode

	// IsEngineNameContext differentiates from other interfaces.
	IsEngineNameContext()
}

type EngineNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEngineNameContext() *EngineNameContext {
	var p = new(EngineNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_engineName
	return p
}

func (*EngineNameContext) IsEngineNameContext() {}

func NewEngineNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EngineNameContext {
	var p = new(EngineNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_engineName

	return p
}

func (s *EngineNameContext) GetParser() antlr.Parser { return s.parser }

func (s *EngineNameContext) ARCHIVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserARCHIVE, 0)
}

func (s *EngineNameContext) BLACKHOLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserBLACKHOLE, 0)
}

func (s *EngineNameContext) CSV() antlr.TerminalNode {
	return s.GetToken(MySqlParserCSV, 0)
}

func (s *EngineNameContext) FEDERATED() antlr.TerminalNode {
	return s.GetToken(MySqlParserFEDERATED, 0)
}

func (s *EngineNameContext) INNODB() antlr.TerminalNode {
	return s.GetToken(MySqlParserINNODB, 0)
}

func (s *EngineNameContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEMORY, 0)
}

func (s *EngineNameContext) MRG_MYISAM() antlr.TerminalNode {
	return s.GetToken(MySqlParserMRG_MYISAM, 0)
}

func (s *EngineNameContext) MYISAM() antlr.TerminalNode {
	return s.GetToken(MySqlParserMYISAM, 0)
}

func (s *EngineNameContext) NDB() antlr.TerminalNode {
	return s.GetToken(MySqlParserNDB, 0)
}

func (s *EngineNameContext) NDBCLUSTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserNDBCLUSTER, 0)
}

func (s *EngineNameContext) PERFORMANCE_SCHEMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserPERFORMANCE_SCHEMA, 0)
}

func (s *EngineNameContext) TOKUDB() antlr.TerminalNode {
	return s.GetToken(MySqlParserTOKUDB, 0)
}

func (s *EngineNameContext) ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserID, 0)
}

func (s *EngineNameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *EngineNameContext) REVERSE_QUOTE_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserREVERSE_QUOTE_ID, 0)
}

func (s *EngineNameContext) CONNECT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONNECT, 0)
}

func (s *EngineNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EngineNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EngineNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterEngineName(s)
	}
}

func (s *EngineNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitEngineName(s)
	}
}

func (p *MySqlParser) EngineName() (localctx IEngineNameContext) {
	this := p
	_ = this

	localctx = NewEngineNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 558, MySqlParserRULE_engineName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6272)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserCONNECT || ((int64((_la-786)) & ^0x3f) == 0 && ((int64(1)<<(_la-786))&4095) != 0) || ((int64((_la-1146)) & ^0x3f) == 0 && ((int64(1)<<(_la-1146))&769) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IUuidSetContext is an interface to support dynamic dispatch.
type IUuidSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDecimalLiteral() []IDecimalLiteralContext
	DecimalLiteral(i int) IDecimalLiteralContext
	AllMINUS() []antlr.TerminalNode
	MINUS(i int) antlr.TerminalNode
	AllCOLON_SYMB() []antlr.TerminalNode
	COLON_SYMB(i int) antlr.TerminalNode

	// IsUuidSetContext differentiates from other interfaces.
	IsUuidSetContext()
}

type UuidSetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUuidSetContext() *UuidSetContext {
	var p = new(UuidSetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_uuidSet
	return p
}

func (*UuidSetContext) IsUuidSetContext() {}

func NewUuidSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UuidSetContext {
	var p = new(UuidSetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_uuidSet

	return p
}

func (s *UuidSetContext) GetParser() antlr.Parser { return s.parser }

func (s *UuidSetContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *UuidSetContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *UuidSetContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserMINUS)
}

func (s *UuidSetContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUS, i)
}

func (s *UuidSetContext) AllCOLON_SYMB() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOLON_SYMB)
}

func (s *UuidSetContext) COLON_SYMB(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLON_SYMB, i)
}

func (s *UuidSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UuidSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UuidSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUuidSet(s)
	}
}

func (s *UuidSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUuidSet(s)
	}
}

func (p *MySqlParser) UuidSet() (localctx IUuidSetContext) {
	this := p
	_ = this

	localctx = NewUuidSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 560, MySqlParserRULE_uuidSet)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6274)
		p.DecimalLiteral()
	}
	{
		p.SetState(6275)
		p.Match(MySqlParserMINUS)
	}
	{
		p.SetState(6276)
		p.DecimalLiteral()
	}
	{
		p.SetState(6277)
		p.Match(MySqlParserMINUS)
	}
	{
		p.SetState(6278)
		p.DecimalLiteral()
	}
	{
		p.SetState(6279)
		p.Match(MySqlParserMINUS)
	}
	{
		p.SetState(6280)
		p.DecimalLiteral()
	}
	{
		p.SetState(6281)
		p.Match(MySqlParserMINUS)
	}
	{
		p.SetState(6282)
		p.DecimalLiteral()
	}
	p.SetState(6288)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == MySqlParserCOLON_SYMB {
		{
			p.SetState(6283)
			p.Match(MySqlParserCOLON_SYMB)
		}
		{
			p.SetState(6284)
			p.DecimalLiteral()
		}
		{
			p.SetState(6285)
			p.Match(MySqlParserMINUS)
		}
		{
			p.SetState(6286)
			p.DecimalLiteral()
		}

		p.SetState(6290)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IXidContext is an interface to support dynamic dispatch.
type IXidContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetGlobalTableUid returns the globalTableUid rule contexts.
	GetGlobalTableUid() IXuidStringIdContext

	// GetQualifier returns the qualifier rule contexts.
	GetQualifier() IXuidStringIdContext

	// GetIdFormat returns the idFormat rule contexts.
	GetIdFormat() IDecimalLiteralContext

	// SetGlobalTableUid sets the globalTableUid rule contexts.
	SetGlobalTableUid(IXuidStringIdContext)

	// SetQualifier sets the qualifier rule contexts.
	SetQualifier(IXuidStringIdContext)

	// SetIdFormat sets the idFormat rule contexts.
	SetIdFormat(IDecimalLiteralContext)

	// Getter signatures
	AllXuidStringId() []IXuidStringIdContext
	XuidStringId(i int) IXuidStringIdContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext

	// IsXidContext differentiates from other interfaces.
	IsXidContext()
}

type XidContext struct {
	*antlr.BaseParserRuleContext
	parser         antlr.Parser
	globalTableUid IXuidStringIdContext
	qualifier      IXuidStringIdContext
	idFormat       IDecimalLiteralContext
}

func NewEmptyXidContext() *XidContext {
	var p = new(XidContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_xid
	return p
}

func (*XidContext) IsXidContext() {}

func NewXidContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XidContext {
	var p = new(XidContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_xid

	return p
}

func (s *XidContext) GetParser() antlr.Parser { return s.parser }

func (s *XidContext) GetGlobalTableUid() IXuidStringIdContext { return s.globalTableUid }

func (s *XidContext) GetQualifier() IXuidStringIdContext { return s.qualifier }

func (s *XidContext) GetIdFormat() IDecimalLiteralContext { return s.idFormat }

func (s *XidContext) SetGlobalTableUid(v IXuidStringIdContext) { s.globalTableUid = v }

func (s *XidContext) SetQualifier(v IXuidStringIdContext) { s.qualifier = v }

func (s *XidContext) SetIdFormat(v IDecimalLiteralContext) { s.idFormat = v }

func (s *XidContext) AllXuidStringId() []IXuidStringIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IXuidStringIdContext); ok {
			len++
		}
	}

	tst := make([]IXuidStringIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IXuidStringIdContext); ok {
			tst[i] = t.(IXuidStringIdContext)
			i++
		}
	}

	return tst
}

func (s *XidContext) XuidStringId(i int) IXuidStringIdContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXuidStringIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXuidStringIdContext)
}

func (s *XidContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *XidContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *XidContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *XidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XidContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterXid(s)
	}
}

func (s *XidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitXid(s)
	}
}

func (p *MySqlParser) Xid() (localctx IXidContext) {
	this := p
	_ = this

	localctx = NewXidContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 562, MySqlParserRULE_xid)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6292)

		var _x = p.XuidStringId()

		localctx.(*XidContext).globalTableUid = _x
	}
	p.SetState(6299)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserCOMMA {
		{
			p.SetState(6293)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(6294)

			var _x = p.XuidStringId()

			localctx.(*XidContext).qualifier = _x
		}
		p.SetState(6297)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCOMMA {
			{
				p.SetState(6295)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(6296)

				var _x = p.DecimalLiteral()

				localctx.(*XidContext).idFormat = _x
			}

		}

	}

	return localctx
}

// IXuidStringIdContext is an interface to support dynamic dispatch.
type IXuidStringIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING_LITERAL() antlr.TerminalNode
	BIT_STRING() antlr.TerminalNode
	AllHEXADECIMAL_LITERAL() []antlr.TerminalNode
	HEXADECIMAL_LITERAL(i int) antlr.TerminalNode

	// IsXuidStringIdContext differentiates from other interfaces.
	IsXuidStringIdContext()
}

type XuidStringIdContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXuidStringIdContext() *XuidStringIdContext {
	var p = new(XuidStringIdContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_xuidStringId
	return p
}

func (*XuidStringIdContext) IsXuidStringIdContext() {}

func NewXuidStringIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XuidStringIdContext {
	var p = new(XuidStringIdContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_xuidStringId

	return p
}

func (s *XuidStringIdContext) GetParser() antlr.Parser { return s.parser }

func (s *XuidStringIdContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *XuidStringIdContext) BIT_STRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_STRING, 0)
}

func (s *XuidStringIdContext) AllHEXADECIMAL_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserHEXADECIMAL_LITERAL)
}

func (s *XuidStringIdContext) HEXADECIMAL_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserHEXADECIMAL_LITERAL, i)
}

func (s *XuidStringIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XuidStringIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XuidStringIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterXuidStringId(s)
	}
}

func (s *XuidStringIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitXuidStringId(s)
	}
}

func (p *MySqlParser) XuidStringId() (localctx IXuidStringIdContext) {
	this := p
	_ = this

	localctx = NewXuidStringIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 564, MySqlParserRULE_xuidStringId)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6308)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6301)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	case MySqlParserBIT_STRING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6302)
			p.Match(MySqlParserBIT_STRING)
		}

	case MySqlParserHEXADECIMAL_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(6304)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == MySqlParserHEXADECIMAL_LITERAL {
			{
				p.SetState(6303)
				p.Match(MySqlParserHEXADECIMAL_LITERAL)
			}

			p.SetState(6306)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAuthPluginContext is an interface to support dynamic dispatch.
type IAuthPluginContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext
	STRING_LITERAL() antlr.TerminalNode

	// IsAuthPluginContext differentiates from other interfaces.
	IsAuthPluginContext()
}

type AuthPluginContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAuthPluginContext() *AuthPluginContext {
	var p = new(AuthPluginContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_authPlugin
	return p
}

func (*AuthPluginContext) IsAuthPluginContext() {}

func NewAuthPluginContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AuthPluginContext {
	var p = new(AuthPluginContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_authPlugin

	return p
}

func (s *AuthPluginContext) GetParser() antlr.Parser { return s.parser }

func (s *AuthPluginContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AuthPluginContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *AuthPluginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AuthPluginContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AuthPluginContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAuthPlugin(s)
	}
}

func (s *AuthPluginContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAuthPlugin(s)
	}
}

func (p *MySqlParser) AuthPlugin() (localctx IAuthPluginContext) {
	this := p
	_ = this

	localctx = NewAuthPluginContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 566, MySqlParserRULE_authPlugin)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6312)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 926, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6310)
			p.Uid()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6311)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	}

	return localctx
}

// IUidContext is an interface to support dynamic dispatch.
type IUidContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleId() ISimpleIdContext
	REVERSE_QUOTE_ID() antlr.TerminalNode
	CHARSET_REVERSE_QOUTE_STRING() antlr.TerminalNode

	// IsUidContext differentiates from other interfaces.
	IsUidContext()
}

type UidContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUidContext() *UidContext {
	var p = new(UidContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_uid
	return p
}

func (*UidContext) IsUidContext() {}

func NewUidContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UidContext {
	var p = new(UidContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_uid

	return p
}

func (s *UidContext) GetParser() antlr.Parser { return s.parser }

func (s *UidContext) SimpleId() ISimpleIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdContext)
}

func (s *UidContext) REVERSE_QUOTE_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserREVERSE_QUOTE_ID, 0)
}

func (s *UidContext) CHARSET_REVERSE_QOUTE_STRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARSET_REVERSE_QOUTE_STRING, 0)
}

func (s *UidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UidContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUid(s)
	}
}

func (s *UidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUid(s)
	}
}

func (p *MySqlParser) Uid() (localctx IUidContext) {
	this := p
	_ = this

	localctx = NewUidContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 568, MySqlParserRULE_uid)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6317)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 927, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6314)
			p.SimpleId()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6315)
			p.Match(MySqlParserREVERSE_QUOTE_ID)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6316)
			p.Match(MySqlParserCHARSET_REVERSE_QOUTE_STRING)
		}

	}

	return localctx
}

// ISimpleIdContext is an interface to support dynamic dispatch.
type ISimpleIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	CharsetNameBase() ICharsetNameBaseContext
	TransactionLevelBase() ITransactionLevelBaseContext
	EngineName() IEngineNameContext
	PrivilegesBase() IPrivilegesBaseContext
	IntervalTypeBase() IIntervalTypeBaseContext
	DataTypeBase() IDataTypeBaseContext
	KeywordsCanBeId() IKeywordsCanBeIdContext
	ScalarFunctionName() IScalarFunctionNameContext

	// IsSimpleIdContext differentiates from other interfaces.
	IsSimpleIdContext()
}

type SimpleIdContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleIdContext() *SimpleIdContext {
	var p = new(SimpleIdContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_simpleId
	return p
}

func (*SimpleIdContext) IsSimpleIdContext() {}

func NewSimpleIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleIdContext {
	var p = new(SimpleIdContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_simpleId

	return p
}

func (s *SimpleIdContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleIdContext) ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserID, 0)
}

func (s *SimpleIdContext) CharsetNameBase() ICharsetNameBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameBaseContext)
}

func (s *SimpleIdContext) TransactionLevelBase() ITransactionLevelBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionLevelBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionLevelBaseContext)
}

func (s *SimpleIdContext) EngineName() IEngineNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *SimpleIdContext) PrivilegesBase() IPrivilegesBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegesBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegesBaseContext)
}

func (s *SimpleIdContext) IntervalTypeBase() IIntervalTypeBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalTypeBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalTypeBaseContext)
}

func (s *SimpleIdContext) DataTypeBase() IDataTypeBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeBaseContext)
}

func (s *SimpleIdContext) KeywordsCanBeId() IKeywordsCanBeIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordsCanBeIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordsCanBeIdContext)
}

func (s *SimpleIdContext) ScalarFunctionName() IScalarFunctionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarFunctionNameContext)
}

func (s *SimpleIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSimpleId(s)
	}
}

func (s *SimpleIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSimpleId(s)
	}
}

func (p *MySqlParser) SimpleId() (localctx ISimpleIdContext) {
	this := p
	_ = this

	localctx = NewSimpleIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 570, MySqlParserRULE_simpleId)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6328)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 928, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6319)
			p.Match(MySqlParserID)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6320)
			p.CharsetNameBase()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6321)
			p.TransactionLevelBase()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6322)
			p.EngineName()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6323)
			p.PrivilegesBase()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6324)
			p.IntervalTypeBase()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6325)
			p.DataTypeBase()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6326)
			p.KeywordsCanBeId()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6327)
			p.ScalarFunctionName()
		}

	}

	return localctx
}

// IDottedIdContext is an interface to support dynamic dispatch.
type IDottedIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOT_ID() antlr.TerminalNode
	DOT() antlr.TerminalNode
	Uid() IUidContext

	// IsDottedIdContext differentiates from other interfaces.
	IsDottedIdContext()
}

type DottedIdContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDottedIdContext() *DottedIdContext {
	var p = new(DottedIdContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_dottedId
	return p
}

func (*DottedIdContext) IsDottedIdContext() {}

func NewDottedIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DottedIdContext {
	var p = new(DottedIdContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dottedId

	return p
}

func (s *DottedIdContext) GetParser() antlr.Parser { return s.parser }

func (s *DottedIdContext) DOT_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT_ID, 0)
}

func (s *DottedIdContext) DOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT, 0)
}

func (s *DottedIdContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DottedIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DottedIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DottedIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDottedId(s)
	}
}

func (s *DottedIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDottedId(s)
	}
}

func (p *MySqlParser) DottedId() (localctx IDottedIdContext) {
	this := p
	_ = this

	localctx = NewDottedIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 572, MySqlParserRULE_dottedId)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6333)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserDOT_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6330)
			p.Match(MySqlParserDOT_ID)
		}

	case MySqlParserDOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6331)
			p.Match(MySqlParserDOT)
		}
		{
			p.SetState(6332)
			p.Uid()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDecimalLiteralContext is an interface to support dynamic dispatch.
type IDecimalLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECIMAL_LITERAL() antlr.TerminalNode
	ZERO_DECIMAL() antlr.TerminalNode
	ONE_DECIMAL() antlr.TerminalNode
	TWO_DECIMAL() antlr.TerminalNode
	REAL_LITERAL() antlr.TerminalNode

	// IsDecimalLiteralContext differentiates from other interfaces.
	IsDecimalLiteralContext()
}

type DecimalLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecimalLiteralContext() *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_decimalLiteral
	return p
}

func (*DecimalLiteralContext) IsDecimalLiteralContext() {}

func NewDecimalLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_decimalLiteral

	return p
}

func (s *DecimalLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *DecimalLiteralContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserDECIMAL_LITERAL, 0)
}

func (s *DecimalLiteralContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserZERO_DECIMAL, 0)
}

func (s *DecimalLiteralContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *DecimalLiteralContext) TWO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserTWO_DECIMAL, 0)
}

func (s *DecimalLiteralContext) REAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAL_LITERAL, 0)
}

func (s *DecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDecimalLiteral(s)
	}
}

func (s *DecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDecimalLiteral(s)
	}
}

func (p *MySqlParser) DecimalLiteral() (localctx IDecimalLiteralContext) {
	this := p
	_ = this

	localctx = NewDecimalLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 574, MySqlParserRULE_decimalLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6335)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-1136)) & ^0x3f) == 0 && ((int64(1)<<(_la-1136))&10247) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IFileSizeLiteralContext is an interface to support dynamic dispatch.
type IFileSizeLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FILESIZE_LITERAL() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext

	// IsFileSizeLiteralContext differentiates from other interfaces.
	IsFileSizeLiteralContext()
}

type FileSizeLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileSizeLiteralContext() *FileSizeLiteralContext {
	var p = new(FileSizeLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_fileSizeLiteral
	return p
}

func (*FileSizeLiteralContext) IsFileSizeLiteralContext() {}

func NewFileSizeLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileSizeLiteralContext {
	var p = new(FileSizeLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_fileSizeLiteral

	return p
}

func (s *FileSizeLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *FileSizeLiteralContext) FILESIZE_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserFILESIZE_LITERAL, 0)
}

func (s *FileSizeLiteralContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *FileSizeLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileSizeLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileSizeLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFileSizeLiteral(s)
	}
}

func (s *FileSizeLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFileSizeLiteral(s)
	}
}

func (p *MySqlParser) FileSizeLiteral() (localctx IFileSizeLiteralContext) {
	this := p
	_ = this

	localctx = NewFileSizeLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 576, MySqlParserRULE_fileSizeLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6339)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserFILESIZE_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6337)
			p.Match(MySqlParserFILESIZE_LITERAL)
		}

	case MySqlParserZERO_DECIMAL, MySqlParserONE_DECIMAL, MySqlParserTWO_DECIMAL, MySqlParserDECIMAL_LITERAL, MySqlParserREAL_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6338)
			p.DecimalLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	START_NATIONAL_STRING_LITERAL() antlr.TerminalNode
	STRING_CHARSET_NAME() antlr.TerminalNode
	COLLATE() antlr.TerminalNode
	CollationName() ICollationNameContext

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_stringLiteral
	return p
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSTRING_LITERAL)
}

func (s *StringLiteralContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, i)
}

func (s *StringLiteralContext) START_NATIONAL_STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTART_NATIONAL_STRING_LITERAL, 0)
}

func (s *StringLiteralContext) STRING_CHARSET_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_CHARSET_NAME, 0)
}

func (s *StringLiteralContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATE, 0)
}

func (s *StringLiteralContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

func (p *MySqlParser) StringLiteral() (localctx IStringLiteralContext) {
	this := p
	_ = this

	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 578, MySqlParserRULE_stringLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(6364)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 937, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6346)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserSTRING_LITERAL, MySqlParserSTRING_CHARSET_NAME:
			p.SetState(6342)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserSTRING_CHARSET_NAME {
				{
					p.SetState(6341)
					p.Match(MySqlParserSTRING_CHARSET_NAME)
				}

			}
			{
				p.SetState(6344)
				p.Match(MySqlParserSTRING_LITERAL)
			}

		case MySqlParserSTART_NATIONAL_STRING_LITERAL:
			{
				p.SetState(6345)
				p.Match(MySqlParserSTART_NATIONAL_STRING_LITERAL)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(6349)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(6348)
					p.Match(MySqlParserSTRING_LITERAL)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(6351)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 933, p.GetParserRuleContext())
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(6358)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserSTRING_LITERAL, MySqlParserSTRING_CHARSET_NAME:
			p.SetState(6354)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserSTRING_CHARSET_NAME {
				{
					p.SetState(6353)
					p.Match(MySqlParserSTRING_CHARSET_NAME)
				}

			}
			{
				p.SetState(6356)
				p.Match(MySqlParserSTRING_LITERAL)
			}

		case MySqlParserSTART_NATIONAL_STRING_LITERAL:
			{
				p.SetState(6357)
				p.Match(MySqlParserSTART_NATIONAL_STRING_LITERAL)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(6362)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 936, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6360)
				p.Match(MySqlParserCOLLATE)
			}
			{
				p.SetState(6361)
				p.CollationName()
			}

		}

	}

	return localctx
}

// IBooleanLiteralContext is an interface to support dynamic dispatch.
type IBooleanLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsBooleanLiteralContext differentiates from other interfaces.
	IsBooleanLiteralContext()
}

type BooleanLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanLiteralContext() *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_booleanLiteral
	return p
}

func (*BooleanLiteralContext) IsBooleanLiteralContext() {}

func NewBooleanLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_booleanLiteral

	return p
}

func (s *BooleanLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanLiteralContext) TRUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRUE, 0)
}

func (s *BooleanLiteralContext) FALSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFALSE, 0)
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (p *MySqlParser) BooleanLiteral() (localctx IBooleanLiteralContext) {
	this := p
	_ = this

	localctx = NewBooleanLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 580, MySqlParserRULE_booleanLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6366)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserFALSE || _la == MySqlParserTRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IHexadecimalLiteralContext is an interface to support dynamic dispatch.
type IHexadecimalLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HEXADECIMAL_LITERAL() antlr.TerminalNode
	STRING_CHARSET_NAME() antlr.TerminalNode

	// IsHexadecimalLiteralContext differentiates from other interfaces.
	IsHexadecimalLiteralContext()
}

type HexadecimalLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHexadecimalLiteralContext() *HexadecimalLiteralContext {
	var p = new(HexadecimalLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_hexadecimalLiteral
	return p
}

func (*HexadecimalLiteralContext) IsHexadecimalLiteralContext() {}

func NewHexadecimalLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HexadecimalLiteralContext {
	var p = new(HexadecimalLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_hexadecimalLiteral

	return p
}

func (s *HexadecimalLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *HexadecimalLiteralContext) HEXADECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserHEXADECIMAL_LITERAL, 0)
}

func (s *HexadecimalLiteralContext) STRING_CHARSET_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_CHARSET_NAME, 0)
}

func (s *HexadecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HexadecimalLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HexadecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHexadecimalLiteral(s)
	}
}

func (s *HexadecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHexadecimalLiteral(s)
	}
}

func (p *MySqlParser) HexadecimalLiteral() (localctx IHexadecimalLiteralContext) {
	this := p
	_ = this

	localctx = NewHexadecimalLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 582, MySqlParserRULE_hexadecimalLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6369)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserSTRING_CHARSET_NAME {
		{
			p.SetState(6368)
			p.Match(MySqlParserSTRING_CHARSET_NAME)
		}

	}
	{
		p.SetState(6371)
		p.Match(MySqlParserHEXADECIMAL_LITERAL)
	}

	return localctx
}

// INullNotnullContext is an interface to support dynamic dispatch.
type INullNotnullContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NULL_LITERAL() antlr.TerminalNode
	NULL_SPEC_LITERAL() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsNullNotnullContext differentiates from other interfaces.
	IsNullNotnullContext()
}

type NullNotnullContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullNotnullContext() *NullNotnullContext {
	var p = new(NullNotnullContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_nullNotnull
	return p
}

func (*NullNotnullContext) IsNullNotnullContext() {}

func NewNullNotnullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullNotnullContext {
	var p = new(NullNotnullContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_nullNotnull

	return p
}

func (s *NullNotnullContext) GetParser() antlr.Parser { return s.parser }

func (s *NullNotnullContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserNULL_LITERAL, 0)
}

func (s *NullNotnullContext) NULL_SPEC_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserNULL_SPEC_LITERAL, 0)
}

func (s *NullNotnullContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *NullNotnullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullNotnullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullNotnullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterNullNotnull(s)
	}
}

func (s *NullNotnullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitNullNotnull(s)
	}
}

func (p *MySqlParser) NullNotnull() (localctx INullNotnullContext) {
	this := p
	_ = this

	localctx = NewNullNotnullContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 584, MySqlParserRULE_nullNotnull)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6374)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserNOT {
		{
			p.SetState(6373)
			p.Match(MySqlParserNOT)
		}

	}
	{
		p.SetState(6376)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserNULL_LITERAL || _la == MySqlParserNULL_SPEC_LITERAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IConstantContext is an interface to support dynamic dispatch.
type IConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNullLiteral returns the nullLiteral token.
	GetNullLiteral() antlr.Token

	// SetNullLiteral sets the nullLiteral token.
	SetNullLiteral(antlr.Token)

	// Getter signatures
	StringLiteral() IStringLiteralContext
	DecimalLiteral() IDecimalLiteralContext
	MINUS() antlr.TerminalNode
	HexadecimalLiteral() IHexadecimalLiteralContext
	BooleanLiteral() IBooleanLiteralContext
	REAL_LITERAL() antlr.TerminalNode
	BIT_STRING() antlr.TerminalNode
	NULL_LITERAL() antlr.TerminalNode
	NULL_SPEC_LITERAL() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsConstantContext differentiates from other interfaces.
	IsConstantContext()
}

type ConstantContext struct {
	*antlr.BaseParserRuleContext
	parser      antlr.Parser
	nullLiteral antlr.Token
}

func NewEmptyConstantContext() *ConstantContext {
	var p = new(ConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_constant
	return p
}

func (*ConstantContext) IsConstantContext() {}

func NewConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantContext {
	var p = new(ConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_constant

	return p
}

func (s *ConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantContext) GetNullLiteral() antlr.Token { return s.nullLiteral }

func (s *ConstantContext) SetNullLiteral(v antlr.Token) { s.nullLiteral = v }

func (s *ConstantContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ConstantContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *ConstantContext) MINUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUS, 0)
}

func (s *ConstantContext) HexadecimalLiteral() IHexadecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHexadecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHexadecimalLiteralContext)
}

func (s *ConstantContext) BooleanLiteral() IBooleanLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *ConstantContext) REAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAL_LITERAL, 0)
}

func (s *ConstantContext) BIT_STRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_STRING, 0)
}

func (s *ConstantContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserNULL_LITERAL, 0)
}

func (s *ConstantContext) NULL_SPEC_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserNULL_SPEC_LITERAL, 0)
}

func (s *ConstantContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *ConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterConstant(s)
	}
}

func (s *ConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitConstant(s)
	}
}

func (p *MySqlParser) Constant() (localctx IConstantContext) {
	this := p
	_ = this

	localctx = NewConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 586, MySqlParserRULE_constant)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6390)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 941, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6378)
			p.StringLiteral()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6379)
			p.DecimalLiteral()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6380)
			p.Match(MySqlParserMINUS)
		}
		{
			p.SetState(6381)
			p.DecimalLiteral()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6382)
			p.HexadecimalLiteral()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6383)
			p.BooleanLiteral()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6384)
			p.Match(MySqlParserREAL_LITERAL)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6385)
			p.Match(MySqlParserBIT_STRING)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		p.SetState(6387)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserNOT {
			{
				p.SetState(6386)
				p.Match(MySqlParserNOT)
			}

		}
		{
			p.SetState(6389)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ConstantContext).nullLiteral = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserNULL_LITERAL || _la == MySqlParserNULL_SPEC_LITERAL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ConstantContext).nullLiteral = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IDataTypeContext is an interface to support dynamic dispatch.
type IDataTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsDataTypeContext differentiates from other interfaces.
	IsDataTypeContext()
}

type DataTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeContext() *DataTypeContext {
	var p = new(DataTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_dataType
	return p
}

func (*DataTypeContext) IsDataTypeContext() {}

func NewDataTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeContext {
	var p = new(DataTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dataType

	return p
}

func (s *DataTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeContext) CopyFrom(ctx *DataTypeContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *DataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SpatialDataTypeContext struct {
	*DataTypeContext
	typeName antlr.Token
}

func NewSpatialDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpatialDataTypeContext {
	var p = new(SpatialDataTypeContext)

	p.DataTypeContext = NewEmptyDataTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*DataTypeContext))

	return p
}

func (s *SpatialDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *SpatialDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *SpatialDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpatialDataTypeContext) GEOMETRYCOLLECTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMETRYCOLLECTION, 0)
}

func (s *SpatialDataTypeContext) GEOMCOLLECTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMCOLLECTION, 0)
}

func (s *SpatialDataTypeContext) LINESTRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINESTRING, 0)
}

func (s *SpatialDataTypeContext) MULTILINESTRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTILINESTRING, 0)
}

func (s *SpatialDataTypeContext) MULTIPOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTIPOINT, 0)
}

func (s *SpatialDataTypeContext) MULTIPOLYGON() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTIPOLYGON, 0)
}

func (s *SpatialDataTypeContext) POINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOINT, 0)
}

func (s *SpatialDataTypeContext) POLYGON() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOLYGON, 0)
}

func (s *SpatialDataTypeContext) JSON() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON, 0)
}

func (s *SpatialDataTypeContext) GEOMETRY() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMETRY, 0)
}

func (s *SpatialDataTypeContext) SRID() antlr.TerminalNode {
	return s.GetToken(MySqlParserSRID, 0)
}

func (s *SpatialDataTypeContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *SpatialDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSpatialDataType(s)
	}
}

func (s *SpatialDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSpatialDataType(s)
	}
}

type LongVarbinaryDataTypeContext struct {
	*DataTypeContext
}

func NewLongVarbinaryDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LongVarbinaryDataTypeContext {
	var p = new(LongVarbinaryDataTypeContext)

	p.DataTypeContext = NewEmptyDataTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*DataTypeContext))

	return p
}

func (s *LongVarbinaryDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LongVarbinaryDataTypeContext) LONG() antlr.TerminalNode {
	return s.GetToken(MySqlParserLONG, 0)
}

func (s *LongVarbinaryDataTypeContext) VARBINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARBINARY, 0)
}

func (s *LongVarbinaryDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLongVarbinaryDataType(s)
	}
}

func (s *LongVarbinaryDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLongVarbinaryDataType(s)
	}
}

type CollectionDataTypeContext struct {
	*DataTypeContext
	typeName antlr.Token
}

func NewCollectionDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CollectionDataTypeContext {
	var p = new(CollectionDataTypeContext)

	p.DataTypeContext = NewEmptyDataTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*DataTypeContext))

	return p
}

func (s *CollectionDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *CollectionDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *CollectionDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollectionDataTypeContext) CollectionOptions() ICollectionOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollectionOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollectionOptionsContext)
}

func (s *CollectionDataTypeContext) ENUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserENUM, 0)
}

func (s *CollectionDataTypeContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *CollectionDataTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *CollectionDataTypeContext) CharSet() ICharSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharSetContext)
}

func (s *CollectionDataTypeContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *CollectionDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCollectionDataType(s)
	}
}

func (s *CollectionDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCollectionDataType(s)
	}
}

type NationalVaryingStringDataTypeContext struct {
	*DataTypeContext
	typeName antlr.Token
}

func NewNationalVaryingStringDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NationalVaryingStringDataTypeContext {
	var p = new(NationalVaryingStringDataTypeContext)

	p.DataTypeContext = NewEmptyDataTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*DataTypeContext))

	return p
}

func (s *NationalVaryingStringDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *NationalVaryingStringDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *NationalVaryingStringDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NationalVaryingStringDataTypeContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserNATIONAL, 0)
}

func (s *NationalVaryingStringDataTypeContext) VARYING() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARYING, 0)
}

func (s *NationalVaryingStringDataTypeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAR, 0)
}

func (s *NationalVaryingStringDataTypeContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER, 0)
}

func (s *NationalVaryingStringDataTypeContext) LengthOneDimension() ILengthOneDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthOneDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *NationalVaryingStringDataTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *NationalVaryingStringDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterNationalVaryingStringDataType(s)
	}
}

func (s *NationalVaryingStringDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitNationalVaryingStringDataType(s)
	}
}

type DimensionDataTypeContext struct {
	*DataTypeContext
	typeName antlr.Token
}

func NewDimensionDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DimensionDataTypeContext {
	var p = new(DimensionDataTypeContext)

	p.DataTypeContext = NewEmptyDataTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*DataTypeContext))

	return p
}

func (s *DimensionDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *DimensionDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *DimensionDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DimensionDataTypeContext) TINYINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserTINYINT, 0)
}

func (s *DimensionDataTypeContext) SMALLINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSMALLINT, 0)
}

func (s *DimensionDataTypeContext) MEDIUMINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEDIUMINT, 0)
}

func (s *DimensionDataTypeContext) INT() antlr.TerminalNode {
	return s.GetToken(MySqlParserINT, 0)
}

func (s *DimensionDataTypeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTEGER, 0)
}

func (s *DimensionDataTypeContext) BIGINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIGINT, 0)
}

func (s *DimensionDataTypeContext) MIDDLEINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMIDDLEINT, 0)
}

func (s *DimensionDataTypeContext) INT1() antlr.TerminalNode {
	return s.GetToken(MySqlParserINT1, 0)
}

func (s *DimensionDataTypeContext) INT2() antlr.TerminalNode {
	return s.GetToken(MySqlParserINT2, 0)
}

func (s *DimensionDataTypeContext) INT3() antlr.TerminalNode {
	return s.GetToken(MySqlParserINT3, 0)
}

func (s *DimensionDataTypeContext) INT4() antlr.TerminalNode {
	return s.GetToken(MySqlParserINT4, 0)
}

func (s *DimensionDataTypeContext) INT8() antlr.TerminalNode {
	return s.GetToken(MySqlParserINT8, 0)
}

func (s *DimensionDataTypeContext) LengthOneDimension() ILengthOneDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthOneDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *DimensionDataTypeContext) AllSIGNED() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSIGNED)
}

func (s *DimensionDataTypeContext) SIGNED(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSIGNED, i)
}

func (s *DimensionDataTypeContext) AllUNSIGNED() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserUNSIGNED)
}

func (s *DimensionDataTypeContext) UNSIGNED(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserUNSIGNED, i)
}

func (s *DimensionDataTypeContext) AllZEROFILL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserZEROFILL)
}

func (s *DimensionDataTypeContext) ZEROFILL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserZEROFILL, i)
}

func (s *DimensionDataTypeContext) REAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAL, 0)
}

func (s *DimensionDataTypeContext) LengthTwoDimension() ILengthTwoDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthTwoDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthTwoDimensionContext)
}

func (s *DimensionDataTypeContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOUBLE, 0)
}

func (s *DimensionDataTypeContext) PRECISION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRECISION, 0)
}

func (s *DimensionDataTypeContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserDECIMAL, 0)
}

func (s *DimensionDataTypeContext) DEC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEC, 0)
}

func (s *DimensionDataTypeContext) FIXED() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIXED, 0)
}

func (s *DimensionDataTypeContext) NUMERIC() antlr.TerminalNode {
	return s.GetToken(MySqlParserNUMERIC, 0)
}

func (s *DimensionDataTypeContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserFLOAT, 0)
}

func (s *DimensionDataTypeContext) FLOAT4() antlr.TerminalNode {
	return s.GetToken(MySqlParserFLOAT4, 0)
}

func (s *DimensionDataTypeContext) FLOAT8() antlr.TerminalNode {
	return s.GetToken(MySqlParserFLOAT8, 0)
}

func (s *DimensionDataTypeContext) LengthTwoOptionalDimension() ILengthTwoOptionalDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthTwoOptionalDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthTwoOptionalDimensionContext)
}

func (s *DimensionDataTypeContext) BIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT, 0)
}

func (s *DimensionDataTypeContext) TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIME, 0)
}

func (s *DimensionDataTypeContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIMESTAMP, 0)
}

func (s *DimensionDataTypeContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATETIME, 0)
}

func (s *DimensionDataTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *DimensionDataTypeContext) VARBINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARBINARY, 0)
}

func (s *DimensionDataTypeContext) BLOB() antlr.TerminalNode {
	return s.GetToken(MySqlParserBLOB, 0)
}

func (s *DimensionDataTypeContext) YEAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserYEAR, 0)
}

func (s *DimensionDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDimensionDataType(s)
	}
}

func (s *DimensionDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDimensionDataType(s)
	}
}

type StringDataTypeContext struct {
	*DataTypeContext
	typeName antlr.Token
}

func NewStringDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringDataTypeContext {
	var p = new(StringDataTypeContext)

	p.DataTypeContext = NewEmptyDataTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*DataTypeContext))

	return p
}

func (s *StringDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *StringDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *StringDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringDataTypeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAR, 0)
}

func (s *StringDataTypeContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER, 0)
}

func (s *StringDataTypeContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARCHAR, 0)
}

func (s *StringDataTypeContext) TINYTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserTINYTEXT, 0)
}

func (s *StringDataTypeContext) TEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserTEXT, 0)
}

func (s *StringDataTypeContext) MEDIUMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEDIUMTEXT, 0)
}

func (s *StringDataTypeContext) LONGTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLONGTEXT, 0)
}

func (s *StringDataTypeContext) NCHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserNCHAR, 0)
}

func (s *StringDataTypeContext) NVARCHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserNVARCHAR, 0)
}

func (s *StringDataTypeContext) LONG() antlr.TerminalNode {
	return s.GetToken(MySqlParserLONG, 0)
}

func (s *StringDataTypeContext) VARYING() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARYING, 0)
}

func (s *StringDataTypeContext) LengthOneDimension() ILengthOneDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthOneDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *StringDataTypeContext) AllBINARY() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserBINARY)
}

func (s *StringDataTypeContext) BINARY(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, i)
}

func (s *StringDataTypeContext) CharSet() ICharSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharSetContext)
}

func (s *StringDataTypeContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *StringDataTypeContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATE, 0)
}

func (s *StringDataTypeContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *StringDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterStringDataType(s)
	}
}

func (s *StringDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitStringDataType(s)
	}
}

type LongVarcharDataTypeContext struct {
	*DataTypeContext
	typeName antlr.Token
}

func NewLongVarcharDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LongVarcharDataTypeContext {
	var p = new(LongVarcharDataTypeContext)

	p.DataTypeContext = NewEmptyDataTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*DataTypeContext))

	return p
}

func (s *LongVarcharDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *LongVarcharDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *LongVarcharDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LongVarcharDataTypeContext) LONG() antlr.TerminalNode {
	return s.GetToken(MySqlParserLONG, 0)
}

func (s *LongVarcharDataTypeContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARCHAR, 0)
}

func (s *LongVarcharDataTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *LongVarcharDataTypeContext) CharSet() ICharSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharSetContext)
}

func (s *LongVarcharDataTypeContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *LongVarcharDataTypeContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATE, 0)
}

func (s *LongVarcharDataTypeContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *LongVarcharDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLongVarcharDataType(s)
	}
}

func (s *LongVarcharDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLongVarcharDataType(s)
	}
}

type NationalStringDataTypeContext struct {
	*DataTypeContext
	typeName antlr.Token
}

func NewNationalStringDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NationalStringDataTypeContext {
	var p = new(NationalStringDataTypeContext)

	p.DataTypeContext = NewEmptyDataTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*DataTypeContext))

	return p
}

func (s *NationalStringDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *NationalStringDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *NationalStringDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NationalStringDataTypeContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserNATIONAL, 0)
}

func (s *NationalStringDataTypeContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARCHAR, 0)
}

func (s *NationalStringDataTypeContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER, 0)
}

func (s *NationalStringDataTypeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAR, 0)
}

func (s *NationalStringDataTypeContext) LengthOneDimension() ILengthOneDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthOneDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *NationalStringDataTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *NationalStringDataTypeContext) NCHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserNCHAR, 0)
}

func (s *NationalStringDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterNationalStringDataType(s)
	}
}

func (s *NationalStringDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitNationalStringDataType(s)
	}
}

type SimpleDataTypeContext struct {
	*DataTypeContext
	typeName antlr.Token
}

func NewSimpleDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleDataTypeContext {
	var p = new(SimpleDataTypeContext)

	p.DataTypeContext = NewEmptyDataTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*DataTypeContext))

	return p
}

func (s *SimpleDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *SimpleDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *SimpleDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleDataTypeContext) DATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATE, 0)
}

func (s *SimpleDataTypeContext) TINYBLOB() antlr.TerminalNode {
	return s.GetToken(MySqlParserTINYBLOB, 0)
}

func (s *SimpleDataTypeContext) MEDIUMBLOB() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEDIUMBLOB, 0)
}

func (s *SimpleDataTypeContext) LONGBLOB() antlr.TerminalNode {
	return s.GetToken(MySqlParserLONGBLOB, 0)
}

func (s *SimpleDataTypeContext) BOOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserBOOL, 0)
}

func (s *SimpleDataTypeContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBOOLEAN, 0)
}

func (s *SimpleDataTypeContext) SERIAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSERIAL, 0)
}

func (s *SimpleDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSimpleDataType(s)
	}
}

func (s *SimpleDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSimpleDataType(s)
	}
}

func (p *MySqlParser) DataType() (localctx IDataTypeContext) {
	this := p
	_ = this

	localctx = NewDataTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 588, MySqlParserRULE_dataType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(6518)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 970, p.GetParserRuleContext()) {
	case 1:
		localctx = NewStringDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6392)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*StringDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCHARACTER || ((int64((_la-222)) & ^0x3f) == 0 && ((int64(1)<<(_la-222))&31239) != 0) || _la == MySqlParserNCHAR) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*StringDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6394)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserVARYING {
			{
				p.SetState(6393)
				p.Match(MySqlParserVARYING)
			}

		}
		p.SetState(6397)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 943, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6396)
				p.LengthOneDimension()
			}

		}
		p.SetState(6400)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 944, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6399)
				p.Match(MySqlParserBINARY)
			}

		}
		p.SetState(6405)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 945, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6402)
				p.CharSet()
			}
			{
				p.SetState(6403)
				p.CharsetName()
			}

		}
		p.SetState(6410)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 946, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6407)
				p.Match(MySqlParserCOLLATE)
			}
			{
				p.SetState(6408)
				p.CollationName()
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 946, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(6409)
				p.Match(MySqlParserBINARY)
			}

		}

	case 2:
		localctx = NewNationalVaryingStringDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6412)
			p.Match(MySqlParserNATIONAL)
		}
		{
			p.SetState(6413)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*NationalVaryingStringDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCHARACTER || _la == MySqlParserCHAR) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*NationalVaryingStringDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6414)
			p.Match(MySqlParserVARYING)
		}
		p.SetState(6416)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 947, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6415)
				p.LengthOneDimension()
			}

		}
		p.SetState(6419)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 948, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6418)
				p.Match(MySqlParserBINARY)
			}

		}

	case 3:
		localctx = NewNationalStringDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6421)
			p.Match(MySqlParserNATIONAL)
		}
		{
			p.SetState(6422)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*NationalStringDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCHARACTER || _la == MySqlParserCHAR || _la == MySqlParserVARCHAR) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*NationalStringDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6424)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 949, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6423)
				p.LengthOneDimension()
			}

		}
		p.SetState(6427)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 950, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6426)
				p.Match(MySqlParserBINARY)
			}

		}

	case 4:
		localctx = NewNationalStringDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6429)
			p.Match(MySqlParserNCHAR)
		}
		{
			p.SetState(6430)

			var _m = p.Match(MySqlParserVARCHAR)

			localctx.(*NationalStringDataTypeContext).typeName = _m
		}
		p.SetState(6432)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 951, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6431)
				p.LengthOneDimension()
			}

		}
		p.SetState(6435)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 952, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6434)
				p.Match(MySqlParserBINARY)
			}

		}

	case 5:
		localctx = NewDimensionDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6437)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DimensionDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&4095) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DimensionDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6439)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 953, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6438)
				p.LengthOneDimension()
			}

		}
		p.SetState(6444)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 954, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(6441)
					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserUNSIGNED || _la == MySqlParserZEROFILL || _la == MySqlParserSIGNED) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			p.SetState(6446)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 954, p.GetParserRuleContext())
		}

	case 6:
		localctx = NewDimensionDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6447)

			var _m = p.Match(MySqlParserREAL)

			localctx.(*DimensionDataTypeContext).typeName = _m
		}
		p.SetState(6449)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 955, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6448)
				p.LengthTwoDimension()
			}

		}
		p.SetState(6454)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 956, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(6451)
					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserUNSIGNED || _la == MySqlParserZEROFILL || _la == MySqlParserSIGNED) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			p.SetState(6456)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 956, p.GetParserRuleContext())
		}

	case 7:
		localctx = NewDimensionDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6457)

			var _m = p.Match(MySqlParserDOUBLE)

			localctx.(*DimensionDataTypeContext).typeName = _m
		}
		p.SetState(6459)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserPRECISION {
			{
				p.SetState(6458)
				p.Match(MySqlParserPRECISION)
			}

		}
		p.SetState(6462)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 958, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6461)
				p.LengthTwoDimension()
			}

		}
		p.SetState(6467)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 959, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(6464)
					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserUNSIGNED || _la == MySqlParserZEROFILL || _la == MySqlParserSIGNED) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			p.SetState(6469)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 959, p.GetParserRuleContext())
		}

	case 8:
		localctx = NewDimensionDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6470)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DimensionDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la-211)) & ^0x3f) == 0 && ((int64(1)<<(_la-211))&63) != 0) || _la == MySqlParserFIXED) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DimensionDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6472)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 960, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6471)
				p.LengthTwoOptionalDimension()
			}

		}
		p.SetState(6477)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 961, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(6474)
					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserUNSIGNED || _la == MySqlParserZEROFILL || _la == MySqlParserSIGNED) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			p.SetState(6479)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 961, p.GetParserRuleContext())
		}

	case 9:
		localctx = NewSimpleDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6480)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SimpleDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&4237313) != 0) || _la == MySqlParserBOOL || _la == MySqlParserBOOLEAN) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SimpleDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 10:
		localctx = NewDimensionDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(6481)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DimensionDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la-218)) & ^0x3f) == 0 && ((int64(1)<<(_la-218))&2831) != 0) || _la == MySqlParserBIT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DimensionDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6483)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 962, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6482)
				p.LengthOneDimension()
			}

		}

	case 11:
		localctx = NewCollectionDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(6485)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CollectionDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserSET || _la == MySqlParserENUM) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CollectionDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6486)
			p.CollectionOptions()
		}
		p.SetState(6488)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 963, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6487)
				p.Match(MySqlParserBINARY)
			}

		}
		p.SetState(6493)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 964, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6490)
				p.CharSet()
			}
			{
				p.SetState(6491)
				p.CharsetName()
			}

		}

	case 12:
		localctx = NewSpatialDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(6495)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SpatialDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserJSON || ((int64((_la-802)) & ^0x3f) == 0 && ((int64(1)<<(_la-802))&511) != 0)) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SpatialDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6498)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 965, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6496)
				p.Match(MySqlParserSRID)
			}
			{
				p.SetState(6497)
				p.DecimalLiteral()
			}

		}

	case 13:
		localctx = NewLongVarcharDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(6500)

			var _m = p.Match(MySqlParserLONG)

			localctx.(*LongVarcharDataTypeContext).typeName = _m
		}
		p.SetState(6502)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserVARCHAR {
			{
				p.SetState(6501)
				p.Match(MySqlParserVARCHAR)
			}

		}
		p.SetState(6505)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 967, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6504)
				p.Match(MySqlParserBINARY)
			}

		}
		p.SetState(6510)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 968, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6507)
				p.CharSet()
			}
			{
				p.SetState(6508)
				p.CharsetName()
			}

		}
		p.SetState(6514)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 969, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6512)
				p.Match(MySqlParserCOLLATE)
			}
			{
				p.SetState(6513)
				p.CollationName()
			}

		}

	case 14:
		localctx = NewLongVarbinaryDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(6516)
			p.Match(MySqlParserLONG)
		}
		{
			p.SetState(6517)
			p.Match(MySqlParserVARBINARY)
		}

	}

	return localctx
}

// ICollectionOptionsContext is an interface to support dynamic dispatch.
type ICollectionOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCollectionOptionsContext differentiates from other interfaces.
	IsCollectionOptionsContext()
}

type CollectionOptionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollectionOptionsContext() *CollectionOptionsContext {
	var p = new(CollectionOptionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_collectionOptions
	return p
}

func (*CollectionOptionsContext) IsCollectionOptionsContext() {}

func NewCollectionOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollectionOptionsContext {
	var p = new(CollectionOptionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_collectionOptions

	return p
}

func (s *CollectionOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *CollectionOptionsContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CollectionOptionsContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSTRING_LITERAL)
}

func (s *CollectionOptionsContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, i)
}

func (s *CollectionOptionsContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CollectionOptionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *CollectionOptionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *CollectionOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollectionOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollectionOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCollectionOptions(s)
	}
}

func (s *CollectionOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCollectionOptions(s)
	}
}

func (p *MySqlParser) CollectionOptions() (localctx ICollectionOptionsContext) {
	this := p
	_ = this

	localctx = NewCollectionOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 590, MySqlParserRULE_collectionOptions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6520)
		p.Match(MySqlParserLR_BRACKET)
	}
	{
		p.SetState(6521)
		p.Match(MySqlParserSTRING_LITERAL)
	}
	p.SetState(6526)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(6522)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(6523)
			p.Match(MySqlParserSTRING_LITERAL)
		}

		p.SetState(6528)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6529)
		p.Match(MySqlParserRR_BRACKET)
	}

	return localctx
}

// IConvertedDataTypeContext is an interface to support dynamic dispatch.
type IConvertedDataTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTypeName returns the typeName token.
	GetTypeName() antlr.Token

	// SetTypeName sets the typeName token.
	SetTypeName(antlr.Token)

	// Getter signatures
	CHAR() antlr.TerminalNode
	DECIMAL() antlr.TerminalNode
	SIGNED() antlr.TerminalNode
	UNSIGNED() antlr.TerminalNode
	ARRAY() antlr.TerminalNode
	BINARY() antlr.TerminalNode
	NCHAR() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DATETIME() antlr.TerminalNode
	TIME() antlr.TerminalNode
	JSON() antlr.TerminalNode
	INT() antlr.TerminalNode
	INTEGER() antlr.TerminalNode
	LengthOneDimension() ILengthOneDimensionContext
	CharSet() ICharSetContext
	CharsetName() ICharsetNameContext
	LengthTwoOptionalDimension() ILengthTwoOptionalDimensionContext

	// IsConvertedDataTypeContext differentiates from other interfaces.
	IsConvertedDataTypeContext()
}

type ConvertedDataTypeContext struct {
	*antlr.BaseParserRuleContext
	parser   antlr.Parser
	typeName antlr.Token
}

func NewEmptyConvertedDataTypeContext() *ConvertedDataTypeContext {
	var p = new(ConvertedDataTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_convertedDataType
	return p
}

func (*ConvertedDataTypeContext) IsConvertedDataTypeContext() {}

func NewConvertedDataTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConvertedDataTypeContext {
	var p = new(ConvertedDataTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_convertedDataType

	return p
}

func (s *ConvertedDataTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ConvertedDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *ConvertedDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *ConvertedDataTypeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAR, 0)
}

func (s *ConvertedDataTypeContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserDECIMAL, 0)
}

func (s *ConvertedDataTypeContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(MySqlParserSIGNED, 0)
}

func (s *ConvertedDataTypeContext) UNSIGNED() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNSIGNED, 0)
}

func (s *ConvertedDataTypeContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserARRAY, 0)
}

func (s *ConvertedDataTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *ConvertedDataTypeContext) NCHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserNCHAR, 0)
}

func (s *ConvertedDataTypeContext) DATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATE, 0)
}

func (s *ConvertedDataTypeContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATETIME, 0)
}

func (s *ConvertedDataTypeContext) TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIME, 0)
}

func (s *ConvertedDataTypeContext) JSON() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON, 0)
}

func (s *ConvertedDataTypeContext) INT() antlr.TerminalNode {
	return s.GetToken(MySqlParserINT, 0)
}

func (s *ConvertedDataTypeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTEGER, 0)
}

func (s *ConvertedDataTypeContext) LengthOneDimension() ILengthOneDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthOneDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *ConvertedDataTypeContext) CharSet() ICharSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharSetContext)
}

func (s *ConvertedDataTypeContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *ConvertedDataTypeContext) LengthTwoOptionalDimension() ILengthTwoOptionalDimensionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthTwoOptionalDimensionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthTwoOptionalDimensionContext)
}

func (s *ConvertedDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConvertedDataTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConvertedDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterConvertedDataType(s)
	}
}

func (s *ConvertedDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitConvertedDataType(s)
	}
}

func (p *MySqlParser) ConvertedDataType() (localctx IConvertedDataTypeContext) {
	this := p
	_ = this

	localctx = NewConvertedDataTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 592, MySqlParserRULE_convertedDataType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6553)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserBINARY, MySqlParserNCHAR:
		{
			p.SetState(6531)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ConvertedDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserBINARY || _la == MySqlParserNCHAR) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ConvertedDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6533)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(6532)
				p.LengthOneDimension()
			}

		}

	case MySqlParserCHAR:
		{
			p.SetState(6535)

			var _m = p.Match(MySqlParserCHAR)

			localctx.(*ConvertedDataTypeContext).typeName = _m
		}
		p.SetState(6537)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(6536)
				p.LengthOneDimension()
			}

		}
		p.SetState(6542)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCHARACTER || _la == MySqlParserCHAR || _la == MySqlParserCHARSET {
			{
				p.SetState(6539)
				p.CharSet()
			}
			{
				p.SetState(6540)
				p.CharsetName()
			}

		}

	case MySqlParserINT, MySqlParserINTEGER, MySqlParserDATE, MySqlParserTIME, MySqlParserDATETIME, MySqlParserJSON:
		{
			p.SetState(6544)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ConvertedDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la-200)) & ^0x3f) == 0 && ((int64(1)<<(_la-200))&1441857) != 0) || _la == MySqlParserJSON) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ConvertedDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case MySqlParserDECIMAL:
		{
			p.SetState(6545)

			var _m = p.Match(MySqlParserDECIMAL)

			localctx.(*ConvertedDataTypeContext).typeName = _m
		}
		p.SetState(6547)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(6546)
				p.LengthTwoOptionalDimension()
			}

		}

	case MySqlParserUNSIGNED, MySqlParserSIGNED:
		{
			p.SetState(6549)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserUNSIGNED || _la == MySqlParserSIGNED) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6551)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserINTEGER {
			{
				p.SetState(6550)
				p.Match(MySqlParserINTEGER)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(6556)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserARRAY {
		{
			p.SetState(6555)
			p.Match(MySqlParserARRAY)
		}

	}

	return localctx
}

// ILengthOneDimensionContext is an interface to support dynamic dispatch.
type ILengthOneDimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	RR_BRACKET() antlr.TerminalNode

	// IsLengthOneDimensionContext differentiates from other interfaces.
	IsLengthOneDimensionContext()
}

type LengthOneDimensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLengthOneDimensionContext() *LengthOneDimensionContext {
	var p = new(LengthOneDimensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_lengthOneDimension
	return p
}

func (*LengthOneDimensionContext) IsLengthOneDimensionContext() {}

func NewLengthOneDimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LengthOneDimensionContext {
	var p = new(LengthOneDimensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_lengthOneDimension

	return p
}

func (s *LengthOneDimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *LengthOneDimensionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *LengthOneDimensionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LengthOneDimensionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *LengthOneDimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LengthOneDimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LengthOneDimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLengthOneDimension(s)
	}
}

func (s *LengthOneDimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLengthOneDimension(s)
	}
}

func (p *MySqlParser) LengthOneDimension() (localctx ILengthOneDimensionContext) {
	this := p
	_ = this

	localctx = NewLengthOneDimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 594, MySqlParserRULE_lengthOneDimension)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6558)
		p.Match(MySqlParserLR_BRACKET)
	}
	{
		p.SetState(6559)
		p.DecimalLiteral()
	}
	{
		p.SetState(6560)
		p.Match(MySqlParserRR_BRACKET)
	}

	return localctx
}

// ILengthTwoDimensionContext is an interface to support dynamic dispatch.
type ILengthTwoDimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	AllDecimalLiteral() []IDecimalLiteralContext
	DecimalLiteral(i int) IDecimalLiteralContext
	COMMA() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode

	// IsLengthTwoDimensionContext differentiates from other interfaces.
	IsLengthTwoDimensionContext()
}

type LengthTwoDimensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLengthTwoDimensionContext() *LengthTwoDimensionContext {
	var p = new(LengthTwoDimensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_lengthTwoDimension
	return p
}

func (*LengthTwoDimensionContext) IsLengthTwoDimensionContext() {}

func NewLengthTwoDimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LengthTwoDimensionContext {
	var p = new(LengthTwoDimensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_lengthTwoDimension

	return p
}

func (s *LengthTwoDimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *LengthTwoDimensionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *LengthTwoDimensionContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *LengthTwoDimensionContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LengthTwoDimensionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *LengthTwoDimensionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *LengthTwoDimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LengthTwoDimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LengthTwoDimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLengthTwoDimension(s)
	}
}

func (s *LengthTwoDimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLengthTwoDimension(s)
	}
}

func (p *MySqlParser) LengthTwoDimension() (localctx ILengthTwoDimensionContext) {
	this := p
	_ = this

	localctx = NewLengthTwoDimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 596, MySqlParserRULE_lengthTwoDimension)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6562)
		p.Match(MySqlParserLR_BRACKET)
	}
	{
		p.SetState(6563)
		p.DecimalLiteral()
	}
	{
		p.SetState(6564)
		p.Match(MySqlParserCOMMA)
	}
	{
		p.SetState(6565)
		p.DecimalLiteral()
	}
	{
		p.SetState(6566)
		p.Match(MySqlParserRR_BRACKET)
	}

	return localctx
}

// ILengthTwoOptionalDimensionContext is an interface to support dynamic dispatch.
type ILengthTwoOptionalDimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	AllDecimalLiteral() []IDecimalLiteralContext
	DecimalLiteral(i int) IDecimalLiteralContext
	RR_BRACKET() antlr.TerminalNode
	COMMA() antlr.TerminalNode

	// IsLengthTwoOptionalDimensionContext differentiates from other interfaces.
	IsLengthTwoOptionalDimensionContext()
}

type LengthTwoOptionalDimensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLengthTwoOptionalDimensionContext() *LengthTwoOptionalDimensionContext {
	var p = new(LengthTwoOptionalDimensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_lengthTwoOptionalDimension
	return p
}

func (*LengthTwoOptionalDimensionContext) IsLengthTwoOptionalDimensionContext() {}

func NewLengthTwoOptionalDimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LengthTwoOptionalDimensionContext {
	var p = new(LengthTwoOptionalDimensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_lengthTwoOptionalDimension

	return p
}

func (s *LengthTwoOptionalDimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *LengthTwoOptionalDimensionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *LengthTwoOptionalDimensionContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *LengthTwoOptionalDimensionContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LengthTwoOptionalDimensionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *LengthTwoOptionalDimensionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *LengthTwoOptionalDimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LengthTwoOptionalDimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LengthTwoOptionalDimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLengthTwoOptionalDimension(s)
	}
}

func (s *LengthTwoOptionalDimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLengthTwoOptionalDimension(s)
	}
}

func (p *MySqlParser) LengthTwoOptionalDimension() (localctx ILengthTwoOptionalDimensionContext) {
	this := p
	_ = this

	localctx = NewLengthTwoOptionalDimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 598, MySqlParserRULE_lengthTwoOptionalDimension)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6568)
		p.Match(MySqlParserLR_BRACKET)
	}
	{
		p.SetState(6569)
		p.DecimalLiteral()
	}
	p.SetState(6572)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserCOMMA {
		{
			p.SetState(6570)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(6571)
			p.DecimalLiteral()
		}

	}
	{
		p.SetState(6574)
		p.Match(MySqlParserRR_BRACKET)
	}

	return localctx
}

// IUidListContext is an interface to support dynamic dispatch.
type IUidListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllUid() []IUidContext
	Uid(i int) IUidContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsUidListContext differentiates from other interfaces.
	IsUidListContext()
}

type UidListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUidListContext() *UidListContext {
	var p = new(UidListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_uidList
	return p
}

func (*UidListContext) IsUidListContext() {}

func NewUidListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UidListContext {
	var p = new(UidListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_uidList

	return p
}

func (s *UidListContext) GetParser() antlr.Parser { return s.parser }

func (s *UidListContext) AllUid() []IUidContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUidContext); ok {
			len++
		}
	}

	tst := make([]IUidContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUidContext); ok {
			tst[i] = t.(IUidContext)
			i++
		}
	}

	return tst
}

func (s *UidListContext) Uid(i int) IUidContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *UidListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *UidListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *UidListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UidListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UidListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUidList(s)
	}
}

func (s *UidListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUidList(s)
	}
}

func (p *MySqlParser) UidList() (localctx IUidListContext) {
	this := p
	_ = this

	localctx = NewUidListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 600, MySqlParserRULE_uidList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6576)
		p.Uid()
	}
	p.SetState(6581)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 980, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(6577)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(6578)
				p.Uid()
			}

		}
		p.SetState(6583)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 980, p.GetParserRuleContext())
	}

	return localctx
}

// IFullColumnNameListContext is an interface to support dynamic dispatch.
type IFullColumnNameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFullColumnName() []IFullColumnNameContext
	FullColumnName(i int) IFullColumnNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFullColumnNameListContext differentiates from other interfaces.
	IsFullColumnNameListContext()
}

type FullColumnNameListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullColumnNameListContext() *FullColumnNameListContext {
	var p = new(FullColumnNameListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_fullColumnNameList
	return p
}

func (*FullColumnNameListContext) IsFullColumnNameListContext() {}

func NewFullColumnNameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullColumnNameListContext {
	var p = new(FullColumnNameListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_fullColumnNameList

	return p
}

func (s *FullColumnNameListContext) GetParser() antlr.Parser { return s.parser }

func (s *FullColumnNameListContext) AllFullColumnName() []IFullColumnNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			len++
		}
	}

	tst := make([]IFullColumnNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFullColumnNameContext); ok {
			tst[i] = t.(IFullColumnNameContext)
			i++
		}
	}

	return tst
}

func (s *FullColumnNameListContext) FullColumnName(i int) IFullColumnNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *FullColumnNameListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *FullColumnNameListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *FullColumnNameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullColumnNameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FullColumnNameListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFullColumnNameList(s)
	}
}

func (s *FullColumnNameListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFullColumnNameList(s)
	}
}

func (p *MySqlParser) FullColumnNameList() (localctx IFullColumnNameListContext) {
	this := p
	_ = this

	localctx = NewFullColumnNameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 602, MySqlParserRULE_fullColumnNameList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6584)
		p.FullColumnName()
	}
	p.SetState(6589)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(6585)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(6586)
			p.FullColumnName()
		}

		p.SetState(6591)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITablesContext is an interface to support dynamic dispatch.
type ITablesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTableName() []ITableNameContext
	TableName(i int) ITableNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTablesContext differentiates from other interfaces.
	IsTablesContext()
}

type TablesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablesContext() *TablesContext {
	var p = new(TablesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_tables
	return p
}

func (*TablesContext) IsTablesContext() {}

func NewTablesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablesContext {
	var p = new(TablesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tables

	return p
}

func (s *TablesContext) GetParser() antlr.Parser { return s.parser }

func (s *TablesContext) AllTableName() []ITableNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableNameContext); ok {
			len++
		}
	}

	tst := make([]ITableNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableNameContext); ok {
			tst[i] = t.(ITableNameContext)
			i++
		}
	}

	return tst
}

func (s *TablesContext) TableName(i int) ITableNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TablesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *TablesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *TablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTables(s)
	}
}

func (s *TablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTables(s)
	}
}

func (p *MySqlParser) Tables() (localctx ITablesContext) {
	this := p
	_ = this

	localctx = NewTablesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 604, MySqlParserRULE_tables)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6592)
		p.TableName()
	}
	p.SetState(6597)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 982, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(6593)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(6594)
				p.TableName()
			}

		}
		p.SetState(6599)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 982, p.GetParserRuleContext())
	}

	return localctx
}

// IIndexColumnNamesContext is an interface to support dynamic dispatch.
type IIndexColumnNamesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	AllIndexColumnName() []IIndexColumnNameContext
	IndexColumnName(i int) IIndexColumnNameContext
	RR_BRACKET() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIndexColumnNamesContext differentiates from other interfaces.
	IsIndexColumnNamesContext()
}

type IndexColumnNamesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexColumnNamesContext() *IndexColumnNamesContext {
	var p = new(IndexColumnNamesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_indexColumnNames
	return p
}

func (*IndexColumnNamesContext) IsIndexColumnNamesContext() {}

func NewIndexColumnNamesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexColumnNamesContext {
	var p = new(IndexColumnNamesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_indexColumnNames

	return p
}

func (s *IndexColumnNamesContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexColumnNamesContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *IndexColumnNamesContext) AllIndexColumnName() []IIndexColumnNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexColumnNameContext); ok {
			len++
		}
	}

	tst := make([]IIndexColumnNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexColumnNameContext); ok {
			tst[i] = t.(IIndexColumnNameContext)
			i++
		}
	}

	return tst
}

func (s *IndexColumnNamesContext) IndexColumnName(i int) IIndexColumnNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnNameContext)
}

func (s *IndexColumnNamesContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *IndexColumnNamesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *IndexColumnNamesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *IndexColumnNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexColumnNamesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexColumnNamesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIndexColumnNames(s)
	}
}

func (s *IndexColumnNamesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIndexColumnNames(s)
	}
}

func (p *MySqlParser) IndexColumnNames() (localctx IIndexColumnNamesContext) {
	this := p
	_ = this

	localctx = NewIndexColumnNamesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 606, MySqlParserRULE_indexColumnNames)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6600)
		p.Match(MySqlParserLR_BRACKET)
	}
	{
		p.SetState(6601)
		p.IndexColumnName()
	}
	p.SetState(6606)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(6602)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(6603)
			p.IndexColumnName()
		}

		p.SetState(6608)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6609)
		p.Match(MySqlParserRR_BRACKET)
	}

	return localctx
}

// IExpressionsContext is an interface to support dynamic dispatch.
type IExpressionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExpressionsContext differentiates from other interfaces.
	IsExpressionsContext()
}

type ExpressionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionsContext() *ExpressionsContext {
	var p = new(ExpressionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_expressions
	return p
}

func (*ExpressionsContext) IsExpressionsContext() {}

func NewExpressionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionsContext {
	var p = new(ExpressionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_expressions

	return p
}

func (s *ExpressionsContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionsContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionsContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *ExpressionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *ExpressionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterExpressions(s)
	}
}

func (s *ExpressionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitExpressions(s)
	}
}

func (p *MySqlParser) Expressions() (localctx IExpressionsContext) {
	this := p
	_ = this

	localctx = NewExpressionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 608, MySqlParserRULE_expressions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6611)
		p.expression(0)
	}
	p.SetState(6616)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(6612)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(6613)
			p.expression(0)
		}

		p.SetState(6618)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExpressionsWithDefaultsContext is an interface to support dynamic dispatch.
type IExpressionsWithDefaultsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpressionOrDefault() []IExpressionOrDefaultContext
	ExpressionOrDefault(i int) IExpressionOrDefaultContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExpressionsWithDefaultsContext differentiates from other interfaces.
	IsExpressionsWithDefaultsContext()
}

type ExpressionsWithDefaultsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionsWithDefaultsContext() *ExpressionsWithDefaultsContext {
	var p = new(ExpressionsWithDefaultsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_expressionsWithDefaults
	return p
}

func (*ExpressionsWithDefaultsContext) IsExpressionsWithDefaultsContext() {}

func NewExpressionsWithDefaultsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionsWithDefaultsContext {
	var p = new(ExpressionsWithDefaultsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_expressionsWithDefaults

	return p
}

func (s *ExpressionsWithDefaultsContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionsWithDefaultsContext) AllExpressionOrDefault() []IExpressionOrDefaultContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionOrDefaultContext); ok {
			len++
		}
	}

	tst := make([]IExpressionOrDefaultContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionOrDefaultContext); ok {
			tst[i] = t.(IExpressionOrDefaultContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionsWithDefaultsContext) ExpressionOrDefault(i int) IExpressionOrDefaultContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionOrDefaultContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionOrDefaultContext)
}

func (s *ExpressionsWithDefaultsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *ExpressionsWithDefaultsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *ExpressionsWithDefaultsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionsWithDefaultsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionsWithDefaultsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterExpressionsWithDefaults(s)
	}
}

func (s *ExpressionsWithDefaultsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitExpressionsWithDefaults(s)
	}
}

func (p *MySqlParser) ExpressionsWithDefaults() (localctx IExpressionsWithDefaultsContext) {
	this := p
	_ = this

	localctx = NewExpressionsWithDefaultsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 610, MySqlParserRULE_expressionsWithDefaults)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6619)
		p.ExpressionOrDefault()
	}
	p.SetState(6624)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(6620)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(6621)
			p.ExpressionOrDefault()
		}

		p.SetState(6626)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IConstantsContext is an interface to support dynamic dispatch.
type IConstantsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllConstant() []IConstantContext
	Constant(i int) IConstantContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsConstantsContext differentiates from other interfaces.
	IsConstantsContext()
}

type ConstantsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantsContext() *ConstantsContext {
	var p = new(ConstantsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_constants
	return p
}

func (*ConstantsContext) IsConstantsContext() {}

func NewConstantsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantsContext {
	var p = new(ConstantsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_constants

	return p
}

func (s *ConstantsContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantsContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *ConstantsContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ConstantsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *ConstantsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *ConstantsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterConstants(s)
	}
}

func (s *ConstantsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitConstants(s)
	}
}

func (p *MySqlParser) Constants() (localctx IConstantsContext) {
	this := p
	_ = this

	localctx = NewConstantsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 612, MySqlParserRULE_constants)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6627)
		p.Constant()
	}
	p.SetState(6632)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(6628)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(6629)
			p.Constant()
		}

		p.SetState(6634)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISimpleStringsContext is an interface to support dynamic dispatch.
type ISimpleStringsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSimpleStringsContext differentiates from other interfaces.
	IsSimpleStringsContext()
}

type SimpleStringsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleStringsContext() *SimpleStringsContext {
	var p = new(SimpleStringsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_simpleStrings
	return p
}

func (*SimpleStringsContext) IsSimpleStringsContext() {}

func NewSimpleStringsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleStringsContext {
	var p = new(SimpleStringsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_simpleStrings

	return p
}

func (s *SimpleStringsContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleStringsContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSTRING_LITERAL)
}

func (s *SimpleStringsContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, i)
}

func (s *SimpleStringsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *SimpleStringsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *SimpleStringsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleStringsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleStringsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSimpleStrings(s)
	}
}

func (s *SimpleStringsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSimpleStrings(s)
	}
}

func (p *MySqlParser) SimpleStrings() (localctx ISimpleStringsContext) {
	this := p
	_ = this

	localctx = NewSimpleStringsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 614, MySqlParserRULE_simpleStrings)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6635)
		p.Match(MySqlParserSTRING_LITERAL)
	}
	p.SetState(6640)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(6636)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(6637)
			p.Match(MySqlParserSTRING_LITERAL)
		}

		p.SetState(6642)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IUserVariablesContext is an interface to support dynamic dispatch.
type IUserVariablesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLOCAL_ID() []antlr.TerminalNode
	LOCAL_ID(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsUserVariablesContext differentiates from other interfaces.
	IsUserVariablesContext()
}

type UserVariablesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserVariablesContext() *UserVariablesContext {
	var p = new(UserVariablesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_userVariables
	return p
}

func (*UserVariablesContext) IsUserVariablesContext() {}

func NewUserVariablesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserVariablesContext {
	var p = new(UserVariablesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_userVariables

	return p
}

func (s *UserVariablesContext) GetParser() antlr.Parser { return s.parser }

func (s *UserVariablesContext) AllLOCAL_ID() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLOCAL_ID)
}

func (s *UserVariablesContext) LOCAL_ID(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL_ID, i)
}

func (s *UserVariablesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *UserVariablesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *UserVariablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserVariablesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserVariablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUserVariables(s)
	}
}

func (s *UserVariablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUserVariables(s)
	}
}

func (p *MySqlParser) UserVariables() (localctx IUserVariablesContext) {
	this := p
	_ = this

	localctx = NewUserVariablesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 616, MySqlParserRULE_userVariables)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6643)
		p.Match(MySqlParserLOCAL_ID)
	}
	p.SetState(6648)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(6644)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(6645)
			p.Match(MySqlParserLOCAL_ID)
		}

		p.SetState(6650)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDefaultValueContext is an interface to support dynamic dispatch.
type IDefaultValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NULL_LITERAL() antlr.TerminalNode
	CAST() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	Expression() IExpressionContext
	AS() antlr.TerminalNode
	ConvertedDataType() IConvertedDataTypeContext
	RR_BRACKET() antlr.TerminalNode
	Constant() IConstantContext
	UnaryOperator() IUnaryOperatorContext
	AllCurrentTimestamp() []ICurrentTimestampContext
	CurrentTimestamp(i int) ICurrentTimestampContext
	ON() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	FullId() IFullIdContext

	// IsDefaultValueContext differentiates from other interfaces.
	IsDefaultValueContext()
}

type DefaultValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultValueContext() *DefaultValueContext {
	var p = new(DefaultValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_defaultValue
	return p
}

func (*DefaultValueContext) IsDefaultValueContext() {}

func NewDefaultValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultValueContext {
	var p = new(DefaultValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_defaultValue

	return p
}

func (s *DefaultValueContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultValueContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserNULL_LITERAL, 0)
}

func (s *DefaultValueContext) CAST() antlr.TerminalNode {
	return s.GetToken(MySqlParserCAST, 0)
}

func (s *DefaultValueContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *DefaultValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DefaultValueContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *DefaultValueContext) ConvertedDataType() IConvertedDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConvertedDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConvertedDataTypeContext)
}

func (s *DefaultValueContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *DefaultValueContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *DefaultValueContext) UnaryOperator() IUnaryOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryOperatorContext)
}

func (s *DefaultValueContext) AllCurrentTimestamp() []ICurrentTimestampContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICurrentTimestampContext); ok {
			len++
		}
	}

	tst := make([]ICurrentTimestampContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICurrentTimestampContext); ok {
			tst[i] = t.(ICurrentTimestampContext)
			i++
		}
	}

	return tst
}

func (s *DefaultValueContext) CurrentTimestamp(i int) ICurrentTimestampContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICurrentTimestampContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICurrentTimestampContext)
}

func (s *DefaultValueContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *DefaultValueContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPDATE, 0)
}

func (s *DefaultValueContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *DefaultValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDefaultValue(s)
	}
}

func (s *DefaultValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDefaultValue(s)
	}
}

func (p *MySqlParser) DefaultValue() (localctx IDefaultValueContext) {
	this := p
	_ = this

	localctx = NewDefaultValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 618, MySqlParserRULE_defaultValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6677)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 991, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6651)
			p.Match(MySqlParserNULL_LITERAL)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6652)
			p.Match(MySqlParserCAST)
		}
		{
			p.SetState(6653)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(6654)
			p.expression(0)
		}
		{
			p.SetState(6655)
			p.Match(MySqlParserAS)
		}
		{
			p.SetState(6656)
			p.ConvertedDataType()
		}
		{
			p.SetState(6657)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(6660)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 989, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6659)
				p.UnaryOperator()
			}

		}
		{
			p.SetState(6662)
			p.Constant()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6663)
			p.CurrentTimestamp()
		}
		p.SetState(6667)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 990, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6664)
				p.Match(MySqlParserON)
			}
			{
				p.SetState(6665)
				p.Match(MySqlParserUPDATE)
			}
			{
				p.SetState(6666)
				p.CurrentTimestamp()
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6669)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(6670)
			p.expression(0)
		}
		{
			p.SetState(6671)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6673)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(6674)
			p.FullId()
		}
		{
			p.SetState(6675)
			p.Match(MySqlParserRR_BRACKET)
		}

	}

	return localctx
}

// ICurrentTimestampContext is an interface to support dynamic dispatch.
type ICurrentTimestampContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NOW() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	CURRENT_TIMESTAMP() antlr.TerminalNode
	LOCALTIME() antlr.TerminalNode
	LOCALTIMESTAMP() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext

	// IsCurrentTimestampContext differentiates from other interfaces.
	IsCurrentTimestampContext()
}

type CurrentTimestampContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCurrentTimestampContext() *CurrentTimestampContext {
	var p = new(CurrentTimestampContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_currentTimestamp
	return p
}

func (*CurrentTimestampContext) IsCurrentTimestampContext() {}

func NewCurrentTimestampContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CurrentTimestampContext {
	var p = new(CurrentTimestampContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_currentTimestamp

	return p
}

func (s *CurrentTimestampContext) GetParser() antlr.Parser { return s.parser }

func (s *CurrentTimestampContext) NOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOW, 0)
}

func (s *CurrentTimestampContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CurrentTimestampContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CurrentTimestampContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT_TIMESTAMP, 0)
}

func (s *CurrentTimestampContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCALTIME, 0)
}

func (s *CurrentTimestampContext) LOCALTIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCALTIMESTAMP, 0)
}

func (s *CurrentTimestampContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *CurrentTimestampContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentTimestampContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CurrentTimestampContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCurrentTimestamp(s)
	}
}

func (s *CurrentTimestampContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCurrentTimestamp(s)
	}
}

func (p *MySqlParser) CurrentTimestamp() (localctx ICurrentTimestampContext) {
	this := p
	_ = this

	localctx = NewCurrentTimestampContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 620, MySqlParserRULE_currentTimestamp)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6693)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserLOCALTIMESTAMP:
		{
			p.SetState(6679)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-315)) & ^0x3f) == 0 && ((int64(1)<<(_la-315))&131) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6685)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 993, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6680)
				p.Match(MySqlParserLR_BRACKET)
			}
			p.SetState(6682)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (int64((_la-1136)) & ^0x3f) == 0 && ((int64(1)<<(_la-1136))&10247) != 0 {
				{
					p.SetState(6681)
					p.DecimalLiteral()
				}

			}
			{
				p.SetState(6684)
				p.Match(MySqlParserRR_BRACKET)
			}

		}

	case MySqlParserNOW:
		{
			p.SetState(6687)
			p.Match(MySqlParserNOW)
		}
		{
			p.SetState(6688)
			p.Match(MySqlParserLR_BRACKET)
		}
		p.SetState(6690)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-1136)) & ^0x3f) == 0 && ((int64(1)<<(_la-1136))&10247) != 0 {
			{
				p.SetState(6689)
				p.DecimalLiteral()
			}

		}
		{
			p.SetState(6692)
			p.Match(MySqlParserRR_BRACKET)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExpressionOrDefaultContext is an interface to support dynamic dispatch.
type IExpressionOrDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	DEFAULT() antlr.TerminalNode

	// IsExpressionOrDefaultContext differentiates from other interfaces.
	IsExpressionOrDefaultContext()
}

type ExpressionOrDefaultContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionOrDefaultContext() *ExpressionOrDefaultContext {
	var p = new(ExpressionOrDefaultContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_expressionOrDefault
	return p
}

func (*ExpressionOrDefaultContext) IsExpressionOrDefaultContext() {}

func NewExpressionOrDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionOrDefaultContext {
	var p = new(ExpressionOrDefaultContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_expressionOrDefault

	return p
}

func (s *ExpressionOrDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionOrDefaultContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionOrDefaultContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *ExpressionOrDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionOrDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionOrDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterExpressionOrDefault(s)
	}
}

func (s *ExpressionOrDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitExpressionOrDefault(s)
	}
}

func (p *MySqlParser) ExpressionOrDefault() (localctx IExpressionOrDefaultContext) {
	this := p
	_ = this

	localctx = NewExpressionOrDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 622, MySqlParserRULE_expressionOrDefault)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6697)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 996, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6695)
			p.expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6696)
			p.Match(MySqlParserDEFAULT)
		}

	}

	return localctx
}

// IIfExistsContext is an interface to support dynamic dispatch.
type IIfExistsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsIfExistsContext differentiates from other interfaces.
	IsIfExistsContext()
}

type IfExistsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfExistsContext() *IfExistsContext {
	var p = new(IfExistsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_ifExists
	return p
}

func (*IfExistsContext) IsIfExistsContext() {}

func NewIfExistsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfExistsContext {
	var p = new(IfExistsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_ifExists

	return p
}

func (s *IfExistsContext) GetParser() antlr.Parser { return s.parser }

func (s *IfExistsContext) IF() antlr.TerminalNode {
	return s.GetToken(MySqlParserIF, 0)
}

func (s *IfExistsContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXISTS, 0)
}

func (s *IfExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfExistsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIfExists(s)
	}
}

func (s *IfExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIfExists(s)
	}
}

func (p *MySqlParser) IfExists() (localctx IIfExistsContext) {
	this := p
	_ = this

	localctx = NewIfExistsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 624, MySqlParserRULE_ifExists)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6699)
		p.Match(MySqlParserIF)
	}
	{
		p.SetState(6700)
		p.Match(MySqlParserEXISTS)
	}

	return localctx
}

// IIfNotExistsContext is an interface to support dynamic dispatch.
type IIfNotExistsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsIfNotExistsContext differentiates from other interfaces.
	IsIfNotExistsContext()
}

type IfNotExistsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfNotExistsContext() *IfNotExistsContext {
	var p = new(IfNotExistsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_ifNotExists
	return p
}

func (*IfNotExistsContext) IsIfNotExistsContext() {}

func NewIfNotExistsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfNotExistsContext {
	var p = new(IfNotExistsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_ifNotExists

	return p
}

func (s *IfNotExistsContext) GetParser() antlr.Parser { return s.parser }

func (s *IfNotExistsContext) IF() antlr.TerminalNode {
	return s.GetToken(MySqlParserIF, 0)
}

func (s *IfNotExistsContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *IfNotExistsContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXISTS, 0)
}

func (s *IfNotExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfNotExistsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfNotExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIfNotExists(s)
	}
}

func (s *IfNotExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIfNotExists(s)
	}
}

func (p *MySqlParser) IfNotExists() (localctx IIfNotExistsContext) {
	this := p
	_ = this

	localctx = NewIfNotExistsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 626, MySqlParserRULE_ifNotExists)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6702)
		p.Match(MySqlParserIF)
	}
	{
		p.SetState(6703)
		p.Match(MySqlParserNOT)
	}
	{
		p.SetState(6704)
		p.Match(MySqlParserEXISTS)
	}

	return localctx
}

// IOrReplaceContext is an interface to support dynamic dispatch.
type IOrReplaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OR() antlr.TerminalNode
	REPLACE() antlr.TerminalNode

	// IsOrReplaceContext differentiates from other interfaces.
	IsOrReplaceContext()
}

type OrReplaceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrReplaceContext() *OrReplaceContext {
	var p = new(OrReplaceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_orReplace
	return p
}

func (*OrReplaceContext) IsOrReplaceContext() {}

func NewOrReplaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrReplaceContext {
	var p = new(OrReplaceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_orReplace

	return p
}

func (s *OrReplaceContext) GetParser() antlr.Parser { return s.parser }

func (s *OrReplaceContext) OR() antlr.TerminalNode {
	return s.GetToken(MySqlParserOR, 0)
}

func (s *OrReplaceContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLACE, 0)
}

func (s *OrReplaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrReplaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrReplaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterOrReplace(s)
	}
}

func (s *OrReplaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitOrReplace(s)
	}
}

func (p *MySqlParser) OrReplace() (localctx IOrReplaceContext) {
	this := p
	_ = this

	localctx = NewOrReplaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 628, MySqlParserRULE_orReplace)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6706)
		p.Match(MySqlParserOR)
	}
	{
		p.SetState(6707)
		p.Match(MySqlParserREPLACE)
	}

	return localctx
}

// IWaitNowaitClauseContext is an interface to support dynamic dispatch.
type IWaitNowaitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WAIT() antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	NOWAIT() antlr.TerminalNode

	// IsWaitNowaitClauseContext differentiates from other interfaces.
	IsWaitNowaitClauseContext()
}

type WaitNowaitClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWaitNowaitClauseContext() *WaitNowaitClauseContext {
	var p = new(WaitNowaitClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_waitNowaitClause
	return p
}

func (*WaitNowaitClauseContext) IsWaitNowaitClauseContext() {}

func NewWaitNowaitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WaitNowaitClauseContext {
	var p = new(WaitNowaitClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_waitNowaitClause

	return p
}

func (s *WaitNowaitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WaitNowaitClauseContext) WAIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserWAIT, 0)
}

func (s *WaitNowaitClauseContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *WaitNowaitClauseContext) NOWAIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOWAIT, 0)
}

func (s *WaitNowaitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WaitNowaitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WaitNowaitClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterWaitNowaitClause(s)
	}
}

func (s *WaitNowaitClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitWaitNowaitClause(s)
	}
}

func (p *MySqlParser) WaitNowaitClause() (localctx IWaitNowaitClauseContext) {
	this := p
	_ = this

	localctx = NewWaitNowaitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 630, MySqlParserRULE_waitNowaitClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6712)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserWAIT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6709)
			p.Match(MySqlParserWAIT)
		}
		{
			p.SetState(6710)
			p.DecimalLiteral()
		}

	case MySqlParserNOWAIT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6711)
			p.Match(MySqlParserNOWAIT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFunctionCallContext is an interface to support dynamic dispatch.
type IFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsFunctionCallContext differentiates from other interfaces.
	IsFunctionCallContext()
}

type FunctionCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallContext() *FunctionCallContext {
	var p = new(FunctionCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_functionCall
	return p
}

func (*FunctionCallContext) IsFunctionCallContext() {}

func NewFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallContext {
	var p = new(FunctionCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_functionCall

	return p
}

func (s *FunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallContext) CopyFrom(ctx *FunctionCallContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SpecificFunctionCallContext struct {
	*FunctionCallContext
}

func NewSpecificFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpecificFunctionCallContext {
	var p = new(SpecificFunctionCallContext)

	p.FunctionCallContext = NewEmptyFunctionCallContext()
	p.parser = parser
	p.CopyFrom(ctx.(*FunctionCallContext))

	return p
}

func (s *SpecificFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecificFunctionCallContext) SpecificFunction() ISpecificFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecificFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecificFunctionContext)
}

func (s *SpecificFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSpecificFunctionCall(s)
	}
}

func (s *SpecificFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSpecificFunctionCall(s)
	}
}

type PasswordFunctionCallContext struct {
	*FunctionCallContext
}

func NewPasswordFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PasswordFunctionCallContext {
	var p = new(PasswordFunctionCallContext)

	p.FunctionCallContext = NewEmptyFunctionCallContext()
	p.parser = parser
	p.CopyFrom(ctx.(*FunctionCallContext))

	return p
}

func (s *PasswordFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PasswordFunctionCallContext) PasswordFunctionClause() IPasswordFunctionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPasswordFunctionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPasswordFunctionClauseContext)
}

func (s *PasswordFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPasswordFunctionCall(s)
	}
}

func (s *PasswordFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPasswordFunctionCall(s)
	}
}

type UdfFunctionCallContext struct {
	*FunctionCallContext
}

func NewUdfFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UdfFunctionCallContext {
	var p = new(UdfFunctionCallContext)

	p.FunctionCallContext = NewEmptyFunctionCallContext()
	p.parser = parser
	p.CopyFrom(ctx.(*FunctionCallContext))

	return p
}

func (s *UdfFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UdfFunctionCallContext) FullId() IFullIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *UdfFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *UdfFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *UdfFunctionCallContext) FunctionArgs() IFunctionArgsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgsContext)
}

func (s *UdfFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUdfFunctionCall(s)
	}
}

func (s *UdfFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUdfFunctionCall(s)
	}
}

type NonAggregateFunctionCallContext struct {
	*FunctionCallContext
}

func NewNonAggregateFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NonAggregateFunctionCallContext {
	var p = new(NonAggregateFunctionCallContext)

	p.FunctionCallContext = NewEmptyFunctionCallContext()
	p.parser = parser
	p.CopyFrom(ctx.(*FunctionCallContext))

	return p
}

func (s *NonAggregateFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonAggregateFunctionCallContext) NonAggregateWindowedFunction() INonAggregateWindowedFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonAggregateWindowedFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonAggregateWindowedFunctionContext)
}

func (s *NonAggregateFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterNonAggregateFunctionCall(s)
	}
}

func (s *NonAggregateFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitNonAggregateFunctionCall(s)
	}
}

type AggregateFunctionCallContext struct {
	*FunctionCallContext
}

func NewAggregateFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AggregateFunctionCallContext {
	var p = new(AggregateFunctionCallContext)

	p.FunctionCallContext = NewEmptyFunctionCallContext()
	p.parser = parser
	p.CopyFrom(ctx.(*FunctionCallContext))

	return p
}

func (s *AggregateFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregateFunctionCallContext) AggregateWindowedFunction() IAggregateWindowedFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggregateWindowedFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggregateWindowedFunctionContext)
}

func (s *AggregateFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAggregateFunctionCall(s)
	}
}

func (s *AggregateFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAggregateFunctionCall(s)
	}
}

type ScalarFunctionCallContext struct {
	*FunctionCallContext
}

func NewScalarFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ScalarFunctionCallContext {
	var p = new(ScalarFunctionCallContext)

	p.FunctionCallContext = NewEmptyFunctionCallContext()
	p.parser = parser
	p.CopyFrom(ctx.(*FunctionCallContext))

	return p
}

func (s *ScalarFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalarFunctionCallContext) ScalarFunctionName() IScalarFunctionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarFunctionNameContext)
}

func (s *ScalarFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *ScalarFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *ScalarFunctionCallContext) FunctionArgs() IFunctionArgsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgsContext)
}

func (s *ScalarFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterScalarFunctionCall(s)
	}
}

func (s *ScalarFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitScalarFunctionCall(s)
	}
}

func (p *MySqlParser) FunctionCall() (localctx IFunctionCallContext) {
	this := p
	_ = this

	localctx = NewFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 632, MySqlParserRULE_functionCall)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6732)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1000, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSpecificFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6714)
			p.SpecificFunction()
		}

	case 2:
		localctx = NewAggregateFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6715)
			p.AggregateWindowedFunction()
		}

	case 3:
		localctx = NewNonAggregateFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6716)
			p.NonAggregateWindowedFunction()
		}

	case 4:
		localctx = NewScalarFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6717)
			p.ScalarFunctionName()
		}
		{
			p.SetState(6718)
			p.Match(MySqlParserLR_BRACKET)
		}
		p.SetState(6720)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 998, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6719)
				p.FunctionArgs()
			}

		}
		{
			p.SetState(6722)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 5:
		localctx = NewUdfFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6724)
			p.FullId()
		}
		{
			p.SetState(6725)
			p.Match(MySqlParserLR_BRACKET)
		}
		p.SetState(6727)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 999, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6726)
				p.FunctionArgs()
			}

		}
		{
			p.SetState(6729)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 6:
		localctx = NewPasswordFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6731)
			p.PasswordFunctionClause()
		}

	}

	return localctx
}

// ISpecificFunctionContext is an interface to support dynamic dispatch.
type ISpecificFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSpecificFunctionContext differentiates from other interfaces.
	IsSpecificFunctionContext()
}

type SpecificFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecificFunctionContext() *SpecificFunctionContext {
	var p = new(SpecificFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_specificFunction
	return p
}

func (*SpecificFunctionContext) IsSpecificFunctionContext() {}

func NewSpecificFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecificFunctionContext {
	var p = new(SpecificFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_specificFunction

	return p
}

func (s *SpecificFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecificFunctionContext) CopyFrom(ctx *SpecificFunctionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *SpecificFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecificFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PositionFunctionCallContext struct {
	*SpecificFunctionContext
	positionString     IStringLiteralContext
	positionExpression IExpressionContext
	inString           IStringLiteralContext
	inExpression       IExpressionContext
}

func NewPositionFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PositionFunctionCallContext {
	var p = new(PositionFunctionCallContext)

	p.SpecificFunctionContext = NewEmptySpecificFunctionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SpecificFunctionContext))

	return p
}

func (s *PositionFunctionCallContext) GetPositionString() IStringLiteralContext {
	return s.positionString
}

func (s *PositionFunctionCallContext) GetPositionExpression() IExpressionContext {
	return s.positionExpression
}

func (s *PositionFunctionCallContext) GetInString() IStringLiteralContext { return s.inString }

func (s *PositionFunctionCallContext) GetInExpression() IExpressionContext { return s.inExpression }

func (s *PositionFunctionCallContext) SetPositionString(v IStringLiteralContext) {
	s.positionString = v
}

func (s *PositionFunctionCallContext) SetPositionExpression(v IExpressionContext) {
	s.positionExpression = v
}

func (s *PositionFunctionCallContext) SetInString(v IStringLiteralContext) { s.inString = v }

func (s *PositionFunctionCallContext) SetInExpression(v IExpressionContext) { s.inExpression = v }

func (s *PositionFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PositionFunctionCallContext) POSITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOSITION, 0)
}

func (s *PositionFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *PositionFunctionCallContext) IN() antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, 0)
}

func (s *PositionFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *PositionFunctionCallContext) AllStringLiteral() []IStringLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringLiteralContext); ok {
			len++
		}
	}

	tst := make([]IStringLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringLiteralContext); ok {
			tst[i] = t.(IStringLiteralContext)
			i++
		}
	}

	return tst
}

func (s *PositionFunctionCallContext) StringLiteral(i int) IStringLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *PositionFunctionCallContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PositionFunctionCallContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PositionFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPositionFunctionCall(s)
	}
}

func (s *PositionFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPositionFunctionCall(s)
	}
}

type TrimFunctionCallContext struct {
	*SpecificFunctionContext
	positioinForm    antlr.Token
	sourceString     IStringLiteralContext
	sourceExpression IExpressionContext
	fromString       IStringLiteralContext
	fromExpression   IExpressionContext
}

func NewTrimFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TrimFunctionCallContext {
	var p = new(TrimFunctionCallContext)

	p.SpecificFunctionContext = NewEmptySpecificFunctionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SpecificFunctionContext))

	return p
}

func (s *TrimFunctionCallContext) GetPositioinForm() antlr.Token { return s.positioinForm }

func (s *TrimFunctionCallContext) SetPositioinForm(v antlr.Token) { s.positioinForm = v }

func (s *TrimFunctionCallContext) GetSourceString() IStringLiteralContext { return s.sourceString }

func (s *TrimFunctionCallContext) GetSourceExpression() IExpressionContext { return s.sourceExpression }

func (s *TrimFunctionCallContext) GetFromString() IStringLiteralContext { return s.fromString }

func (s *TrimFunctionCallContext) GetFromExpression() IExpressionContext { return s.fromExpression }

func (s *TrimFunctionCallContext) SetSourceString(v IStringLiteralContext) { s.sourceString = v }

func (s *TrimFunctionCallContext) SetSourceExpression(v IExpressionContext) { s.sourceExpression = v }

func (s *TrimFunctionCallContext) SetFromString(v IStringLiteralContext) { s.fromString = v }

func (s *TrimFunctionCallContext) SetFromExpression(v IExpressionContext) { s.fromExpression = v }

func (s *TrimFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TrimFunctionCallContext) TRIM() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRIM, 0)
}

func (s *TrimFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *TrimFunctionCallContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *TrimFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *TrimFunctionCallContext) BOTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserBOTH, 0)
}

func (s *TrimFunctionCallContext) LEADING() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEADING, 0)
}

func (s *TrimFunctionCallContext) TRAILING() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRAILING, 0)
}

func (s *TrimFunctionCallContext) AllStringLiteral() []IStringLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringLiteralContext); ok {
			len++
		}
	}

	tst := make([]IStringLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringLiteralContext); ok {
			tst[i] = t.(IStringLiteralContext)
			i++
		}
	}

	return tst
}

func (s *TrimFunctionCallContext) StringLiteral(i int) IStringLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *TrimFunctionCallContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TrimFunctionCallContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TrimFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTrimFunctionCall(s)
	}
}

func (s *TrimFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTrimFunctionCall(s)
	}
}

type JsonValueFunctionCallContext struct {
	*SpecificFunctionContext
}

func NewJsonValueFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JsonValueFunctionCallContext {
	var p = new(JsonValueFunctionCallContext)

	p.SpecificFunctionContext = NewEmptySpecificFunctionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SpecificFunctionContext))

	return p
}

func (s *JsonValueFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonValueFunctionCallContext) JSON_VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_VALUE, 0)
}

func (s *JsonValueFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *JsonValueFunctionCallContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *JsonValueFunctionCallContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *JsonValueFunctionCallContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *JsonValueFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *JsonValueFunctionCallContext) RETURNING() antlr.TerminalNode {
	return s.GetToken(MySqlParserRETURNING, 0)
}

func (s *JsonValueFunctionCallContext) ConvertedDataType() IConvertedDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConvertedDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConvertedDataTypeContext)
}

func (s *JsonValueFunctionCallContext) JsonOnEmpty() IJsonOnEmptyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonOnEmptyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonOnEmptyContext)
}

func (s *JsonValueFunctionCallContext) JsonOnError() IJsonOnErrorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonOnErrorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonOnErrorContext)
}

func (s *JsonValueFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterJsonValueFunctionCall(s)
	}
}

func (s *JsonValueFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitJsonValueFunctionCall(s)
	}
}

type CaseFunctionCallContext struct {
	*SpecificFunctionContext
	elseArg IFunctionArgContext
}

func NewCaseFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CaseFunctionCallContext {
	var p = new(CaseFunctionCallContext)

	p.SpecificFunctionContext = NewEmptySpecificFunctionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SpecificFunctionContext))

	return p
}

func (s *CaseFunctionCallContext) GetElseArg() IFunctionArgContext { return s.elseArg }

func (s *CaseFunctionCallContext) SetElseArg(v IFunctionArgContext) { s.elseArg = v }

func (s *CaseFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseFunctionCallContext) CASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCASE, 0)
}

func (s *CaseFunctionCallContext) END() antlr.TerminalNode {
	return s.GetToken(MySqlParserEND, 0)
}

func (s *CaseFunctionCallContext) AllCaseFuncAlternative() []ICaseFuncAlternativeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseFuncAlternativeContext); ok {
			len++
		}
	}

	tst := make([]ICaseFuncAlternativeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseFuncAlternativeContext); ok {
			tst[i] = t.(ICaseFuncAlternativeContext)
			i++
		}
	}

	return tst
}

func (s *CaseFunctionCallContext) CaseFuncAlternative(i int) ICaseFuncAlternativeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseFuncAlternativeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseFuncAlternativeContext)
}

func (s *CaseFunctionCallContext) ELSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserELSE, 0)
}

func (s *CaseFunctionCallContext) FunctionArg() IFunctionArgContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgContext)
}

func (s *CaseFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCaseFunctionCall(s)
	}
}

func (s *CaseFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCaseFunctionCall(s)
	}
}

type ExtractFunctionCallContext struct {
	*SpecificFunctionContext
	sourceString     IStringLiteralContext
	sourceExpression IExpressionContext
}

func NewExtractFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExtractFunctionCallContext {
	var p = new(ExtractFunctionCallContext)

	p.SpecificFunctionContext = NewEmptySpecificFunctionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SpecificFunctionContext))

	return p
}

func (s *ExtractFunctionCallContext) GetSourceString() IStringLiteralContext { return s.sourceString }

func (s *ExtractFunctionCallContext) GetSourceExpression() IExpressionContext {
	return s.sourceExpression
}

func (s *ExtractFunctionCallContext) SetSourceString(v IStringLiteralContext) { s.sourceString = v }

func (s *ExtractFunctionCallContext) SetSourceExpression(v IExpressionContext) {
	s.sourceExpression = v
}

func (s *ExtractFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtractFunctionCallContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXTRACT, 0)
}

func (s *ExtractFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *ExtractFunctionCallContext) IntervalType() IIntervalTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalTypeContext)
}

func (s *ExtractFunctionCallContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *ExtractFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *ExtractFunctionCallContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ExtractFunctionCallContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExtractFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterExtractFunctionCall(s)
	}
}

func (s *ExtractFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitExtractFunctionCall(s)
	}
}

type DataTypeFunctionCallContext struct {
	*SpecificFunctionContext
	separator antlr.Token
}

func NewDataTypeFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DataTypeFunctionCallContext {
	var p = new(DataTypeFunctionCallContext)

	p.SpecificFunctionContext = NewEmptySpecificFunctionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SpecificFunctionContext))

	return p
}

func (s *DataTypeFunctionCallContext) GetSeparator() antlr.Token { return s.separator }

func (s *DataTypeFunctionCallContext) SetSeparator(v antlr.Token) { s.separator = v }

func (s *DataTypeFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeFunctionCallContext) CONVERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONVERT, 0)
}

func (s *DataTypeFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *DataTypeFunctionCallContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DataTypeFunctionCallContext) ConvertedDataType() IConvertedDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConvertedDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConvertedDataTypeContext)
}

func (s *DataTypeFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *DataTypeFunctionCallContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *DataTypeFunctionCallContext) USING() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSING, 0)
}

func (s *DataTypeFunctionCallContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *DataTypeFunctionCallContext) CAST() antlr.TerminalNode {
	return s.GetToken(MySqlParserCAST, 0)
}

func (s *DataTypeFunctionCallContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *DataTypeFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDataTypeFunctionCall(s)
	}
}

func (s *DataTypeFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDataTypeFunctionCall(s)
	}
}

type ValuesFunctionCallContext struct {
	*SpecificFunctionContext
}

func NewValuesFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ValuesFunctionCallContext {
	var p = new(ValuesFunctionCallContext)

	p.SpecificFunctionContext = NewEmptySpecificFunctionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SpecificFunctionContext))

	return p
}

func (s *ValuesFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValuesFunctionCallContext) VALUES() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUES, 0)
}

func (s *ValuesFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *ValuesFunctionCallContext) FullColumnName() IFullColumnNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *ValuesFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *ValuesFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterValuesFunctionCall(s)
	}
}

func (s *ValuesFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitValuesFunctionCall(s)
	}
}

type CaseExpressionFunctionCallContext struct {
	*SpecificFunctionContext
	elseArg IFunctionArgContext
}

func NewCaseExpressionFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CaseExpressionFunctionCallContext {
	var p = new(CaseExpressionFunctionCallContext)

	p.SpecificFunctionContext = NewEmptySpecificFunctionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SpecificFunctionContext))

	return p
}

func (s *CaseExpressionFunctionCallContext) GetElseArg() IFunctionArgContext { return s.elseArg }

func (s *CaseExpressionFunctionCallContext) SetElseArg(v IFunctionArgContext) { s.elseArg = v }

func (s *CaseExpressionFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseExpressionFunctionCallContext) CASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCASE, 0)
}

func (s *CaseExpressionFunctionCallContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseExpressionFunctionCallContext) END() antlr.TerminalNode {
	return s.GetToken(MySqlParserEND, 0)
}

func (s *CaseExpressionFunctionCallContext) AllCaseFuncAlternative() []ICaseFuncAlternativeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseFuncAlternativeContext); ok {
			len++
		}
	}

	tst := make([]ICaseFuncAlternativeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseFuncAlternativeContext); ok {
			tst[i] = t.(ICaseFuncAlternativeContext)
			i++
		}
	}

	return tst
}

func (s *CaseExpressionFunctionCallContext) CaseFuncAlternative(i int) ICaseFuncAlternativeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseFuncAlternativeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseFuncAlternativeContext)
}

func (s *CaseExpressionFunctionCallContext) ELSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserELSE, 0)
}

func (s *CaseExpressionFunctionCallContext) FunctionArg() IFunctionArgContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgContext)
}

func (s *CaseExpressionFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCaseExpressionFunctionCall(s)
	}
}

func (s *CaseExpressionFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCaseExpressionFunctionCall(s)
	}
}

type SimpleFunctionCallContext struct {
	*SpecificFunctionContext
}

func NewSimpleFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleFunctionCallContext {
	var p = new(SimpleFunctionCallContext)

	p.SpecificFunctionContext = NewEmptySpecificFunctionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SpecificFunctionContext))

	return p
}

func (s *SimpleFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleFunctionCallContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT_DATE, 0)
}

func (s *SimpleFunctionCallContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT_TIME, 0)
}

func (s *SimpleFunctionCallContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT_TIMESTAMP, 0)
}

func (s *SimpleFunctionCallContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT_USER, 0)
}

func (s *SimpleFunctionCallContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCALTIME, 0)
}

func (s *SimpleFunctionCallContext) UTC_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTC_TIMESTAMP, 0)
}

func (s *SimpleFunctionCallContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEMA, 0)
}

func (s *SimpleFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *SimpleFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *SimpleFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSimpleFunctionCall(s)
	}
}

func (s *SimpleFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSimpleFunctionCall(s)
	}
}

type CharFunctionCallContext struct {
	*SpecificFunctionContext
}

func NewCharFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CharFunctionCallContext {
	var p = new(CharFunctionCallContext)

	p.SpecificFunctionContext = NewEmptySpecificFunctionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SpecificFunctionContext))

	return p
}

func (s *CharFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharFunctionCallContext) CHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAR, 0)
}

func (s *CharFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CharFunctionCallContext) FunctionArgs() IFunctionArgsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgsContext)
}

func (s *CharFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CharFunctionCallContext) USING() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSING, 0)
}

func (s *CharFunctionCallContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *CharFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCharFunctionCall(s)
	}
}

func (s *CharFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCharFunctionCall(s)
	}
}

type WeightFunctionCallContext struct {
	*SpecificFunctionContext
	stringFormat antlr.Token
}

func NewWeightFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WeightFunctionCallContext {
	var p = new(WeightFunctionCallContext)

	p.SpecificFunctionContext = NewEmptySpecificFunctionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SpecificFunctionContext))

	return p
}

func (s *WeightFunctionCallContext) GetStringFormat() antlr.Token { return s.stringFormat }

func (s *WeightFunctionCallContext) SetStringFormat(v antlr.Token) { s.stringFormat = v }

func (s *WeightFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WeightFunctionCallContext) WEIGHT_STRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserWEIGHT_STRING, 0)
}

func (s *WeightFunctionCallContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *WeightFunctionCallContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *WeightFunctionCallContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *WeightFunctionCallContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *WeightFunctionCallContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *WeightFunctionCallContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WeightFunctionCallContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *WeightFunctionCallContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *WeightFunctionCallContext) LevelsInWeightString() ILevelsInWeightStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILevelsInWeightStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILevelsInWeightStringContext)
}

func (s *WeightFunctionCallContext) CHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAR, 0)
}

func (s *WeightFunctionCallContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *WeightFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterWeightFunctionCall(s)
	}
}

func (s *WeightFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitWeightFunctionCall(s)
	}
}

type GetFormatFunctionCallContext struct {
	*SpecificFunctionContext
	datetimeFormat antlr.Token
}

func NewGetFormatFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GetFormatFunctionCallContext {
	var p = new(GetFormatFunctionCallContext)

	p.SpecificFunctionContext = NewEmptySpecificFunctionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SpecificFunctionContext))

	return p
}

func (s *GetFormatFunctionCallContext) GetDatetimeFormat() antlr.Token { return s.datetimeFormat }

func (s *GetFormatFunctionCallContext) SetDatetimeFormat(v antlr.Token) { s.datetimeFormat = v }

func (s *GetFormatFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GetFormatFunctionCallContext) GET_FORMAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGET_FORMAT, 0)
}

func (s *GetFormatFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *GetFormatFunctionCallContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *GetFormatFunctionCallContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *GetFormatFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *GetFormatFunctionCallContext) DATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATE, 0)
}

func (s *GetFormatFunctionCallContext) TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIME, 0)
}

func (s *GetFormatFunctionCallContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATETIME, 0)
}

func (s *GetFormatFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterGetFormatFunctionCall(s)
	}
}

func (s *GetFormatFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitGetFormatFunctionCall(s)
	}
}

type SubstrFunctionCallContext struct {
	*SpecificFunctionContext
	sourceString     IStringLiteralContext
	sourceExpression IExpressionContext
	fromDecimal      IDecimalLiteralContext
	fromExpression   IExpressionContext
	forDecimal       IDecimalLiteralContext
	forExpression    IExpressionContext
}

func NewSubstrFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubstrFunctionCallContext {
	var p = new(SubstrFunctionCallContext)

	p.SpecificFunctionContext = NewEmptySpecificFunctionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SpecificFunctionContext))

	return p
}

func (s *SubstrFunctionCallContext) GetSourceString() IStringLiteralContext { return s.sourceString }

func (s *SubstrFunctionCallContext) GetSourceExpression() IExpressionContext {
	return s.sourceExpression
}

func (s *SubstrFunctionCallContext) GetFromDecimal() IDecimalLiteralContext { return s.fromDecimal }

func (s *SubstrFunctionCallContext) GetFromExpression() IExpressionContext { return s.fromExpression }

func (s *SubstrFunctionCallContext) GetForDecimal() IDecimalLiteralContext { return s.forDecimal }

func (s *SubstrFunctionCallContext) GetForExpression() IExpressionContext { return s.forExpression }

func (s *SubstrFunctionCallContext) SetSourceString(v IStringLiteralContext) { s.sourceString = v }

func (s *SubstrFunctionCallContext) SetSourceExpression(v IExpressionContext) { s.sourceExpression = v }

func (s *SubstrFunctionCallContext) SetFromDecimal(v IDecimalLiteralContext) { s.fromDecimal = v }

func (s *SubstrFunctionCallContext) SetFromExpression(v IExpressionContext) { s.fromExpression = v }

func (s *SubstrFunctionCallContext) SetForDecimal(v IDecimalLiteralContext) { s.forDecimal = v }

func (s *SubstrFunctionCallContext) SetForExpression(v IExpressionContext) { s.forExpression = v }

func (s *SubstrFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubstrFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *SubstrFunctionCallContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *SubstrFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *SubstrFunctionCallContext) SUBSTR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBSTR, 0)
}

func (s *SubstrFunctionCallContext) SUBSTRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBSTRING, 0)
}

func (s *SubstrFunctionCallContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *SubstrFunctionCallContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SubstrFunctionCallContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SubstrFunctionCallContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *SubstrFunctionCallContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *SubstrFunctionCallContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *SubstrFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSubstrFunctionCall(s)
	}
}

func (s *SubstrFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSubstrFunctionCall(s)
	}
}

func (p *MySqlParser) SpecificFunction() (localctx ISpecificFunctionContext) {
	this := p
	_ = this

	localctx = NewSpecificFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 634, MySqlParserRULE_specificFunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6912)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1024, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSimpleFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6734)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCURRENT_USER || _la == MySqlParserSCHEMA || ((int64((_la-313)) & ^0x3f) == 0 && ((int64(1)<<(_la-313))&262159) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6737)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1001, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6735)
				p.Match(MySqlParserLR_BRACKET)
			}
			{
				p.SetState(6736)
				p.Match(MySqlParserRR_BRACKET)
			}

		}

	case 2:
		localctx = NewDataTypeFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6739)
			p.Match(MySqlParserCONVERT)
		}
		{
			p.SetState(6740)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(6741)
			p.expression(0)
		}
		{
			p.SetState(6742)

			var _m = p.Match(MySqlParserCOMMA)

			localctx.(*DataTypeFunctionCallContext).separator = _m
		}
		{
			p.SetState(6743)
			p.ConvertedDataType()
		}
		{
			p.SetState(6744)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 3:
		localctx = NewDataTypeFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6746)
			p.Match(MySqlParserCONVERT)
		}
		{
			p.SetState(6747)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(6748)
			p.expression(0)
		}
		{
			p.SetState(6749)
			p.Match(MySqlParserUSING)
		}
		{
			p.SetState(6750)
			p.CharsetName()
		}
		{
			p.SetState(6751)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 4:
		localctx = NewDataTypeFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6753)
			p.Match(MySqlParserCAST)
		}
		{
			p.SetState(6754)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(6755)
			p.expression(0)
		}
		{
			p.SetState(6756)
			p.Match(MySqlParserAS)
		}
		{
			p.SetState(6757)
			p.ConvertedDataType()
		}
		{
			p.SetState(6758)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 5:
		localctx = NewValuesFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6760)
			p.Match(MySqlParserVALUES)
		}
		{
			p.SetState(6761)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(6762)
			p.FullColumnName()
		}
		{
			p.SetState(6763)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 6:
		localctx = NewCaseExpressionFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6765)
			p.Match(MySqlParserCASE)
		}
		{
			p.SetState(6766)
			p.expression(0)
		}
		p.SetState(6768)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == MySqlParserWHEN {
			{
				p.SetState(6767)
				p.CaseFuncAlternative()
			}

			p.SetState(6770)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(6774)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserELSE {
			{
				p.SetState(6772)
				p.Match(MySqlParserELSE)
			}
			{
				p.SetState(6773)

				var _x = p.FunctionArg()

				localctx.(*CaseExpressionFunctionCallContext).elseArg = _x
			}

		}
		{
			p.SetState(6776)
			p.Match(MySqlParserEND)
		}

	case 7:
		localctx = NewCaseFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6778)
			p.Match(MySqlParserCASE)
		}
		p.SetState(6780)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == MySqlParserWHEN {
			{
				p.SetState(6779)
				p.CaseFuncAlternative()
			}

			p.SetState(6782)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(6786)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserELSE {
			{
				p.SetState(6784)
				p.Match(MySqlParserELSE)
			}
			{
				p.SetState(6785)

				var _x = p.FunctionArg()

				localctx.(*CaseFunctionCallContext).elseArg = _x
			}

		}
		{
			p.SetState(6788)
			p.Match(MySqlParserEND)
		}

	case 8:
		localctx = NewCharFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6790)
			p.Match(MySqlParserCHAR)
		}
		{
			p.SetState(6791)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(6792)
			p.FunctionArgs()
		}
		p.SetState(6795)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserUSING {
			{
				p.SetState(6793)
				p.Match(MySqlParserUSING)
			}
			{
				p.SetState(6794)
				p.CharsetName()
			}

		}
		{
			p.SetState(6797)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 9:
		localctx = NewPositionFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6799)
			p.Match(MySqlParserPOSITION)
		}
		{
			p.SetState(6800)
			p.Match(MySqlParserLR_BRACKET)
		}
		p.SetState(6803)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1007, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(6801)

				var _x = p.StringLiteral()

				localctx.(*PositionFunctionCallContext).positionString = _x
			}

		case 2:
			{
				p.SetState(6802)

				var _x = p.expression(0)

				localctx.(*PositionFunctionCallContext).positionExpression = _x
			}

		}
		{
			p.SetState(6805)
			p.Match(MySqlParserIN)
		}
		p.SetState(6808)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1008, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(6806)

				var _x = p.StringLiteral()

				localctx.(*PositionFunctionCallContext).inString = _x
			}

		case 2:
			{
				p.SetState(6807)

				var _x = p.expression(0)

				localctx.(*PositionFunctionCallContext).inExpression = _x
			}

		}
		{
			p.SetState(6810)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 10:
		localctx = NewSubstrFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(6812)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserSUBSTR || _la == MySqlParserSUBSTRING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6813)
			p.Match(MySqlParserLR_BRACKET)
		}
		p.SetState(6816)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1009, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(6814)

				var _x = p.StringLiteral()

				localctx.(*SubstrFunctionCallContext).sourceString = _x
			}

		case 2:
			{
				p.SetState(6815)

				var _x = p.expression(0)

				localctx.(*SubstrFunctionCallContext).sourceExpression = _x
			}

		}
		{
			p.SetState(6818)
			p.Match(MySqlParserFROM)
		}
		p.SetState(6821)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1010, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(6819)

				var _x = p.DecimalLiteral()

				localctx.(*SubstrFunctionCallContext).fromDecimal = _x
			}

		case 2:
			{
				p.SetState(6820)

				var _x = p.expression(0)

				localctx.(*SubstrFunctionCallContext).fromExpression = _x
			}

		}
		p.SetState(6828)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserFOR {
			{
				p.SetState(6823)
				p.Match(MySqlParserFOR)
			}
			p.SetState(6826)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1011, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(6824)

					var _x = p.DecimalLiteral()

					localctx.(*SubstrFunctionCallContext).forDecimal = _x
				}

			case 2:
				{
					p.SetState(6825)

					var _x = p.expression(0)

					localctx.(*SubstrFunctionCallContext).forExpression = _x
				}

			}

		}
		{
			p.SetState(6830)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 11:
		localctx = NewTrimFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(6832)
			p.Match(MySqlParserTRIM)
		}
		{
			p.SetState(6833)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(6834)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TrimFunctionCallContext).positioinForm = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserBOTH || _la == MySqlParserLEADING || _la == MySqlParserTRAILING) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TrimFunctionCallContext).positioinForm = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6837)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1013, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6835)

				var _x = p.StringLiteral()

				localctx.(*TrimFunctionCallContext).sourceString = _x
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1013, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(6836)

				var _x = p.expression(0)

				localctx.(*TrimFunctionCallContext).sourceExpression = _x
			}

		}
		{
			p.SetState(6839)
			p.Match(MySqlParserFROM)
		}
		p.SetState(6842)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1014, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(6840)

				var _x = p.StringLiteral()

				localctx.(*TrimFunctionCallContext).fromString = _x
			}

		case 2:
			{
				p.SetState(6841)

				var _x = p.expression(0)

				localctx.(*TrimFunctionCallContext).fromExpression = _x
			}

		}
		{
			p.SetState(6844)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 12:
		localctx = NewTrimFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(6846)
			p.Match(MySqlParserTRIM)
		}
		{
			p.SetState(6847)
			p.Match(MySqlParserLR_BRACKET)
		}
		p.SetState(6850)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1015, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(6848)

				var _x = p.StringLiteral()

				localctx.(*TrimFunctionCallContext).sourceString = _x
			}

		case 2:
			{
				p.SetState(6849)

				var _x = p.expression(0)

				localctx.(*TrimFunctionCallContext).sourceExpression = _x
			}

		}
		{
			p.SetState(6852)
			p.Match(MySqlParserFROM)
		}
		p.SetState(6855)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1016, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(6853)

				var _x = p.StringLiteral()

				localctx.(*TrimFunctionCallContext).fromString = _x
			}

		case 2:
			{
				p.SetState(6854)

				var _x = p.expression(0)

				localctx.(*TrimFunctionCallContext).fromExpression = _x
			}

		}
		{
			p.SetState(6857)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 13:
		localctx = NewWeightFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(6859)
			p.Match(MySqlParserWEIGHT_STRING)
		}
		{
			p.SetState(6860)
			p.Match(MySqlParserLR_BRACKET)
		}
		p.SetState(6863)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1017, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(6861)
				p.StringLiteral()
			}

		case 2:
			{
				p.SetState(6862)
				p.expression(0)
			}

		}
		p.SetState(6871)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserAS {
			{
				p.SetState(6865)
				p.Match(MySqlParserAS)
			}
			{
				p.SetState(6866)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*WeightFunctionCallContext).stringFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserCHAR || _la == MySqlParserBINARY) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*WeightFunctionCallContext).stringFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(6867)
				p.Match(MySqlParserLR_BRACKET)
			}
			{
				p.SetState(6868)
				p.DecimalLiteral()
			}
			{
				p.SetState(6869)
				p.Match(MySqlParserRR_BRACKET)
			}

		}
		p.SetState(6874)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLEVEL {
			{
				p.SetState(6873)
				p.LevelsInWeightString()
			}

		}
		{
			p.SetState(6876)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 14:
		localctx = NewExtractFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(6878)
			p.Match(MySqlParserEXTRACT)
		}
		{
			p.SetState(6879)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(6880)
			p.IntervalType()
		}
		{
			p.SetState(6881)
			p.Match(MySqlParserFROM)
		}
		p.SetState(6884)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1020, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(6882)

				var _x = p.StringLiteral()

				localctx.(*ExtractFunctionCallContext).sourceString = _x
			}

		case 2:
			{
				p.SetState(6883)

				var _x = p.expression(0)

				localctx.(*ExtractFunctionCallContext).sourceExpression = _x
			}

		}
		{
			p.SetState(6886)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 15:
		localctx = NewGetFormatFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(6888)
			p.Match(MySqlParserGET_FORMAT)
		}
		{
			p.SetState(6889)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(6890)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*GetFormatFunctionCallContext).datetimeFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&11) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*GetFormatFunctionCallContext).datetimeFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6891)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(6892)
			p.StringLiteral()
		}
		{
			p.SetState(6893)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 16:
		localctx = NewJsonValueFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(6895)
			p.Match(MySqlParserJSON_VALUE)
		}
		{
			p.SetState(6896)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(6897)
			p.expression(0)
		}
		{
			p.SetState(6898)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(6899)
			p.expression(0)
		}
		p.SetState(6902)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserRETURNING {
			{
				p.SetState(6900)
				p.Match(MySqlParserRETURNING)
			}
			{
				p.SetState(6901)
				p.ConvertedDataType()
			}

		}
		p.SetState(6905)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1022, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6904)
				p.JsonOnEmpty()
			}

		}
		p.SetState(6908)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserDEFAULT || _la == MySqlParserNULL_LITERAL || _la == MySqlParserERROR {
			{
				p.SetState(6907)
				p.JsonOnError()
			}

		}
		{
			p.SetState(6910)
			p.Match(MySqlParserRR_BRACKET)
		}

	}

	return localctx
}

// ICaseFuncAlternativeContext is an interface to support dynamic dispatch.
type ICaseFuncAlternativeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCondition returns the condition rule contexts.
	GetCondition() IFunctionArgContext

	// GetConsequent returns the consequent rule contexts.
	GetConsequent() IFunctionArgContext

	// SetCondition sets the condition rule contexts.
	SetCondition(IFunctionArgContext)

	// SetConsequent sets the consequent rule contexts.
	SetConsequent(IFunctionArgContext)

	// Getter signatures
	WHEN() antlr.TerminalNode
	THEN() antlr.TerminalNode
	AllFunctionArg() []IFunctionArgContext
	FunctionArg(i int) IFunctionArgContext

	// IsCaseFuncAlternativeContext differentiates from other interfaces.
	IsCaseFuncAlternativeContext()
}

type CaseFuncAlternativeContext struct {
	*antlr.BaseParserRuleContext
	parser     antlr.Parser
	condition  IFunctionArgContext
	consequent IFunctionArgContext
}

func NewEmptyCaseFuncAlternativeContext() *CaseFuncAlternativeContext {
	var p = new(CaseFuncAlternativeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_caseFuncAlternative
	return p
}

func (*CaseFuncAlternativeContext) IsCaseFuncAlternativeContext() {}

func NewCaseFuncAlternativeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseFuncAlternativeContext {
	var p = new(CaseFuncAlternativeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_caseFuncAlternative

	return p
}

func (s *CaseFuncAlternativeContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseFuncAlternativeContext) GetCondition() IFunctionArgContext { return s.condition }

func (s *CaseFuncAlternativeContext) GetConsequent() IFunctionArgContext { return s.consequent }

func (s *CaseFuncAlternativeContext) SetCondition(v IFunctionArgContext) { s.condition = v }

func (s *CaseFuncAlternativeContext) SetConsequent(v IFunctionArgContext) { s.consequent = v }

func (s *CaseFuncAlternativeContext) WHEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserWHEN, 0)
}

func (s *CaseFuncAlternativeContext) THEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserTHEN, 0)
}

func (s *CaseFuncAlternativeContext) AllFunctionArg() []IFunctionArgContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionArgContext); ok {
			len++
		}
	}

	tst := make([]IFunctionArgContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionArgContext); ok {
			tst[i] = t.(IFunctionArgContext)
			i++
		}
	}

	return tst
}

func (s *CaseFuncAlternativeContext) FunctionArg(i int) IFunctionArgContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgContext)
}

func (s *CaseFuncAlternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseFuncAlternativeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseFuncAlternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCaseFuncAlternative(s)
	}
}

func (s *CaseFuncAlternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCaseFuncAlternative(s)
	}
}

func (p *MySqlParser) CaseFuncAlternative() (localctx ICaseFuncAlternativeContext) {
	this := p
	_ = this

	localctx = NewCaseFuncAlternativeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 636, MySqlParserRULE_caseFuncAlternative)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6914)
		p.Match(MySqlParserWHEN)
	}
	{
		p.SetState(6915)

		var _x = p.FunctionArg()

		localctx.(*CaseFuncAlternativeContext).condition = _x
	}
	{
		p.SetState(6916)
		p.Match(MySqlParserTHEN)
	}
	{
		p.SetState(6917)

		var _x = p.FunctionArg()

		localctx.(*CaseFuncAlternativeContext).consequent = _x
	}

	return localctx
}

// ILevelsInWeightStringContext is an interface to support dynamic dispatch.
type ILevelsInWeightStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLevelsInWeightStringContext differentiates from other interfaces.
	IsLevelsInWeightStringContext()
}

type LevelsInWeightStringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLevelsInWeightStringContext() *LevelsInWeightStringContext {
	var p = new(LevelsInWeightStringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_levelsInWeightString
	return p
}

func (*LevelsInWeightStringContext) IsLevelsInWeightStringContext() {}

func NewLevelsInWeightStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LevelsInWeightStringContext {
	var p = new(LevelsInWeightStringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_levelsInWeightString

	return p
}

func (s *LevelsInWeightStringContext) GetParser() antlr.Parser { return s.parser }

func (s *LevelsInWeightStringContext) CopyFrom(ctx *LevelsInWeightStringContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *LevelsInWeightStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LevelsInWeightStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LevelWeightRangeContext struct {
	*LevelsInWeightStringContext
	firstLevel IDecimalLiteralContext
	lastLevel  IDecimalLiteralContext
}

func NewLevelWeightRangeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LevelWeightRangeContext {
	var p = new(LevelWeightRangeContext)

	p.LevelsInWeightStringContext = NewEmptyLevelsInWeightStringContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LevelsInWeightStringContext))

	return p
}

func (s *LevelWeightRangeContext) GetFirstLevel() IDecimalLiteralContext { return s.firstLevel }

func (s *LevelWeightRangeContext) GetLastLevel() IDecimalLiteralContext { return s.lastLevel }

func (s *LevelWeightRangeContext) SetFirstLevel(v IDecimalLiteralContext) { s.firstLevel = v }

func (s *LevelWeightRangeContext) SetLastLevel(v IDecimalLiteralContext) { s.lastLevel = v }

func (s *LevelWeightRangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LevelWeightRangeContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEVEL, 0)
}

func (s *LevelWeightRangeContext) MINUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUS, 0)
}

func (s *LevelWeightRangeContext) AllDecimalLiteral() []IDecimalLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			len++
		}
	}

	tst := make([]IDecimalLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDecimalLiteralContext); ok {
			tst[i] = t.(IDecimalLiteralContext)
			i++
		}
	}

	return tst
}

func (s *LevelWeightRangeContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LevelWeightRangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLevelWeightRange(s)
	}
}

func (s *LevelWeightRangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLevelWeightRange(s)
	}
}

type LevelWeightListContext struct {
	*LevelsInWeightStringContext
}

func NewLevelWeightListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LevelWeightListContext {
	var p = new(LevelWeightListContext)

	p.LevelsInWeightStringContext = NewEmptyLevelsInWeightStringContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LevelsInWeightStringContext))

	return p
}

func (s *LevelWeightListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LevelWeightListContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEVEL, 0)
}

func (s *LevelWeightListContext) AllLevelInWeightListElement() []ILevelInWeightListElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILevelInWeightListElementContext); ok {
			len++
		}
	}

	tst := make([]ILevelInWeightListElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILevelInWeightListElementContext); ok {
			tst[i] = t.(ILevelInWeightListElementContext)
			i++
		}
	}

	return tst
}

func (s *LevelWeightListContext) LevelInWeightListElement(i int) ILevelInWeightListElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILevelInWeightListElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILevelInWeightListElementContext)
}

func (s *LevelWeightListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *LevelWeightListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *LevelWeightListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLevelWeightList(s)
	}
}

func (s *LevelWeightListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLevelWeightList(s)
	}
}

func (p *MySqlParser) LevelsInWeightString() (localctx ILevelsInWeightStringContext) {
	this := p
	_ = this

	localctx = NewLevelsInWeightStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 638, MySqlParserRULE_levelsInWeightString)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6933)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1026, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLevelWeightListContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6919)
			p.Match(MySqlParserLEVEL)
		}
		{
			p.SetState(6920)
			p.LevelInWeightListElement()
		}
		p.SetState(6925)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(6921)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(6922)
				p.LevelInWeightListElement()
			}

			p.SetState(6927)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewLevelWeightRangeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6928)
			p.Match(MySqlParserLEVEL)
		}
		{
			p.SetState(6929)

			var _x = p.DecimalLiteral()

			localctx.(*LevelWeightRangeContext).firstLevel = _x
		}
		{
			p.SetState(6930)
			p.Match(MySqlParserMINUS)
		}
		{
			p.SetState(6931)

			var _x = p.DecimalLiteral()

			localctx.(*LevelWeightRangeContext).lastLevel = _x
		}

	}

	return localctx
}

// ILevelInWeightListElementContext is an interface to support dynamic dispatch.
type ILevelInWeightListElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOrderType returns the orderType token.
	GetOrderType() antlr.Token

	// SetOrderType sets the orderType token.
	SetOrderType(antlr.Token)

	// Getter signatures
	DecimalLiteral() IDecimalLiteralContext
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode
	REVERSE() antlr.TerminalNode

	// IsLevelInWeightListElementContext differentiates from other interfaces.
	IsLevelInWeightListElementContext()
}

type LevelInWeightListElementContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	orderType antlr.Token
}

func NewEmptyLevelInWeightListElementContext() *LevelInWeightListElementContext {
	var p = new(LevelInWeightListElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_levelInWeightListElement
	return p
}

func (*LevelInWeightListElementContext) IsLevelInWeightListElementContext() {}

func NewLevelInWeightListElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LevelInWeightListElementContext {
	var p = new(LevelInWeightListElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_levelInWeightListElement

	return p
}

func (s *LevelInWeightListElementContext) GetParser() antlr.Parser { return s.parser }

func (s *LevelInWeightListElementContext) GetOrderType() antlr.Token { return s.orderType }

func (s *LevelInWeightListElementContext) SetOrderType(v antlr.Token) { s.orderType = v }

func (s *LevelInWeightListElementContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LevelInWeightListElementContext) ASC() antlr.TerminalNode {
	return s.GetToken(MySqlParserASC, 0)
}

func (s *LevelInWeightListElementContext) DESC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDESC, 0)
}

func (s *LevelInWeightListElementContext) REVERSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREVERSE, 0)
}

func (s *LevelInWeightListElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LevelInWeightListElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LevelInWeightListElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLevelInWeightListElement(s)
	}
}

func (s *LevelInWeightListElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLevelInWeightListElement(s)
	}
}

func (p *MySqlParser) LevelInWeightListElement() (localctx ILevelInWeightListElementContext) {
	this := p
	_ = this

	localctx = NewLevelInWeightListElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 640, MySqlParserRULE_levelInWeightListElement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6935)
		p.DecimalLiteral()
	}
	p.SetState(6937)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserASC || _la == MySqlParserDESC || _la == MySqlParserREVERSE {
		{
			p.SetState(6936)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LevelInWeightListElementContext).orderType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserASC || _la == MySqlParserDESC || _la == MySqlParserREVERSE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LevelInWeightListElementContext).orderType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IAggregateWindowedFunctionContext is an interface to support dynamic dispatch.
type IAggregateWindowedFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAggregator returns the aggregator token.
	GetAggregator() antlr.Token

	// GetStarArg returns the starArg token.
	GetStarArg() antlr.Token

	// GetSeparator returns the separator token.
	GetSeparator() antlr.Token

	// SetAggregator sets the aggregator token.
	SetAggregator(antlr.Token)

	// SetStarArg sets the starArg token.
	SetStarArg(antlr.Token)

	// SetSeparator sets the separator token.
	SetSeparator(antlr.Token)

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	FunctionArg() IFunctionArgContext
	RR_BRACKET() antlr.TerminalNode
	AVG() antlr.TerminalNode
	MAX() antlr.TerminalNode
	MIN() antlr.TerminalNode
	SUM() antlr.TerminalNode
	OverClause() IOverClauseContext
	ALL() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode
	COUNT() antlr.TerminalNode
	FunctionArgs() IFunctionArgsContext
	STAR() antlr.TerminalNode
	BIT_AND() antlr.TerminalNode
	BIT_OR() antlr.TerminalNode
	BIT_XOR() antlr.TerminalNode
	STD() antlr.TerminalNode
	STDDEV() antlr.TerminalNode
	STDDEV_POP() antlr.TerminalNode
	STDDEV_SAMP() antlr.TerminalNode
	VAR_POP() antlr.TerminalNode
	VAR_SAMP() antlr.TerminalNode
	VARIANCE() antlr.TerminalNode
	GROUP_CONCAT() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllOrderByExpression() []IOrderByExpressionContext
	OrderByExpression(i int) IOrderByExpressionContext
	SEPARATOR() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAggregateWindowedFunctionContext differentiates from other interfaces.
	IsAggregateWindowedFunctionContext()
}

type AggregateWindowedFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser     antlr.Parser
	aggregator antlr.Token
	starArg    antlr.Token
	separator  antlr.Token
}

func NewEmptyAggregateWindowedFunctionContext() *AggregateWindowedFunctionContext {
	var p = new(AggregateWindowedFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_aggregateWindowedFunction
	return p
}

func (*AggregateWindowedFunctionContext) IsAggregateWindowedFunctionContext() {}

func NewAggregateWindowedFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggregateWindowedFunctionContext {
	var p = new(AggregateWindowedFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_aggregateWindowedFunction

	return p
}

func (s *AggregateWindowedFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *AggregateWindowedFunctionContext) GetAggregator() antlr.Token { return s.aggregator }

func (s *AggregateWindowedFunctionContext) GetStarArg() antlr.Token { return s.starArg }

func (s *AggregateWindowedFunctionContext) GetSeparator() antlr.Token { return s.separator }

func (s *AggregateWindowedFunctionContext) SetAggregator(v antlr.Token) { s.aggregator = v }

func (s *AggregateWindowedFunctionContext) SetStarArg(v antlr.Token) { s.starArg = v }

func (s *AggregateWindowedFunctionContext) SetSeparator(v antlr.Token) { s.separator = v }

func (s *AggregateWindowedFunctionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AggregateWindowedFunctionContext) FunctionArg() IFunctionArgContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgContext)
}

func (s *AggregateWindowedFunctionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AggregateWindowedFunctionContext) AVG() antlr.TerminalNode {
	return s.GetToken(MySqlParserAVG, 0)
}

func (s *AggregateWindowedFunctionContext) MAX() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX, 0)
}

func (s *AggregateWindowedFunctionContext) MIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserMIN, 0)
}

func (s *AggregateWindowedFunctionContext) SUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUM, 0)
}

func (s *AggregateWindowedFunctionContext) OverClause() IOverClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverClauseContext)
}

func (s *AggregateWindowedFunctionContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *AggregateWindowedFunctionContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISTINCT, 0)
}

func (s *AggregateWindowedFunctionContext) COUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOUNT, 0)
}

func (s *AggregateWindowedFunctionContext) FunctionArgs() IFunctionArgsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgsContext)
}

func (s *AggregateWindowedFunctionContext) STAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTAR, 0)
}

func (s *AggregateWindowedFunctionContext) BIT_AND() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_AND, 0)
}

func (s *AggregateWindowedFunctionContext) BIT_OR() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_OR, 0)
}

func (s *AggregateWindowedFunctionContext) BIT_XOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_XOR, 0)
}

func (s *AggregateWindowedFunctionContext) STD() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTD, 0)
}

func (s *AggregateWindowedFunctionContext) STDDEV() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTDDEV, 0)
}

func (s *AggregateWindowedFunctionContext) STDDEV_POP() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTDDEV_POP, 0)
}

func (s *AggregateWindowedFunctionContext) STDDEV_SAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTDDEV_SAMP, 0)
}

func (s *AggregateWindowedFunctionContext) VAR_POP() antlr.TerminalNode {
	return s.GetToken(MySqlParserVAR_POP, 0)
}

func (s *AggregateWindowedFunctionContext) VAR_SAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserVAR_SAMP, 0)
}

func (s *AggregateWindowedFunctionContext) VARIANCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARIANCE, 0)
}

func (s *AggregateWindowedFunctionContext) GROUP_CONCAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP_CONCAT, 0)
}

func (s *AggregateWindowedFunctionContext) ORDER() antlr.TerminalNode {
	return s.GetToken(MySqlParserORDER, 0)
}

func (s *AggregateWindowedFunctionContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *AggregateWindowedFunctionContext) AllOrderByExpression() []IOrderByExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOrderByExpressionContext); ok {
			len++
		}
	}

	tst := make([]IOrderByExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOrderByExpressionContext); ok {
			tst[i] = t.(IOrderByExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AggregateWindowedFunctionContext) OrderByExpression(i int) IOrderByExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByExpressionContext)
}

func (s *AggregateWindowedFunctionContext) SEPARATOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSEPARATOR, 0)
}

func (s *AggregateWindowedFunctionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *AggregateWindowedFunctionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AggregateWindowedFunctionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *AggregateWindowedFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregateWindowedFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggregateWindowedFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAggregateWindowedFunction(s)
	}
}

func (s *AggregateWindowedFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAggregateWindowedFunction(s)
	}
}

func (p *MySqlParser) AggregateWindowedFunction() (localctx IAggregateWindowedFunctionContext) {
	this := p
	_ = this

	localctx = NewAggregateWindowedFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 642, MySqlParserRULE_aggregateWindowedFunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6998)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserAVG, MySqlParserMAX, MySqlParserMIN, MySqlParserSUM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6939)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-286)) & ^0x3f) == 0 && ((int64(1)<<(_la-286))&8400897) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6940)
			p.Match(MySqlParserLR_BRACKET)
		}
		p.SetState(6942)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1028, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6941)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*AggregateWindowedFunctionContext).aggregator = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserALL || _la == MySqlParserDISTINCT) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*AggregateWindowedFunctionContext).aggregator = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(6944)
			p.FunctionArg()
		}
		{
			p.SetState(6945)
			p.Match(MySqlParserRR_BRACKET)
		}
		p.SetState(6947)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1029, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6946)
				p.OverClause()
			}

		}

	case MySqlParserCOUNT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6949)
			p.Match(MySqlParserCOUNT)
		}
		{
			p.SetState(6950)
			p.Match(MySqlParserLR_BRACKET)
		}
		p.SetState(6958)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1031, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(6951)

				var _m = p.Match(MySqlParserSTAR)

				localctx.(*AggregateWindowedFunctionContext).starArg = _m
			}

		case 2:
			p.SetState(6953)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1030, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(6952)

					var _m = p.Match(MySqlParserALL)

					localctx.(*AggregateWindowedFunctionContext).aggregator = _m
				}

			}
			{
				p.SetState(6955)
				p.FunctionArg()
			}

		case 3:
			{
				p.SetState(6956)

				var _m = p.Match(MySqlParserDISTINCT)

				localctx.(*AggregateWindowedFunctionContext).aggregator = _m
			}
			{
				p.SetState(6957)
				p.FunctionArgs()
			}

		}
		{
			p.SetState(6960)
			p.Match(MySqlParserRR_BRACKET)
		}
		p.SetState(6962)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1032, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6961)
				p.OverClause()
			}

		}

	case MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6964)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-287)) & ^0x3f) == 0 && ((int64(1)<<(_la-287))&62652423) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6965)
			p.Match(MySqlParserLR_BRACKET)
		}
		p.SetState(6967)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1033, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6966)

				var _m = p.Match(MySqlParserALL)

				localctx.(*AggregateWindowedFunctionContext).aggregator = _m
			}

		}
		{
			p.SetState(6969)
			p.FunctionArg()
		}
		{
			p.SetState(6970)
			p.Match(MySqlParserRR_BRACKET)
		}
		p.SetState(6972)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1034, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6971)
				p.OverClause()
			}

		}

	case MySqlParserGROUP_CONCAT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6974)
			p.Match(MySqlParserGROUP_CONCAT)
		}
		{
			p.SetState(6975)
			p.Match(MySqlParserLR_BRACKET)
		}
		p.SetState(6977)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1035, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6976)

				var _m = p.Match(MySqlParserDISTINCT)

				localctx.(*AggregateWindowedFunctionContext).aggregator = _m
			}

		}
		{
			p.SetState(6979)
			p.FunctionArgs()
		}
		p.SetState(6990)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserORDER {
			{
				p.SetState(6980)
				p.Match(MySqlParserORDER)
			}
			{
				p.SetState(6981)
				p.Match(MySqlParserBY)
			}
			{
				p.SetState(6982)
				p.OrderByExpression()
			}
			p.SetState(6987)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == MySqlParserCOMMA {
				{
					p.SetState(6983)
					p.Match(MySqlParserCOMMA)
				}
				{
					p.SetState(6984)
					p.OrderByExpression()
				}

				p.SetState(6989)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(6994)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserSEPARATOR {
			{
				p.SetState(6992)
				p.Match(MySqlParserSEPARATOR)
			}
			{
				p.SetState(6993)

				var _m = p.Match(MySqlParserSTRING_LITERAL)

				localctx.(*AggregateWindowedFunctionContext).separator = _m
			}

		}
		{
			p.SetState(6996)
			p.Match(MySqlParserRR_BRACKET)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INonAggregateWindowedFunctionContext is an interface to support dynamic dispatch.
type INonAggregateWindowedFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	RR_BRACKET() antlr.TerminalNode
	OverClause() IOverClauseContext
	LAG() antlr.TerminalNode
	LEAD() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	DecimalLiteral() IDecimalLiteralContext
	FIRST_VALUE() antlr.TerminalNode
	LAST_VALUE() antlr.TerminalNode
	CUME_DIST() antlr.TerminalNode
	DENSE_RANK() antlr.TerminalNode
	PERCENT_RANK() antlr.TerminalNode
	RANK() antlr.TerminalNode
	ROW_NUMBER() antlr.TerminalNode
	NTH_VALUE() antlr.TerminalNode
	NTILE() antlr.TerminalNode

	// IsNonAggregateWindowedFunctionContext differentiates from other interfaces.
	IsNonAggregateWindowedFunctionContext()
}

type NonAggregateWindowedFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonAggregateWindowedFunctionContext() *NonAggregateWindowedFunctionContext {
	var p = new(NonAggregateWindowedFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_nonAggregateWindowedFunction
	return p
}

func (*NonAggregateWindowedFunctionContext) IsNonAggregateWindowedFunctionContext() {}

func NewNonAggregateWindowedFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonAggregateWindowedFunctionContext {
	var p = new(NonAggregateWindowedFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_nonAggregateWindowedFunction

	return p
}

func (s *NonAggregateWindowedFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *NonAggregateWindowedFunctionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *NonAggregateWindowedFunctionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *NonAggregateWindowedFunctionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NonAggregateWindowedFunctionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *NonAggregateWindowedFunctionContext) OverClause() IOverClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverClauseContext)
}

func (s *NonAggregateWindowedFunctionContext) LAG() antlr.TerminalNode {
	return s.GetToken(MySqlParserLAG, 0)
}

func (s *NonAggregateWindowedFunctionContext) LEAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEAD, 0)
}

func (s *NonAggregateWindowedFunctionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *NonAggregateWindowedFunctionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *NonAggregateWindowedFunctionContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *NonAggregateWindowedFunctionContext) FIRST_VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIRST_VALUE, 0)
}

func (s *NonAggregateWindowedFunctionContext) LAST_VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLAST_VALUE, 0)
}

func (s *NonAggregateWindowedFunctionContext) CUME_DIST() antlr.TerminalNode {
	return s.GetToken(MySqlParserCUME_DIST, 0)
}

func (s *NonAggregateWindowedFunctionContext) DENSE_RANK() antlr.TerminalNode {
	return s.GetToken(MySqlParserDENSE_RANK, 0)
}

func (s *NonAggregateWindowedFunctionContext) PERCENT_RANK() antlr.TerminalNode {
	return s.GetToken(MySqlParserPERCENT_RANK, 0)
}

func (s *NonAggregateWindowedFunctionContext) RANK() antlr.TerminalNode {
	return s.GetToken(MySqlParserRANK, 0)
}

func (s *NonAggregateWindowedFunctionContext) ROW_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySqlParserROW_NUMBER, 0)
}

func (s *NonAggregateWindowedFunctionContext) NTH_VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserNTH_VALUE, 0)
}

func (s *NonAggregateWindowedFunctionContext) NTILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserNTILE, 0)
}

func (s *NonAggregateWindowedFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonAggregateWindowedFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonAggregateWindowedFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterNonAggregateWindowedFunction(s)
	}
}

func (s *NonAggregateWindowedFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitNonAggregateWindowedFunction(s)
	}
}

func (p *MySqlParser) NonAggregateWindowedFunction() (localctx INonAggregateWindowedFunctionContext) {
	this := p
	_ = this

	localctx = NewNonAggregateWindowedFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 644, MySqlParserRULE_nonAggregateWindowedFunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(7038)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserLAG, MySqlParserLEAD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7000)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserLAG || _la == MySqlParserLEAD) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(7001)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(7002)
			p.expression(0)
		}
		p.SetState(7005)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1040, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7003)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(7004)
				p.DecimalLiteral()
			}

		}
		p.SetState(7009)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCOMMA {
			{
				p.SetState(7007)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(7008)
				p.expression(0)
			}

		}
		{
			p.SetState(7011)
			p.Match(MySqlParserRR_BRACKET)
		}
		{
			p.SetState(7012)
			p.OverClause()
		}

	case MySqlParserFIRST_VALUE, MySqlParserLAST_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7014)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFIRST_VALUE || _la == MySqlParserLAST_VALUE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(7015)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(7016)
			p.expression(0)
		}
		{
			p.SetState(7017)
			p.Match(MySqlParserRR_BRACKET)
		}
		{
			p.SetState(7018)
			p.OverClause()
		}

	case MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7020)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-291)) & ^0x3f) == 0 && ((int64(1)<<(_la-291))&14339) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(7021)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(7022)
			p.Match(MySqlParserRR_BRACKET)
		}
		{
			p.SetState(7023)
			p.OverClause()
		}

	case MySqlParserNTH_VALUE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7024)
			p.Match(MySqlParserNTH_VALUE)
		}
		{
			p.SetState(7025)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(7026)
			p.expression(0)
		}
		{
			p.SetState(7027)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(7028)
			p.DecimalLiteral()
		}
		{
			p.SetState(7029)
			p.Match(MySqlParserRR_BRACKET)
		}
		{
			p.SetState(7030)
			p.OverClause()
		}

	case MySqlParserNTILE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7032)
			p.Match(MySqlParserNTILE)
		}
		{
			p.SetState(7033)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(7034)
			p.DecimalLiteral()
		}
		{
			p.SetState(7035)
			p.Match(MySqlParserRR_BRACKET)
		}
		{
			p.SetState(7036)
			p.OverClause()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOverClauseContext is an interface to support dynamic dispatch.
type IOverClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OVER() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	WindowSpec() IWindowSpecContext
	RR_BRACKET() antlr.TerminalNode
	WindowName() IWindowNameContext

	// IsOverClauseContext differentiates from other interfaces.
	IsOverClauseContext()
}

type OverClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOverClauseContext() *OverClauseContext {
	var p = new(OverClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_overClause
	return p
}

func (*OverClauseContext) IsOverClauseContext() {}

func NewOverClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OverClauseContext {
	var p = new(OverClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_overClause

	return p
}

func (s *OverClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OverClauseContext) OVER() antlr.TerminalNode {
	return s.GetToken(MySqlParserOVER, 0)
}

func (s *OverClauseContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *OverClauseContext) WindowSpec() IWindowSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowSpecContext)
}

func (s *OverClauseContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *OverClauseContext) WindowName() IWindowNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowNameContext)
}

func (s *OverClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OverClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OverClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterOverClause(s)
	}
}

func (s *OverClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitOverClause(s)
	}
}

func (p *MySqlParser) OverClause() (localctx IOverClauseContext) {
	this := p
	_ = this

	localctx = NewOverClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 646, MySqlParserRULE_overClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7040)
		p.Match(MySqlParserOVER)
	}
	p.SetState(7046)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserLR_BRACKET:
		{
			p.SetState(7041)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(7042)
			p.WindowSpec()
		}
		{
			p.SetState(7043)
			p.Match(MySqlParserRR_BRACKET)
		}

	case MySqlParserATTRIBUTE, MySqlParserBUCKETS, MySqlParserCONDITION, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDEFAULT, MySqlParserDIAGNOSTICS, MySqlParserEMPTY, MySqlParserENFORCED, MySqlParserEXCEPT, MySqlParserGROUP, MySqlParserIF, MySqlParserIGNORED, MySqlParserINSERT, MySqlParserLATERAL, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserOPTIONAL, MySqlParserORDER, MySqlParserPRIMARY, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserSKIP_QUERY_REWRITE, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserNESTED, MySqlParserORDINALITY, MySqlParserPATH, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserGROUP_CONCAT, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserMAX, MySqlParserMIN, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCLUSTERING, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAILED_LOGIN_ATTEMPTS, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHISTORY, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINSTANT, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNOCOPY, MySqlParserNOWAIT, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserODBC, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPASSWORD_LOCK_TIME, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserRECURSIVE, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNS, MySqlParserREUSE, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserRTREE, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTABLE_TYPE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNBOUNDED, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVIRTUAL, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserEUR, MySqlParserUSA, MySqlParserJIS, MySqlParserISO, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserADMIN, MySqlParserAUDIT_ABORT_EXEMPT, MySqlParserAUDIT_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_EXEMPT, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserINVOKE, MySqlParserLAMBDA, MySqlParserNDB_STORED_USER, MySqlParserPASSWORDLESS_USER_ADMIN, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserPRIVILEGES, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserROUTINE, MySqlParserS3, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLES, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB18030, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENGINE_ATTRIBUTE, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSECONDARY_ENGINE_ATTRIBUTE, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserTP_CONNECTION_ADMIN, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID, MySqlParserREVERSE_QUOTE_ID:
		{
			p.SetState(7045)
			p.WindowName()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IWindowSpecContext is an interface to support dynamic dispatch.
type IWindowSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WindowName() IWindowNameContext
	PartitionClause() IPartitionClauseContext
	OrderByClause() IOrderByClauseContext
	FrameClause() IFrameClauseContext

	// IsWindowSpecContext differentiates from other interfaces.
	IsWindowSpecContext()
}

type WindowSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowSpecContext() *WindowSpecContext {
	var p = new(WindowSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_windowSpec
	return p
}

func (*WindowSpecContext) IsWindowSpecContext() {}

func NewWindowSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowSpecContext {
	var p = new(WindowSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_windowSpec

	return p
}

func (s *WindowSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowSpecContext) WindowName() IWindowNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowNameContext)
}

func (s *WindowSpecContext) PartitionClause() IPartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionClauseContext)
}

func (s *WindowSpecContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *WindowSpecContext) FrameClause() IFrameClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameClauseContext)
}

func (s *WindowSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterWindowSpec(s)
	}
}

func (s *WindowSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitWindowSpec(s)
	}
}

func (p *MySqlParser) WindowSpec() (localctx IWindowSpecContext) {
	this := p
	_ = this

	localctx = NewWindowSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 648, MySqlParserRULE_windowSpec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7049)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1044, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(7048)
			p.WindowName()
		}

	}
	p.SetState(7052)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserPARTITION {
		{
			p.SetState(7051)
			p.PartitionClause()
		}

	}
	p.SetState(7055)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserORDER {
		{
			p.SetState(7054)
			p.OrderByClause()
		}

	}
	p.SetState(7058)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserRANGE || _la == MySqlParserROWS {
		{
			p.SetState(7057)
			p.FrameClause()
		}

	}

	return localctx
}

// IWindowNameContext is an interface to support dynamic dispatch.
type IWindowNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uid() IUidContext

	// IsWindowNameContext differentiates from other interfaces.
	IsWindowNameContext()
}

type WindowNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowNameContext() *WindowNameContext {
	var p = new(WindowNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_windowName
	return p
}

func (*WindowNameContext) IsWindowNameContext() {}

func NewWindowNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowNameContext {
	var p = new(WindowNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_windowName

	return p
}

func (s *WindowNameContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowNameContext) Uid() IUidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *WindowNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterWindowName(s)
	}
}

func (s *WindowNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitWindowName(s)
	}
}

func (p *MySqlParser) WindowName() (localctx IWindowNameContext) {
	this := p
	_ = this

	localctx = NewWindowNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 650, MySqlParserRULE_windowName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7060)
		p.Uid()
	}

	return localctx
}

// IFrameClauseContext is an interface to support dynamic dispatch.
type IFrameClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FrameUnits() IFrameUnitsContext
	FrameExtent() IFrameExtentContext

	// IsFrameClauseContext differentiates from other interfaces.
	IsFrameClauseContext()
}

type FrameClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrameClauseContext() *FrameClauseContext {
	var p = new(FrameClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_frameClause
	return p
}

func (*FrameClauseContext) IsFrameClauseContext() {}

func NewFrameClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameClauseContext {
	var p = new(FrameClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_frameClause

	return p
}

func (s *FrameClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameClauseContext) FrameUnits() IFrameUnitsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameUnitsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameUnitsContext)
}

func (s *FrameClauseContext) FrameExtent() IFrameExtentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameExtentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameExtentContext)
}

func (s *FrameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FrameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFrameClause(s)
	}
}

func (s *FrameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFrameClause(s)
	}
}

func (p *MySqlParser) FrameClause() (localctx IFrameClauseContext) {
	this := p
	_ = this

	localctx = NewFrameClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 652, MySqlParserRULE_frameClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7062)
		p.FrameUnits()
	}
	{
		p.SetState(7063)
		p.FrameExtent()
	}

	return localctx
}

// IFrameUnitsContext is an interface to support dynamic dispatch.
type IFrameUnitsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROWS() antlr.TerminalNode
	RANGE() antlr.TerminalNode

	// IsFrameUnitsContext differentiates from other interfaces.
	IsFrameUnitsContext()
}

type FrameUnitsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrameUnitsContext() *FrameUnitsContext {
	var p = new(FrameUnitsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_frameUnits
	return p
}

func (*FrameUnitsContext) IsFrameUnitsContext() {}

func NewFrameUnitsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameUnitsContext {
	var p = new(FrameUnitsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_frameUnits

	return p
}

func (s *FrameUnitsContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameUnitsContext) ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserROWS, 0)
}

func (s *FrameUnitsContext) RANGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRANGE, 0)
}

func (s *FrameUnitsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameUnitsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FrameUnitsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFrameUnits(s)
	}
}

func (s *FrameUnitsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFrameUnits(s)
	}
}

func (p *MySqlParser) FrameUnits() (localctx IFrameUnitsContext) {
	this := p
	_ = this

	localctx = NewFrameUnitsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 654, MySqlParserRULE_frameUnits)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7065)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserRANGE || _la == MySqlParserROWS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IFrameExtentContext is an interface to support dynamic dispatch.
type IFrameExtentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FrameRange() IFrameRangeContext
	FrameBetween() IFrameBetweenContext

	// IsFrameExtentContext differentiates from other interfaces.
	IsFrameExtentContext()
}

type FrameExtentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrameExtentContext() *FrameExtentContext {
	var p = new(FrameExtentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_frameExtent
	return p
}

func (*FrameExtentContext) IsFrameExtentContext() {}

func NewFrameExtentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameExtentContext {
	var p = new(FrameExtentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_frameExtent

	return p
}

func (s *FrameExtentContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameExtentContext) FrameRange() IFrameRangeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameRangeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameRangeContext)
}

func (s *FrameExtentContext) FrameBetween() IFrameBetweenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameBetweenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameBetweenContext)
}

func (s *FrameExtentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameExtentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FrameExtentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFrameExtent(s)
	}
}

func (s *FrameExtentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFrameExtent(s)
	}
}

func (p *MySqlParser) FrameExtent() (localctx IFrameExtentContext) {
	this := p
	_ = this

	localctx = NewFrameExtentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 656, MySqlParserRULE_frameExtent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(7069)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1048, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7067)
			p.FrameRange()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7068)
			p.FrameBetween()
		}

	}

	return localctx
}

// IFrameBetweenContext is an interface to support dynamic dispatch.
type IFrameBetweenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BETWEEN() antlr.TerminalNode
	AllFrameRange() []IFrameRangeContext
	FrameRange(i int) IFrameRangeContext
	AND() antlr.TerminalNode

	// IsFrameBetweenContext differentiates from other interfaces.
	IsFrameBetweenContext()
}

type FrameBetweenContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrameBetweenContext() *FrameBetweenContext {
	var p = new(FrameBetweenContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_frameBetween
	return p
}

func (*FrameBetweenContext) IsFrameBetweenContext() {}

func NewFrameBetweenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameBetweenContext {
	var p = new(FrameBetweenContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_frameBetween

	return p
}

func (s *FrameBetweenContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameBetweenContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBETWEEN, 0)
}

func (s *FrameBetweenContext) AllFrameRange() []IFrameRangeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFrameRangeContext); ok {
			len++
		}
	}

	tst := make([]IFrameRangeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFrameRangeContext); ok {
			tst[i] = t.(IFrameRangeContext)
			i++
		}
	}

	return tst
}

func (s *FrameBetweenContext) FrameRange(i int) IFrameRangeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameRangeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameRangeContext)
}

func (s *FrameBetweenContext) AND() antlr.TerminalNode {
	return s.GetToken(MySqlParserAND, 0)
}

func (s *FrameBetweenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameBetweenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FrameBetweenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFrameBetween(s)
	}
}

func (s *FrameBetweenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFrameBetween(s)
	}
}

func (p *MySqlParser) FrameBetween() (localctx IFrameBetweenContext) {
	this := p
	_ = this

	localctx = NewFrameBetweenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 658, MySqlParserRULE_frameBetween)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7071)
		p.Match(MySqlParserBETWEEN)
	}
	{
		p.SetState(7072)
		p.FrameRange()
	}
	{
		p.SetState(7073)
		p.Match(MySqlParserAND)
	}
	{
		p.SetState(7074)
		p.FrameRange()
	}

	return localctx
}

// IFrameRangeContext is an interface to support dynamic dispatch.
type IFrameRangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CURRENT() antlr.TerminalNode
	ROW() antlr.TerminalNode
	UNBOUNDED() antlr.TerminalNode
	PRECEDING() antlr.TerminalNode
	FOLLOWING() antlr.TerminalNode
	Expression() IExpressionContext

	// IsFrameRangeContext differentiates from other interfaces.
	IsFrameRangeContext()
}

type FrameRangeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrameRangeContext() *FrameRangeContext {
	var p = new(FrameRangeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_frameRange
	return p
}

func (*FrameRangeContext) IsFrameRangeContext() {}

func NewFrameRangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameRangeContext {
	var p = new(FrameRangeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_frameRange

	return p
}

func (s *FrameRangeContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameRangeContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT, 0)
}

func (s *FrameRangeContext) ROW() antlr.TerminalNode {
	return s.GetToken(MySqlParserROW, 0)
}

func (s *FrameRangeContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNBOUNDED, 0)
}

func (s *FrameRangeContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRECEDING, 0)
}

func (s *FrameRangeContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOLLOWING, 0)
}

func (s *FrameRangeContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FrameRangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameRangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FrameRangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFrameRange(s)
	}
}

func (s *FrameRangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFrameRange(s)
	}
}

func (p *MySqlParser) FrameRange() (localctx IFrameRangeContext) {
	this := p
	_ = this

	localctx = NewFrameRangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 660, MySqlParserRULE_frameRange)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(7083)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1049, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7076)
			p.Match(MySqlParserCURRENT)
		}
		{
			p.SetState(7077)
			p.Match(MySqlParserROW)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7078)
			p.Match(MySqlParserUNBOUNDED)
		}
		{
			p.SetState(7079)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFOLLOWING || _la == MySqlParserPRECEDING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7080)
			p.expression(0)
		}
		{
			p.SetState(7081)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFOLLOWING || _la == MySqlParserPRECEDING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IPartitionClauseContext is an interface to support dynamic dispatch.
type IPartitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPartitionClauseContext differentiates from other interfaces.
	IsPartitionClauseContext()
}

type PartitionClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionClauseContext() *PartitionClauseContext {
	var p = new(PartitionClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_partitionClause
	return p
}

func (*PartitionClauseContext) IsPartitionClauseContext() {}

func NewPartitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionClauseContext {
	var p = new(PartitionClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_partitionClause

	return p
}

func (s *PartitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *PartitionClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *PartitionClauseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionClauseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PartitionClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *PartitionClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *PartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPartitionClause(s)
	}
}

func (s *PartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPartitionClause(s)
	}
}

func (p *MySqlParser) PartitionClause() (localctx IPartitionClauseContext) {
	this := p
	_ = this

	localctx = NewPartitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 662, MySqlParserRULE_partitionClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7085)
		p.Match(MySqlParserPARTITION)
	}
	{
		p.SetState(7086)
		p.Match(MySqlParserBY)
	}
	{
		p.SetState(7087)
		p.expression(0)
	}
	p.SetState(7092)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(7088)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(7089)
			p.expression(0)
		}

		p.SetState(7094)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IScalarFunctionNameContext is an interface to support dynamic dispatch.
type IScalarFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionNameBase() IFunctionNameBaseContext
	ASCII() antlr.TerminalNode
	CURDATE() antlr.TerminalNode
	CURRENT_DATE() antlr.TerminalNode
	CURRENT_TIME() antlr.TerminalNode
	CURRENT_TIMESTAMP() antlr.TerminalNode
	CURTIME() antlr.TerminalNode
	DATE_ADD() antlr.TerminalNode
	DATE_SUB() antlr.TerminalNode
	IF() antlr.TerminalNode
	INSERT() antlr.TerminalNode
	LOCALTIME() antlr.TerminalNode
	LOCALTIMESTAMP() antlr.TerminalNode
	MID() antlr.TerminalNode
	NOW() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	SUBSTR() antlr.TerminalNode
	SUBSTRING() antlr.TerminalNode
	SYSDATE() antlr.TerminalNode
	TRIM() antlr.TerminalNode
	UTC_DATE() antlr.TerminalNode
	UTC_TIME() antlr.TerminalNode
	UTC_TIMESTAMP() antlr.TerminalNode

	// IsScalarFunctionNameContext differentiates from other interfaces.
	IsScalarFunctionNameContext()
}

type ScalarFunctionNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScalarFunctionNameContext() *ScalarFunctionNameContext {
	var p = new(ScalarFunctionNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_scalarFunctionName
	return p
}

func (*ScalarFunctionNameContext) IsScalarFunctionNameContext() {}

func NewScalarFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScalarFunctionNameContext {
	var p = new(ScalarFunctionNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_scalarFunctionName

	return p
}

func (s *ScalarFunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ScalarFunctionNameContext) FunctionNameBase() IFunctionNameBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionNameBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionNameBaseContext)
}

func (s *ScalarFunctionNameContext) ASCII() antlr.TerminalNode {
	return s.GetToken(MySqlParserASCII, 0)
}

func (s *ScalarFunctionNameContext) CURDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURDATE, 0)
}

func (s *ScalarFunctionNameContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT_DATE, 0)
}

func (s *ScalarFunctionNameContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT_TIME, 0)
}

func (s *ScalarFunctionNameContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT_TIMESTAMP, 0)
}

func (s *ScalarFunctionNameContext) CURTIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURTIME, 0)
}

func (s *ScalarFunctionNameContext) DATE_ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATE_ADD, 0)
}

func (s *ScalarFunctionNameContext) DATE_SUB() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATE_SUB, 0)
}

func (s *ScalarFunctionNameContext) IF() antlr.TerminalNode {
	return s.GetToken(MySqlParserIF, 0)
}

func (s *ScalarFunctionNameContext) INSERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSERT, 0)
}

func (s *ScalarFunctionNameContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCALTIME, 0)
}

func (s *ScalarFunctionNameContext) LOCALTIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCALTIMESTAMP, 0)
}

func (s *ScalarFunctionNameContext) MID() antlr.TerminalNode {
	return s.GetToken(MySqlParserMID, 0)
}

func (s *ScalarFunctionNameContext) NOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOW, 0)
}

func (s *ScalarFunctionNameContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLACE, 0)
}

func (s *ScalarFunctionNameContext) SUBSTR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBSTR, 0)
}

func (s *ScalarFunctionNameContext) SUBSTRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBSTRING, 0)
}

func (s *ScalarFunctionNameContext) SYSDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSYSDATE, 0)
}

func (s *ScalarFunctionNameContext) TRIM() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRIM, 0)
}

func (s *ScalarFunctionNameContext) UTC_DATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTC_DATE, 0)
}

func (s *ScalarFunctionNameContext) UTC_TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTC_TIME, 0)
}

func (s *ScalarFunctionNameContext) UTC_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTC_TIMESTAMP, 0)
}

func (s *ScalarFunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalarFunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScalarFunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterScalarFunctionName(s)
	}
}

func (s *ScalarFunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitScalarFunctionName(s)
	}
}

func (p *MySqlParser) ScalarFunctionName() (localctx IScalarFunctionNameContext) {
	this := p
	_ = this

	localctx = NewScalarFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 664, MySqlParserRULE_scalarFunctionName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(7118)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserDATABASE, MySqlParserLEFT, MySqlParserRIGHT, MySqlParserSCHEMA, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserYEAR, MySqlParserJSON_ARRAY, MySqlParserJSON_ARRAYAGG, MySqlParserJSON_ARRAY_APPEND, MySqlParserJSON_ARRAY_INSERT, MySqlParserJSON_CONTAINS, MySqlParserJSON_CONTAINS_PATH, MySqlParserJSON_DEPTH, MySqlParserJSON_EXTRACT, MySqlParserJSON_INSERT, MySqlParserJSON_KEYS, MySqlParserJSON_LENGTH, MySqlParserJSON_MERGE, MySqlParserJSON_MERGE_PATCH, MySqlParserJSON_MERGE_PRESERVE, MySqlParserJSON_OBJECT, MySqlParserJSON_OBJECTAGG, MySqlParserJSON_OVERLAPS, MySqlParserJSON_PRETTY, MySqlParserJSON_QUOTE, MySqlParserJSON_REMOVE, MySqlParserJSON_REPLACE, MySqlParserJSON_SCHEMA_VALID, MySqlParserJSON_SCHEMA_VALIDATION_REPORT, MySqlParserJSON_SEARCH, MySqlParserJSON_SET, MySqlParserJSON_STORAGE_FREE, MySqlParserJSON_STORAGE_SIZE, MySqlParserJSON_TABLE, MySqlParserJSON_TYPE, MySqlParserJSON_UNQUOTE, MySqlParserJSON_VALID, MySqlParserJSON_VALUE, MySqlParserCOUNT, MySqlParserCUME_DIST, MySqlParserDENSE_RANK, MySqlParserFIRST_VALUE, MySqlParserLAG, MySqlParserLAST_VALUE, MySqlParserLEAD, MySqlParserNTILE, MySqlParserNTH_VALUE, MySqlParserPERCENT_RANK, MySqlParserRANK, MySqlParserROW_NUMBER, MySqlParserPOSITION, MySqlParserINVISIBLE, MySqlParserVISIBLE, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserMOD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7095)
			p.FunctionNameBase()
		}

	case MySqlParserASCII:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7096)
			p.Match(MySqlParserASCII)
		}

	case MySqlParserCURDATE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7097)
			p.Match(MySqlParserCURDATE)
		}

	case MySqlParserCURRENT_DATE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7098)
			p.Match(MySqlParserCURRENT_DATE)
		}

	case MySqlParserCURRENT_TIME:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7099)
			p.Match(MySqlParserCURRENT_TIME)
		}

	case MySqlParserCURRENT_TIMESTAMP:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7100)
			p.Match(MySqlParserCURRENT_TIMESTAMP)
		}

	case MySqlParserCURTIME:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(7101)
			p.Match(MySqlParserCURTIME)
		}

	case MySqlParserDATE_ADD:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(7102)
			p.Match(MySqlParserDATE_ADD)
		}

	case MySqlParserDATE_SUB:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(7103)
			p.Match(MySqlParserDATE_SUB)
		}

	case MySqlParserIF:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(7104)
			p.Match(MySqlParserIF)
		}

	case MySqlParserINSERT:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(7105)
			p.Match(MySqlParserINSERT)
		}

	case MySqlParserLOCALTIME:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(7106)
			p.Match(MySqlParserLOCALTIME)
		}

	case MySqlParserLOCALTIMESTAMP:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(7107)
			p.Match(MySqlParserLOCALTIMESTAMP)
		}

	case MySqlParserMID:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(7108)
			p.Match(MySqlParserMID)
		}

	case MySqlParserNOW:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(7109)
			p.Match(MySqlParserNOW)
		}

	case MySqlParserREPLACE:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(7110)
			p.Match(MySqlParserREPLACE)
		}

	case MySqlParserSUBSTR:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(7111)
			p.Match(MySqlParserSUBSTR)
		}

	case MySqlParserSUBSTRING:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(7112)
			p.Match(MySqlParserSUBSTRING)
		}

	case MySqlParserSYSDATE:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(7113)
			p.Match(MySqlParserSYSDATE)
		}

	case MySqlParserTRIM:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(7114)
			p.Match(MySqlParserTRIM)
		}

	case MySqlParserUTC_DATE:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(7115)
			p.Match(MySqlParserUTC_DATE)
		}

	case MySqlParserUTC_TIME:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(7116)
			p.Match(MySqlParserUTC_TIME)
		}

	case MySqlParserUTC_TIMESTAMP:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(7117)
			p.Match(MySqlParserUTC_TIMESTAMP)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPasswordFunctionClauseContext is an interface to support dynamic dispatch.
type IPasswordFunctionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFunctionName returns the functionName token.
	GetFunctionName() antlr.Token

	// SetFunctionName sets the functionName token.
	SetFunctionName(antlr.Token)

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	FunctionArg() IFunctionArgContext
	RR_BRACKET() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	OLD_PASSWORD() antlr.TerminalNode

	// IsPasswordFunctionClauseContext differentiates from other interfaces.
	IsPasswordFunctionClauseContext()
}

type PasswordFunctionClauseContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	functionName antlr.Token
}

func NewEmptyPasswordFunctionClauseContext() *PasswordFunctionClauseContext {
	var p = new(PasswordFunctionClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_passwordFunctionClause
	return p
}

func (*PasswordFunctionClauseContext) IsPasswordFunctionClauseContext() {}

func NewPasswordFunctionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PasswordFunctionClauseContext {
	var p = new(PasswordFunctionClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_passwordFunctionClause

	return p
}

func (s *PasswordFunctionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PasswordFunctionClauseContext) GetFunctionName() antlr.Token { return s.functionName }

func (s *PasswordFunctionClauseContext) SetFunctionName(v antlr.Token) { s.functionName = v }

func (s *PasswordFunctionClauseContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *PasswordFunctionClauseContext) FunctionArg() IFunctionArgContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgContext)
}

func (s *PasswordFunctionClauseContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *PasswordFunctionClauseContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD, 0)
}

func (s *PasswordFunctionClauseContext) OLD_PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserOLD_PASSWORD, 0)
}

func (s *PasswordFunctionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PasswordFunctionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PasswordFunctionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPasswordFunctionClause(s)
	}
}

func (s *PasswordFunctionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPasswordFunctionClause(s)
	}
}

func (p *MySqlParser) PasswordFunctionClause() (localctx IPasswordFunctionClauseContext) {
	this := p
	_ = this

	localctx = NewPasswordFunctionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 666, MySqlParserRULE_passwordFunctionClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7120)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*PasswordFunctionClauseContext).functionName = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserOLD_PASSWORD || _la == MySqlParserPASSWORD) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*PasswordFunctionClauseContext).functionName = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(7121)
		p.Match(MySqlParserLR_BRACKET)
	}
	{
		p.SetState(7122)
		p.FunctionArg()
	}
	{
		p.SetState(7123)
		p.Match(MySqlParserRR_BRACKET)
	}

	return localctx
}

// IFunctionArgsContext is an interface to support dynamic dispatch.
type IFunctionArgsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllConstant() []IConstantContext
	Constant(i int) IConstantContext
	AllFullColumnName() []IFullColumnNameContext
	FullColumnName(i int) IFullColumnNameContext
	AllFunctionCall() []IFunctionCallContext
	FunctionCall(i int) IFunctionCallContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFunctionArgsContext differentiates from other interfaces.
	IsFunctionArgsContext()
}

type FunctionArgsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionArgsContext() *FunctionArgsContext {
	var p = new(FunctionArgsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_functionArgs
	return p
}

func (*FunctionArgsContext) IsFunctionArgsContext() {}

func NewFunctionArgsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionArgsContext {
	var p = new(FunctionArgsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_functionArgs

	return p
}

func (s *FunctionArgsContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionArgsContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *FunctionArgsContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *FunctionArgsContext) AllFullColumnName() []IFullColumnNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			len++
		}
	}

	tst := make([]IFullColumnNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFullColumnNameContext); ok {
			tst[i] = t.(IFullColumnNameContext)
			i++
		}
	}

	return tst
}

func (s *FunctionArgsContext) FullColumnName(i int) IFullColumnNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *FunctionArgsContext) AllFunctionCall() []IFunctionCallContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionCallContext); ok {
			len++
		}
	}

	tst := make([]IFunctionCallContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionCallContext); ok {
			tst[i] = t.(IFunctionCallContext)
			i++
		}
	}

	return tst
}

func (s *FunctionArgsContext) FunctionCall(i int) IFunctionCallContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *FunctionArgsContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *FunctionArgsContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionArgsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *FunctionArgsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *FunctionArgsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionArgsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionArgsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFunctionArgs(s)
	}
}

func (s *FunctionArgsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFunctionArgs(s)
	}
}

func (p *MySqlParser) FunctionArgs() (localctx IFunctionArgsContext) {
	this := p
	_ = this

	localctx = NewFunctionArgsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 668, MySqlParserRULE_functionArgs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7129)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1052, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(7125)
			p.Constant()
		}

	case 2:
		{
			p.SetState(7126)
			p.FullColumnName()
		}

	case 3:
		{
			p.SetState(7127)
			p.FunctionCall()
		}

	case 4:
		{
			p.SetState(7128)
			p.expression(0)
		}

	}
	p.SetState(7140)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(7131)
			p.Match(MySqlParserCOMMA)
		}
		p.SetState(7136)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1053, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(7132)
				p.Constant()
			}

		case 2:
			{
				p.SetState(7133)
				p.FullColumnName()
			}

		case 3:
			{
				p.SetState(7134)
				p.FunctionCall()
			}

		case 4:
			{
				p.SetState(7135)
				p.expression(0)
			}

		}

		p.SetState(7142)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFunctionArgContext is an interface to support dynamic dispatch.
type IFunctionArgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Constant() IConstantContext
	FullColumnName() IFullColumnNameContext
	FunctionCall() IFunctionCallContext
	Expression() IExpressionContext

	// IsFunctionArgContext differentiates from other interfaces.
	IsFunctionArgContext()
}

type FunctionArgContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionArgContext() *FunctionArgContext {
	var p = new(FunctionArgContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_functionArg
	return p
}

func (*FunctionArgContext) IsFunctionArgContext() {}

func NewFunctionArgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionArgContext {
	var p = new(FunctionArgContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_functionArg

	return p
}

func (s *FunctionArgContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionArgContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *FunctionArgContext) FullColumnName() IFullColumnNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *FunctionArgContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *FunctionArgContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionArgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionArgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionArgContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFunctionArg(s)
	}
}

func (s *FunctionArgContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFunctionArg(s)
	}
}

func (p *MySqlParser) FunctionArg() (localctx IFunctionArgContext) {
	this := p
	_ = this

	localctx = NewFunctionArgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 670, MySqlParserRULE_functionArg)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(7147)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1055, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7143)
			p.Constant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7144)
			p.FullColumnName()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7145)
			p.FunctionCall()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7146)
			p.expression(0)
		}

	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) CopyFrom(ctx *ExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type IsExpressionContext struct {
	*ExpressionContext
	testValue antlr.Token
}

func NewIsExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IsExpressionContext {
	var p = new(IsExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *IsExpressionContext) GetTestValue() antlr.Token { return s.testValue }

func (s *IsExpressionContext) SetTestValue(v antlr.Token) { s.testValue = v }

func (s *IsExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsExpressionContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *IsExpressionContext) IS() antlr.TerminalNode {
	return s.GetToken(MySqlParserIS, 0)
}

func (s *IsExpressionContext) TRUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRUE, 0)
}

func (s *IsExpressionContext) FALSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFALSE, 0)
}

func (s *IsExpressionContext) UNKNOWN() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNKNOWN, 0)
}

func (s *IsExpressionContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *IsExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIsExpression(s)
	}
}

func (s *IsExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIsExpression(s)
	}
}

type NotExpressionContext struct {
	*ExpressionContext
	notOperator antlr.Token
}

func NewNotExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NotExpressionContext {
	var p = new(NotExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *NotExpressionContext) GetNotOperator() antlr.Token { return s.notOperator }

func (s *NotExpressionContext) SetNotOperator(v antlr.Token) { s.notOperator = v }

func (s *NotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NotExpressionContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *NotExpressionContext) EXCLAMATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCLAMATION_SYMBOL, 0)
}

func (s *NotExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterNotExpression(s)
	}
}

func (s *NotExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitNotExpression(s)
	}
}

type LogicalExpressionContext struct {
	*ExpressionContext
}

func NewLogicalExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalExpressionContext {
	var p = new(LogicalExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *LogicalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogicalExpressionContext) LogicalOperator() ILogicalOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalOperatorContext)
}

func (s *LogicalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLogicalExpression(s)
	}
}

func (s *LogicalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLogicalExpression(s)
	}
}

type PredicateExpressionContext struct {
	*ExpressionContext
}

func NewPredicateExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredicateExpressionContext {
	var p = new(PredicateExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *PredicateExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateExpressionContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PredicateExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPredicateExpression(s)
	}
}

func (s *PredicateExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPredicateExpression(s)
	}
}

func (p *MySqlParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *MySqlParser) expression(_p int) (localctx IExpressionContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 672
	p.EnterRecursionRule(localctx, 672, MySqlParserRULE_expression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7160)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1057, p.GetParserRuleContext()) {
	case 1:
		localctx = NewNotExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(7150)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*NotExpressionContext).notOperator = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserNOT || _la == MySqlParserEXCLAMATION_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*NotExpressionContext).notOperator = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(7151)
			p.expression(4)
		}

	case 2:
		localctx = NewIsExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7152)
			p.predicate(0)
		}
		{
			p.SetState(7153)
			p.Match(MySqlParserIS)
		}
		p.SetState(7155)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserNOT {
			{
				p.SetState(7154)
				p.Match(MySqlParserNOT)
			}

		}
		{
			p.SetState(7157)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*IsExpressionContext).testValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFALSE || _la == MySqlParserTRUE || _la == MySqlParserUNKNOWN) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*IsExpressionContext).testValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 3:
		localctx = NewPredicateExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7159)
			p.predicate(0)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(7168)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1058, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewLogicalExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
			p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_expression)
			p.SetState(7162)

			if !(p.Precpred(p.GetParserRuleContext(), 3)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
			}
			{
				p.SetState(7163)
				p.LogicalOperator()
			}
			{
				p.SetState(7164)
				p.expression(4)
			}

		}
		p.SetState(7170)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1058, p.GetParserRuleContext())
	}

	return localctx
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_predicate
	return p
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateContext {
	var p = new(PredicateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_predicate

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) CopyFrom(ctx *PredicateContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SoundsLikePredicateContext struct {
	*PredicateContext
}

func NewSoundsLikePredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SoundsLikePredicateContext {
	var p = new(SoundsLikePredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *SoundsLikePredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SoundsLikePredicateContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *SoundsLikePredicateContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *SoundsLikePredicateContext) SOUNDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSOUNDS, 0)
}

func (s *SoundsLikePredicateContext) LIKE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIKE, 0)
}

func (s *SoundsLikePredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSoundsLikePredicate(s)
	}
}

func (s *SoundsLikePredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSoundsLikePredicate(s)
	}
}

type ExpressionAtomPredicateContext struct {
	*PredicateContext
}

func NewExpressionAtomPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExpressionAtomPredicateContext {
	var p = new(ExpressionAtomPredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *ExpressionAtomPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionAtomPredicateContext) ExpressionAtom() IExpressionAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *ExpressionAtomPredicateContext) LOCAL_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL_ID, 0)
}

func (s *ExpressionAtomPredicateContext) VAR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserVAR_ASSIGN, 0)
}

func (s *ExpressionAtomPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterExpressionAtomPredicate(s)
	}
}

func (s *ExpressionAtomPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitExpressionAtomPredicate(s)
	}
}

type SubqueryComparisonPredicateContext struct {
	*PredicateContext
	quantifier antlr.Token
}

func NewSubqueryComparisonPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryComparisonPredicateContext {
	var p = new(SubqueryComparisonPredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *SubqueryComparisonPredicateContext) GetQuantifier() antlr.Token { return s.quantifier }

func (s *SubqueryComparisonPredicateContext) SetQuantifier(v antlr.Token) { s.quantifier = v }

func (s *SubqueryComparisonPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryComparisonPredicateContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *SubqueryComparisonPredicateContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *SubqueryComparisonPredicateContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *SubqueryComparisonPredicateContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *SubqueryComparisonPredicateContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *SubqueryComparisonPredicateContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *SubqueryComparisonPredicateContext) ANY() antlr.TerminalNode {
	return s.GetToken(MySqlParserANY, 0)
}

func (s *SubqueryComparisonPredicateContext) SOME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSOME, 0)
}

func (s *SubqueryComparisonPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSubqueryComparisonPredicate(s)
	}
}

func (s *SubqueryComparisonPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSubqueryComparisonPredicate(s)
	}
}

type JsonMemberOfPredicateContext struct {
	*PredicateContext
}

func NewJsonMemberOfPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JsonMemberOfPredicateContext {
	var p = new(JsonMemberOfPredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *JsonMemberOfPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonMemberOfPredicateContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *JsonMemberOfPredicateContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *JsonMemberOfPredicateContext) MEMBER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEMBER, 0)
}

func (s *JsonMemberOfPredicateContext) OF() antlr.TerminalNode {
	return s.GetToken(MySqlParserOF, 0)
}

func (s *JsonMemberOfPredicateContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *JsonMemberOfPredicateContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *JsonMemberOfPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterJsonMemberOfPredicate(s)
	}
}

func (s *JsonMemberOfPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitJsonMemberOfPredicate(s)
	}
}

type BinaryComparisonPredicateContext struct {
	*PredicateContext
	left  IPredicateContext
	right IPredicateContext
}

func NewBinaryComparisonPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BinaryComparisonPredicateContext {
	var p = new(BinaryComparisonPredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *BinaryComparisonPredicateContext) GetLeft() IPredicateContext { return s.left }

func (s *BinaryComparisonPredicateContext) GetRight() IPredicateContext { return s.right }

func (s *BinaryComparisonPredicateContext) SetLeft(v IPredicateContext) { s.left = v }

func (s *BinaryComparisonPredicateContext) SetRight(v IPredicateContext) { s.right = v }

func (s *BinaryComparisonPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryComparisonPredicateContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *BinaryComparisonPredicateContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *BinaryComparisonPredicateContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *BinaryComparisonPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterBinaryComparisonPredicate(s)
	}
}

func (s *BinaryComparisonPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitBinaryComparisonPredicate(s)
	}
}

type InPredicateContext struct {
	*PredicateContext
}

func NewInPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InPredicateContext {
	var p = new(InPredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *InPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InPredicateContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *InPredicateContext) IN() antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, 0)
}

func (s *InPredicateContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *InPredicateContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *InPredicateContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *InPredicateContext) Expressions() IExpressionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *InPredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *InPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterInPredicate(s)
	}
}

func (s *InPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitInPredicate(s)
	}
}

type BetweenPredicateContext struct {
	*PredicateContext
}

func NewBetweenPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BetweenPredicateContext {
	var p = new(BetweenPredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *BetweenPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BetweenPredicateContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *BetweenPredicateContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *BetweenPredicateContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBETWEEN, 0)
}

func (s *BetweenPredicateContext) AND() antlr.TerminalNode {
	return s.GetToken(MySqlParserAND, 0)
}

func (s *BetweenPredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *BetweenPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterBetweenPredicate(s)
	}
}

func (s *BetweenPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitBetweenPredicate(s)
	}
}

type IsNullPredicateContext struct {
	*PredicateContext
}

func NewIsNullPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IsNullPredicateContext {
	var p = new(IsNullPredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *IsNullPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsNullPredicateContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *IsNullPredicateContext) IS() antlr.TerminalNode {
	return s.GetToken(MySqlParserIS, 0)
}

func (s *IsNullPredicateContext) NullNotnull() INullNotnullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullNotnullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullNotnullContext)
}

func (s *IsNullPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIsNullPredicate(s)
	}
}

func (s *IsNullPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIsNullPredicate(s)
	}
}

type LikePredicateContext struct {
	*PredicateContext
}

func NewLikePredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LikePredicateContext {
	var p = new(LikePredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *LikePredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikePredicateContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *LikePredicateContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *LikePredicateContext) LIKE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIKE, 0)
}

func (s *LikePredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *LikePredicateContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(MySqlParserESCAPE, 0)
}

func (s *LikePredicateContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *LikePredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLikePredicate(s)
	}
}

func (s *LikePredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLikePredicate(s)
	}
}

type RegexpPredicateContext struct {
	*PredicateContext
	regex antlr.Token
}

func NewRegexpPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RegexpPredicateContext {
	var p = new(RegexpPredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *RegexpPredicateContext) GetRegex() antlr.Token { return s.regex }

func (s *RegexpPredicateContext) SetRegex(v antlr.Token) { s.regex = v }

func (s *RegexpPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RegexpPredicateContext) AllPredicate() []IPredicateContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPredicateContext); ok {
			len++
		}
	}

	tst := make([]IPredicateContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPredicateContext); ok {
			tst[i] = t.(IPredicateContext)
			i++
		}
	}

	return tst
}

func (s *RegexpPredicateContext) Predicate(i int) IPredicateContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *RegexpPredicateContext) REGEXP() antlr.TerminalNode {
	return s.GetToken(MySqlParserREGEXP, 0)
}

func (s *RegexpPredicateContext) RLIKE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRLIKE, 0)
}

func (s *RegexpPredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *RegexpPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRegexpPredicate(s)
	}
}

func (s *RegexpPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRegexpPredicate(s)
	}
}

func (p *MySqlParser) Predicate() (localctx IPredicateContext) {
	return p.predicate(0)
}

func (p *MySqlParser) predicate(_p int) (localctx IPredicateContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewPredicateContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPredicateContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 674
	p.EnterRecursionRule(localctx, 674, MySqlParserRULE_predicate, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewExpressionAtomPredicateContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	p.SetState(7174)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1059, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(7172)
			p.Match(MySqlParserLOCAL_ID)
		}
		{
			p.SetState(7173)
			p.Match(MySqlParserVAR_ASSIGN)
		}

	}
	{
		p.SetState(7176)
		p.expressionAtom(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(7242)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1067, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(7240)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1066, p.GetParserRuleContext()) {
			case 1:
				localctx = NewBinaryComparisonPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				localctx.(*BinaryComparisonPredicateContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(7178)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
				}
				{
					p.SetState(7179)
					p.ComparisonOperator()
				}
				{
					p.SetState(7180)

					var _x = p.predicate(9)

					localctx.(*BinaryComparisonPredicateContext).right = _x
				}

			case 2:
				localctx = NewBetweenPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(7182)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
				}
				p.SetState(7184)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == MySqlParserNOT {
					{
						p.SetState(7183)
						p.Match(MySqlParserNOT)
					}

				}
				{
					p.SetState(7186)
					p.Match(MySqlParserBETWEEN)
				}
				{
					p.SetState(7187)
					p.predicate(0)
				}
				{
					p.SetState(7188)
					p.Match(MySqlParserAND)
				}
				{
					p.SetState(7189)
					p.predicate(7)
				}

			case 3:
				localctx = NewSoundsLikePredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(7191)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(7192)
					p.Match(MySqlParserSOUNDS)
				}
				{
					p.SetState(7193)
					p.Match(MySqlParserLIKE)
				}
				{
					p.SetState(7194)
					p.predicate(6)
				}

			case 4:
				localctx = NewRegexpPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(7195)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				p.SetState(7197)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == MySqlParserNOT {
					{
						p.SetState(7196)
						p.Match(MySqlParserNOT)
					}

				}
				{
					p.SetState(7199)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*RegexpPredicateContext).regex = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserREGEXP || _la == MySqlParserRLIKE) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*RegexpPredicateContext).regex = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(7200)
					p.predicate(4)
				}

			case 5:
				localctx = NewInPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(7201)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
				}
				p.SetState(7203)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == MySqlParserNOT {
					{
						p.SetState(7202)
						p.Match(MySqlParserNOT)
					}

				}
				{
					p.SetState(7205)
					p.Match(MySqlParserIN)
				}
				{
					p.SetState(7206)
					p.Match(MySqlParserLR_BRACKET)
				}
				p.SetState(7209)
				p.GetErrorHandler().Sync(p)
				switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1063, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(7207)
						p.SelectStatement()
					}

				case 2:
					{
						p.SetState(7208)
						p.Expressions()
					}

				}
				{
					p.SetState(7211)
					p.Match(MySqlParserRR_BRACKET)
				}

			case 6:
				localctx = NewIsNullPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(7213)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
				}
				{
					p.SetState(7214)
					p.Match(MySqlParserIS)
				}
				{
					p.SetState(7215)
					p.NullNotnull()
				}

			case 7:
				localctx = NewSubqueryComparisonPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(7216)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
				}
				{
					p.SetState(7217)
					p.ComparisonOperator()
				}
				{
					p.SetState(7218)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*SubqueryComparisonPredicateContext).quantifier = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserALL || _la == MySqlParserANY || _la == MySqlParserSOME) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*SubqueryComparisonPredicateContext).quantifier = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(7219)
					p.Match(MySqlParserLR_BRACKET)
				}
				{
					p.SetState(7220)
					p.SelectStatement()
				}
				{
					p.SetState(7221)
					p.Match(MySqlParserRR_BRACKET)
				}

			case 8:
				localctx = NewLikePredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(7223)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				p.SetState(7225)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == MySqlParserNOT {
					{
						p.SetState(7224)
						p.Match(MySqlParserNOT)
					}

				}
				{
					p.SetState(7227)
					p.Match(MySqlParserLIKE)
				}
				{
					p.SetState(7228)
					p.predicate(0)
				}
				p.SetState(7231)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1065, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(7229)
						p.Match(MySqlParserESCAPE)
					}
					{
						p.SetState(7230)
						p.Match(MySqlParserSTRING_LITERAL)
					}

				}

			case 9:
				localctx = NewJsonMemberOfPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(7233)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(7234)
					p.Match(MySqlParserMEMBER)
				}
				{
					p.SetState(7235)
					p.Match(MySqlParserOF)
				}
				{
					p.SetState(7236)
					p.Match(MySqlParserLR_BRACKET)
				}
				{
					p.SetState(7237)
					p.predicate(0)
				}
				{
					p.SetState(7238)
					p.Match(MySqlParserRR_BRACKET)
				}

			}

		}
		p.SetState(7244)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1067, p.GetParserRuleContext())
	}

	return localctx
}

// IExpressionAtomContext is an interface to support dynamic dispatch.
type IExpressionAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExpressionAtomContext differentiates from other interfaces.
	IsExpressionAtomContext()
}

type ExpressionAtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionAtomContext() *ExpressionAtomContext {
	var p = new(ExpressionAtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_expressionAtom
	return p
}

func (*ExpressionAtomContext) IsExpressionAtomContext() {}

func NewExpressionAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionAtomContext {
	var p = new(ExpressionAtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_expressionAtom

	return p
}

func (s *ExpressionAtomContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionAtomContext) CopyFrom(ctx *ExpressionAtomContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionAtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UnaryExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewUnaryExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryExpressionAtomContext {
	var p = new(UnaryExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *UnaryExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryExpressionAtomContext) UnaryOperator() IUnaryOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryOperatorContext)
}

func (s *UnaryExpressionAtomContext) ExpressionAtom() IExpressionAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *UnaryExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUnaryExpressionAtom(s)
	}
}

func (s *UnaryExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUnaryExpressionAtom(s)
	}
}

type CollateExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewCollateExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CollateExpressionAtomContext {
	var p = new(CollateExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *CollateExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollateExpressionAtomContext) ExpressionAtom() IExpressionAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *CollateExpressionAtomContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATE, 0)
}

func (s *CollateExpressionAtomContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *CollateExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCollateExpressionAtom(s)
	}
}

func (s *CollateExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCollateExpressionAtom(s)
	}
}

type BindExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewBindExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BindExpressionAtomContext {
	var p = new(BindExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *BindExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindExpressionAtomContext) BIND_PARAMETER() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIND_PARAMETER, 0)
}

func (s *BindExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterBindExpressionAtom(s)
	}
}

func (s *BindExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitBindExpressionAtom(s)
	}
}

type MysqlVariableExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewMysqlVariableExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MysqlVariableExpressionAtomContext {
	var p = new(MysqlVariableExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *MysqlVariableExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MysqlVariableExpressionAtomContext) MysqlVariable() IMysqlVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMysqlVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMysqlVariableContext)
}

func (s *MysqlVariableExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMysqlVariableExpressionAtom(s)
	}
}

func (s *MysqlVariableExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMysqlVariableExpressionAtom(s)
	}
}

type NestedExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewNestedExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NestedExpressionAtomContext {
	var p = new(NestedExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *NestedExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NestedExpressionAtomContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *NestedExpressionAtomContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *NestedExpressionAtomContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NestedExpressionAtomContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *NestedExpressionAtomContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *NestedExpressionAtomContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *NestedExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterNestedExpressionAtom(s)
	}
}

func (s *NestedExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitNestedExpressionAtom(s)
	}
}

type NestedRowExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewNestedRowExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NestedRowExpressionAtomContext {
	var p = new(NestedRowExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *NestedRowExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NestedRowExpressionAtomContext) ROW() antlr.TerminalNode {
	return s.GetToken(MySqlParserROW, 0)
}

func (s *NestedRowExpressionAtomContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *NestedRowExpressionAtomContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *NestedRowExpressionAtomContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NestedRowExpressionAtomContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *NestedRowExpressionAtomContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *NestedRowExpressionAtomContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *NestedRowExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterNestedRowExpressionAtom(s)
	}
}

func (s *NestedRowExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitNestedRowExpressionAtom(s)
	}
}

type MathExpressionAtomContext struct {
	*ExpressionAtomContext
	left  IExpressionAtomContext
	right IExpressionAtomContext
}

func NewMathExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MathExpressionAtomContext {
	var p = new(MathExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *MathExpressionAtomContext) GetLeft() IExpressionAtomContext { return s.left }

func (s *MathExpressionAtomContext) GetRight() IExpressionAtomContext { return s.right }

func (s *MathExpressionAtomContext) SetLeft(v IExpressionAtomContext) { s.left = v }

func (s *MathExpressionAtomContext) SetRight(v IExpressionAtomContext) { s.right = v }

func (s *MathExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MathExpressionAtomContext) MathOperator() IMathOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMathOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMathOperatorContext)
}

func (s *MathExpressionAtomContext) AllExpressionAtom() []IExpressionAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			len++
		}
	}

	tst := make([]IExpressionAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionAtomContext); ok {
			tst[i] = t.(IExpressionAtomContext)
			i++
		}
	}

	return tst
}

func (s *MathExpressionAtomContext) ExpressionAtom(i int) IExpressionAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *MathExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMathExpressionAtom(s)
	}
}

func (s *MathExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMathExpressionAtom(s)
	}
}

type ExistsExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewExistsExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExistsExpressionAtomContext {
	var p = new(ExistsExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *ExistsExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExistsExpressionAtomContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXISTS, 0)
}

func (s *ExistsExpressionAtomContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *ExistsExpressionAtomContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *ExistsExpressionAtomContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *ExistsExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterExistsExpressionAtom(s)
	}
}

func (s *ExistsExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitExistsExpressionAtom(s)
	}
}

type IntervalExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewIntervalExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntervalExpressionAtomContext {
	var p = new(IntervalExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *IntervalExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalExpressionAtomContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTERVAL, 0)
}

func (s *IntervalExpressionAtomContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IntervalExpressionAtomContext) IntervalType() IIntervalTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalTypeContext)
}

func (s *IntervalExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIntervalExpressionAtom(s)
	}
}

func (s *IntervalExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIntervalExpressionAtom(s)
	}
}

type JsonExpressionAtomContext struct {
	*ExpressionAtomContext
	left  IExpressionAtomContext
	right IExpressionAtomContext
}

func NewJsonExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JsonExpressionAtomContext {
	var p = new(JsonExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *JsonExpressionAtomContext) GetLeft() IExpressionAtomContext { return s.left }

func (s *JsonExpressionAtomContext) GetRight() IExpressionAtomContext { return s.right }

func (s *JsonExpressionAtomContext) SetLeft(v IExpressionAtomContext) { s.left = v }

func (s *JsonExpressionAtomContext) SetRight(v IExpressionAtomContext) { s.right = v }

func (s *JsonExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonExpressionAtomContext) JsonOperator() IJsonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonOperatorContext)
}

func (s *JsonExpressionAtomContext) AllExpressionAtom() []IExpressionAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			len++
		}
	}

	tst := make([]IExpressionAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionAtomContext); ok {
			tst[i] = t.(IExpressionAtomContext)
			i++
		}
	}

	return tst
}

func (s *JsonExpressionAtomContext) ExpressionAtom(i int) IExpressionAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *JsonExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterJsonExpressionAtom(s)
	}
}

func (s *JsonExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitJsonExpressionAtom(s)
	}
}

type SubqueryExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewSubqueryExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryExpressionAtomContext {
	var p = new(SubqueryExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *SubqueryExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryExpressionAtomContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *SubqueryExpressionAtomContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *SubqueryExpressionAtomContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *SubqueryExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSubqueryExpressionAtom(s)
	}
}

func (s *SubqueryExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSubqueryExpressionAtom(s)
	}
}

type ConstantExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewConstantExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConstantExpressionAtomContext {
	var p = new(ConstantExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *ConstantExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantExpressionAtomContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ConstantExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterConstantExpressionAtom(s)
	}
}

func (s *ConstantExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitConstantExpressionAtom(s)
	}
}

type FunctionCallExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewFunctionCallExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionCallExpressionAtomContext {
	var p = new(FunctionCallExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *FunctionCallExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallExpressionAtomContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *FunctionCallExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFunctionCallExpressionAtom(s)
	}
}

func (s *FunctionCallExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFunctionCallExpressionAtom(s)
	}
}

type BinaryExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewBinaryExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BinaryExpressionAtomContext {
	var p = new(BinaryExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *BinaryExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryExpressionAtomContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *BinaryExpressionAtomContext) ExpressionAtom() IExpressionAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *BinaryExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterBinaryExpressionAtom(s)
	}
}

func (s *BinaryExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitBinaryExpressionAtom(s)
	}
}

type FullColumnNameExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewFullColumnNameExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FullColumnNameExpressionAtomContext {
	var p = new(FullColumnNameExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *FullColumnNameExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullColumnNameExpressionAtomContext) FullColumnName() IFullColumnNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullColumnNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *FullColumnNameExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFullColumnNameExpressionAtom(s)
	}
}

func (s *FullColumnNameExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFullColumnNameExpressionAtom(s)
	}
}

type BitExpressionAtomContext struct {
	*ExpressionAtomContext
	left  IExpressionAtomContext
	right IExpressionAtomContext
}

func NewBitExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitExpressionAtomContext {
	var p = new(BitExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *BitExpressionAtomContext) GetLeft() IExpressionAtomContext { return s.left }

func (s *BitExpressionAtomContext) GetRight() IExpressionAtomContext { return s.right }

func (s *BitExpressionAtomContext) SetLeft(v IExpressionAtomContext) { s.left = v }

func (s *BitExpressionAtomContext) SetRight(v IExpressionAtomContext) { s.right = v }

func (s *BitExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitExpressionAtomContext) BitOperator() IBitOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitOperatorContext)
}

func (s *BitExpressionAtomContext) AllExpressionAtom() []IExpressionAtomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			len++
		}
	}

	tst := make([]IExpressionAtomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionAtomContext); ok {
			tst[i] = t.(IExpressionAtomContext)
			i++
		}
	}

	return tst
}

func (s *BitExpressionAtomContext) ExpressionAtom(i int) IExpressionAtomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionAtomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *BitExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterBitExpressionAtom(s)
	}
}

func (s *BitExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitBitExpressionAtom(s)
	}
}

func (p *MySqlParser) ExpressionAtom() (localctx IExpressionAtomContext) {
	return p.expressionAtom(0)
}

func (p *MySqlParser) expressionAtom(_p int) (localctx IExpressionAtomContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExpressionAtomContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionAtomContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 676
	p.EnterRecursionRule(localctx, 676, MySqlParserRULE_expressionAtom, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7291)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1070, p.GetParserRuleContext()) {
	case 1:
		localctx = NewConstantExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(7246)
			p.Constant()
		}

	case 2:
		localctx = NewBindExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7247)
			p.Match(MySqlParserBIND_PARAMETER)
		}

	case 3:
		localctx = NewFullColumnNameExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7248)
			p.FullColumnName()
		}

	case 4:
		localctx = NewFunctionCallExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7249)
			p.FunctionCall()
		}

	case 5:
		localctx = NewMysqlVariableExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7250)
			p.MysqlVariable()
		}

	case 6:
		localctx = NewUnaryExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7251)
			p.UnaryOperator()
		}
		{
			p.SetState(7252)
			p.expressionAtom(10)
		}

	case 7:
		localctx = NewBinaryExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7254)
			p.Match(MySqlParserBINARY)
		}
		{
			p.SetState(7255)
			p.expressionAtom(9)
		}

	case 8:
		localctx = NewNestedExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7256)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(7257)
			p.expression(0)
		}
		p.SetState(7262)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(7258)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(7259)
				p.expression(0)
			}

			p.SetState(7264)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(7265)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 9:
		localctx = NewNestedRowExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7267)
			p.Match(MySqlParserROW)
		}
		{
			p.SetState(7268)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(7269)
			p.expression(0)
		}
		p.SetState(7272)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == MySqlParserCOMMA {
			{
				p.SetState(7270)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(7271)
				p.expression(0)
			}

			p.SetState(7274)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(7276)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 10:
		localctx = NewExistsExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7278)
			p.Match(MySqlParserEXISTS)
		}
		{
			p.SetState(7279)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(7280)
			p.SelectStatement()
		}
		{
			p.SetState(7281)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 11:
		localctx = NewSubqueryExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7283)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(7284)
			p.SelectStatement()
		}
		{
			p.SetState(7285)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 12:
		localctx = NewIntervalExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(7287)
			p.Match(MySqlParserINTERVAL)
		}
		{
			p.SetState(7288)
			p.expression(0)
		}
		{
			p.SetState(7289)
			p.IntervalType()
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(7310)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1072, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(7308)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1071, p.GetParserRuleContext()) {
			case 1:
				localctx = NewBitExpressionAtomContext(p, NewExpressionAtomContext(p, _parentctx, _parentState))
				localctx.(*BitExpressionAtomContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_expressionAtom)
				p.SetState(7293)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(7294)
					p.BitOperator()
				}
				{
					p.SetState(7295)

					var _x = p.expressionAtom(4)

					localctx.(*BitExpressionAtomContext).right = _x
				}

			case 2:
				localctx = NewMathExpressionAtomContext(p, NewExpressionAtomContext(p, _parentctx, _parentState))
				localctx.(*MathExpressionAtomContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_expressionAtom)
				p.SetState(7297)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(7298)
					p.MathOperator()
				}
				{
					p.SetState(7299)

					var _x = p.expressionAtom(3)

					localctx.(*MathExpressionAtomContext).right = _x
				}

			case 3:
				localctx = NewJsonExpressionAtomContext(p, NewExpressionAtomContext(p, _parentctx, _parentState))
				localctx.(*JsonExpressionAtomContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_expressionAtom)
				p.SetState(7301)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(7302)
					p.JsonOperator()
				}
				{
					p.SetState(7303)

					var _x = p.expressionAtom(2)

					localctx.(*JsonExpressionAtomContext).right = _x
				}

			case 4:
				localctx = NewCollateExpressionAtomContext(p, NewExpressionAtomContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_expressionAtom)
				p.SetState(7305)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
				}
				{
					p.SetState(7306)
					p.Match(MySqlParserCOLLATE)
				}
				{
					p.SetState(7307)
					p.CollationName()
				}

			}

		}
		p.SetState(7312)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1072, p.GetParserRuleContext())
	}

	return localctx
}

// IUnaryOperatorContext is an interface to support dynamic dispatch.
type IUnaryOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXCLAMATION_SYMBOL() antlr.TerminalNode
	BIT_NOT_OP() antlr.TerminalNode
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsUnaryOperatorContext differentiates from other interfaces.
	IsUnaryOperatorContext()
}

type UnaryOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryOperatorContext() *UnaryOperatorContext {
	var p = new(UnaryOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_unaryOperator
	return p
}

func (*UnaryOperatorContext) IsUnaryOperatorContext() {}

func NewUnaryOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryOperatorContext {
	var p = new(UnaryOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_unaryOperator

	return p
}

func (s *UnaryOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryOperatorContext) EXCLAMATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCLAMATION_SYMBOL, 0)
}

func (s *UnaryOperatorContext) BIT_NOT_OP() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_NOT_OP, 0)
}

func (s *UnaryOperatorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPLUS, 0)
}

func (s *UnaryOperatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUS, 0)
}

func (s *UnaryOperatorContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *UnaryOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUnaryOperator(s)
	}
}

func (s *UnaryOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUnaryOperator(s)
	}
}

func (p *MySqlParser) UnaryOperator() (localctx IUnaryOperatorContext) {
	this := p
	_ = this

	localctx = NewUnaryOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 678, MySqlParserRULE_unaryOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7313)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserNOT || ((int64((_la-1118)) & ^0x3f) == 0 && ((int64(1)<<(_la-1118))&387) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUAL_SYMBOL() antlr.TerminalNode
	GREATER_SYMBOL() antlr.TerminalNode
	LESS_SYMBOL() antlr.TerminalNode
	EXCLAMATION_SYMBOL() antlr.TerminalNode

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_comparisonOperator
	return p
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) GREATER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserGREATER_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) LESS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLESS_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) EXCLAMATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCLAMATION_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitComparisonOperator(s)
	}
}

func (p *MySqlParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	this := p
	_ = this

	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 680, MySqlParserRULE_comparisonOperator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(7329)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1073, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7315)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7316)
			p.Match(MySqlParserGREATER_SYMBOL)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7317)
			p.Match(MySqlParserLESS_SYMBOL)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7318)
			p.Match(MySqlParserLESS_SYMBOL)
		}
		{
			p.SetState(7319)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7320)
			p.Match(MySqlParserGREATER_SYMBOL)
		}
		{
			p.SetState(7321)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7322)
			p.Match(MySqlParserLESS_SYMBOL)
		}
		{
			p.SetState(7323)
			p.Match(MySqlParserGREATER_SYMBOL)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(7324)
			p.Match(MySqlParserEXCLAMATION_SYMBOL)
		}
		{
			p.SetState(7325)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(7326)
			p.Match(MySqlParserLESS_SYMBOL)
		}
		{
			p.SetState(7327)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}
		{
			p.SetState(7328)
			p.Match(MySqlParserGREATER_SYMBOL)
		}

	}

	return localctx
}

// ILogicalOperatorContext is an interface to support dynamic dispatch.
type ILogicalOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AND() antlr.TerminalNode
	AllBIT_AND_OP() []antlr.TerminalNode
	BIT_AND_OP(i int) antlr.TerminalNode
	XOR() antlr.TerminalNode
	OR() antlr.TerminalNode
	AllBIT_OR_OP() []antlr.TerminalNode
	BIT_OR_OP(i int) antlr.TerminalNode

	// IsLogicalOperatorContext differentiates from other interfaces.
	IsLogicalOperatorContext()
}

type LogicalOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogicalOperatorContext() *LogicalOperatorContext {
	var p = new(LogicalOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_logicalOperator
	return p
}

func (*LogicalOperatorContext) IsLogicalOperatorContext() {}

func NewLogicalOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicalOperatorContext {
	var p = new(LogicalOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_logicalOperator

	return p
}

func (s *LogicalOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *LogicalOperatorContext) AND() antlr.TerminalNode {
	return s.GetToken(MySqlParserAND, 0)
}

func (s *LogicalOperatorContext) AllBIT_AND_OP() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserBIT_AND_OP)
}

func (s *LogicalOperatorContext) BIT_AND_OP(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_AND_OP, i)
}

func (s *LogicalOperatorContext) XOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserXOR, 0)
}

func (s *LogicalOperatorContext) OR() antlr.TerminalNode {
	return s.GetToken(MySqlParserOR, 0)
}

func (s *LogicalOperatorContext) AllBIT_OR_OP() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserBIT_OR_OP)
}

func (s *LogicalOperatorContext) BIT_OR_OP(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_OR_OP, i)
}

func (s *LogicalOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogicalOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLogicalOperator(s)
	}
}

func (s *LogicalOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLogicalOperator(s)
	}
}

func (p *MySqlParser) LogicalOperator() (localctx ILogicalOperatorContext) {
	this := p
	_ = this

	localctx = NewLogicalOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 682, MySqlParserRULE_logicalOperator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(7338)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserAND:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7331)
			p.Match(MySqlParserAND)
		}

	case MySqlParserBIT_AND_OP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7332)
			p.Match(MySqlParserBIT_AND_OP)
		}
		{
			p.SetState(7333)
			p.Match(MySqlParserBIT_AND_OP)
		}

	case MySqlParserXOR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7334)
			p.Match(MySqlParserXOR)
		}

	case MySqlParserOR:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7335)
			p.Match(MySqlParserOR)
		}

	case MySqlParserBIT_OR_OP:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7336)
			p.Match(MySqlParserBIT_OR_OP)
		}
		{
			p.SetState(7337)
			p.Match(MySqlParserBIT_OR_OP)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBitOperatorContext is an interface to support dynamic dispatch.
type IBitOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLESS_SYMBOL() []antlr.TerminalNode
	LESS_SYMBOL(i int) antlr.TerminalNode
	AllGREATER_SYMBOL() []antlr.TerminalNode
	GREATER_SYMBOL(i int) antlr.TerminalNode
	BIT_AND_OP() antlr.TerminalNode
	BIT_XOR_OP() antlr.TerminalNode
	BIT_OR_OP() antlr.TerminalNode

	// IsBitOperatorContext differentiates from other interfaces.
	IsBitOperatorContext()
}

type BitOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitOperatorContext() *BitOperatorContext {
	var p = new(BitOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_bitOperator
	return p
}

func (*BitOperatorContext) IsBitOperatorContext() {}

func NewBitOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitOperatorContext {
	var p = new(BitOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_bitOperator

	return p
}

func (s *BitOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *BitOperatorContext) AllLESS_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLESS_SYMBOL)
}

func (s *BitOperatorContext) LESS_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLESS_SYMBOL, i)
}

func (s *BitOperatorContext) AllGREATER_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserGREATER_SYMBOL)
}

func (s *BitOperatorContext) GREATER_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserGREATER_SYMBOL, i)
}

func (s *BitOperatorContext) BIT_AND_OP() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_AND_OP, 0)
}

func (s *BitOperatorContext) BIT_XOR_OP() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_XOR_OP, 0)
}

func (s *BitOperatorContext) BIT_OR_OP() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_OR_OP, 0)
}

func (s *BitOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterBitOperator(s)
	}
}

func (s *BitOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitBitOperator(s)
	}
}

func (p *MySqlParser) BitOperator() (localctx IBitOperatorContext) {
	this := p
	_ = this

	localctx = NewBitOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 684, MySqlParserRULE_bitOperator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(7347)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserLESS_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7340)
			p.Match(MySqlParserLESS_SYMBOL)
		}
		{
			p.SetState(7341)
			p.Match(MySqlParserLESS_SYMBOL)
		}

	case MySqlParserGREATER_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7342)
			p.Match(MySqlParserGREATER_SYMBOL)
		}
		{
			p.SetState(7343)
			p.Match(MySqlParserGREATER_SYMBOL)
		}

	case MySqlParserBIT_AND_OP:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7344)
			p.Match(MySqlParserBIT_AND_OP)
		}

	case MySqlParserBIT_XOR_OP:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7345)
			p.Match(MySqlParserBIT_XOR_OP)
		}

	case MySqlParserBIT_OR_OP:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7346)
			p.Match(MySqlParserBIT_OR_OP)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMathOperatorContext is an interface to support dynamic dispatch.
type IMathOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	DIVIDE() antlr.TerminalNode
	MODULE() antlr.TerminalNode
	DIV() antlr.TerminalNode
	MOD() antlr.TerminalNode
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode

	// IsMathOperatorContext differentiates from other interfaces.
	IsMathOperatorContext()
}

type MathOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMathOperatorContext() *MathOperatorContext {
	var p = new(MathOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_mathOperator
	return p
}

func (*MathOperatorContext) IsMathOperatorContext() {}

func NewMathOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MathOperatorContext {
	var p = new(MathOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_mathOperator

	return p
}

func (s *MathOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *MathOperatorContext) STAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTAR, 0)
}

func (s *MathOperatorContext) DIVIDE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDIVIDE, 0)
}

func (s *MathOperatorContext) MODULE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMODULE, 0)
}

func (s *MathOperatorContext) DIV() antlr.TerminalNode {
	return s.GetToken(MySqlParserDIV, 0)
}

func (s *MathOperatorContext) MOD() antlr.TerminalNode {
	return s.GetToken(MySqlParserMOD, 0)
}

func (s *MathOperatorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPLUS, 0)
}

func (s *MathOperatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUS, 0)
}

func (s *MathOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MathOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MathOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMathOperator(s)
	}
}

func (s *MathOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMathOperator(s)
	}
}

func (p *MySqlParser) MathOperator() (localctx IMathOperatorContext) {
	this := p
	_ = this

	localctx = NewMathOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 686, MySqlParserRULE_mathOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7349)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-1115)) & ^0x3f) == 0 && ((int64(1)<<(_la-1115))&127) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IJsonOperatorContext is an interface to support dynamic dispatch.
type IJsonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MINUS() antlr.TerminalNode
	AllGREATER_SYMBOL() []antlr.TerminalNode
	GREATER_SYMBOL(i int) antlr.TerminalNode

	// IsJsonOperatorContext differentiates from other interfaces.
	IsJsonOperatorContext()
}

type JsonOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonOperatorContext() *JsonOperatorContext {
	var p = new(JsonOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_jsonOperator
	return p
}

func (*JsonOperatorContext) IsJsonOperatorContext() {}

func NewJsonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonOperatorContext {
	var p = new(JsonOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_jsonOperator

	return p
}

func (s *JsonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonOperatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUS, 0)
}

func (s *JsonOperatorContext) AllGREATER_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserGREATER_SYMBOL)
}

func (s *JsonOperatorContext) GREATER_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserGREATER_SYMBOL, i)
}

func (s *JsonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterJsonOperator(s)
	}
}

func (s *JsonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitJsonOperator(s)
	}
}

func (p *MySqlParser) JsonOperator() (localctx IJsonOperatorContext) {
	this := p
	_ = this

	localctx = NewJsonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 688, MySqlParserRULE_jsonOperator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(7356)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1076, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7351)
			p.Match(MySqlParserMINUS)
		}
		{
			p.SetState(7352)
			p.Match(MySqlParserGREATER_SYMBOL)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7353)
			p.Match(MySqlParserMINUS)
		}
		{
			p.SetState(7354)
			p.Match(MySqlParserGREATER_SYMBOL)
		}
		{
			p.SetState(7355)
			p.Match(MySqlParserGREATER_SYMBOL)
		}

	}

	return localctx
}

// ICharsetNameBaseContext is an interface to support dynamic dispatch.
type ICharsetNameBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARMSCII8() antlr.TerminalNode
	ASCII() antlr.TerminalNode
	BIG5() antlr.TerminalNode
	BINARY() antlr.TerminalNode
	CP1250() antlr.TerminalNode
	CP1251() antlr.TerminalNode
	CP1256() antlr.TerminalNode
	CP1257() antlr.TerminalNode
	CP850() antlr.TerminalNode
	CP852() antlr.TerminalNode
	CP866() antlr.TerminalNode
	CP932() antlr.TerminalNode
	DEC8() antlr.TerminalNode
	EUCJPMS() antlr.TerminalNode
	EUCKR() antlr.TerminalNode
	GB18030() antlr.TerminalNode
	GB2312() antlr.TerminalNode
	GBK() antlr.TerminalNode
	GEOSTD8() antlr.TerminalNode
	GREEK() antlr.TerminalNode
	HEBREW() antlr.TerminalNode
	HP8() antlr.TerminalNode
	KEYBCS2() antlr.TerminalNode
	KOI8R() antlr.TerminalNode
	KOI8U() antlr.TerminalNode
	LATIN1() antlr.TerminalNode
	LATIN2() antlr.TerminalNode
	LATIN5() antlr.TerminalNode
	LATIN7() antlr.TerminalNode
	MACCE() antlr.TerminalNode
	MACROMAN() antlr.TerminalNode
	SJIS() antlr.TerminalNode
	SWE7() antlr.TerminalNode
	TIS620() antlr.TerminalNode
	UCS2() antlr.TerminalNode
	UJIS() antlr.TerminalNode
	UTF16() antlr.TerminalNode
	UTF16LE() antlr.TerminalNode
	UTF32() antlr.TerminalNode
	UTF8() antlr.TerminalNode
	UTF8MB3() antlr.TerminalNode
	UTF8MB4() antlr.TerminalNode

	// IsCharsetNameBaseContext differentiates from other interfaces.
	IsCharsetNameBaseContext()
}

type CharsetNameBaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharsetNameBaseContext() *CharsetNameBaseContext {
	var p = new(CharsetNameBaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_charsetNameBase
	return p
}

func (*CharsetNameBaseContext) IsCharsetNameBaseContext() {}

func NewCharsetNameBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharsetNameBaseContext {
	var p = new(CharsetNameBaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_charsetNameBase

	return p
}

func (s *CharsetNameBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *CharsetNameBaseContext) ARMSCII8() antlr.TerminalNode {
	return s.GetToken(MySqlParserARMSCII8, 0)
}

func (s *CharsetNameBaseContext) ASCII() antlr.TerminalNode {
	return s.GetToken(MySqlParserASCII, 0)
}

func (s *CharsetNameBaseContext) BIG5() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIG5, 0)
}

func (s *CharsetNameBaseContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *CharsetNameBaseContext) CP1250() antlr.TerminalNode {
	return s.GetToken(MySqlParserCP1250, 0)
}

func (s *CharsetNameBaseContext) CP1251() antlr.TerminalNode {
	return s.GetToken(MySqlParserCP1251, 0)
}

func (s *CharsetNameBaseContext) CP1256() antlr.TerminalNode {
	return s.GetToken(MySqlParserCP1256, 0)
}

func (s *CharsetNameBaseContext) CP1257() antlr.TerminalNode {
	return s.GetToken(MySqlParserCP1257, 0)
}

func (s *CharsetNameBaseContext) CP850() antlr.TerminalNode {
	return s.GetToken(MySqlParserCP850, 0)
}

func (s *CharsetNameBaseContext) CP852() antlr.TerminalNode {
	return s.GetToken(MySqlParserCP852, 0)
}

func (s *CharsetNameBaseContext) CP866() antlr.TerminalNode {
	return s.GetToken(MySqlParserCP866, 0)
}

func (s *CharsetNameBaseContext) CP932() antlr.TerminalNode {
	return s.GetToken(MySqlParserCP932, 0)
}

func (s *CharsetNameBaseContext) DEC8() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEC8, 0)
}

func (s *CharsetNameBaseContext) EUCJPMS() antlr.TerminalNode {
	return s.GetToken(MySqlParserEUCJPMS, 0)
}

func (s *CharsetNameBaseContext) EUCKR() antlr.TerminalNode {
	return s.GetToken(MySqlParserEUCKR, 0)
}

func (s *CharsetNameBaseContext) GB18030() antlr.TerminalNode {
	return s.GetToken(MySqlParserGB18030, 0)
}

func (s *CharsetNameBaseContext) GB2312() antlr.TerminalNode {
	return s.GetToken(MySqlParserGB2312, 0)
}

func (s *CharsetNameBaseContext) GBK() antlr.TerminalNode {
	return s.GetToken(MySqlParserGBK, 0)
}

func (s *CharsetNameBaseContext) GEOSTD8() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOSTD8, 0)
}

func (s *CharsetNameBaseContext) GREEK() antlr.TerminalNode {
	return s.GetToken(MySqlParserGREEK, 0)
}

func (s *CharsetNameBaseContext) HEBREW() antlr.TerminalNode {
	return s.GetToken(MySqlParserHEBREW, 0)
}

func (s *CharsetNameBaseContext) HP8() antlr.TerminalNode {
	return s.GetToken(MySqlParserHP8, 0)
}

func (s *CharsetNameBaseContext) KEYBCS2() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEYBCS2, 0)
}

func (s *CharsetNameBaseContext) KOI8R() antlr.TerminalNode {
	return s.GetToken(MySqlParserKOI8R, 0)
}

func (s *CharsetNameBaseContext) KOI8U() antlr.TerminalNode {
	return s.GetToken(MySqlParserKOI8U, 0)
}

func (s *CharsetNameBaseContext) LATIN1() antlr.TerminalNode {
	return s.GetToken(MySqlParserLATIN1, 0)
}

func (s *CharsetNameBaseContext) LATIN2() antlr.TerminalNode {
	return s.GetToken(MySqlParserLATIN2, 0)
}

func (s *CharsetNameBaseContext) LATIN5() antlr.TerminalNode {
	return s.GetToken(MySqlParserLATIN5, 0)
}

func (s *CharsetNameBaseContext) LATIN7() antlr.TerminalNode {
	return s.GetToken(MySqlParserLATIN7, 0)
}

func (s *CharsetNameBaseContext) MACCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMACCE, 0)
}

func (s *CharsetNameBaseContext) MACROMAN() antlr.TerminalNode {
	return s.GetToken(MySqlParserMACROMAN, 0)
}

func (s *CharsetNameBaseContext) SJIS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSJIS, 0)
}

func (s *CharsetNameBaseContext) SWE7() antlr.TerminalNode {
	return s.GetToken(MySqlParserSWE7, 0)
}

func (s *CharsetNameBaseContext) TIS620() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIS620, 0)
}

func (s *CharsetNameBaseContext) UCS2() antlr.TerminalNode {
	return s.GetToken(MySqlParserUCS2, 0)
}

func (s *CharsetNameBaseContext) UJIS() antlr.TerminalNode {
	return s.GetToken(MySqlParserUJIS, 0)
}

func (s *CharsetNameBaseContext) UTF16() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTF16, 0)
}

func (s *CharsetNameBaseContext) UTF16LE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTF16LE, 0)
}

func (s *CharsetNameBaseContext) UTF32() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTF32, 0)
}

func (s *CharsetNameBaseContext) UTF8() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTF8, 0)
}

func (s *CharsetNameBaseContext) UTF8MB3() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTF8MB3, 0)
}

func (s *CharsetNameBaseContext) UTF8MB4() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTF8MB4, 0)
}

func (s *CharsetNameBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharsetNameBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharsetNameBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCharsetNameBase(s)
	}
}

func (s *CharsetNameBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCharsetNameBase(s)
	}
}

func (p *MySqlParser) CharsetNameBase() (localctx ICharsetNameBaseContext) {
	this := p
	_ = this

	localctx = NewCharsetNameBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 690, MySqlParserRULE_charsetNameBase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7358)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserBINARY || ((int64((_la-745)) & ^0x3f) == 0 && ((int64(1)<<(_la-745))&2199023255551) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ITransactionLevelBaseContext is an interface to support dynamic dispatch.
type ITransactionLevelBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPEATABLE() antlr.TerminalNode
	COMMITTED() antlr.TerminalNode
	UNCOMMITTED() antlr.TerminalNode
	SERIALIZABLE() antlr.TerminalNode

	// IsTransactionLevelBaseContext differentiates from other interfaces.
	IsTransactionLevelBaseContext()
}

type TransactionLevelBaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionLevelBaseContext() *TransactionLevelBaseContext {
	var p = new(TransactionLevelBaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_transactionLevelBase
	return p
}

func (*TransactionLevelBaseContext) IsTransactionLevelBaseContext() {}

func NewTransactionLevelBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionLevelBaseContext {
	var p = new(TransactionLevelBaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_transactionLevelBase

	return p
}

func (s *TransactionLevelBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionLevelBaseContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPEATABLE, 0)
}

func (s *TransactionLevelBaseContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMITTED, 0)
}

func (s *TransactionLevelBaseContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNCOMMITTED, 0)
}

func (s *TransactionLevelBaseContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSERIALIZABLE, 0)
}

func (s *TransactionLevelBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionLevelBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionLevelBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTransactionLevelBase(s)
	}
}

func (s *TransactionLevelBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTransactionLevelBase(s)
	}
}

func (p *MySqlParser) TransactionLevelBase() (localctx ITransactionLevelBaseContext) {
	this := p
	_ = this

	localctx = NewTransactionLevelBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 692, MySqlParserRULE_transactionLevelBase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7360)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-798)) & ^0x3f) == 0 && ((int64(1)<<(_la-798))&15) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPrivilegesBaseContext is an interface to support dynamic dispatch.
type IPrivilegesBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLES() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	EXECUTE() antlr.TerminalNode
	FILE() antlr.TerminalNode
	PROCESS() antlr.TerminalNode
	RELOAD() antlr.TerminalNode
	SHUTDOWN() antlr.TerminalNode
	SUPER() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode

	// IsPrivilegesBaseContext differentiates from other interfaces.
	IsPrivilegesBaseContext()
}

type PrivilegesBaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegesBaseContext() *PrivilegesBaseContext {
	var p = new(PrivilegesBaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_privilegesBase
	return p
}

func (*PrivilegesBaseContext) IsPrivilegesBaseContext() {}

func NewPrivilegesBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegesBaseContext {
	var p = new(PrivilegesBaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_privilegesBase

	return p
}

func (s *PrivilegesBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegesBaseContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLES, 0)
}

func (s *PrivilegesBaseContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROUTINE, 0)
}

func (s *PrivilegesBaseContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXECUTE, 0)
}

func (s *PrivilegesBaseContext) FILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFILE, 0)
}

func (s *PrivilegesBaseContext) PROCESS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROCESS, 0)
}

func (s *PrivilegesBaseContext) RELOAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELOAD, 0)
}

func (s *PrivilegesBaseContext) SHUTDOWN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHUTDOWN, 0)
}

func (s *PrivilegesBaseContext) SUPER() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUPER, 0)
}

func (s *PrivilegesBaseContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRIVILEGES, 0)
}

func (s *PrivilegesBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegesBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegesBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPrivilegesBase(s)
	}
}

func (s *PrivilegesBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPrivilegesBase(s)
	}
}

func (p *MySqlParser) PrivilegesBase() (localctx IPrivilegesBaseContext) {
	this := p
	_ = this

	localctx = NewPrivilegesBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 694, MySqlParserRULE_privilegesBase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7362)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-707)) & ^0x3f) == 0 && ((int64(1)<<(_la-707))&23656792067) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IIntervalTypeBaseContext is an interface to support dynamic dispatch.
type IIntervalTypeBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QUARTER() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	DAY() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	WEEK() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	MICROSECOND() antlr.TerminalNode

	// IsIntervalTypeBaseContext differentiates from other interfaces.
	IsIntervalTypeBaseContext()
}

type IntervalTypeBaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalTypeBaseContext() *IntervalTypeBaseContext {
	var p = new(IntervalTypeBaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_intervalTypeBase
	return p
}

func (*IntervalTypeBaseContext) IsIntervalTypeBaseContext() {}

func NewIntervalTypeBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalTypeBaseContext {
	var p = new(IntervalTypeBaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_intervalTypeBase

	return p
}

func (s *IntervalTypeBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalTypeBaseContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUARTER, 0)
}

func (s *IntervalTypeBaseContext) MONTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserMONTH, 0)
}

func (s *IntervalTypeBaseContext) DAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAY, 0)
}

func (s *IntervalTypeBaseContext) HOUR() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOUR, 0)
}

func (s *IntervalTypeBaseContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUTE, 0)
}

func (s *IntervalTypeBaseContext) WEEK() antlr.TerminalNode {
	return s.GetToken(MySqlParserWEEK, 0)
}

func (s *IntervalTypeBaseContext) SECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserSECOND, 0)
}

func (s *IntervalTypeBaseContext) MICROSECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserMICROSECOND, 0)
}

func (s *IntervalTypeBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalTypeBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalTypeBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIntervalTypeBase(s)
	}
}

func (s *IntervalTypeBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIntervalTypeBase(s)
	}
}

func (p *MySqlParser) IntervalTypeBase() (localctx IIntervalTypeBaseContext) {
	this := p
	_ = this

	localctx = NewIntervalTypeBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 696, MySqlParserRULE_intervalTypeBase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7364)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-689)) & ^0x3f) == 0 && ((int64(1)<<(_la-689))&255) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDataTypeBaseContext is an interface to support dynamic dispatch.
type IDataTypeBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DATE() antlr.TerminalNode
	TIME() antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode
	DATETIME() antlr.TerminalNode
	YEAR() antlr.TerminalNode
	ENUM() antlr.TerminalNode
	TEXT() antlr.TerminalNode

	// IsDataTypeBaseContext differentiates from other interfaces.
	IsDataTypeBaseContext()
}

type DataTypeBaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeBaseContext() *DataTypeBaseContext {
	var p = new(DataTypeBaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_dataTypeBase
	return p
}

func (*DataTypeBaseContext) IsDataTypeBaseContext() {}

func NewDataTypeBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeBaseContext {
	var p = new(DataTypeBaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dataTypeBase

	return p
}

func (s *DataTypeBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeBaseContext) DATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATE, 0)
}

func (s *DataTypeBaseContext) TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIME, 0)
}

func (s *DataTypeBaseContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIMESTAMP, 0)
}

func (s *DataTypeBaseContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATETIME, 0)
}

func (s *DataTypeBaseContext) YEAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserYEAR, 0)
}

func (s *DataTypeBaseContext) ENUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserENUM, 0)
}

func (s *DataTypeBaseContext) TEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserTEXT, 0)
}

func (s *DataTypeBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDataTypeBase(s)
	}
}

func (s *DataTypeBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDataTypeBase(s)
	}
}

func (p *MySqlParser) DataTypeBase() (localctx IDataTypeBaseContext) {
	this := p
	_ = this

	localctx = NewDataTypeBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 698, MySqlParserRULE_dataTypeBase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7366)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&1179679) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IKeywordsCanBeIdContext is an interface to support dynamic dispatch.
type IKeywordsCanBeIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ACCOUNT() antlr.TerminalNode
	ACTION() antlr.TerminalNode
	ADMIN() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	AGGREGATE() antlr.TerminalNode
	ALGORITHM() antlr.TerminalNode
	ANY() antlr.TerminalNode
	AT() antlr.TerminalNode
	AUDIT_ADMIN() antlr.TerminalNode
	AUDIT_ABORT_EXEMPT() antlr.TerminalNode
	AUTHORS() antlr.TerminalNode
	AUTOCOMMIT() antlr.TerminalNode
	AUTOEXTEND_SIZE() antlr.TerminalNode
	AUTO_INCREMENT() antlr.TerminalNode
	AVG() antlr.TerminalNode
	AVG_ROW_LENGTH() antlr.TerminalNode
	ATTRIBUTE() antlr.TerminalNode
	BACKUP_ADMIN() antlr.TerminalNode
	BEGIN() antlr.TerminalNode
	BINLOG() antlr.TerminalNode
	BINLOG_ADMIN() antlr.TerminalNode
	BINLOG_ENCRYPTION_ADMIN() antlr.TerminalNode
	BIT() antlr.TerminalNode
	BIT_AND() antlr.TerminalNode
	BIT_OR() antlr.TerminalNode
	BIT_XOR() antlr.TerminalNode
	BLOCK() antlr.TerminalNode
	BOOL() antlr.TerminalNode
	BOOLEAN() antlr.TerminalNode
	BTREE() antlr.TerminalNode
	BUCKETS() antlr.TerminalNode
	CACHE() antlr.TerminalNode
	CASCADED() antlr.TerminalNode
	CHAIN() antlr.TerminalNode
	CHANGED() antlr.TerminalNode
	CHANNEL() antlr.TerminalNode
	CHECKSUM() antlr.TerminalNode
	PAGE_CHECKSUM() antlr.TerminalNode
	CATALOG_NAME() antlr.TerminalNode
	CIPHER() antlr.TerminalNode
	CLASS_ORIGIN() antlr.TerminalNode
	CLIENT() antlr.TerminalNode
	CLONE_ADMIN() antlr.TerminalNode
	CLOSE() antlr.TerminalNode
	CLUSTERING() antlr.TerminalNode
	COALESCE() antlr.TerminalNode
	CODE() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	COLUMN_FORMAT() antlr.TerminalNode
	COLUMN_NAME() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	COMMIT() antlr.TerminalNode
	COMPACT() antlr.TerminalNode
	COMPLETION() antlr.TerminalNode
	COMPRESSED() antlr.TerminalNode
	COMPRESSION() antlr.TerminalNode
	CONCURRENT() antlr.TerminalNode
	CONDITION() antlr.TerminalNode
	CONNECT() antlr.TerminalNode
	CONNECTION() antlr.TerminalNode
	CONNECTION_ADMIN() antlr.TerminalNode
	CONSISTENT() antlr.TerminalNode
	CONSTRAINT_CATALOG() antlr.TerminalNode
	CONSTRAINT_NAME() antlr.TerminalNode
	CONSTRAINT_SCHEMA() antlr.TerminalNode
	CONTAINS() antlr.TerminalNode
	CONTEXT() antlr.TerminalNode
	CONTRIBUTORS() antlr.TerminalNode
	COPY() antlr.TerminalNode
	COUNT() antlr.TerminalNode
	CPU() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	CURRENT_USER() antlr.TerminalNode
	CURSOR_NAME() antlr.TerminalNode
	DATA() antlr.TerminalNode
	DATAFILE() antlr.TerminalNode
	DEALLOCATE() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	DEFAULT_AUTH() antlr.TerminalNode
	DEFINER() antlr.TerminalNode
	DELAY_KEY_WRITE() antlr.TerminalNode
	DES_KEY_FILE() antlr.TerminalNode
	DIAGNOSTICS() antlr.TerminalNode
	DIRECTORY() antlr.TerminalNode
	DISABLE() antlr.TerminalNode
	DISCARD() antlr.TerminalNode
	DISK() antlr.TerminalNode
	DO() antlr.TerminalNode
	DUMPFILE() antlr.TerminalNode
	DUPLICATE() antlr.TerminalNode
	DYNAMIC() antlr.TerminalNode
	EMPTY() antlr.TerminalNode
	ENABLE() antlr.TerminalNode
	ENCRYPTION() antlr.TerminalNode
	ENCRYPTION_KEY_ADMIN() antlr.TerminalNode
	END() antlr.TerminalNode
	ENDS() antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	ENGINE_ATTRIBUTE() antlr.TerminalNode
	ENGINES() antlr.TerminalNode
	ENFORCED() antlr.TerminalNode
	ERROR() antlr.TerminalNode
	ERRORS() antlr.TerminalNode
	ESCAPE() antlr.TerminalNode
	EUR() antlr.TerminalNode
	EVEN() antlr.TerminalNode
	EVENT() antlr.TerminalNode
	EVENTS() antlr.TerminalNode
	EVERY() antlr.TerminalNode
	EXCEPT() antlr.TerminalNode
	EXCHANGE() antlr.TerminalNode
	EXCLUSIVE() antlr.TerminalNode
	EXPIRE() antlr.TerminalNode
	EXPORT() antlr.TerminalNode
	EXTENDED() antlr.TerminalNode
	EXTENT_SIZE() antlr.TerminalNode
	FAILED_LOGIN_ATTEMPTS() antlr.TerminalNode
	FAST() antlr.TerminalNode
	FAULTS() antlr.TerminalNode
	FIELDS() antlr.TerminalNode
	FILE_BLOCK_SIZE() antlr.TerminalNode
	FILTER() antlr.TerminalNode
	FIREWALL_ADMIN() antlr.TerminalNode
	FIREWALL_EXEMPT() antlr.TerminalNode
	FIREWALL_USER() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	FIXED() antlr.TerminalNode
	FLUSH() antlr.TerminalNode
	FOLLOWS() antlr.TerminalNode
	FOUND() antlr.TerminalNode
	FULL() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	GENERAL() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	GRANTS() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	GROUP_CONCAT() antlr.TerminalNode
	GROUP_REPLICATION() antlr.TerminalNode
	GROUP_REPLICATION_ADMIN() antlr.TerminalNode
	HANDLER() antlr.TerminalNode
	HASH() antlr.TerminalNode
	HELP() antlr.TerminalNode
	HISTORY() antlr.TerminalNode
	HOST() antlr.TerminalNode
	HOSTS() antlr.TerminalNode
	IDENTIFIED() antlr.TerminalNode
	IGNORED() antlr.TerminalNode
	IGNORE_SERVER_IDS() antlr.TerminalNode
	IMPORT() antlr.TerminalNode
	INDEXES() antlr.TerminalNode
	INITIAL_SIZE() antlr.TerminalNode
	INNODB_REDO_LOG_ARCHIVE() antlr.TerminalNode
	INPLACE() antlr.TerminalNode
	INSERT_METHOD() antlr.TerminalNode
	INSTALL() antlr.TerminalNode
	INSTANCE() antlr.TerminalNode
	INSTANT() antlr.TerminalNode
	INTERNAL() antlr.TerminalNode
	INVOKE() antlr.TerminalNode
	INVOKER() antlr.TerminalNode
	IO() antlr.TerminalNode
	IO_THREAD() antlr.TerminalNode
	IPC() antlr.TerminalNode
	ISO() antlr.TerminalNode
	ISOLATION() antlr.TerminalNode
	ISSUER() antlr.TerminalNode
	JIS() antlr.TerminalNode
	JSON() antlr.TerminalNode
	KEY_BLOCK_SIZE() antlr.TerminalNode
	LAMBDA() antlr.TerminalNode
	LANGUAGE() antlr.TerminalNode
	LAST() antlr.TerminalNode
	LATERAL() antlr.TerminalNode
	LEAVES() antlr.TerminalNode
	LESS() antlr.TerminalNode
	LEVEL() antlr.TerminalNode
	LIST() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	LOGFILE() antlr.TerminalNode
	LOGS() antlr.TerminalNode
	MASTER() antlr.TerminalNode
	MASTER_AUTO_POSITION() antlr.TerminalNode
	MASTER_CONNECT_RETRY() antlr.TerminalNode
	MASTER_DELAY() antlr.TerminalNode
	MASTER_HEARTBEAT_PERIOD() antlr.TerminalNode
	MASTER_HOST() antlr.TerminalNode
	MASTER_LOG_FILE() antlr.TerminalNode
	MASTER_LOG_POS() antlr.TerminalNode
	MASTER_PASSWORD() antlr.TerminalNode
	MASTER_PORT() antlr.TerminalNode
	MASTER_RETRY_COUNT() antlr.TerminalNode
	MASTER_SSL() antlr.TerminalNode
	MASTER_SSL_CA() antlr.TerminalNode
	MASTER_SSL_CAPATH() antlr.TerminalNode
	MASTER_SSL_CERT() antlr.TerminalNode
	MASTER_SSL_CIPHER() antlr.TerminalNode
	MASTER_SSL_CRL() antlr.TerminalNode
	MASTER_SSL_CRLPATH() antlr.TerminalNode
	MASTER_SSL_KEY() antlr.TerminalNode
	MASTER_TLS_VERSION() antlr.TerminalNode
	MASTER_USER() antlr.TerminalNode
	MAX_CONNECTIONS_PER_HOUR() antlr.TerminalNode
	MAX_QUERIES_PER_HOUR() antlr.TerminalNode
	MAX() antlr.TerminalNode
	MAX_ROWS() antlr.TerminalNode
	MAX_SIZE() antlr.TerminalNode
	MAX_UPDATES_PER_HOUR() antlr.TerminalNode
	MAX_USER_CONNECTIONS() antlr.TerminalNode
	MEDIUM() antlr.TerminalNode
	MEMBER() antlr.TerminalNode
	MEMORY() antlr.TerminalNode
	MERGE() antlr.TerminalNode
	MESSAGE_TEXT() antlr.TerminalNode
	MID() antlr.TerminalNode
	MIGRATE() antlr.TerminalNode
	MIN() antlr.TerminalNode
	MIN_ROWS() antlr.TerminalNode
	MODE() antlr.TerminalNode
	MODIFY() antlr.TerminalNode
	MUTEX() antlr.TerminalNode
	MYSQL() antlr.TerminalNode
	MYSQL_ERRNO() antlr.TerminalNode
	NAME() antlr.TerminalNode
	NAMES() antlr.TerminalNode
	NCHAR() antlr.TerminalNode
	NDB_STORED_USER() antlr.TerminalNode
	NESTED() antlr.TerminalNode
	NEVER() antlr.TerminalNode
	NEXT() antlr.TerminalNode
	NO() antlr.TerminalNode
	NOCOPY() antlr.TerminalNode
	NODEGROUP() antlr.TerminalNode
	NONE() antlr.TerminalNode
	NOWAIT() antlr.TerminalNode
	NUMBER() antlr.TerminalNode
	ODBC() antlr.TerminalNode
	OFFLINE() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	OF() antlr.TerminalNode
	OJ() antlr.TerminalNode
	OLD_PASSWORD() antlr.TerminalNode
	ONE() antlr.TerminalNode
	ONLINE() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	OPEN() antlr.TerminalNode
	OPTIMIZER_COSTS() antlr.TerminalNode
	OPTIONAL() antlr.TerminalNode
	OPTIONS() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	ORDINALITY() antlr.TerminalNode
	OWNER() antlr.TerminalNode
	PACK_KEYS() antlr.TerminalNode
	PAGE() antlr.TerminalNode
	PARSER() antlr.TerminalNode
	PARTIAL() antlr.TerminalNode
	PARTITIONING() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	PASSWORDLESS_USER_ADMIN() antlr.TerminalNode
	PASSWORD_LOCK_TIME() antlr.TerminalNode
	PATH() antlr.TerminalNode
	PERSIST_RO_VARIABLES_ADMIN() antlr.TerminalNode
	PHASE() antlr.TerminalNode
	PLUGINS() antlr.TerminalNode
	PLUGIN_DIR() antlr.TerminalNode
	PLUGIN() antlr.TerminalNode
	PORT() antlr.TerminalNode
	PRECEDES() antlr.TerminalNode
	PREPARE() antlr.TerminalNode
	PRESERVE() antlr.TerminalNode
	PREV() antlr.TerminalNode
	PRIMARY() antlr.TerminalNode
	PROCESSLIST() antlr.TerminalNode
	PROFILE() antlr.TerminalNode
	PROFILES() antlr.TerminalNode
	PROXY() antlr.TerminalNode
	QUERY() antlr.TerminalNode
	QUICK() antlr.TerminalNode
	REBUILD() antlr.TerminalNode
	RECOVER() antlr.TerminalNode
	RECURSIVE() antlr.TerminalNode
	REDO_BUFFER_SIZE() antlr.TerminalNode
	REDUNDANT() antlr.TerminalNode
	RELAY() antlr.TerminalNode
	RELAYLOG() antlr.TerminalNode
	RELAY_LOG_FILE() antlr.TerminalNode
	RELAY_LOG_POS() antlr.TerminalNode
	REMOVE() antlr.TerminalNode
	REORGANIZE() antlr.TerminalNode
	REPAIR() antlr.TerminalNode
	REPLICATE_DO_DB() antlr.TerminalNode
	REPLICATE_DO_TABLE() antlr.TerminalNode
	REPLICATE_IGNORE_DB() antlr.TerminalNode
	REPLICATE_IGNORE_TABLE() antlr.TerminalNode
	REPLICATE_REWRITE_DB() antlr.TerminalNode
	REPLICATE_WILD_DO_TABLE() antlr.TerminalNode
	REPLICATE_WILD_IGNORE_TABLE() antlr.TerminalNode
	REPLICATION() antlr.TerminalNode
	REPLICATION_APPLIER() antlr.TerminalNode
	REPLICATION_SLAVE_ADMIN() antlr.TerminalNode
	RESET() antlr.TerminalNode
	RESOURCE_GROUP_ADMIN() antlr.TerminalNode
	RESOURCE_GROUP_USER() antlr.TerminalNode
	RESUME() antlr.TerminalNode
	RETURNED_SQLSTATE() antlr.TerminalNode
	RETURNS() antlr.TerminalNode
	REUSE() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	ROLE_ADMIN() antlr.TerminalNode
	ROLLBACK() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	ROTATE() antlr.TerminalNode
	ROW() antlr.TerminalNode
	ROWS() antlr.TerminalNode
	ROW_FORMAT() antlr.TerminalNode
	RTREE() antlr.TerminalNode
	S3() antlr.TerminalNode
	SAVEPOINT() antlr.TerminalNode
	SCHEDULE() antlr.TerminalNode
	SCHEMA_NAME() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	SECONDARY_ENGINE_ATTRIBUTE() antlr.TerminalNode
	SERIAL() antlr.TerminalNode
	SERVER() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	SESSION_VARIABLES_ADMIN() antlr.TerminalNode
	SET_USER_ID() antlr.TerminalNode
	SHARE() antlr.TerminalNode
	SHARED() antlr.TerminalNode
	SHOW_ROUTINE() antlr.TerminalNode
	SIGNED() antlr.TerminalNode
	SIMPLE() antlr.TerminalNode
	SLAVE() antlr.TerminalNode
	SLOW() antlr.TerminalNode
	SKIP_QUERY_REWRITE() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	SOCKET() antlr.TerminalNode
	SOME() antlr.TerminalNode
	SONAME() antlr.TerminalNode
	SOUNDS() antlr.TerminalNode
	SOURCE() antlr.TerminalNode
	SQL_AFTER_GTIDS() antlr.TerminalNode
	SQL_AFTER_MTS_GAPS() antlr.TerminalNode
	SQL_BEFORE_GTIDS() antlr.TerminalNode
	SQL_BUFFER_RESULT() antlr.TerminalNode
	SQL_CACHE() antlr.TerminalNode
	SQL_NO_CACHE() antlr.TerminalNode
	SQL_THREAD() antlr.TerminalNode
	STACKED() antlr.TerminalNode
	START() antlr.TerminalNode
	STARTS() antlr.TerminalNode
	STATS_AUTO_RECALC() antlr.TerminalNode
	STATS_PERSISTENT() antlr.TerminalNode
	STATS_SAMPLE_PAGES() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	STD() antlr.TerminalNode
	STDDEV() antlr.TerminalNode
	STDDEV_POP() antlr.TerminalNode
	STDDEV_SAMP() antlr.TerminalNode
	STOP() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	STRING() antlr.TerminalNode
	SUBCLASS_ORIGIN() antlr.TerminalNode
	SUBJECT() antlr.TerminalNode
	SUBPARTITION() antlr.TerminalNode
	SUBPARTITIONS() antlr.TerminalNode
	SUM() antlr.TerminalNode
	SUSPEND() antlr.TerminalNode
	SWAPS() antlr.TerminalNode
	SWITCHES() antlr.TerminalNode
	SYSTEM_VARIABLES_ADMIN() antlr.TerminalNode
	TABLE_NAME() antlr.TerminalNode
	TABLESPACE() antlr.TerminalNode
	TABLE_ENCRYPTION_ADMIN() antlr.TerminalNode
	TABLE_TYPE() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	TEMPTABLE() antlr.TerminalNode
	THAN() antlr.TerminalNode
	TP_CONNECTION_ADMIN() antlr.TerminalNode
	TRADITIONAL() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	TRANSACTIONAL() antlr.TerminalNode
	TRIGGERS() antlr.TerminalNode
	TRUNCATE() antlr.TerminalNode
	UNBOUNDED() antlr.TerminalNode
	UNDEFINED() antlr.TerminalNode
	UNDOFILE() antlr.TerminalNode
	UNDO_BUFFER_SIZE() antlr.TerminalNode
	UNINSTALL() antlr.TerminalNode
	UNKNOWN() antlr.TerminalNode
	UNTIL() antlr.TerminalNode
	UPGRADE() antlr.TerminalNode
	USA() antlr.TerminalNode
	USER() antlr.TerminalNode
	USE_FRM() antlr.TerminalNode
	USER_RESOURCES() antlr.TerminalNode
	VALIDATION() antlr.TerminalNode
	VALUE() antlr.TerminalNode
	VAR_POP() antlr.TerminalNode
	VAR_SAMP() antlr.TerminalNode
	VARIABLES() antlr.TerminalNode
	VARIANCE() antlr.TerminalNode
	VERSION_TOKEN_ADMIN() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	VIRTUAL() antlr.TerminalNode
	WAIT() antlr.TerminalNode
	WARNINGS() antlr.TerminalNode
	WITHOUT() antlr.TerminalNode
	WORK() antlr.TerminalNode
	WRAPPER() antlr.TerminalNode
	X509() antlr.TerminalNode
	XA() antlr.TerminalNode
	XA_RECOVER_ADMIN() antlr.TerminalNode
	XML() antlr.TerminalNode

	// IsKeywordsCanBeIdContext differentiates from other interfaces.
	IsKeywordsCanBeIdContext()
}

type KeywordsCanBeIdContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordsCanBeIdContext() *KeywordsCanBeIdContext {
	var p = new(KeywordsCanBeIdContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_keywordsCanBeId
	return p
}

func (*KeywordsCanBeIdContext) IsKeywordsCanBeIdContext() {}

func NewKeywordsCanBeIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordsCanBeIdContext {
	var p = new(KeywordsCanBeIdContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_keywordsCanBeId

	return p
}

func (s *KeywordsCanBeIdContext) GetParser() antlr.Parser { return s.parser }

func (s *KeywordsCanBeIdContext) ACCOUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserACCOUNT, 0)
}

func (s *KeywordsCanBeIdContext) ACTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserACTION, 0)
}

func (s *KeywordsCanBeIdContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserADMIN, 0)
}

func (s *KeywordsCanBeIdContext) AFTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserAFTER, 0)
}

func (s *KeywordsCanBeIdContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserAGGREGATE, 0)
}

func (s *KeywordsCanBeIdContext) ALGORITHM() antlr.TerminalNode {
	return s.GetToken(MySqlParserALGORITHM, 0)
}

func (s *KeywordsCanBeIdContext) ANY() antlr.TerminalNode {
	return s.GetToken(MySqlParserANY, 0)
}

func (s *KeywordsCanBeIdContext) AT() antlr.TerminalNode {
	return s.GetToken(MySqlParserAT, 0)
}

func (s *KeywordsCanBeIdContext) AUDIT_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUDIT_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) AUDIT_ABORT_EXEMPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUDIT_ABORT_EXEMPT, 0)
}

func (s *KeywordsCanBeIdContext) AUTHORS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUTHORS, 0)
}

func (s *KeywordsCanBeIdContext) AUTOCOMMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUTOCOMMIT, 0)
}

func (s *KeywordsCanBeIdContext) AUTOEXTEND_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUTOEXTEND_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUTO_INCREMENT, 0)
}

func (s *KeywordsCanBeIdContext) AVG() antlr.TerminalNode {
	return s.GetToken(MySqlParserAVG, 0)
}

func (s *KeywordsCanBeIdContext) AVG_ROW_LENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserAVG_ROW_LENGTH, 0)
}

func (s *KeywordsCanBeIdContext) ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserATTRIBUTE, 0)
}

func (s *KeywordsCanBeIdContext) BACKUP_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBACKUP_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBEGIN, 0)
}

func (s *KeywordsCanBeIdContext) BINLOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINLOG, 0)
}

func (s *KeywordsCanBeIdContext) BINLOG_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINLOG_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) BINLOG_ENCRYPTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINLOG_ENCRYPTION_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) BIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT, 0)
}

func (s *KeywordsCanBeIdContext) BIT_AND() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_AND, 0)
}

func (s *KeywordsCanBeIdContext) BIT_OR() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_OR, 0)
}

func (s *KeywordsCanBeIdContext) BIT_XOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_XOR, 0)
}

func (s *KeywordsCanBeIdContext) BLOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserBLOCK, 0)
}

func (s *KeywordsCanBeIdContext) BOOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserBOOL, 0)
}

func (s *KeywordsCanBeIdContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBOOLEAN, 0)
}

func (s *KeywordsCanBeIdContext) BTREE() antlr.TerminalNode {
	return s.GetToken(MySqlParserBTREE, 0)
}

func (s *KeywordsCanBeIdContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(MySqlParserBUCKETS, 0)
}

func (s *KeywordsCanBeIdContext) CACHE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCACHE, 0)
}

func (s *KeywordsCanBeIdContext) CASCADED() antlr.TerminalNode {
	return s.GetToken(MySqlParserCASCADED, 0)
}

func (s *KeywordsCanBeIdContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAIN, 0)
}

func (s *KeywordsCanBeIdContext) CHANGED() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHANGED, 0)
}

func (s *KeywordsCanBeIdContext) CHANNEL() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHANNEL, 0)
}

func (s *KeywordsCanBeIdContext) CHECKSUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHECKSUM, 0)
}

func (s *KeywordsCanBeIdContext) PAGE_CHECKSUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserPAGE_CHECKSUM, 0)
}

func (s *KeywordsCanBeIdContext) CATALOG_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCATALOG_NAME, 0)
}

func (s *KeywordsCanBeIdContext) CIPHER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCIPHER, 0)
}

func (s *KeywordsCanBeIdContext) CLASS_ORIGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCLASS_ORIGIN, 0)
}

func (s *KeywordsCanBeIdContext) CLIENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCLIENT, 0)
}

func (s *KeywordsCanBeIdContext) CLONE_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCLONE_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) CLOSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCLOSE, 0)
}

func (s *KeywordsCanBeIdContext) CLUSTERING() antlr.TerminalNode {
	return s.GetToken(MySqlParserCLUSTERING, 0)
}

func (s *KeywordsCanBeIdContext) COALESCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOALESCE, 0)
}

func (s *KeywordsCanBeIdContext) CODE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCODE, 0)
}

func (s *KeywordsCanBeIdContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMNS, 0)
}

func (s *KeywordsCanBeIdContext) COLUMN_FORMAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN_FORMAT, 0)
}

func (s *KeywordsCanBeIdContext) COLUMN_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN_NAME, 0)
}

func (s *KeywordsCanBeIdContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT, 0)
}

func (s *KeywordsCanBeIdContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMIT, 0)
}

func (s *KeywordsCanBeIdContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMPACT, 0)
}

func (s *KeywordsCanBeIdContext) COMPLETION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMPLETION, 0)
}

func (s *KeywordsCanBeIdContext) COMPRESSED() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMPRESSED, 0)
}

func (s *KeywordsCanBeIdContext) COMPRESSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMPRESSION, 0)
}

func (s *KeywordsCanBeIdContext) CONCURRENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONCURRENT, 0)
}

func (s *KeywordsCanBeIdContext) CONDITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONDITION, 0)
}

func (s *KeywordsCanBeIdContext) CONNECT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONNECT, 0)
}

func (s *KeywordsCanBeIdContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONNECTION, 0)
}

func (s *KeywordsCanBeIdContext) CONNECTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONNECTION_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) CONSISTENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSISTENT, 0)
}

func (s *KeywordsCanBeIdContext) CONSTRAINT_CATALOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT_CATALOG, 0)
}

func (s *KeywordsCanBeIdContext) CONSTRAINT_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT_NAME, 0)
}

func (s *KeywordsCanBeIdContext) CONSTRAINT_SCHEMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT_SCHEMA, 0)
}

func (s *KeywordsCanBeIdContext) CONTAINS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONTAINS, 0)
}

func (s *KeywordsCanBeIdContext) CONTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONTEXT, 0)
}

func (s *KeywordsCanBeIdContext) CONTRIBUTORS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONTRIBUTORS, 0)
}

func (s *KeywordsCanBeIdContext) COPY() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOPY, 0)
}

func (s *KeywordsCanBeIdContext) COUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOUNT, 0)
}

func (s *KeywordsCanBeIdContext) CPU() antlr.TerminalNode {
	return s.GetToken(MySqlParserCPU, 0)
}

func (s *KeywordsCanBeIdContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT, 0)
}

func (s *KeywordsCanBeIdContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT_USER, 0)
}

func (s *KeywordsCanBeIdContext) CURSOR_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURSOR_NAME, 0)
}

func (s *KeywordsCanBeIdContext) DATA() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATA, 0)
}

func (s *KeywordsCanBeIdContext) DATAFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATAFILE, 0)
}

func (s *KeywordsCanBeIdContext) DEALLOCATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEALLOCATE, 0)
}

func (s *KeywordsCanBeIdContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT, 0)
}

func (s *KeywordsCanBeIdContext) DEFAULT_AUTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT_AUTH, 0)
}

func (s *KeywordsCanBeIdContext) DEFINER() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFINER, 0)
}

func (s *KeywordsCanBeIdContext) DELAY_KEY_WRITE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDELAY_KEY_WRITE, 0)
}

func (s *KeywordsCanBeIdContext) DES_KEY_FILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDES_KEY_FILE, 0)
}

func (s *KeywordsCanBeIdContext) DIAGNOSTICS() antlr.TerminalNode {
	return s.GetToken(MySqlParserDIAGNOSTICS, 0)
}

func (s *KeywordsCanBeIdContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserDIRECTORY, 0)
}

func (s *KeywordsCanBeIdContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISABLE, 0)
}

func (s *KeywordsCanBeIdContext) DISCARD() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISCARD, 0)
}

func (s *KeywordsCanBeIdContext) DISK() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISK, 0)
}

func (s *KeywordsCanBeIdContext) DO() antlr.TerminalNode {
	return s.GetToken(MySqlParserDO, 0)
}

func (s *KeywordsCanBeIdContext) DUMPFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDUMPFILE, 0)
}

func (s *KeywordsCanBeIdContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDUPLICATE, 0)
}

func (s *KeywordsCanBeIdContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDYNAMIC, 0)
}

func (s *KeywordsCanBeIdContext) EMPTY() antlr.TerminalNode {
	return s.GetToken(MySqlParserEMPTY, 0)
}

func (s *KeywordsCanBeIdContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENABLE, 0)
}

func (s *KeywordsCanBeIdContext) ENCRYPTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserENCRYPTION, 0)
}

func (s *KeywordsCanBeIdContext) ENCRYPTION_KEY_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserENCRYPTION_KEY_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) END() antlr.TerminalNode {
	return s.GetToken(MySqlParserEND, 0)
}

func (s *KeywordsCanBeIdContext) ENDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserENDS, 0)
}

func (s *KeywordsCanBeIdContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE, 0)
}

func (s *KeywordsCanBeIdContext) ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE_ATTRIBUTE, 0)
}

func (s *KeywordsCanBeIdContext) ENGINES() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINES, 0)
}

func (s *KeywordsCanBeIdContext) ENFORCED() antlr.TerminalNode {
	return s.GetToken(MySqlParserENFORCED, 0)
}

func (s *KeywordsCanBeIdContext) ERROR() antlr.TerminalNode {
	return s.GetToken(MySqlParserERROR, 0)
}

func (s *KeywordsCanBeIdContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(MySqlParserERRORS, 0)
}

func (s *KeywordsCanBeIdContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(MySqlParserESCAPE, 0)
}

func (s *KeywordsCanBeIdContext) EUR() antlr.TerminalNode {
	return s.GetToken(MySqlParserEUR, 0)
}

func (s *KeywordsCanBeIdContext) EVEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVEN, 0)
}

func (s *KeywordsCanBeIdContext) EVENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVENT, 0)
}

func (s *KeywordsCanBeIdContext) EVENTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVENTS, 0)
}

func (s *KeywordsCanBeIdContext) EVERY() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVERY, 0)
}

func (s *KeywordsCanBeIdContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCEPT, 0)
}

func (s *KeywordsCanBeIdContext) EXCHANGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCHANGE, 0)
}

func (s *KeywordsCanBeIdContext) EXCLUSIVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCLUSIVE, 0)
}

func (s *KeywordsCanBeIdContext) EXPIRE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXPIRE, 0)
}

func (s *KeywordsCanBeIdContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXPORT, 0)
}

func (s *KeywordsCanBeIdContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXTENDED, 0)
}

func (s *KeywordsCanBeIdContext) EXTENT_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXTENT_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) FAILED_LOGIN_ATTEMPTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFAILED_LOGIN_ATTEMPTS, 0)
}

func (s *KeywordsCanBeIdContext) FAST() antlr.TerminalNode {
	return s.GetToken(MySqlParserFAST, 0)
}

func (s *KeywordsCanBeIdContext) FAULTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFAULTS, 0)
}

func (s *KeywordsCanBeIdContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIELDS, 0)
}

func (s *KeywordsCanBeIdContext) FILE_BLOCK_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFILE_BLOCK_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) FILTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserFILTER, 0)
}

func (s *KeywordsCanBeIdContext) FIREWALL_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIREWALL_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) FIREWALL_EXEMPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIREWALL_EXEMPT, 0)
}

func (s *KeywordsCanBeIdContext) FIREWALL_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIREWALL_USER, 0)
}

func (s *KeywordsCanBeIdContext) FIRST() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIRST, 0)
}

func (s *KeywordsCanBeIdContext) FIXED() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIXED, 0)
}

func (s *KeywordsCanBeIdContext) FLUSH() antlr.TerminalNode {
	return s.GetToken(MySqlParserFLUSH, 0)
}

func (s *KeywordsCanBeIdContext) FOLLOWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOLLOWS, 0)
}

func (s *KeywordsCanBeIdContext) FOUND() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOUND, 0)
}

func (s *KeywordsCanBeIdContext) FULL() antlr.TerminalNode {
	return s.GetToken(MySqlParserFULL, 0)
}

func (s *KeywordsCanBeIdContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserFUNCTION, 0)
}

func (s *KeywordsCanBeIdContext) GENERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserGENERAL, 0)
}

func (s *KeywordsCanBeIdContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserGLOBAL, 0)
}

func (s *KeywordsCanBeIdContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserGRANTS, 0)
}

func (s *KeywordsCanBeIdContext) GROUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP, 0)
}

func (s *KeywordsCanBeIdContext) GROUP_CONCAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP_CONCAT, 0)
}

func (s *KeywordsCanBeIdContext) GROUP_REPLICATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP_REPLICATION, 0)
}

func (s *KeywordsCanBeIdContext) GROUP_REPLICATION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP_REPLICATION_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) HANDLER() antlr.TerminalNode {
	return s.GetToken(MySqlParserHANDLER, 0)
}

func (s *KeywordsCanBeIdContext) HASH() antlr.TerminalNode {
	return s.GetToken(MySqlParserHASH, 0)
}

func (s *KeywordsCanBeIdContext) HELP() antlr.TerminalNode {
	return s.GetToken(MySqlParserHELP, 0)
}

func (s *KeywordsCanBeIdContext) HISTORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserHISTORY, 0)
}

func (s *KeywordsCanBeIdContext) HOST() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOST, 0)
}

func (s *KeywordsCanBeIdContext) HOSTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOSTS, 0)
}

func (s *KeywordsCanBeIdContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(MySqlParserIDENTIFIED, 0)
}

func (s *KeywordsCanBeIdContext) IGNORED() antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORED, 0)
}

func (s *KeywordsCanBeIdContext) IGNORE_SERVER_IDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE_SERVER_IDS, 0)
}

func (s *KeywordsCanBeIdContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(MySqlParserIMPORT, 0)
}

func (s *KeywordsCanBeIdContext) INDEXES() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEXES, 0)
}

func (s *KeywordsCanBeIdContext) INITIAL_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINITIAL_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) INNODB_REDO_LOG_ARCHIVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINNODB_REDO_LOG_ARCHIVE, 0)
}

func (s *KeywordsCanBeIdContext) INPLACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINPLACE, 0)
}

func (s *KeywordsCanBeIdContext) INSERT_METHOD() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSERT_METHOD, 0)
}

func (s *KeywordsCanBeIdContext) INSTALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSTALL, 0)
}

func (s *KeywordsCanBeIdContext) INSTANCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSTANCE, 0)
}

func (s *KeywordsCanBeIdContext) INSTANT() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSTANT, 0)
}

func (s *KeywordsCanBeIdContext) INTERNAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTERNAL, 0)
}

func (s *KeywordsCanBeIdContext) INVOKE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINVOKE, 0)
}

func (s *KeywordsCanBeIdContext) INVOKER() antlr.TerminalNode {
	return s.GetToken(MySqlParserINVOKER, 0)
}

func (s *KeywordsCanBeIdContext) IO() antlr.TerminalNode {
	return s.GetToken(MySqlParserIO, 0)
}

func (s *KeywordsCanBeIdContext) IO_THREAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserIO_THREAD, 0)
}

func (s *KeywordsCanBeIdContext) IPC() antlr.TerminalNode {
	return s.GetToken(MySqlParserIPC, 0)
}

func (s *KeywordsCanBeIdContext) ISO() antlr.TerminalNode {
	return s.GetToken(MySqlParserISO, 0)
}

func (s *KeywordsCanBeIdContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserISOLATION, 0)
}

func (s *KeywordsCanBeIdContext) ISSUER() antlr.TerminalNode {
	return s.GetToken(MySqlParserISSUER, 0)
}

func (s *KeywordsCanBeIdContext) JIS() antlr.TerminalNode {
	return s.GetToken(MySqlParserJIS, 0)
}

func (s *KeywordsCanBeIdContext) JSON() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON, 0)
}

func (s *KeywordsCanBeIdContext) KEY_BLOCK_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY_BLOCK_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) LAMBDA() antlr.TerminalNode {
	return s.GetToken(MySqlParserLAMBDA, 0)
}

func (s *KeywordsCanBeIdContext) LANGUAGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLANGUAGE, 0)
}

func (s *KeywordsCanBeIdContext) LAST() antlr.TerminalNode {
	return s.GetToken(MySqlParserLAST, 0)
}

func (s *KeywordsCanBeIdContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLATERAL, 0)
}

func (s *KeywordsCanBeIdContext) LEAVES() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEAVES, 0)
}

func (s *KeywordsCanBeIdContext) LESS() antlr.TerminalNode {
	return s.GetToken(MySqlParserLESS, 0)
}

func (s *KeywordsCanBeIdContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEVEL, 0)
}

func (s *KeywordsCanBeIdContext) LIST() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIST, 0)
}

func (s *KeywordsCanBeIdContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL, 0)
}

func (s *KeywordsCanBeIdContext) LOGFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOGFILE, 0)
}

func (s *KeywordsCanBeIdContext) LOGS() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOGS, 0)
}

func (s *KeywordsCanBeIdContext) MASTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_AUTO_POSITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_AUTO_POSITION, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_CONNECT_RETRY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_CONNECT_RETRY, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_DELAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_DELAY, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_HEARTBEAT_PERIOD() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_HEARTBEAT_PERIOD, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_HOST() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_HOST, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_LOG_FILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_LOG_FILE, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_LOG_POS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_LOG_POS, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_PASSWORD, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_PORT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_PORT, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_RETRY_COUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_RETRY_COUNT, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CA() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CA, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CAPATH() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CAPATH, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CERT, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CIPHER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CIPHER, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CRL() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CRL, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CRLPATH() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CRLPATH, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_KEY, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_TLS_VERSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_TLS_VERSION, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_USER, 0)
}

func (s *KeywordsCanBeIdContext) MAX_CONNECTIONS_PER_HOUR() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_CONNECTIONS_PER_HOUR, 0)
}

func (s *KeywordsCanBeIdContext) MAX_QUERIES_PER_HOUR() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_QUERIES_PER_HOUR, 0)
}

func (s *KeywordsCanBeIdContext) MAX() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX, 0)
}

func (s *KeywordsCanBeIdContext) MAX_ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_ROWS, 0)
}

func (s *KeywordsCanBeIdContext) MAX_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) MAX_UPDATES_PER_HOUR() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_UPDATES_PER_HOUR, 0)
}

func (s *KeywordsCanBeIdContext) MAX_USER_CONNECTIONS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_USER_CONNECTIONS, 0)
}

func (s *KeywordsCanBeIdContext) MEDIUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEDIUM, 0)
}

func (s *KeywordsCanBeIdContext) MEMBER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEMBER, 0)
}

func (s *KeywordsCanBeIdContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEMORY, 0)
}

func (s *KeywordsCanBeIdContext) MERGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMERGE, 0)
}

func (s *KeywordsCanBeIdContext) MESSAGE_TEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMESSAGE_TEXT, 0)
}

func (s *KeywordsCanBeIdContext) MID() antlr.TerminalNode {
	return s.GetToken(MySqlParserMID, 0)
}

func (s *KeywordsCanBeIdContext) MIGRATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMIGRATE, 0)
}

func (s *KeywordsCanBeIdContext) MIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserMIN, 0)
}

func (s *KeywordsCanBeIdContext) MIN_ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMIN_ROWS, 0)
}

func (s *KeywordsCanBeIdContext) MODE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMODE, 0)
}

func (s *KeywordsCanBeIdContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMODIFY, 0)
}

func (s *KeywordsCanBeIdContext) MUTEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserMUTEX, 0)
}

func (s *KeywordsCanBeIdContext) MYSQL() antlr.TerminalNode {
	return s.GetToken(MySqlParserMYSQL, 0)
}

func (s *KeywordsCanBeIdContext) MYSQL_ERRNO() antlr.TerminalNode {
	return s.GetToken(MySqlParserMYSQL_ERRNO, 0)
}

func (s *KeywordsCanBeIdContext) NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserNAME, 0)
}

func (s *KeywordsCanBeIdContext) NAMES() antlr.TerminalNode {
	return s.GetToken(MySqlParserNAMES, 0)
}

func (s *KeywordsCanBeIdContext) NCHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserNCHAR, 0)
}

func (s *KeywordsCanBeIdContext) NDB_STORED_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserNDB_STORED_USER, 0)
}

func (s *KeywordsCanBeIdContext) NESTED() antlr.TerminalNode {
	return s.GetToken(MySqlParserNESTED, 0)
}

func (s *KeywordsCanBeIdContext) NEVER() antlr.TerminalNode {
	return s.GetToken(MySqlParserNEVER, 0)
}

func (s *KeywordsCanBeIdContext) NEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNEXT, 0)
}

func (s *KeywordsCanBeIdContext) NO() antlr.TerminalNode {
	return s.GetToken(MySqlParserNO, 0)
}

func (s *KeywordsCanBeIdContext) NOCOPY() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOCOPY, 0)
}

func (s *KeywordsCanBeIdContext) NODEGROUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserNODEGROUP, 0)
}

func (s *KeywordsCanBeIdContext) NONE() antlr.TerminalNode {
	return s.GetToken(MySqlParserNONE, 0)
}

func (s *KeywordsCanBeIdContext) NOWAIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOWAIT, 0)
}

func (s *KeywordsCanBeIdContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(MySqlParserNUMBER, 0)
}

func (s *KeywordsCanBeIdContext) ODBC() antlr.TerminalNode {
	return s.GetToken(MySqlParserODBC, 0)
}

func (s *KeywordsCanBeIdContext) OFFLINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserOFFLINE, 0)
}

func (s *KeywordsCanBeIdContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(MySqlParserOFFSET, 0)
}

func (s *KeywordsCanBeIdContext) OF() antlr.TerminalNode {
	return s.GetToken(MySqlParserOF, 0)
}

func (s *KeywordsCanBeIdContext) OJ() antlr.TerminalNode {
	return s.GetToken(MySqlParserOJ, 0)
}

func (s *KeywordsCanBeIdContext) OLD_PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserOLD_PASSWORD, 0)
}

func (s *KeywordsCanBeIdContext) ONE() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE, 0)
}

func (s *KeywordsCanBeIdContext) ONLINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserONLINE, 0)
}

func (s *KeywordsCanBeIdContext) ONLY() antlr.TerminalNode {
	return s.GetToken(MySqlParserONLY, 0)
}

func (s *KeywordsCanBeIdContext) OPEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPEN, 0)
}

func (s *KeywordsCanBeIdContext) OPTIMIZER_COSTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTIMIZER_COSTS, 0)
}

func (s *KeywordsCanBeIdContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTIONAL, 0)
}

func (s *KeywordsCanBeIdContext) OPTIONS() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTIONS, 0)
}

func (s *KeywordsCanBeIdContext) ORDER() antlr.TerminalNode {
	return s.GetToken(MySqlParserORDER, 0)
}

func (s *KeywordsCanBeIdContext) ORDINALITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserORDINALITY, 0)
}

func (s *KeywordsCanBeIdContext) OWNER() antlr.TerminalNode {
	return s.GetToken(MySqlParserOWNER, 0)
}

func (s *KeywordsCanBeIdContext) PACK_KEYS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPACK_KEYS, 0)
}

func (s *KeywordsCanBeIdContext) PAGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPAGE, 0)
}

func (s *KeywordsCanBeIdContext) PARSER() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARSER, 0)
}

func (s *KeywordsCanBeIdContext) PARTIAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTIAL, 0)
}

func (s *KeywordsCanBeIdContext) PARTITIONING() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITIONING, 0)
}

func (s *KeywordsCanBeIdContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITIONS, 0)
}

func (s *KeywordsCanBeIdContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD, 0)
}

func (s *KeywordsCanBeIdContext) PASSWORDLESS_USER_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORDLESS_USER_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) PASSWORD_LOCK_TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD_LOCK_TIME, 0)
}

func (s *KeywordsCanBeIdContext) PATH() antlr.TerminalNode {
	return s.GetToken(MySqlParserPATH, 0)
}

func (s *KeywordsCanBeIdContext) PERSIST_RO_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserPERSIST_RO_VARIABLES_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) PHASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPHASE, 0)
}

func (s *KeywordsCanBeIdContext) PLUGINS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPLUGINS, 0)
}

func (s *KeywordsCanBeIdContext) PLUGIN_DIR() antlr.TerminalNode {
	return s.GetToken(MySqlParserPLUGIN_DIR, 0)
}

func (s *KeywordsCanBeIdContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserPLUGIN, 0)
}

func (s *KeywordsCanBeIdContext) PORT() antlr.TerminalNode {
	return s.GetToken(MySqlParserPORT, 0)
}

func (s *KeywordsCanBeIdContext) PRECEDES() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRECEDES, 0)
}

func (s *KeywordsCanBeIdContext) PREPARE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPREPARE, 0)
}

func (s *KeywordsCanBeIdContext) PRESERVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRESERVE, 0)
}

func (s *KeywordsCanBeIdContext) PREV() antlr.TerminalNode {
	return s.GetToken(MySqlParserPREV, 0)
}

func (s *KeywordsCanBeIdContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRIMARY, 0)
}

func (s *KeywordsCanBeIdContext) PROCESSLIST() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROCESSLIST, 0)
}

func (s *KeywordsCanBeIdContext) PROFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROFILE, 0)
}

func (s *KeywordsCanBeIdContext) PROFILES() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROFILES, 0)
}

func (s *KeywordsCanBeIdContext) PROXY() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROXY, 0)
}

func (s *KeywordsCanBeIdContext) QUERY() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUERY, 0)
}

func (s *KeywordsCanBeIdContext) QUICK() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUICK, 0)
}

func (s *KeywordsCanBeIdContext) REBUILD() antlr.TerminalNode {
	return s.GetToken(MySqlParserREBUILD, 0)
}

func (s *KeywordsCanBeIdContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(MySqlParserRECOVER, 0)
}

func (s *KeywordsCanBeIdContext) RECURSIVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRECURSIVE, 0)
}

func (s *KeywordsCanBeIdContext) REDO_BUFFER_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREDO_BUFFER_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) REDUNDANT() antlr.TerminalNode {
	return s.GetToken(MySqlParserREDUNDANT, 0)
}

func (s *KeywordsCanBeIdContext) RELAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELAY, 0)
}

func (s *KeywordsCanBeIdContext) RELAYLOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELAYLOG, 0)
}

func (s *KeywordsCanBeIdContext) RELAY_LOG_FILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELAY_LOG_FILE, 0)
}

func (s *KeywordsCanBeIdContext) RELAY_LOG_POS() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELAY_LOG_POS, 0)
}

func (s *KeywordsCanBeIdContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREMOVE, 0)
}

func (s *KeywordsCanBeIdContext) REORGANIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREORGANIZE, 0)
}

func (s *KeywordsCanBeIdContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPAIR, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_DO_DB() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_DO_DB, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_DO_TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_DO_TABLE, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_IGNORE_DB() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_IGNORE_DB, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_IGNORE_TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_IGNORE_TABLE, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_REWRITE_DB() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_REWRITE_DB, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_WILD_DO_TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_WILD_DO_TABLE, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_WILD_IGNORE_TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_WILD_IGNORE_TABLE, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATION, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATION_APPLIER() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATION_APPLIER, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATION_SLAVE_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATION_SLAVE_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) RESET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESET, 0)
}

func (s *KeywordsCanBeIdContext) RESOURCE_GROUP_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESOURCE_GROUP_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) RESOURCE_GROUP_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESOURCE_GROUP_USER, 0)
}

func (s *KeywordsCanBeIdContext) RESUME() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESUME, 0)
}

func (s *KeywordsCanBeIdContext) RETURNED_SQLSTATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRETURNED_SQLSTATE, 0)
}

func (s *KeywordsCanBeIdContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(MySqlParserRETURNS, 0)
}

func (s *KeywordsCanBeIdContext) REUSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREUSE, 0)
}

func (s *KeywordsCanBeIdContext) ROLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLE, 0)
}

func (s *KeywordsCanBeIdContext) ROLE_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLE_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLLBACK, 0)
}

func (s *KeywordsCanBeIdContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLLUP, 0)
}

func (s *KeywordsCanBeIdContext) ROTATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROTATE, 0)
}

func (s *KeywordsCanBeIdContext) ROW() antlr.TerminalNode {
	return s.GetToken(MySqlParserROW, 0)
}

func (s *KeywordsCanBeIdContext) ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserROWS, 0)
}

func (s *KeywordsCanBeIdContext) ROW_FORMAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserROW_FORMAT, 0)
}

func (s *KeywordsCanBeIdContext) RTREE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRTREE, 0)
}

func (s *KeywordsCanBeIdContext) S3() antlr.TerminalNode {
	return s.GetToken(MySqlParserS3, 0)
}

func (s *KeywordsCanBeIdContext) SAVEPOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSAVEPOINT, 0)
}

func (s *KeywordsCanBeIdContext) SCHEDULE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEDULE, 0)
}

func (s *KeywordsCanBeIdContext) SCHEMA_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEMA_NAME, 0)
}

func (s *KeywordsCanBeIdContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserSECURITY, 0)
}

func (s *KeywordsCanBeIdContext) SECONDARY_ENGINE_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSECONDARY_ENGINE_ATTRIBUTE, 0)
}

func (s *KeywordsCanBeIdContext) SERIAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSERIAL, 0)
}

func (s *KeywordsCanBeIdContext) SERVER() antlr.TerminalNode {
	return s.GetToken(MySqlParserSERVER, 0)
}

func (s *KeywordsCanBeIdContext) SESSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserSESSION, 0)
}

func (s *KeywordsCanBeIdContext) SESSION_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSESSION_VARIABLES_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) SET_USER_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET_USER_ID, 0)
}

func (s *KeywordsCanBeIdContext) SHARE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHARE, 0)
}

func (s *KeywordsCanBeIdContext) SHARED() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHARED, 0)
}

func (s *KeywordsCanBeIdContext) SHOW_ROUTINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW_ROUTINE, 0)
}

func (s *KeywordsCanBeIdContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(MySqlParserSIGNED, 0)
}

func (s *KeywordsCanBeIdContext) SIMPLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSIMPLE, 0)
}

func (s *KeywordsCanBeIdContext) SLAVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSLAVE, 0)
}

func (s *KeywordsCanBeIdContext) SLOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSLOW, 0)
}

func (s *KeywordsCanBeIdContext) SKIP_QUERY_REWRITE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSKIP_QUERY_REWRITE, 0)
}

func (s *KeywordsCanBeIdContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSNAPSHOT, 0)
}

func (s *KeywordsCanBeIdContext) SOCKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSOCKET, 0)
}

func (s *KeywordsCanBeIdContext) SOME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSOME, 0)
}

func (s *KeywordsCanBeIdContext) SONAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSONAME, 0)
}

func (s *KeywordsCanBeIdContext) SOUNDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSOUNDS, 0)
}

func (s *KeywordsCanBeIdContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSOURCE, 0)
}

func (s *KeywordsCanBeIdContext) SQL_AFTER_GTIDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_AFTER_GTIDS, 0)
}

func (s *KeywordsCanBeIdContext) SQL_AFTER_MTS_GAPS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_AFTER_MTS_GAPS, 0)
}

func (s *KeywordsCanBeIdContext) SQL_BEFORE_GTIDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_BEFORE_GTIDS, 0)
}

func (s *KeywordsCanBeIdContext) SQL_BUFFER_RESULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_BUFFER_RESULT, 0)
}

func (s *KeywordsCanBeIdContext) SQL_CACHE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_CACHE, 0)
}

func (s *KeywordsCanBeIdContext) SQL_NO_CACHE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_NO_CACHE, 0)
}

func (s *KeywordsCanBeIdContext) SQL_THREAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_THREAD, 0)
}

func (s *KeywordsCanBeIdContext) STACKED() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTACKED, 0)
}

func (s *KeywordsCanBeIdContext) START() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTART, 0)
}

func (s *KeywordsCanBeIdContext) STARTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTARTS, 0)
}

func (s *KeywordsCanBeIdContext) STATS_AUTO_RECALC() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATS_AUTO_RECALC, 0)
}

func (s *KeywordsCanBeIdContext) STATS_PERSISTENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATS_PERSISTENT, 0)
}

func (s *KeywordsCanBeIdContext) STATS_SAMPLE_PAGES() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATS_SAMPLE_PAGES, 0)
}

func (s *KeywordsCanBeIdContext) STATUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATUS, 0)
}

func (s *KeywordsCanBeIdContext) STD() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTD, 0)
}

func (s *KeywordsCanBeIdContext) STDDEV() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTDDEV, 0)
}

func (s *KeywordsCanBeIdContext) STDDEV_POP() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTDDEV_POP, 0)
}

func (s *KeywordsCanBeIdContext) STDDEV_SAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTDDEV_SAMP, 0)
}

func (s *KeywordsCanBeIdContext) STOP() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTOP, 0)
}

func (s *KeywordsCanBeIdContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTORAGE, 0)
}

func (s *KeywordsCanBeIdContext) STRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING, 0)
}

func (s *KeywordsCanBeIdContext) SUBCLASS_ORIGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBCLASS_ORIGIN, 0)
}

func (s *KeywordsCanBeIdContext) SUBJECT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBJECT, 0)
}

func (s *KeywordsCanBeIdContext) SUBPARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBPARTITION, 0)
}

func (s *KeywordsCanBeIdContext) SUBPARTITIONS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBPARTITIONS, 0)
}

func (s *KeywordsCanBeIdContext) SUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUM, 0)
}

func (s *KeywordsCanBeIdContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUSPEND, 0)
}

func (s *KeywordsCanBeIdContext) SWAPS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSWAPS, 0)
}

func (s *KeywordsCanBeIdContext) SWITCHES() antlr.TerminalNode {
	return s.GetToken(MySqlParserSWITCHES, 0)
}

func (s *KeywordsCanBeIdContext) SYSTEM_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSYSTEM_VARIABLES_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) TABLE_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE_NAME, 0)
}

func (s *KeywordsCanBeIdContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLESPACE, 0)
}

func (s *KeywordsCanBeIdContext) TABLE_ENCRYPTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE_ENCRYPTION_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) TABLE_TYPE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE_TYPE, 0)
}

func (s *KeywordsCanBeIdContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserTEMPORARY, 0)
}

func (s *KeywordsCanBeIdContext) TEMPTABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTEMPTABLE, 0)
}

func (s *KeywordsCanBeIdContext) THAN() antlr.TerminalNode {
	return s.GetToken(MySqlParserTHAN, 0)
}

func (s *KeywordsCanBeIdContext) TP_CONNECTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserTP_CONNECTION_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) TRADITIONAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRADITIONAL, 0)
}

func (s *KeywordsCanBeIdContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRANSACTION, 0)
}

func (s *KeywordsCanBeIdContext) TRANSACTIONAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRANSACTIONAL, 0)
}

func (s *KeywordsCanBeIdContext) TRIGGERS() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRIGGERS, 0)
}

func (s *KeywordsCanBeIdContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRUNCATE, 0)
}

func (s *KeywordsCanBeIdContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNBOUNDED, 0)
}

func (s *KeywordsCanBeIdContext) UNDEFINED() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNDEFINED, 0)
}

func (s *KeywordsCanBeIdContext) UNDOFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNDOFILE, 0)
}

func (s *KeywordsCanBeIdContext) UNDO_BUFFER_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNDO_BUFFER_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) UNINSTALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNINSTALL, 0)
}

func (s *KeywordsCanBeIdContext) UNKNOWN() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNKNOWN, 0)
}

func (s *KeywordsCanBeIdContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNTIL, 0)
}

func (s *KeywordsCanBeIdContext) UPGRADE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPGRADE, 0)
}

func (s *KeywordsCanBeIdContext) USA() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSA, 0)
}

func (s *KeywordsCanBeIdContext) USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER, 0)
}

func (s *KeywordsCanBeIdContext) USE_FRM() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSE_FRM, 0)
}

func (s *KeywordsCanBeIdContext) USER_RESOURCES() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER_RESOURCES, 0)
}

func (s *KeywordsCanBeIdContext) VALIDATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALIDATION, 0)
}

func (s *KeywordsCanBeIdContext) VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUE, 0)
}

func (s *KeywordsCanBeIdContext) VAR_POP() antlr.TerminalNode {
	return s.GetToken(MySqlParserVAR_POP, 0)
}

func (s *KeywordsCanBeIdContext) VAR_SAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserVAR_SAMP, 0)
}

func (s *KeywordsCanBeIdContext) VARIABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARIABLES, 0)
}

func (s *KeywordsCanBeIdContext) VARIANCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARIANCE, 0)
}

func (s *KeywordsCanBeIdContext) VERSION_TOKEN_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserVERSION_TOKEN_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) VIEW() antlr.TerminalNode {
	return s.GetToken(MySqlParserVIEW, 0)
}

func (s *KeywordsCanBeIdContext) VIRTUAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserVIRTUAL, 0)
}

func (s *KeywordsCanBeIdContext) WAIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserWAIT, 0)
}

func (s *KeywordsCanBeIdContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(MySqlParserWARNINGS, 0)
}

func (s *KeywordsCanBeIdContext) WITHOUT() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITHOUT, 0)
}

func (s *KeywordsCanBeIdContext) WORK() antlr.TerminalNode {
	return s.GetToken(MySqlParserWORK, 0)
}

func (s *KeywordsCanBeIdContext) WRAPPER() antlr.TerminalNode {
	return s.GetToken(MySqlParserWRAPPER, 0)
}

func (s *KeywordsCanBeIdContext) X509() antlr.TerminalNode {
	return s.GetToken(MySqlParserX509, 0)
}

func (s *KeywordsCanBeIdContext) XA() antlr.TerminalNode {
	return s.GetToken(MySqlParserXA, 0)
}

func (s *KeywordsCanBeIdContext) XA_RECOVER_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserXA_RECOVER_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) XML() antlr.TerminalNode {
	return s.GetToken(MySqlParserXML, 0)
}

func (s *KeywordsCanBeIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordsCanBeIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeywordsCanBeIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterKeywordsCanBeId(s)
	}
}

func (s *KeywordsCanBeIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitKeywordsCanBeId(s)
	}
}

func (p *MySqlParser) KeywordsCanBeId() (localctx IKeywordsCanBeIdContext) {
	this := p
	_ = this

	localctx = NewKeywordsCanBeIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 700, MySqlParserRULE_keywordsCanBeId)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7368)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&756890782757306368) != 0) || ((int64((_la-73)) & ^0x3f) == 0 && ((int64(1)<<(_la-73))&146666055054393409) != 0) || _la == MySqlParserSKIP_QUERY_REWRITE || _la == MySqlParserSTACKED || ((int64((_la-239)) & ^0x3f) == 0 && ((int64(1)<<(_la-239))&1769897061370560513) != 0) || ((int64((_la-305)) & ^0x3f) == 0 && ((int64(1)<<(_la-305))&-134217473) != 0) || ((int64((_la-369)) & ^0x3f) == 0 && ((int64(1)<<(_la-369))&-171798822913) != 0) || ((int64((_la-434)) & ^0x3f) == 0 && ((int64(1)<<(_la-434))&-33685505) != 0) || ((int64((_la-498)) & ^0x3f) == 0 && ((int64(1)<<(_la-498))&-2306265222165299201) != 0) || ((int64((_la-562)) & ^0x3f) == 0 && ((int64(1)<<(_la-562))&-35186788007937) != 0) || ((int64((_la-626)) & ^0x3f) == 0 && ((int64(1)<<(_la-626))&9077990211383719935) != 0) || ((int64((_la-697)) & ^0x3f) == 0 && ((int64(1)<<(_la-697))&257112980091901) != 0) || _la == MySqlParserMEMORY || _la == MySqlParserCATALOG_NAME || _la == MySqlParserENGINE_ATTRIBUTE || _la == MySqlParserSECONDARY_ENGINE_ATTRIBUTE || _la == MySqlParserSCHEMA_NAME || _la == MySqlParserTP_CONNECTION_ADMIN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IFunctionNameBaseContext is an interface to support dynamic dispatch.
type IFunctionNameBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ABS() antlr.TerminalNode
	ACOS() antlr.TerminalNode
	ADDDATE() antlr.TerminalNode
	ADDTIME() antlr.TerminalNode
	AES_DECRYPT() antlr.TerminalNode
	AES_ENCRYPT() antlr.TerminalNode
	AREA() antlr.TerminalNode
	ASBINARY() antlr.TerminalNode
	ASIN() antlr.TerminalNode
	ASTEXT() antlr.TerminalNode
	ASWKB() antlr.TerminalNode
	ASWKT() antlr.TerminalNode
	ASYMMETRIC_DECRYPT() antlr.TerminalNode
	ASYMMETRIC_DERIVE() antlr.TerminalNode
	ASYMMETRIC_ENCRYPT() antlr.TerminalNode
	ASYMMETRIC_SIGN() antlr.TerminalNode
	ASYMMETRIC_VERIFY() antlr.TerminalNode
	ATAN() antlr.TerminalNode
	ATAN2() antlr.TerminalNode
	BENCHMARK() antlr.TerminalNode
	BIN() antlr.TerminalNode
	BIT_COUNT() antlr.TerminalNode
	BIT_LENGTH() antlr.TerminalNode
	BUFFER() antlr.TerminalNode
	CEIL() antlr.TerminalNode
	CEILING() antlr.TerminalNode
	CENTROID() antlr.TerminalNode
	CHARACTER_LENGTH() antlr.TerminalNode
	CHARSET() antlr.TerminalNode
	CHAR_LENGTH() antlr.TerminalNode
	COERCIBILITY() antlr.TerminalNode
	COLLATION() antlr.TerminalNode
	COMPRESS() antlr.TerminalNode
	CONCAT() antlr.TerminalNode
	CONCAT_WS() antlr.TerminalNode
	CONNECTION_ID() antlr.TerminalNode
	CONV() antlr.TerminalNode
	CONVERT_TZ() antlr.TerminalNode
	COS() antlr.TerminalNode
	COT() antlr.TerminalNode
	COUNT() antlr.TerminalNode
	CRC32() antlr.TerminalNode
	CREATE_ASYMMETRIC_PRIV_KEY() antlr.TerminalNode
	CREATE_ASYMMETRIC_PUB_KEY() antlr.TerminalNode
	CREATE_DH_PARAMETERS() antlr.TerminalNode
	CREATE_DIGEST() antlr.TerminalNode
	CROSSES() antlr.TerminalNode
	CUME_DIST() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DATEDIFF() antlr.TerminalNode
	DATE_FORMAT() antlr.TerminalNode
	DAY() antlr.TerminalNode
	DAYNAME() antlr.TerminalNode
	DAYOFMONTH() antlr.TerminalNode
	DAYOFWEEK() antlr.TerminalNode
	DAYOFYEAR() antlr.TerminalNode
	DECODE() antlr.TerminalNode
	DEGREES() antlr.TerminalNode
	DENSE_RANK() antlr.TerminalNode
	DES_DECRYPT() antlr.TerminalNode
	DES_ENCRYPT() antlr.TerminalNode
	DIMENSION() antlr.TerminalNode
	DISJOINT() antlr.TerminalNode
	ELT() antlr.TerminalNode
	ENCODE() antlr.TerminalNode
	ENCRYPT() antlr.TerminalNode
	ENDPOINT() antlr.TerminalNode
	ENVELOPE() antlr.TerminalNode
	EQUALS() antlr.TerminalNode
	EXP() antlr.TerminalNode
	EXPORT_SET() antlr.TerminalNode
	EXTERIORRING() antlr.TerminalNode
	EXTRACTVALUE() antlr.TerminalNode
	FIELD() antlr.TerminalNode
	FIND_IN_SET() antlr.TerminalNode
	FIRST_VALUE() antlr.TerminalNode
	FLOOR() antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	FOUND_ROWS() antlr.TerminalNode
	FROM_BASE64() antlr.TerminalNode
	FROM_DAYS() antlr.TerminalNode
	FROM_UNIXTIME() antlr.TerminalNode
	GEOMCOLLFROMTEXT() antlr.TerminalNode
	GEOMCOLLFROMWKB() antlr.TerminalNode
	GEOMETRYCOLLECTION() antlr.TerminalNode
	GEOMETRYCOLLECTIONFROMTEXT() antlr.TerminalNode
	GEOMETRYCOLLECTIONFROMWKB() antlr.TerminalNode
	GEOMETRYFROMTEXT() antlr.TerminalNode
	GEOMETRYFROMWKB() antlr.TerminalNode
	GEOMETRYN() antlr.TerminalNode
	GEOMETRYTYPE() antlr.TerminalNode
	GEOMFROMTEXT() antlr.TerminalNode
	GEOMFROMWKB() antlr.TerminalNode
	GET_FORMAT() antlr.TerminalNode
	GET_LOCK() antlr.TerminalNode
	GLENGTH() antlr.TerminalNode
	GREATEST() antlr.TerminalNode
	GTID_SUBSET() antlr.TerminalNode
	GTID_SUBTRACT() antlr.TerminalNode
	HEX() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	IFNULL() antlr.TerminalNode
	INET6_ATON() antlr.TerminalNode
	INET6_NTOA() antlr.TerminalNode
	INET_ATON() antlr.TerminalNode
	INET_NTOA() antlr.TerminalNode
	INSTR() antlr.TerminalNode
	INTERIORRINGN() antlr.TerminalNode
	INTERSECTS() antlr.TerminalNode
	INVISIBLE() antlr.TerminalNode
	ISCLOSED() antlr.TerminalNode
	ISEMPTY() antlr.TerminalNode
	ISNULL() antlr.TerminalNode
	ISSIMPLE() antlr.TerminalNode
	IS_FREE_LOCK() antlr.TerminalNode
	IS_IPV4() antlr.TerminalNode
	IS_IPV4_COMPAT() antlr.TerminalNode
	IS_IPV4_MAPPED() antlr.TerminalNode
	IS_IPV6() antlr.TerminalNode
	IS_USED_LOCK() antlr.TerminalNode
	LAG() antlr.TerminalNode
	LAST_INSERT_ID() antlr.TerminalNode
	LAST_VALUE() antlr.TerminalNode
	LCASE() antlr.TerminalNode
	LEAD() antlr.TerminalNode
	LEAST() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	LENGTH() antlr.TerminalNode
	LINEFROMTEXT() antlr.TerminalNode
	LINEFROMWKB() antlr.TerminalNode
	LINESTRING() antlr.TerminalNode
	LINESTRINGFROMTEXT() antlr.TerminalNode
	LINESTRINGFROMWKB() antlr.TerminalNode
	LN() antlr.TerminalNode
	LOAD_FILE() antlr.TerminalNode
	LOCATE() antlr.TerminalNode
	LOG() antlr.TerminalNode
	LOG10() antlr.TerminalNode
	LOG2() antlr.TerminalNode
	LOWER() antlr.TerminalNode
	LPAD() antlr.TerminalNode
	LTRIM() antlr.TerminalNode
	MAKEDATE() antlr.TerminalNode
	MAKETIME() antlr.TerminalNode
	MAKE_SET() antlr.TerminalNode
	MASTER_POS_WAIT() antlr.TerminalNode
	MBRCONTAINS() antlr.TerminalNode
	MBRDISJOINT() antlr.TerminalNode
	MBREQUAL() antlr.TerminalNode
	MBRINTERSECTS() antlr.TerminalNode
	MBROVERLAPS() antlr.TerminalNode
	MBRTOUCHES() antlr.TerminalNode
	MBRWITHIN() antlr.TerminalNode
	MD5() antlr.TerminalNode
	MICROSECOND() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	MLINEFROMTEXT() antlr.TerminalNode
	MLINEFROMWKB() antlr.TerminalNode
	MOD() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	MONTHNAME() antlr.TerminalNode
	MPOINTFROMTEXT() antlr.TerminalNode
	MPOINTFROMWKB() antlr.TerminalNode
	MPOLYFROMTEXT() antlr.TerminalNode
	MPOLYFROMWKB() antlr.TerminalNode
	MULTILINESTRING() antlr.TerminalNode
	MULTILINESTRINGFROMTEXT() antlr.TerminalNode
	MULTILINESTRINGFROMWKB() antlr.TerminalNode
	MULTIPOINT() antlr.TerminalNode
	MULTIPOINTFROMTEXT() antlr.TerminalNode
	MULTIPOINTFROMWKB() antlr.TerminalNode
	MULTIPOLYGON() antlr.TerminalNode
	MULTIPOLYGONFROMTEXT() antlr.TerminalNode
	MULTIPOLYGONFROMWKB() antlr.TerminalNode
	NAME_CONST() antlr.TerminalNode
	NTH_VALUE() antlr.TerminalNode
	NTILE() antlr.TerminalNode
	NULLIF() antlr.TerminalNode
	NUMGEOMETRIES() antlr.TerminalNode
	NUMINTERIORRINGS() antlr.TerminalNode
	NUMPOINTS() antlr.TerminalNode
	OCT() antlr.TerminalNode
	OCTET_LENGTH() antlr.TerminalNode
	ORD() antlr.TerminalNode
	OVERLAPS() antlr.TerminalNode
	PERCENT_RANK() antlr.TerminalNode
	PERIOD_ADD() antlr.TerminalNode
	PERIOD_DIFF() antlr.TerminalNode
	PI() antlr.TerminalNode
	POINT() antlr.TerminalNode
	POINTFROMTEXT() antlr.TerminalNode
	POINTFROMWKB() antlr.TerminalNode
	POINTN() antlr.TerminalNode
	POLYFROMTEXT() antlr.TerminalNode
	POLYFROMWKB() antlr.TerminalNode
	POLYGON() antlr.TerminalNode
	POLYGONFROMTEXT() antlr.TerminalNode
	POLYGONFROMWKB() antlr.TerminalNode
	POSITION() antlr.TerminalNode
	POW() antlr.TerminalNode
	POWER() antlr.TerminalNode
	QUARTER() antlr.TerminalNode
	QUOTE() antlr.TerminalNode
	RADIANS() antlr.TerminalNode
	RAND() antlr.TerminalNode
	RANK() antlr.TerminalNode
	RANDOM_BYTES() antlr.TerminalNode
	RELEASE_LOCK() antlr.TerminalNode
	REVERSE() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	ROUND() antlr.TerminalNode
	ROW_COUNT() antlr.TerminalNode
	ROW_NUMBER() antlr.TerminalNode
	RPAD() antlr.TerminalNode
	RTRIM() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	SEC_TO_TIME() antlr.TerminalNode
	SESSION_USER() antlr.TerminalNode
	SESSION_VARIABLES_ADMIN() antlr.TerminalNode
	SHA() antlr.TerminalNode
	SHA1() antlr.TerminalNode
	SHA2() antlr.TerminalNode
	SIGN() antlr.TerminalNode
	SIN() antlr.TerminalNode
	SLEEP() antlr.TerminalNode
	SOUNDEX() antlr.TerminalNode
	SQL_THREAD_WAIT_AFTER_GTIDS() antlr.TerminalNode
	SQRT() antlr.TerminalNode
	SRID() antlr.TerminalNode
	STARTPOINT() antlr.TerminalNode
	STRCMP() antlr.TerminalNode
	STR_TO_DATE() antlr.TerminalNode
	ST_AREA() antlr.TerminalNode
	ST_ASBINARY() antlr.TerminalNode
	ST_ASTEXT() antlr.TerminalNode
	ST_ASWKB() antlr.TerminalNode
	ST_ASWKT() antlr.TerminalNode
	ST_BUFFER() antlr.TerminalNode
	ST_CENTROID() antlr.TerminalNode
	ST_CONTAINS() antlr.TerminalNode
	ST_CROSSES() antlr.TerminalNode
	ST_DIFFERENCE() antlr.TerminalNode
	ST_DIMENSION() antlr.TerminalNode
	ST_DISJOINT() antlr.TerminalNode
	ST_DISTANCE() antlr.TerminalNode
	ST_ENDPOINT() antlr.TerminalNode
	ST_ENVELOPE() antlr.TerminalNode
	ST_EQUALS() antlr.TerminalNode
	ST_EXTERIORRING() antlr.TerminalNode
	ST_GEOMCOLLFROMTEXT() antlr.TerminalNode
	ST_GEOMCOLLFROMTXT() antlr.TerminalNode
	ST_GEOMCOLLFROMWKB() antlr.TerminalNode
	ST_GEOMETRYCOLLECTIONFROMTEXT() antlr.TerminalNode
	ST_GEOMETRYCOLLECTIONFROMWKB() antlr.TerminalNode
	ST_GEOMETRYFROMTEXT() antlr.TerminalNode
	ST_GEOMETRYFROMWKB() antlr.TerminalNode
	ST_GEOMETRYN() antlr.TerminalNode
	ST_GEOMETRYTYPE() antlr.TerminalNode
	ST_GEOMFROMTEXT() antlr.TerminalNode
	ST_GEOMFROMWKB() antlr.TerminalNode
	ST_INTERIORRINGN() antlr.TerminalNode
	ST_INTERSECTION() antlr.TerminalNode
	ST_INTERSECTS() antlr.TerminalNode
	ST_ISCLOSED() antlr.TerminalNode
	ST_ISEMPTY() antlr.TerminalNode
	ST_ISSIMPLE() antlr.TerminalNode
	ST_LINEFROMTEXT() antlr.TerminalNode
	ST_LINEFROMWKB() antlr.TerminalNode
	ST_LINESTRINGFROMTEXT() antlr.TerminalNode
	ST_LINESTRINGFROMWKB() antlr.TerminalNode
	ST_NUMGEOMETRIES() antlr.TerminalNode
	ST_NUMINTERIORRING() antlr.TerminalNode
	ST_NUMINTERIORRINGS() antlr.TerminalNode
	ST_NUMPOINTS() antlr.TerminalNode
	ST_OVERLAPS() antlr.TerminalNode
	ST_POINTFROMTEXT() antlr.TerminalNode
	ST_POINTFROMWKB() antlr.TerminalNode
	ST_POINTN() antlr.TerminalNode
	ST_POLYFROMTEXT() antlr.TerminalNode
	ST_POLYFROMWKB() antlr.TerminalNode
	ST_POLYGONFROMTEXT() antlr.TerminalNode
	ST_POLYGONFROMWKB() antlr.TerminalNode
	ST_SRID() antlr.TerminalNode
	ST_STARTPOINT() antlr.TerminalNode
	ST_SYMDIFFERENCE() antlr.TerminalNode
	ST_TOUCHES() antlr.TerminalNode
	ST_UNION() antlr.TerminalNode
	ST_WITHIN() antlr.TerminalNode
	ST_X() antlr.TerminalNode
	ST_Y() antlr.TerminalNode
	SUBDATE() antlr.TerminalNode
	SUBSTRING_INDEX() antlr.TerminalNode
	SUBTIME() antlr.TerminalNode
	SYSTEM_USER() antlr.TerminalNode
	TAN() antlr.TerminalNode
	TIME() antlr.TerminalNode
	TIMEDIFF() antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode
	TIMESTAMPADD() antlr.TerminalNode
	TIMESTAMPDIFF() antlr.TerminalNode
	TIME_FORMAT() antlr.TerminalNode
	TIME_TO_SEC() antlr.TerminalNode
	TOUCHES() antlr.TerminalNode
	TO_BASE64() antlr.TerminalNode
	TO_DAYS() antlr.TerminalNode
	TO_SECONDS() antlr.TerminalNode
	UCASE() antlr.TerminalNode
	UNCOMPRESS() antlr.TerminalNode
	UNCOMPRESSED_LENGTH() antlr.TerminalNode
	UNHEX() antlr.TerminalNode
	UNIX_TIMESTAMP() antlr.TerminalNode
	UPDATEXML() antlr.TerminalNode
	UPPER() antlr.TerminalNode
	UUID() antlr.TerminalNode
	UUID_SHORT() antlr.TerminalNode
	VALIDATE_PASSWORD_STRENGTH() antlr.TerminalNode
	VERSION() antlr.TerminalNode
	VISIBLE() antlr.TerminalNode
	WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS() antlr.TerminalNode
	WEEK() antlr.TerminalNode
	WEEKDAY() antlr.TerminalNode
	WEEKOFYEAR() antlr.TerminalNode
	WEIGHT_STRING() antlr.TerminalNode
	WITHIN() antlr.TerminalNode
	YEAR() antlr.TerminalNode
	YEARWEEK() antlr.TerminalNode
	Y_FUNCTION() antlr.TerminalNode
	X_FUNCTION() antlr.TerminalNode
	JSON_ARRAY() antlr.TerminalNode
	JSON_OBJECT() antlr.TerminalNode
	JSON_QUOTE() antlr.TerminalNode
	JSON_CONTAINS() antlr.TerminalNode
	JSON_CONTAINS_PATH() antlr.TerminalNode
	JSON_EXTRACT() antlr.TerminalNode
	JSON_KEYS() antlr.TerminalNode
	JSON_OVERLAPS() antlr.TerminalNode
	JSON_SEARCH() antlr.TerminalNode
	JSON_VALUE() antlr.TerminalNode
	JSON_ARRAY_APPEND() antlr.TerminalNode
	JSON_ARRAY_INSERT() antlr.TerminalNode
	JSON_INSERT() antlr.TerminalNode
	JSON_MERGE() antlr.TerminalNode
	JSON_MERGE_PATCH() antlr.TerminalNode
	JSON_MERGE_PRESERVE() antlr.TerminalNode
	JSON_REMOVE() antlr.TerminalNode
	JSON_REPLACE() antlr.TerminalNode
	JSON_SET() antlr.TerminalNode
	JSON_UNQUOTE() antlr.TerminalNode
	JSON_DEPTH() antlr.TerminalNode
	JSON_LENGTH() antlr.TerminalNode
	JSON_TYPE() antlr.TerminalNode
	JSON_VALID() antlr.TerminalNode
	JSON_TABLE() antlr.TerminalNode
	JSON_SCHEMA_VALID() antlr.TerminalNode
	JSON_SCHEMA_VALIDATION_REPORT() antlr.TerminalNode
	JSON_PRETTY() antlr.TerminalNode
	JSON_STORAGE_FREE() antlr.TerminalNode
	JSON_STORAGE_SIZE() antlr.TerminalNode
	JSON_ARRAYAGG() antlr.TerminalNode
	JSON_OBJECTAGG() antlr.TerminalNode

	// IsFunctionNameBaseContext differentiates from other interfaces.
	IsFunctionNameBaseContext()
}

type FunctionNameBaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionNameBaseContext() *FunctionNameBaseContext {
	var p = new(FunctionNameBaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_functionNameBase
	return p
}

func (*FunctionNameBaseContext) IsFunctionNameBaseContext() {}

func NewFunctionNameBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionNameBaseContext {
	var p = new(FunctionNameBaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_functionNameBase

	return p
}

func (s *FunctionNameBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionNameBaseContext) ABS() antlr.TerminalNode {
	return s.GetToken(MySqlParserABS, 0)
}

func (s *FunctionNameBaseContext) ACOS() antlr.TerminalNode {
	return s.GetToken(MySqlParserACOS, 0)
}

func (s *FunctionNameBaseContext) ADDDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserADDDATE, 0)
}

func (s *FunctionNameBaseContext) ADDTIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserADDTIME, 0)
}

func (s *FunctionNameBaseContext) AES_DECRYPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserAES_DECRYPT, 0)
}

func (s *FunctionNameBaseContext) AES_ENCRYPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserAES_ENCRYPT, 0)
}

func (s *FunctionNameBaseContext) AREA() antlr.TerminalNode {
	return s.GetToken(MySqlParserAREA, 0)
}

func (s *FunctionNameBaseContext) ASBINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserASBINARY, 0)
}

func (s *FunctionNameBaseContext) ASIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserASIN, 0)
}

func (s *FunctionNameBaseContext) ASTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserASTEXT, 0)
}

func (s *FunctionNameBaseContext) ASWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserASWKB, 0)
}

func (s *FunctionNameBaseContext) ASWKT() antlr.TerminalNode {
	return s.GetToken(MySqlParserASWKT, 0)
}

func (s *FunctionNameBaseContext) ASYMMETRIC_DECRYPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserASYMMETRIC_DECRYPT, 0)
}

func (s *FunctionNameBaseContext) ASYMMETRIC_DERIVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserASYMMETRIC_DERIVE, 0)
}

func (s *FunctionNameBaseContext) ASYMMETRIC_ENCRYPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserASYMMETRIC_ENCRYPT, 0)
}

func (s *FunctionNameBaseContext) ASYMMETRIC_SIGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserASYMMETRIC_SIGN, 0)
}

func (s *FunctionNameBaseContext) ASYMMETRIC_VERIFY() antlr.TerminalNode {
	return s.GetToken(MySqlParserASYMMETRIC_VERIFY, 0)
}

func (s *FunctionNameBaseContext) ATAN() antlr.TerminalNode {
	return s.GetToken(MySqlParserATAN, 0)
}

func (s *FunctionNameBaseContext) ATAN2() antlr.TerminalNode {
	return s.GetToken(MySqlParserATAN2, 0)
}

func (s *FunctionNameBaseContext) BENCHMARK() antlr.TerminalNode {
	return s.GetToken(MySqlParserBENCHMARK, 0)
}

func (s *FunctionNameBaseContext) BIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIN, 0)
}

func (s *FunctionNameBaseContext) BIT_COUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_COUNT, 0)
}

func (s *FunctionNameBaseContext) BIT_LENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_LENGTH, 0)
}

func (s *FunctionNameBaseContext) BUFFER() antlr.TerminalNode {
	return s.GetToken(MySqlParserBUFFER, 0)
}

func (s *FunctionNameBaseContext) CEIL() antlr.TerminalNode {
	return s.GetToken(MySqlParserCEIL, 0)
}

func (s *FunctionNameBaseContext) CEILING() antlr.TerminalNode {
	return s.GetToken(MySqlParserCEILING, 0)
}

func (s *FunctionNameBaseContext) CENTROID() antlr.TerminalNode {
	return s.GetToken(MySqlParserCENTROID, 0)
}

func (s *FunctionNameBaseContext) CHARACTER_LENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER_LENGTH, 0)
}

func (s *FunctionNameBaseContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARSET, 0)
}

func (s *FunctionNameBaseContext) CHAR_LENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAR_LENGTH, 0)
}

func (s *FunctionNameBaseContext) COERCIBILITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOERCIBILITY, 0)
}

func (s *FunctionNameBaseContext) COLLATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATION, 0)
}

func (s *FunctionNameBaseContext) COMPRESS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMPRESS, 0)
}

func (s *FunctionNameBaseContext) CONCAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONCAT, 0)
}

func (s *FunctionNameBaseContext) CONCAT_WS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONCAT_WS, 0)
}

func (s *FunctionNameBaseContext) CONNECTION_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONNECTION_ID, 0)
}

func (s *FunctionNameBaseContext) CONV() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONV, 0)
}

func (s *FunctionNameBaseContext) CONVERT_TZ() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONVERT_TZ, 0)
}

func (s *FunctionNameBaseContext) COS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOS, 0)
}

func (s *FunctionNameBaseContext) COT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOT, 0)
}

func (s *FunctionNameBaseContext) COUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOUNT, 0)
}

func (s *FunctionNameBaseContext) CRC32() antlr.TerminalNode {
	return s.GetToken(MySqlParserCRC32, 0)
}

func (s *FunctionNameBaseContext) CREATE_ASYMMETRIC_PRIV_KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, 0)
}

func (s *FunctionNameBaseContext) CREATE_ASYMMETRIC_PUB_KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE_ASYMMETRIC_PUB_KEY, 0)
}

func (s *FunctionNameBaseContext) CREATE_DH_PARAMETERS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE_DH_PARAMETERS, 0)
}

func (s *FunctionNameBaseContext) CREATE_DIGEST() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE_DIGEST, 0)
}

func (s *FunctionNameBaseContext) CROSSES() antlr.TerminalNode {
	return s.GetToken(MySqlParserCROSSES, 0)
}

func (s *FunctionNameBaseContext) CUME_DIST() antlr.TerminalNode {
	return s.GetToken(MySqlParserCUME_DIST, 0)
}

func (s *FunctionNameBaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATABASE, 0)
}

func (s *FunctionNameBaseContext) DATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATE, 0)
}

func (s *FunctionNameBaseContext) DATEDIFF() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATEDIFF, 0)
}

func (s *FunctionNameBaseContext) DATE_FORMAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATE_FORMAT, 0)
}

func (s *FunctionNameBaseContext) DAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAY, 0)
}

func (s *FunctionNameBaseContext) DAYNAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAYNAME, 0)
}

func (s *FunctionNameBaseContext) DAYOFMONTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAYOFMONTH, 0)
}

func (s *FunctionNameBaseContext) DAYOFWEEK() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAYOFWEEK, 0)
}

func (s *FunctionNameBaseContext) DAYOFYEAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAYOFYEAR, 0)
}

func (s *FunctionNameBaseContext) DECODE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDECODE, 0)
}

func (s *FunctionNameBaseContext) DEGREES() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEGREES, 0)
}

func (s *FunctionNameBaseContext) DENSE_RANK() antlr.TerminalNode {
	return s.GetToken(MySqlParserDENSE_RANK, 0)
}

func (s *FunctionNameBaseContext) DES_DECRYPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDES_DECRYPT, 0)
}

func (s *FunctionNameBaseContext) DES_ENCRYPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDES_ENCRYPT, 0)
}

func (s *FunctionNameBaseContext) DIMENSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserDIMENSION, 0)
}

func (s *FunctionNameBaseContext) DISJOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISJOINT, 0)
}

func (s *FunctionNameBaseContext) ELT() antlr.TerminalNode {
	return s.GetToken(MySqlParserELT, 0)
}

func (s *FunctionNameBaseContext) ENCODE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENCODE, 0)
}

func (s *FunctionNameBaseContext) ENCRYPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserENCRYPT, 0)
}

func (s *FunctionNameBaseContext) ENDPOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserENDPOINT, 0)
}

func (s *FunctionNameBaseContext) ENVELOPE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENVELOPE, 0)
}

func (s *FunctionNameBaseContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUALS, 0)
}

func (s *FunctionNameBaseContext) EXP() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXP, 0)
}

func (s *FunctionNameBaseContext) EXPORT_SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXPORT_SET, 0)
}

func (s *FunctionNameBaseContext) EXTERIORRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXTERIORRING, 0)
}

func (s *FunctionNameBaseContext) EXTRACTVALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXTRACTVALUE, 0)
}

func (s *FunctionNameBaseContext) FIELD() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIELD, 0)
}

func (s *FunctionNameBaseContext) FIND_IN_SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIND_IN_SET, 0)
}

func (s *FunctionNameBaseContext) FIRST_VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIRST_VALUE, 0)
}

func (s *FunctionNameBaseContext) FLOOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFLOOR, 0)
}

func (s *FunctionNameBaseContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserFORMAT, 0)
}

func (s *FunctionNameBaseContext) FOUND_ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOUND_ROWS, 0)
}

func (s *FunctionNameBaseContext) FROM_BASE64() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM_BASE64, 0)
}

func (s *FunctionNameBaseContext) FROM_DAYS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM_DAYS, 0)
}

func (s *FunctionNameBaseContext) FROM_UNIXTIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM_UNIXTIME, 0)
}

func (s *FunctionNameBaseContext) GEOMCOLLFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMCOLLFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) GEOMCOLLFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMCOLLFROMWKB, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYCOLLECTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMETRYCOLLECTION, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYCOLLECTIONFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMETRYCOLLECTIONFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYCOLLECTIONFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMETRYCOLLECTIONFROMWKB, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMETRYFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMETRYFROMWKB, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYN() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMETRYN, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYTYPE() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMETRYTYPE, 0)
}

func (s *FunctionNameBaseContext) GEOMFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) GEOMFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMFROMWKB, 0)
}

func (s *FunctionNameBaseContext) GET_FORMAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGET_FORMAT, 0)
}

func (s *FunctionNameBaseContext) GET_LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserGET_LOCK, 0)
}

func (s *FunctionNameBaseContext) GLENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserGLENGTH, 0)
}

func (s *FunctionNameBaseContext) GREATEST() antlr.TerminalNode {
	return s.GetToken(MySqlParserGREATEST, 0)
}

func (s *FunctionNameBaseContext) GTID_SUBSET() antlr.TerminalNode {
	return s.GetToken(MySqlParserGTID_SUBSET, 0)
}

func (s *FunctionNameBaseContext) GTID_SUBTRACT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGTID_SUBTRACT, 0)
}

func (s *FunctionNameBaseContext) HEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserHEX, 0)
}

func (s *FunctionNameBaseContext) HOUR() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOUR, 0)
}

func (s *FunctionNameBaseContext) IFNULL() antlr.TerminalNode {
	return s.GetToken(MySqlParserIFNULL, 0)
}

func (s *FunctionNameBaseContext) INET6_ATON() antlr.TerminalNode {
	return s.GetToken(MySqlParserINET6_ATON, 0)
}

func (s *FunctionNameBaseContext) INET6_NTOA() antlr.TerminalNode {
	return s.GetToken(MySqlParserINET6_NTOA, 0)
}

func (s *FunctionNameBaseContext) INET_ATON() antlr.TerminalNode {
	return s.GetToken(MySqlParserINET_ATON, 0)
}

func (s *FunctionNameBaseContext) INET_NTOA() antlr.TerminalNode {
	return s.GetToken(MySqlParserINET_NTOA, 0)
}

func (s *FunctionNameBaseContext) INSTR() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSTR, 0)
}

func (s *FunctionNameBaseContext) INTERIORRINGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTERIORRINGN, 0)
}

func (s *FunctionNameBaseContext) INTERSECTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTERSECTS, 0)
}

func (s *FunctionNameBaseContext) INVISIBLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINVISIBLE, 0)
}

func (s *FunctionNameBaseContext) ISCLOSED() antlr.TerminalNode {
	return s.GetToken(MySqlParserISCLOSED, 0)
}

func (s *FunctionNameBaseContext) ISEMPTY() antlr.TerminalNode {
	return s.GetToken(MySqlParserISEMPTY, 0)
}

func (s *FunctionNameBaseContext) ISNULL() antlr.TerminalNode {
	return s.GetToken(MySqlParserISNULL, 0)
}

func (s *FunctionNameBaseContext) ISSIMPLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserISSIMPLE, 0)
}

func (s *FunctionNameBaseContext) IS_FREE_LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserIS_FREE_LOCK, 0)
}

func (s *FunctionNameBaseContext) IS_IPV4() antlr.TerminalNode {
	return s.GetToken(MySqlParserIS_IPV4, 0)
}

func (s *FunctionNameBaseContext) IS_IPV4_COMPAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserIS_IPV4_COMPAT, 0)
}

func (s *FunctionNameBaseContext) IS_IPV4_MAPPED() antlr.TerminalNode {
	return s.GetToken(MySqlParserIS_IPV4_MAPPED, 0)
}

func (s *FunctionNameBaseContext) IS_IPV6() antlr.TerminalNode {
	return s.GetToken(MySqlParserIS_IPV6, 0)
}

func (s *FunctionNameBaseContext) IS_USED_LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserIS_USED_LOCK, 0)
}

func (s *FunctionNameBaseContext) LAG() antlr.TerminalNode {
	return s.GetToken(MySqlParserLAG, 0)
}

func (s *FunctionNameBaseContext) LAST_INSERT_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserLAST_INSERT_ID, 0)
}

func (s *FunctionNameBaseContext) LAST_VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLAST_VALUE, 0)
}

func (s *FunctionNameBaseContext) LCASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLCASE, 0)
}

func (s *FunctionNameBaseContext) LEAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEAD, 0)
}

func (s *FunctionNameBaseContext) LEAST() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEAST, 0)
}

func (s *FunctionNameBaseContext) LEFT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEFT, 0)
}

func (s *FunctionNameBaseContext) LENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserLENGTH, 0)
}

func (s *FunctionNameBaseContext) LINEFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINEFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) LINEFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINEFROMWKB, 0)
}

func (s *FunctionNameBaseContext) LINESTRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINESTRING, 0)
}

func (s *FunctionNameBaseContext) LINESTRINGFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINESTRINGFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) LINESTRINGFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINESTRINGFROMWKB, 0)
}

func (s *FunctionNameBaseContext) LN() antlr.TerminalNode {
	return s.GetToken(MySqlParserLN, 0)
}

func (s *FunctionNameBaseContext) LOAD_FILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOAD_FILE, 0)
}

func (s *FunctionNameBaseContext) LOCATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCATE, 0)
}

func (s *FunctionNameBaseContext) LOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOG, 0)
}

func (s *FunctionNameBaseContext) LOG10() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOG10, 0)
}

func (s *FunctionNameBaseContext) LOG2() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOG2, 0)
}

func (s *FunctionNameBaseContext) LOWER() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOWER, 0)
}

func (s *FunctionNameBaseContext) LPAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserLPAD, 0)
}

func (s *FunctionNameBaseContext) LTRIM() antlr.TerminalNode {
	return s.GetToken(MySqlParserLTRIM, 0)
}

func (s *FunctionNameBaseContext) MAKEDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAKEDATE, 0)
}

func (s *FunctionNameBaseContext) MAKETIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAKETIME, 0)
}

func (s *FunctionNameBaseContext) MAKE_SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAKE_SET, 0)
}

func (s *FunctionNameBaseContext) MASTER_POS_WAIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_POS_WAIT, 0)
}

func (s *FunctionNameBaseContext) MBRCONTAINS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMBRCONTAINS, 0)
}

func (s *FunctionNameBaseContext) MBRDISJOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMBRDISJOINT, 0)
}

func (s *FunctionNameBaseContext) MBREQUAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserMBREQUAL, 0)
}

func (s *FunctionNameBaseContext) MBRINTERSECTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMBRINTERSECTS, 0)
}

func (s *FunctionNameBaseContext) MBROVERLAPS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMBROVERLAPS, 0)
}

func (s *FunctionNameBaseContext) MBRTOUCHES() antlr.TerminalNode {
	return s.GetToken(MySqlParserMBRTOUCHES, 0)
}

func (s *FunctionNameBaseContext) MBRWITHIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserMBRWITHIN, 0)
}

func (s *FunctionNameBaseContext) MD5() antlr.TerminalNode {
	return s.GetToken(MySqlParserMD5, 0)
}

func (s *FunctionNameBaseContext) MICROSECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserMICROSECOND, 0)
}

func (s *FunctionNameBaseContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUTE, 0)
}

func (s *FunctionNameBaseContext) MLINEFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMLINEFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MLINEFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserMLINEFROMWKB, 0)
}

func (s *FunctionNameBaseContext) MOD() antlr.TerminalNode {
	return s.GetToken(MySqlParserMOD, 0)
}

func (s *FunctionNameBaseContext) MONTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserMONTH, 0)
}

func (s *FunctionNameBaseContext) MONTHNAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserMONTHNAME, 0)
}

func (s *FunctionNameBaseContext) MPOINTFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMPOINTFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MPOINTFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserMPOINTFROMWKB, 0)
}

func (s *FunctionNameBaseContext) MPOLYFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMPOLYFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MPOLYFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserMPOLYFROMWKB, 0)
}

func (s *FunctionNameBaseContext) MULTILINESTRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTILINESTRING, 0)
}

func (s *FunctionNameBaseContext) MULTILINESTRINGFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTILINESTRINGFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MULTILINESTRINGFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTILINESTRINGFROMWKB, 0)
}

func (s *FunctionNameBaseContext) MULTIPOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTIPOINT, 0)
}

func (s *FunctionNameBaseContext) MULTIPOINTFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTIPOINTFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MULTIPOINTFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTIPOINTFROMWKB, 0)
}

func (s *FunctionNameBaseContext) MULTIPOLYGON() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTIPOLYGON, 0)
}

func (s *FunctionNameBaseContext) MULTIPOLYGONFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTIPOLYGONFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MULTIPOLYGONFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTIPOLYGONFROMWKB, 0)
}

func (s *FunctionNameBaseContext) NAME_CONST() antlr.TerminalNode {
	return s.GetToken(MySqlParserNAME_CONST, 0)
}

func (s *FunctionNameBaseContext) NTH_VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserNTH_VALUE, 0)
}

func (s *FunctionNameBaseContext) NTILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserNTILE, 0)
}

func (s *FunctionNameBaseContext) NULLIF() antlr.TerminalNode {
	return s.GetToken(MySqlParserNULLIF, 0)
}

func (s *FunctionNameBaseContext) NUMGEOMETRIES() antlr.TerminalNode {
	return s.GetToken(MySqlParserNUMGEOMETRIES, 0)
}

func (s *FunctionNameBaseContext) NUMINTERIORRINGS() antlr.TerminalNode {
	return s.GetToken(MySqlParserNUMINTERIORRINGS, 0)
}

func (s *FunctionNameBaseContext) NUMPOINTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserNUMPOINTS, 0)
}

func (s *FunctionNameBaseContext) OCT() antlr.TerminalNode {
	return s.GetToken(MySqlParserOCT, 0)
}

func (s *FunctionNameBaseContext) OCTET_LENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserOCTET_LENGTH, 0)
}

func (s *FunctionNameBaseContext) ORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserORD, 0)
}

func (s *FunctionNameBaseContext) OVERLAPS() antlr.TerminalNode {
	return s.GetToken(MySqlParserOVERLAPS, 0)
}

func (s *FunctionNameBaseContext) PERCENT_RANK() antlr.TerminalNode {
	return s.GetToken(MySqlParserPERCENT_RANK, 0)
}

func (s *FunctionNameBaseContext) PERIOD_ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserPERIOD_ADD, 0)
}

func (s *FunctionNameBaseContext) PERIOD_DIFF() antlr.TerminalNode {
	return s.GetToken(MySqlParserPERIOD_DIFF, 0)
}

func (s *FunctionNameBaseContext) PI() antlr.TerminalNode {
	return s.GetToken(MySqlParserPI, 0)
}

func (s *FunctionNameBaseContext) POINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOINT, 0)
}

func (s *FunctionNameBaseContext) POINTFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOINTFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) POINTFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOINTFROMWKB, 0)
}

func (s *FunctionNameBaseContext) POINTN() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOINTN, 0)
}

func (s *FunctionNameBaseContext) POLYFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOLYFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) POLYFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOLYFROMWKB, 0)
}

func (s *FunctionNameBaseContext) POLYGON() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOLYGON, 0)
}

func (s *FunctionNameBaseContext) POLYGONFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOLYGONFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) POLYGONFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOLYGONFROMWKB, 0)
}

func (s *FunctionNameBaseContext) POSITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOSITION, 0)
}

func (s *FunctionNameBaseContext) POW() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOW, 0)
}

func (s *FunctionNameBaseContext) POWER() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOWER, 0)
}

func (s *FunctionNameBaseContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUARTER, 0)
}

func (s *FunctionNameBaseContext) QUOTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUOTE, 0)
}

func (s *FunctionNameBaseContext) RADIANS() antlr.TerminalNode {
	return s.GetToken(MySqlParserRADIANS, 0)
}

func (s *FunctionNameBaseContext) RAND() antlr.TerminalNode {
	return s.GetToken(MySqlParserRAND, 0)
}

func (s *FunctionNameBaseContext) RANK() antlr.TerminalNode {
	return s.GetToken(MySqlParserRANK, 0)
}

func (s *FunctionNameBaseContext) RANDOM_BYTES() antlr.TerminalNode {
	return s.GetToken(MySqlParserRANDOM_BYTES, 0)
}

func (s *FunctionNameBaseContext) RELEASE_LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELEASE_LOCK, 0)
}

func (s *FunctionNameBaseContext) REVERSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREVERSE, 0)
}

func (s *FunctionNameBaseContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(MySqlParserRIGHT, 0)
}

func (s *FunctionNameBaseContext) ROUND() antlr.TerminalNode {
	return s.GetToken(MySqlParserROUND, 0)
}

func (s *FunctionNameBaseContext) ROW_COUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserROW_COUNT, 0)
}

func (s *FunctionNameBaseContext) ROW_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySqlParserROW_NUMBER, 0)
}

func (s *FunctionNameBaseContext) RPAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserRPAD, 0)
}

func (s *FunctionNameBaseContext) RTRIM() antlr.TerminalNode {
	return s.GetToken(MySqlParserRTRIM, 0)
}

func (s *FunctionNameBaseContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEMA, 0)
}

func (s *FunctionNameBaseContext) SECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserSECOND, 0)
}

func (s *FunctionNameBaseContext) SEC_TO_TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSEC_TO_TIME, 0)
}

func (s *FunctionNameBaseContext) SESSION_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserSESSION_USER, 0)
}

func (s *FunctionNameBaseContext) SESSION_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSESSION_VARIABLES_ADMIN, 0)
}

func (s *FunctionNameBaseContext) SHA() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHA, 0)
}

func (s *FunctionNameBaseContext) SHA1() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHA1, 0)
}

func (s *FunctionNameBaseContext) SHA2() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHA2, 0)
}

func (s *FunctionNameBaseContext) SIGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSIGN, 0)
}

func (s *FunctionNameBaseContext) SIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSIN, 0)
}

func (s *FunctionNameBaseContext) SLEEP() antlr.TerminalNode {
	return s.GetToken(MySqlParserSLEEP, 0)
}

func (s *FunctionNameBaseContext) SOUNDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserSOUNDEX, 0)
}

func (s *FunctionNameBaseContext) SQL_THREAD_WAIT_AFTER_GTIDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, 0)
}

func (s *FunctionNameBaseContext) SQRT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQRT, 0)
}

func (s *FunctionNameBaseContext) SRID() antlr.TerminalNode {
	return s.GetToken(MySqlParserSRID, 0)
}

func (s *FunctionNameBaseContext) STARTPOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTARTPOINT, 0)
}

func (s *FunctionNameBaseContext) STRCMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRCMP, 0)
}

func (s *FunctionNameBaseContext) STR_TO_DATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTR_TO_DATE, 0)
}

func (s *FunctionNameBaseContext) ST_AREA() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_AREA, 0)
}

func (s *FunctionNameBaseContext) ST_ASBINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_ASBINARY, 0)
}

func (s *FunctionNameBaseContext) ST_ASTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_ASTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_ASWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_ASWKB, 0)
}

func (s *FunctionNameBaseContext) ST_ASWKT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_ASWKT, 0)
}

func (s *FunctionNameBaseContext) ST_BUFFER() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_BUFFER, 0)
}

func (s *FunctionNameBaseContext) ST_CENTROID() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_CENTROID, 0)
}

func (s *FunctionNameBaseContext) ST_CONTAINS() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_CONTAINS, 0)
}

func (s *FunctionNameBaseContext) ST_CROSSES() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_CROSSES, 0)
}

func (s *FunctionNameBaseContext) ST_DIFFERENCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_DIFFERENCE, 0)
}

func (s *FunctionNameBaseContext) ST_DIMENSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_DIMENSION, 0)
}

func (s *FunctionNameBaseContext) ST_DISJOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_DISJOINT, 0)
}

func (s *FunctionNameBaseContext) ST_DISTANCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_DISTANCE, 0)
}

func (s *FunctionNameBaseContext) ST_ENDPOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_ENDPOINT, 0)
}

func (s *FunctionNameBaseContext) ST_ENVELOPE() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_ENVELOPE, 0)
}

func (s *FunctionNameBaseContext) ST_EQUALS() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_EQUALS, 0)
}

func (s *FunctionNameBaseContext) ST_EXTERIORRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_EXTERIORRING, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMCOLLFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMCOLLFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMCOLLFROMTXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMCOLLFROMTXT, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMCOLLFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMCOLLFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYCOLLECTIONFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYCOLLECTIONFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMETRYFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMETRYFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYN() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMETRYN, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYTYPE() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMETRYTYPE, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_INTERIORRINGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_INTERIORRINGN, 0)
}

func (s *FunctionNameBaseContext) ST_INTERSECTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_INTERSECTION, 0)
}

func (s *FunctionNameBaseContext) ST_INTERSECTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_INTERSECTS, 0)
}

func (s *FunctionNameBaseContext) ST_ISCLOSED() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_ISCLOSED, 0)
}

func (s *FunctionNameBaseContext) ST_ISEMPTY() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_ISEMPTY, 0)
}

func (s *FunctionNameBaseContext) ST_ISSIMPLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_ISSIMPLE, 0)
}

func (s *FunctionNameBaseContext) ST_LINEFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_LINEFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_LINEFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_LINEFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_LINESTRINGFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_LINESTRINGFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_LINESTRINGFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_LINESTRINGFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_NUMGEOMETRIES() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_NUMGEOMETRIES, 0)
}

func (s *FunctionNameBaseContext) ST_NUMINTERIORRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_NUMINTERIORRING, 0)
}

func (s *FunctionNameBaseContext) ST_NUMINTERIORRINGS() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_NUMINTERIORRINGS, 0)
}

func (s *FunctionNameBaseContext) ST_NUMPOINTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_NUMPOINTS, 0)
}

func (s *FunctionNameBaseContext) ST_OVERLAPS() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_OVERLAPS, 0)
}

func (s *FunctionNameBaseContext) ST_POINTFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_POINTFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_POINTFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_POINTFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_POINTN() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_POINTN, 0)
}

func (s *FunctionNameBaseContext) ST_POLYFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_POLYFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_POLYFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_POLYFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_POLYGONFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_POLYGONFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_POLYGONFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_POLYGONFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_SRID() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_SRID, 0)
}

func (s *FunctionNameBaseContext) ST_STARTPOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_STARTPOINT, 0)
}

func (s *FunctionNameBaseContext) ST_SYMDIFFERENCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_SYMDIFFERENCE, 0)
}

func (s *FunctionNameBaseContext) ST_TOUCHES() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_TOUCHES, 0)
}

func (s *FunctionNameBaseContext) ST_UNION() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_UNION, 0)
}

func (s *FunctionNameBaseContext) ST_WITHIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_WITHIN, 0)
}

func (s *FunctionNameBaseContext) ST_X() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_X, 0)
}

func (s *FunctionNameBaseContext) ST_Y() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_Y, 0)
}

func (s *FunctionNameBaseContext) SUBDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBDATE, 0)
}

func (s *FunctionNameBaseContext) SUBSTRING_INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBSTRING_INDEX, 0)
}

func (s *FunctionNameBaseContext) SUBTIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBTIME, 0)
}

func (s *FunctionNameBaseContext) SYSTEM_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserSYSTEM_USER, 0)
}

func (s *FunctionNameBaseContext) TAN() antlr.TerminalNode {
	return s.GetToken(MySqlParserTAN, 0)
}

func (s *FunctionNameBaseContext) TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIME, 0)
}

func (s *FunctionNameBaseContext) TIMEDIFF() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIMEDIFF, 0)
}

func (s *FunctionNameBaseContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIMESTAMP, 0)
}

func (s *FunctionNameBaseContext) TIMESTAMPADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIMESTAMPADD, 0)
}

func (s *FunctionNameBaseContext) TIMESTAMPDIFF() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIMESTAMPDIFF, 0)
}

func (s *FunctionNameBaseContext) TIME_FORMAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIME_FORMAT, 0)
}

func (s *FunctionNameBaseContext) TIME_TO_SEC() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIME_TO_SEC, 0)
}

func (s *FunctionNameBaseContext) TOUCHES() antlr.TerminalNode {
	return s.GetToken(MySqlParserTOUCHES, 0)
}

func (s *FunctionNameBaseContext) TO_BASE64() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO_BASE64, 0)
}

func (s *FunctionNameBaseContext) TO_DAYS() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO_DAYS, 0)
}

func (s *FunctionNameBaseContext) TO_SECONDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO_SECONDS, 0)
}

func (s *FunctionNameBaseContext) UCASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUCASE, 0)
}

func (s *FunctionNameBaseContext) UNCOMPRESS() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNCOMPRESS, 0)
}

func (s *FunctionNameBaseContext) UNCOMPRESSED_LENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNCOMPRESSED_LENGTH, 0)
}

func (s *FunctionNameBaseContext) UNHEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNHEX, 0)
}

func (s *FunctionNameBaseContext) UNIX_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNIX_TIMESTAMP, 0)
}

func (s *FunctionNameBaseContext) UPDATEXML() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPDATEXML, 0)
}

func (s *FunctionNameBaseContext) UPPER() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPPER, 0)
}

func (s *FunctionNameBaseContext) UUID() antlr.TerminalNode {
	return s.GetToken(MySqlParserUUID, 0)
}

func (s *FunctionNameBaseContext) UUID_SHORT() antlr.TerminalNode {
	return s.GetToken(MySqlParserUUID_SHORT, 0)
}

func (s *FunctionNameBaseContext) VALIDATE_PASSWORD_STRENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALIDATE_PASSWORD_STRENGTH, 0)
}

func (s *FunctionNameBaseContext) VERSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserVERSION, 0)
}

func (s *FunctionNameBaseContext) VISIBLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVISIBLE, 0)
}

func (s *FunctionNameBaseContext) WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, 0)
}

func (s *FunctionNameBaseContext) WEEK() antlr.TerminalNode {
	return s.GetToken(MySqlParserWEEK, 0)
}

func (s *FunctionNameBaseContext) WEEKDAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserWEEKDAY, 0)
}

func (s *FunctionNameBaseContext) WEEKOFYEAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserWEEKOFYEAR, 0)
}

func (s *FunctionNameBaseContext) WEIGHT_STRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserWEIGHT_STRING, 0)
}

func (s *FunctionNameBaseContext) WITHIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITHIN, 0)
}

func (s *FunctionNameBaseContext) YEAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserYEAR, 0)
}

func (s *FunctionNameBaseContext) YEARWEEK() antlr.TerminalNode {
	return s.GetToken(MySqlParserYEARWEEK, 0)
}

func (s *FunctionNameBaseContext) Y_FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserY_FUNCTION, 0)
}

func (s *FunctionNameBaseContext) X_FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserX_FUNCTION, 0)
}

func (s *FunctionNameBaseContext) JSON_ARRAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_ARRAY, 0)
}

func (s *FunctionNameBaseContext) JSON_OBJECT() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_OBJECT, 0)
}

func (s *FunctionNameBaseContext) JSON_QUOTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_QUOTE, 0)
}

func (s *FunctionNameBaseContext) JSON_CONTAINS() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_CONTAINS, 0)
}

func (s *FunctionNameBaseContext) JSON_CONTAINS_PATH() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_CONTAINS_PATH, 0)
}

func (s *FunctionNameBaseContext) JSON_EXTRACT() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_EXTRACT, 0)
}

func (s *FunctionNameBaseContext) JSON_KEYS() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_KEYS, 0)
}

func (s *FunctionNameBaseContext) JSON_OVERLAPS() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_OVERLAPS, 0)
}

func (s *FunctionNameBaseContext) JSON_SEARCH() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_SEARCH, 0)
}

func (s *FunctionNameBaseContext) JSON_VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_VALUE, 0)
}

func (s *FunctionNameBaseContext) JSON_ARRAY_APPEND() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_ARRAY_APPEND, 0)
}

func (s *FunctionNameBaseContext) JSON_ARRAY_INSERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_ARRAY_INSERT, 0)
}

func (s *FunctionNameBaseContext) JSON_INSERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_INSERT, 0)
}

func (s *FunctionNameBaseContext) JSON_MERGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_MERGE, 0)
}

func (s *FunctionNameBaseContext) JSON_MERGE_PATCH() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_MERGE_PATCH, 0)
}

func (s *FunctionNameBaseContext) JSON_MERGE_PRESERVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_MERGE_PRESERVE, 0)
}

func (s *FunctionNameBaseContext) JSON_REMOVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_REMOVE, 0)
}

func (s *FunctionNameBaseContext) JSON_REPLACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_REPLACE, 0)
}

func (s *FunctionNameBaseContext) JSON_SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_SET, 0)
}

func (s *FunctionNameBaseContext) JSON_UNQUOTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_UNQUOTE, 0)
}

func (s *FunctionNameBaseContext) JSON_DEPTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_DEPTH, 0)
}

func (s *FunctionNameBaseContext) JSON_LENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_LENGTH, 0)
}

func (s *FunctionNameBaseContext) JSON_TYPE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_TYPE, 0)
}

func (s *FunctionNameBaseContext) JSON_VALID() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_VALID, 0)
}

func (s *FunctionNameBaseContext) JSON_TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_TABLE, 0)
}

func (s *FunctionNameBaseContext) JSON_SCHEMA_VALID() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_SCHEMA_VALID, 0)
}

func (s *FunctionNameBaseContext) JSON_SCHEMA_VALIDATION_REPORT() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_SCHEMA_VALIDATION_REPORT, 0)
}

func (s *FunctionNameBaseContext) JSON_PRETTY() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_PRETTY, 0)
}

func (s *FunctionNameBaseContext) JSON_STORAGE_FREE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_STORAGE_FREE, 0)
}

func (s *FunctionNameBaseContext) JSON_STORAGE_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_STORAGE_SIZE, 0)
}

func (s *FunctionNameBaseContext) JSON_ARRAYAGG() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_ARRAYAGG, 0)
}

func (s *FunctionNameBaseContext) JSON_OBJECTAGG() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_OBJECTAGG, 0)
}

func (s *FunctionNameBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionNameBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionNameBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFunctionNameBase(s)
	}
}

func (s *FunctionNameBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFunctionNameBase(s)
	}
}

func (p *MySqlParser) FunctionNameBase() (localctx IFunctionNameBaseContext) {
	this := p
	_ = this

	localctx = NewFunctionNameBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 702, MySqlParserRULE_functionNameBase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7370)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserDATABASE || ((int64((_la-97)) & ^0x3f) == 0 && ((int64(1)<<(_la-97))&11258999068426241) != 0) || ((int64((_la-217)) & ^0x3f) == 0 && ((int64(1)<<(_la-217))&-17179869161) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&8796109397507) != 0) || _la == MySqlParserINVISIBLE || ((int64((_la-673)) & ^0x3f) == 0 && ((int64(1)<<(_la-673))&4611686018444099585) != 0) || ((int64((_la-802)) & ^0x3f) == 0 && ((int64(1)<<(_la-802))&-8589934599) != 0) || ((int64((_la-866)) & ^0x3f) == 0 && ((int64(1)<<(_la-866))&-257) != 0) || ((int64((_la-930)) & ^0x3f) == 0 && ((int64(1)<<(_la-930))&-1) != 0) || ((int64((_la-994)) & ^0x3f) == 0 && ((int64(1)<<(_la-994))&-529) != 0) || ((int64((_la-1058)) & ^0x3f) == 0 && ((int64(1)<<(_la-1058))&-9223090562146500609) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

func (p *MySqlParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 336:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	case 337:
		var t *PredicateContext = nil
		if localctx != nil {
			t = localctx.(*PredicateContext)
		}
		return p.Predicate_Sempred(t, predIndex)

	case 338:
		var t *ExpressionAtomContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionAtomContext)
		}
		return p.ExpressionAtom_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *MySqlParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySqlParser) Predicate_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySqlParser) ExpressionAtom_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 10:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 1)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 12)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
